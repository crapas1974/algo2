# 단계 9. 다이나믹 프로그래밍 응용 문제

## 스토리

유전자 정보를 연구하는 G 연구원과 T 연구원은 학창 시절부터의 절친이었다. 어쩌다보니 같은 직장에서 근무하게 된 두 사람은 종종 식사나 술자리를 함께 하면서 여전히 좋은 관계를 유지하고 있었다. 어느 가을 저녁, 두 사람은 연구소 근처 맛집에서 저녁을 먹고 있었다. T 연구원은 연구소 밖에서 업무 이야기하는 것을 좋아하지는 않았지만, 요즘 잘 안풀리는 문제가 있다며 G 연구원에게 의견을 물어봤다.

“우리 연구 그룹에서 개발한 스마트 마우스 기억나지?”

“응. 기억 능력에 연산 능력이 있을지도 모른다고 발표했던 그 쥐 말하는거지?”

“응. 그런데 문제가 있어.”

“뭔데?”

“쥐의 지능을 검증하려고 하는데, 우리가 멍청한게 문제지.”

이렇게 시작한 사연은 다음과 같았다.

스마트 동물 연구 그룹에서 개발한 “영리한 쥐”가 연산 능력과 학습 능력이 있는지를 확인하기 위해 다음과 같은 실험을 설계했다.

방이 N개가 있는 미로를 설치한다. 각 방은 1번 방에서 N번 방까지 이름이 붙어 있고, 시작 지점은 방은 아니지만 편의상 0번 방이라고 부르고 있다. 0번 방은 N개의 통로가 있고, 1번 방에서 N번 방까지 연결되어 있다. 1번 방은 N-1개의 통로가 있고 2번 방에서 N번 방까지 연결되어 있다. 이런 식으로 K번 방은 K+1번 방부터 N번 방까지 연결된 통로를 가지고 있다. 각 통로는 길이가 정해져 있으며, 쥐들의 속도는 모두 일정하다. 그리고 N번 방에 도착하면 보상을 주는데, 빨리 도착할 수록 보상이 좋아진다.

“그래서 보상이 뭐야?”

“응. 8년 숙성된 냄새가 엄청난 치즈. 쥐가 그 냄새를 맡으면 미칠 듯이 좋아하더라구. 문제는, 이 치즈가 싸구려라서 시간이 지나면 지날 수록 냄새가 점점 사라진다는건데…”

“그래서?”

“이 치즈 냄새가 통로에 퍼지니까, 기를 쓰고 쥐들이 달리더라구.”

“그리고?”

“영리한 쥐가 매번 1등을 했지.”

“그러면 입증된거 아니야?”

“그런데, 영리한 쥐가 점점 학습을 해서 더 영리해지고 있는지를 확인해야 하니까. 그런데 문제는 영리한 쥐가 최선의 선택을 했는지 확인해보고 싶은데… 그게 계산이 잘 안되더라구.”

“음. 혹시, 실험할 때 방은 몇 개 설치한거야?”

“적당히 설치했어. 한 1000개 정도?”

G 연구원은 순간 할 말을 잃었다. 방이 1000개인 미로라면 방과 방 사이의 통로의 개수만 499500개이다. 적당히라는게 뭔지 모르는 녀석. 아니, 우리 연구소 실험 예산 괜찮은거야?

---

# 문제 1. 모든 경로

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

S 연구원은 논문 성과가 탁월한 연구원이다. 그러다 보니 논문 발표를 위해서 해외 출장도 잦은 편이다. 그런 그도 이런 신기한 동전을 발행하는 나라는 처음이었다.

'1 다음이 7, 그리고 그 다음이 15?'

알고보니 그 국가의 오래전 역사 시대에 초대 국왕 1명이 7명의 기사들과 15개의 주변 왕국을 정복한 역사를 기념하기 위한 주화 시스템이었던 것이다. 그리고 33원 동전이 있었는데, 이 동전이 왜 발행되고 있는지는 도무지 알 수가 없었다.

여하튼 S 연구원은 이 나라에서도 동전을 사용해 이곳저곳을 방문해야 한다.

## 수행목표

- 편의상 어떤 국가의 화폐 단위를 원이라고 부르기로 하자. S 연구원이 방문한 국가의 동전은 1원 동전, 7원 동전, 15원 동전, 33원 동전으로 구성되어 있다.
- 이 나라의 일반 버스 요금은 1117원, 고급 버스 요금은 2521원, 지하철 요금은 1923원이다. 네 종류의 동전을 제한없이 사용할 수 있을 때, 최소 개수의 동전으로 일반 버스, 고급 버스, 지하철을 탑승할 때 사용해야 할 동전 별 개수를 출력해보자.
- S 연구원이 귀국하기 전에 인플레이션으로 인한 영향으로 1원 동전이 사용금지되고, 대신 53원 동전이 새로 발행되었다. 세로운 네 종류의 동전이 있을 때 최소 개수의 동전으로 세 종류의 대중교통을 탑승할 때 사용해야 할 동전의 개수와 손해보는 금액이 얼마인지를 출력해보자.

## 수행단계

- `dp_exer/bus_fare_dynamic.py` 파일에 다음을 구현한다.
  - 어떤 구성의 동전으로도 정해진 요금을 최소 개수의 동전으로 이용하는데 필요한 각 동전 별 개수와 정확히 지정한 요금을 만들 수 없을 때 손해를 보아야 하는 금액이 얼마인지를 반환하는 함수를 구현한다.
  - 각 동전의 사용 개수에는 제한이 없다.
  - 사용 가능한 동전 조합으로 정해진 금액을 지불할 수 없는 경우 이 금액을 초과하는 최소 요금을 지불하며, 이 차액이 손해를 보아야 하는 금액이 된다.
  - 다이나믹 프로그래밍을 사용해서 구현한다.
- 사용 가능한 동전이 1원, 7원, 15원, 33원 네 종류일 때 1117원, 2521원, 1923원을 최소 개수의 동전으로 각각 지불할 때 필요한 각 동전의 개수를 출력한다.
- 사용 가능한 동전이 7원, 15원, 33원, 53원 네 종류일 때 1117원, 2521원, 1923원을 최소 개수의 동전으로 각각 지불할 때 필요한 각 동전의 개수와 손해를 보게 되는 경우 손해 금액을 출력한다.

## 결과 예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 호주머니에 사용 가능한 동전의 수가 제한되어 있는 상황에서 다이나믹 프로그래밍 방식으로 최소한의 동전으로 요금을 지불하는 방법을 알려주는 함수를 구현한다.
  - 만약 모든 동전을 사용해도 요금을 지불할 수 없는 경우는 모자란 금액을, 동전이 남은 상태에서 정확히 지정한 요금을 지불할 수 없는 경우는 최소한의 손해를 보고 요금을 지불할 때, 이 최소한의 손해가 얼마인지도 반환한다.
- 7원, 15원, 33원, 53원 동전이 각각 20개씩 있을 때, 1117원, 2521원, 1923원을 최소 개수의 동전으로 지불해야 하는 경우의 필요한 각 동전의 개수, 모자란 금액 또는 손해를 보는 금액이 얼마인지를 출력한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/bus_fare_dynamic.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방식을 적용해 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```

    ```

### [보너스 과제 확인]

- 보너스 과제를 지시한 대로 해결하였으며 그 결과는 정확한가?
  - 동전이 제한되어 있을 때 요금을 지불하는 방법과 모자란 요금 또는 손해보는 요금의 금액을 반환하는 함수를 다이나믹 프로그래밍 방식을 사용해 구현하였는지 확인한다.
  - 결과 예시는 다음과 같다.

```

```

### [문제에 대한 이해]

- 그리디 알고리즘으로 최소의 동전 개수를 사용하는 거스름돈을 계산 방법을 제공해주지 못하는 이유는 무엇인가? 이전 문제의 예제와 위에서 제시한 경우를 비교해서 답해보라.
  - 탐욕적인 선택이 최적해를 보장하지 못하는 경우이다.
  - 상위 동전이 하위 동전의 정수배로만 구성되어 있는 경우, 상위 동전이 하위 동전의 선택을 완전히 커버할 수 있는 반면, 그렇지 않은 경우 상위 동전을 선택했을 때 하위 동전의 선택보다 못한 경우가 발생하기 때문이다.
- 그리디 알고리즘에서 탐욕적 선택을 한 후의 상황은 마치 다이나믹 프로그래밍에서 어떤 문제의 일부를 해결한 상황과 유사하다. 이 시점에서 그리디 알고리즘과 다이나믹 프로그램의 차이는 무엇인가?
  - 다이나믹 프로그래밍의 경우 하위 문제가 상위 문제에 속해 있고, 가장 작은 문제가 최적의 문제라는 조건이 있다.
  - 그리디 알고리즘은 하위 문제가 상위 문제에 속하지 못하는 경우가 발생한다.
- 최소 동전을 사용해 거스름돈 거슬러 주는 다이나믹 프로그래밍 접근 전략을 제시하라.
  - 금액 별로 최소 개수를 저장하고, 가장 작은 경우 (0센트) 부터 시작해 목표 금액 까지 거슬러 주는 방법을 상향식으로 계산해 올라가면서, 작은 금액에 대해서 계산한 결과를 사용한다.
  - 점화식은 다음과 같다. 거슬러 주는 동전의 개수를 coin_count(n)이라고 하면 coin_count(n) = min(coin_coint(n), 1 + [n - coin]) for all coin이 된다.
- 사용 가능한 동전 종류의 배열이 정렬되어 있다고 가정하자. 동전의 개수가 m, 거슬러주는 목표 금액이 n인 경우, 그리디 알고리즘으로 구현한 경우의 시간 복잡도를 제시하라.
  - 금액과 무관하게 가장 큰 동전부터 나눗셈을 한 번씩 하면 된다. 시간 복잡도는 O(m)이다.
- 동전의 개수가 m, 거슬러주는 목표 금액이 n인 경우, 다이나믹 프로그래밍으로 접근한 경우의 시간 복잡도를 제시하라.
  - 금액 별(n)로 반복하면서 매 반복 시에 동전의 개수(m) 만큼 반복하므로, 시간 복잡도는 O(mn)이다.

### [코드 예시]

```python

```

---

# 문제 2. 제한된 모든 경로

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

연구소의 예산은 주로 국가에서 지원해주지만, 그것만으로 모든 연구 예산을 확보할 수가 없었다. 그래서 연구소에는 몇 가지 수익 사업을 병행하고 있었다. 그 중 하나가 다른 기관의 의뢰를 받아서 DNA 염기 서열을 해독해 주는 일이었다.
이 사업의 사업 책임자 P 책임 행정원은 지선생의 입사동기로 오래된 벗이었다. 그 친구가 어느날 지선생을 찾아와 물었다.
“이걸 어떻게 굴려야 돈일 더 벌 수 있을까?”

## 수행목표

- 지선생은 이 문제를 다음과 같이 정의했다.
  > - 연구소는 한 번에 주문에서 처리하는 DNA의 최소 개수를 1단위로 정해놓고 있으며, 이 최소 단위의 정수배에 해당하는 요청만 받고 있다. 그리고 염기서열 해독 시스템은 매월 연구 진행상황에 따라 사업에 사용할 수 있는 요청 건수, 그리고 요청의 개수에 따른 가격이 바뀐다.
  > - 이에 따라 특정 월의 사업에서 다음의 값이 고정되어 있다.
  >   - 사업을 통해 받아서 처리해 줄 수 전체 요청 건수(기준 : 단위)
  >   - 주문당 요청의 단위 별 가격 배열 (억원)
  > - 구하고자 하는 해답은 다음과 같다.
  >   - 가능한 최대 매출액과 최고의 매출을 기록할 수 있도록 판매하는 방법을 반환한다. 단 같은 최대 매출을 기록하는 판매 방법이 있는 경우, 처리하는 주문의 횟수가 최소인 방법을 출력하며, 처리하는 주문의 횟수가 동일한 경우, 아무거나 출력해도 무방하다.
- 다음 테스트케이스의 결과를 출력한다.
  - 각 테스트케이스는 (n, price)의 튜플로 구성되며, n은 처리 가능한 전체 요청 건수이며, price는 단위 별 가격의 배열이며, 이 때의 단위는 각 배열의 항목에 대응되는 인덱스 값에 1을 더한 값이다.
  - 예를 들어 price 배열이 [1, 5, 8, 9]인 경우, 1단위 주문의 가격은 1억원, 4단위 주문의 가격은 9억원이라는 의미가 된다.

```python
TC1 = (4, [1, 5, 8, 9])
TC2 = (8, [2, 5, 8, 9, 10, 17, 17, 20])
TC3 = (10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
TC4 = (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
TC5 = (100, [2, 5, 7, 8, 10, 14, 16, 17, 20, 24, 27, 29, 32, 33, 37, 38, 41, 43, 47, 49, 51, 54, 56, 60, 64, 68, 71, 75, 78, 80, 82, 84, 87, 91, 93, 94, 95, 99, 100, 104, 106, 107, 109, 111, 115, 118, 120, 124, 126, 130, 133, 136, 138, 140, 142, 145, 149, 153, 155, 158, 162, 163, 165, 166, 168, 172, 174, 175, 179, 182, 183, 186, 188, 189, 193, 196, 200, 203, 204, 207, 211, 214, 218, 220, 223, 227, 228, 230, 231, 232, 233, 236, 239, 240, 242, 244, 246, 248, 251, 253])
```

## 수행단계

- 문제의 구조를 분석한다. 다음 흐름을 따라가 보면 분석에 도움이 될 수도 있다.
  - 이 문제를 처리 가능한 단위수 n, 주문의 요청 단위가 n일 때의 가격을 price[n - 1], max_sales(n)은 처리 가능 단위수가 n일 때의 최대의 매출로 정의하고 다음 사항을 확인해보자.
  - n단위의 처리가 가능한 상태에서 1단위의 요청을 처리했을 때, 기대 가능한 최대 매출은 얼마인가? price 배열과 max_sales 함수로 표현해보자.
  - 2단위의 요청을 처리했을 때 기대 가능한 최대 매출은 얼마인가?
  - i단위의 요청을 처리했을 때 기대 가능한 최대 매출은 얼마인가?
  - 이렇게 구한 매출들을 어떤 방식으로 취합해야 n 단위가 있을 때의 최대 매출이 될까?
- 이 문제를 다이나믹 프로그래밍 방식을 사용해 해결하는 함수를 dp_exer/max_sales.py 파일에 구현한다.
  - 만약 하향식 다이나믹 프로그래밍으로 구현하는 경우 메모이제이션을 적용한다.
  - 최대 기대 매출 뿐 아니라 어떻게 주문을 받아야 하는지도 계산해 함께 반환한다.
- 테스트 케이스를 구현한 함수를 사용해 결과를 구하고 출력하는 테스트 코드를 main 함수에 구현한다.

## 결과예시

```
TC 1:
최대 매출 : 10억원
판매 방법 :
    2단위 주문 : 2회
(이하 생략)
```

## 참고사항

- 이전 문제의 테스트 데이터와 비교하면 첫 번째, 다섯 번째 테스트케이스의 데이터만 다르고 나머지는 같다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 지선생의 도움을 받아서 사업이 번창하자, 이번에는 실제 염기 서열 해독 작업을 진행하는 연구원들의 불만이 쇄도했다. 그들의 요구는 번잡한 1단위 주문은 더 이상 받지 말자는 것이었고, 어짜피 일손은 부족하고 사업은 번창하고 있는 상황이라 이를 수용하기로 했다. 이 경우 다음과 같은 고려 사항이 추가된다.
  - 가격 배열에 1단위 처리의 가격이 적혀 있더라도 이 값은 더 이상 사용하지 않는 값이 된다.
  - 1단위 이외에도 처리하지 않는 단위가 추가된다. 이 경우 해당 단위의 금액은 0으로 제시된다.
  - 최소 요청 건수에 제한이 발생하면서, 최대 매출을 기록하면서도 남는 처리 용량이 발생할 수 있다. 남는 처리 용량도 함께 반환한다.
- 다음 테스트 케이스에 대해서, 최대 기대 매출, 판매 방법, 잔여 처리 용량을 출력한다.

```
TC1 = (4, prices = [0, 5, 0, 9])
TC2 = (8, prices = [0, 0, 8, 0, 0, 0, 14, 0])
TC3 = (10, prices = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1])
TC4 = (10, prices = [0, 2, 3, 4, 5, 6, 7, 8, 9, 0])
TC5 = (100, prices = [0, 0, 7, 8, 10, 14, 16, 17, 20, 24, 27, 29, 32, 33, 37, 38, 41, 43, 47, 49, 51, 54, 56, 60, 64, 68, 71, 75, 78, 80, 0, 0, 0, 0, 0, 94, 95, 99, 100, 104, 106, 107, 109, 111, 115, 118, 120, 124, 126, 130, 133, 136, 138, 140, 142, 145, 149, 153, 155, 158, 162, 163, 165, 166, 168, 172, 174, 175, 179, 182, 183, 186, 188, 189, 193, 196, 200, 203, 204, 207, 211, 214, 218, 220, 223, 227, 228, 230, 231, 232, 233, 236, 239, 240, 242, 244, 246, 248, 251, 253])
```

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/max_sales.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방식으로 구현하였는지 확인한다. 만약 하향식 다이나믹 프로그래밍 방법으로 구현한 경우 메모이제이션이 적용되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다.

    ```
    TC 1:
    최대 매출 : 10억원
    판매 방법 :
        2단위 주문 : 2회

    TC 2:
    최대 매출 : 22억원
    판매 방법 :
        6단위 주문 : 1회
        2단위 주문 : 1회

    TC 3:
    최대 매출 : 10억원
    판매 방법 :
        1단위 주문 : 10회

    TC 4:
    최대 매출 : 10억원
    판매 방법 :
        10단위 주문 : 1회

    TC 5:
    최대 매출 : 267억원
    판매 방법 :
        35단위 주문 : 1회
        34단위 주문 : 1회
        29단위 주문 : 1회
        2단위 주문 : 1회
    ```

### [보너스 과제의 확인]

- 보너스 과제를 지시대로 해결하였는가?
  - 문제의 구조를 사용하는 재귀 호출 방식으로 구현하고 있는지 확인한다.
- 결과가 정확한가?

  - 결과 예시는 다음과 같다.

    ```
    TC 1:
        최대 매출 : 10억원
        판매 방법 :
            2단위 주문 : 2회
        잔여 처리 용량 : 0단위

    TC 2:
        최대 매출 : 16억원
        판매 방법 :
            3단위 주문 : 2회
        잔여 처리 용량 : 2단위

    TC 3:
        최대 매출 : 5억원
        판매 방법 :
            2단위 주문 : 5회
        잔여 처리 용량 : 0단위

    TC 4:
        최대 매출 : 10억원
        판매 방법 :
            8단위 주문 : 1회
            2단위 주문 : 1회
        잔여 처리 용량 : 0단위

    TC 5:
        최대 매출 : 266억원
        판매 방법 :
            29단위 주문 : 3회
            13단위 주문 : 1회
        잔여 처리 용량 : 0단위
    ```

### [문제에 대한 이해]

- n = 4, prices = [1, 5, 8, 9]일 때 최대 매출은 얼마이며, 이 때의 판매 방법은 어떻게 될까?
  - 최고의 매출을 기록하기 위해서는 2단위씩 2번 주문을 받으면 된다. 이 때의 매출은 10억원이다.
- i단위의 요청을 처리했을 때 기대 가능한 최대 매출은 얼마인가? 처리 가능한 용량이 n일 때의 기대 가능한 최대 매출을 max_sales(n)이라 표현하고, i 단위의 가격을 price(i)라고 할 때, 최대 매출을 max_sales와 price를 사용해서 표현하라.
  - i단위의 요청을 처리했을 때의 기대 가능한 최대 매출 : price[i] + max_sales(n - i)
- 문제의 구조를 제시하라.
- 구현한 방식의 시간 복잡도는 얼마인가?

### [코드 예시]

```python

```

---

# 문제 3. 경로합이 최소인 경로

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

목에 건 직원증에 ‘E’이라는 이름이 적혀 있는 연구원이 어이없는 표정으로 멍하니 앉아 있었다. 그가 뒷목을 잡게 된 사연은 다음과 같다.

> - 넓은 사막을 가진 Z국은 전 세계에서 가장 많은 화석을 발견할 수 있는 나라이다. 그런데, 최근 Z국이 어느 나라의 연구자가 발굴하건 간에, 화석의 가치를 종류별로 정하고 각 국가별로 반출할 수 있는 화석의 전체 가치의 크기를 정했다. 만약 정확히 그 가치를 맞추지 못하고 그 값을 넘거나, 모자라는 경우 화석을 반출 할 수 없었다. 다행인 것은 종류별로 개수의 제한은 없다는 점이었다. 즉 가치가 작은 화석은 많은 수를 반출할 수 있으며, 수는 작더라도 가치가 높은 화석을 위주로 반출하는 선택도 가능한 상황이었다.
> - 주로 화석을 연구하는 진화생물학 연구 그룹에서는 반입 가능한 모든 ‘경우의 수’를 살펴보기로 했다. 그래서 E 연구원에게 내려진 특명은 반입 가능한 모든 ‘경우의 수’를 구해오라는 것이었다. 하지만, 일일이 목록의 수를 세어보는것은, 너무나 힘든 일이었다.

진화계통도와 관련된 프로그램을 몇 개 작성한 것이 사람들의 기대감을 지나치게 높여버렸다. E 연구원은 문제를 분석하다가 다시 프로그래밍 지원 게시판의 문을 두드렸다.

## 수행목표

- 반입이 허용된 화석 가치의 총 합과 화석 별 가치가 포함된 배열이 주어진다. 이 상황에서 정확하게 반입 허용 화석 가치를 구성할 수 있는 모든 반입 목록을 작성할 때, 이 반입 목록의 개수를 반환하는 함수를 구현한다.
- 다음 6개의 테스트케이스에 포함된 각각의 테스트케이스는 반입 목표 가치와 화석별 가치의 배열로 구성된 튜플이다.
  - 첫 번째 테스트케이스는 각 화석의 가치가 34, 47, 55일 때, 이 화석들을 조합해 가치 501을 만들 수 있는 목록의 개수를 반환해야 하며, 501을 만들 수 없으므로 반환하는 값은 0이 된다.
  - 두 번째 테스트케이스는 각 화석의 가치가 2, 2일 때 이 화석들을 조합해 가치 8을 만들 수 있는 목록의 개수를 반환해야 한다. 주의할 점은, 두 화석의 가치가 같더라도, 서로 다른 화석이라는 점을 고려해 목록을 만들어야 한다는 것이다. 이 경우, (첫 번째 화석의 개수, 두 번째 화석의 개수) 기준으로 (4, 0), (3, 1), (2, 2), (1, 3), (0, 4) 5개의 목록을 만들 수 있고, 5를 반환한다.
- 다음 테스트케이스의 각각에 대한 결과를 출력한다.

```python
TC1 = (501, [34, 47, 55])
TC2 = (8, [2, 2])
TC3 = (99, [3, 4, 5, 6])
TC4 = (590, [2, 6, 9, 3, 10])
TC5 = (500, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
TC6 = (1000, [1, 2, 3, 4, 5])
```

## 수행단계

- 문제의 구조를 분석하고, 이 문제를 상향식 접근법과 하향식 접근법 각각을 사용해서 해결하는 경우의 해결 방법을 정리한다.
- 반입이 허용된 화석 가치의 총 합과 화석 별 가치가 포함된 배열이 주어진다. 이 상황에서 정확하게 반입 허용 화석 가치를 구성할 수 있는 모든 반입 목록을 작성할 때, 이 반입 목록의 개수를 반환하는 함수를 dp_exer/fossil1.py 파일에 구현한다.
  - 상향식 접근법과 하향식 접근법 각각을 사용하는 두 개의 별도의 함수를 모두 구현한다.
  - 하향식 접근법으로 구현하는 경우 메모이제이션을 적용한다.
- 주어진 테스트케이스에 대해서 결과를 구한 후, 이를 출력한다.
  - 상향식, 하향식 각 접근법으로 답을 구하는데 걸린 시간을 각각 측정해 출력한다.
- 상향식, 하향식 두 접근법의 차이를 구현 방식과 함수의 성능 양 측면에서 비교해보자.

## 결과예시

```
하향식 다이나믹 프로그래밍
    수행 시간: 0.00033283233642578125 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 1.0967254638671875e-05 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
    수행 시간: 0.0011639595031738281 초
(중간 생략)
상향식 다이나믹 프로그래밍
    수행 시간: 9.226799011230469e-05 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 2.1457672119140625e-06 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
(이하 생략)
```

## 참고사항

- 이 문제의 테스트케이스 중 처음 10개는 이전 문제의 테스트케이스와 동일하며, 뒤의 2개가 추가되었다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/fossil1.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍, 메모이제이션을 적용한 하향식 다이나믹 프로그래밍 방법을 사용한 각각의 함수가 구현되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 상향식, 하향식 두 접근 방법의 결과는 동일해야 한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 실행 시간은 다를 수 있다.

```
하향식 다이나믹 프로그래밍
    수행 시간: 0.00033283233642578125 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 1.0967254638671875e-05 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
    수행 시간: 0.0011639595031738281 초
    TC 3에서 생성할 수 있는 반입 목록의 경우의 수 : 585
    수행 시간: 0.041081905364990234 초
    TC 4에서 생성할 수 있는 반입 목록의 경우의 수 : 1722389
    수행 시간: 0.0815131664276123 초
    TC 5에서 생성할 수 있는 반입 목록의 경우의 수 : 2391508958235
    수행 시간: 0.1903541088104248 초
    TC 6에서 생성할 수 있는 반입 목록의 경우의 수 : 357746987
상향식 다이나믹 프로그래밍
    수행 시간: 9.226799011230469e-05 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 2.1457672119140625e-06 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
    수행 시간: 2.7894973754882812e-05 초
    TC 3에서 생성할 수 있는 반입 목록의 경우의 수 : 585
    수행 시간: 0.000186920166015625 초
    TC 4에서 생성할 수 있는 반입 목록의 경우의 수 : 1722389
    수행 시간: 0.00030112266540527344 초
    TC 5에서 생성할 수 있는 반입 목록의 경우의 수 : 2391508958235
    수행 시간: 0.0003070831298828125 초
    TC 6에서 생성할 수 있는 반입 목록의 경우의 수 : 357746987
```

### [문제에 대한 이해]

- 문제의 구조를 설명하라.
- 상향식 접근법, 하향식 접근법 각각의 해결 전략을 제시하라.
- 두 접근법의 차이를 분석하라. 만약 두 함수의 실행 시간 기준의 성능 차이가 존재한다면, 분석을 통해 이 차이를 설명할 수 있어야 한다.

### [코드 예시]

```python

```

---

# 문제 4. 경로합이 최대인 경로

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

“그 경우의 수가 그 경우의 수가 아니다!”

진화생물학 연구그룹의 그룹장이 E 연구원에게 핀잔을 줬다. 우리는 ‘경우의 수'라는 말을 쓸 때, ‘경우의 개수'로 쓰기도 하지만 ‘모든 경우의 목록'에도 경우의 수라는 표현을 쓰곤 한다. 물론 E 연구원도 ‘경우의 수’가 그 ‘경우의 수’일지도 모른다는 생각은 했지만, 계산 결과 나온 어마어마한 크기의 ‘경우의 수’를 보고, 전체 가능한 목록을 가지고 오라는 이야기는 아니겠지 생각했던 것이다. 그래서, E 연구원은 그룹장에게 되물었다.

“2조개가 넘는 목록을 다 보시겠다구요?”

그룹장의 말.

“내가 알아서 할 테니까…”

## 수행목표

- 이전 문제에서 해결한 방법 중 상향식 접근법을 사용해서 문제를 해결하면서 동시에 목록의 개수 뿐 아니라 모든 목록을 출력하는 프로그램을 작성한다.
- 다음 데이터를 사용해 각 테스트케이스의 목록의 개수 및 모든 목록을 구하고, 이를 출력한다.

```python
TC1 = (501, [34, 47, 55])
TC2 = (5, [1, 2, 3])
TC3 = (25, [3, 4, 5, 6])
```

## 수행단계

- 이전 문제에서 구현한 두 가지 방식 중 상향식 다이나믹 프로그래밍 접근 방법을 사용할 때, 목록의 개수 뿐 아니라 모든 목록을 작성하도록 수정하는 방법을 정리한다.
- 상향식 접근 방법을 사용해서 주어진 데이터로 생성 가능한 전체 목록의 수와 모든 목록을 반환하는 함수를 dp_exer/fossil2.py 파일에 구현한다.
- 주어진 3개의 테스트케이스에 대해서 각각의 결과를 출력한다.

## 결과 예시

```
TC2에서 생성할 수 있는 반입 목록의 수 : 5
TC2에서 생성할 수 있는 반입 목록 : [[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], [1, 1, 3], [2, 3]]
(TC1, TC3 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/shortest_path4.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 접근 방법으로 최단 거리와 최단 경로를 구하는 함수를 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

```
    TC1에서 생성할 수 있는 반입 목록의 수 : 0
    TC1에서 생성할 수 있는 반입 목록 : []

    TC2에서 생성할 수 있는 반입 목록의 수 : 5
    TC2에서 생성할 수 있는 반입 목록 : [[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], [1, 1, 3], [2, 3]]

    TC3에서 생성할 수 있는 반입 목록의 수 : 17
    TC3에서 생성할 수 있는 반입 목록 : [[3, 3, 3, 3, 3, 3, 3, 4], [3, 3, 3, 4, 4, 4, 4], [3, 3, 3, 3, 4, 4, 5], [4, 4, 4, 4, 4, 5], [3, 3, 3, 3, 3, 5, 5], [3, 4, 4, 4, 5, 5], [3, 3, 4, 5, 5, 5], [5, 5, 5, 5, 5], [3, 3, 3, 3, 3, 4, 6], [3, 4, 4, 4, 4, 6], [3, 3, 4, 4, 5, 6], [3, 3, 3, 5, 5, 6], [4, 5, 5, 5, 6], [3, 3, 3, 4, 6, 6], [4, 4, 5, 6, 6], [3, 5, 5, 6, 6], [3, 4, 6, 6, 6]]
```

### [문제에 대한 이해]

- 모든 목록을 반환하기 위해서 이 목록들을 저장하는 변수의 자료형은 무엇이며 어떻게 정의하고 초기화 하였는가?
  - 리스트를 사용한다.
  - 생성하는 크기는 (target_value + 1)의 크기로 생성한다.
  - 초기화 값은 cases[0]은 아무것도 반입하지 않는 경우의 빈 리스트가 존재하므로 `[[]]`로 초기화한다.
  - 나머지 경우는 계산 전이므로 `[]`로 초기화한다.
- 모든 목록을 반환하기 위해 구현한 알고리즘의 동작 방식을 설명하라.
  - 경우의 수를 구할 때는 num_case에 하위 문제의 경우의 수를 더했던 부분에서
  - 대신 현재 선택 가능한 모든 경우에 대해서,
  - 현재 화석의 가치를 추가한 새로운 경우를 생성하고,
  - 이를 목록 배열에 추가해 모두 취합한다.

### [코드 예시]

```python

```

---

# 문제 5. 최대경로합 (3방향)

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

E 연구원은 그룹장의 명령만 수행하는 수동적인 연구원은 아니고, 본인의 고유한 연구 주제를 가지고 있었다. 그는 진화생물학을 전공했지만, 오늘날 여러 이론의 발전으로 각 분야의 연구가 서로에게 도움이 되다 보니, 진화생물학에 DNA 구조 분석을 접목하는 접근 방법을 찾고 있었다.

E 연구원은 본인이 발견한, 아니 발견했다고 주장하는 이론이 있다. 그런데, 그 이론을 검증하려면 복잡한 계산이 필요한데, 다이나믹 프로그래밍의 개념을 접하자, 그 문제도 다이나믹 프로그래밍으로 풀 수 있다는 사실을 알게 되었다. 그의 이론은 다음과 같다.

> - 특별한 종의 미생물들은 유전자 염기서열은 몇 개의 패턴으로만 중첩 없이 구성되며, 이 특징으로 특정 진화의 갈래를 확인할 수 있다는 것이었다. 예를 들어서 CTAGC와 TAGGCT 두 개의 염기서열 패턴만으로 구성되는 예제는 다음과 같다.
>   - CTAGC, TAGGCT (패턴 그 자체)
>   - CTAGCT-TAGGCT, TAGGCT-CTAGC, CTAGC-CTAGC-TAGGCT-CTAGC (패턴들의 조합)
> - 다음은 여기에 해당되지 않는 예제이다.
>   - C-TAGGCT-AGCA-TAGGCT (해당 패턴이 포함되어는 있지만, 해당 패턴 만으로 구성되지 않음)
>   - TAGG-CT-AGC (TAGGCT, CTAGC가 포함되어 있지만, 중첩되어 있다.)

이 이론을 검증하기 위해서 실제 어떤 유전자가 특정 패턴으로만 구성되어 있는지 확인해야 하는데, 이 문제가 어려운 이유는 간단한 미생물 정도만 해도 몇 백만에서 천만 정도의 길이에 달할 정도로 유전자 염기서열이 길다는 것이었다. 이 중 1% 정도만 샘플링해서 조사한다 해도 1만 정도의 길이가 된다. 연구원 L은 유전자 염기 서열에서 1만 이하의 길이를 가지는 부분을 샘플링해서 테스트 작업을 시작하고 있는 중이었다.

## 수행목표

- E 연구원이 풀어야 하는 문제는 다음과 같다.
  - 패턴은 C, T, A, G 네 글자가 조합된 문자열로 주어진다.
  - 주어진 문자열이 지정된 패턴 만으로 중첩없이 구성되어 있는지를 검사하고, 결과에 따라 True 또는 False를 반환한다.
- E 연구원이 풀어야 하는 문제를 해결해주는 함수를 구현한다.
- 다음은 검사할 패턴(patterns 리스트)과 테스트 대상 DNA 염기 서열(문자열)들이 기재되어 있다. 11개의 DNA 염기 서열에 대해서 해당 염기 서열이 검사할 패턴 만으로 중첩 없이 구성되어 있는지 검사한 결과를 출력한다.
  ```python
  patterns = ['CTAG', 'GCC', 'CTA']
  test1 = "CTAG"
  test2 = "GCCCTACTAG"
  test3 = "CCCCCCCCCC"
  test4 = "GTTTCAGGGA"
  test5 = "CTAGCTAGCC"
  test6 = "CTACTAGCTAGCC"
  test7 = "ACCAGAGTCTCTCCTCTTAC"
  test8 = "GCCCTACTAGCCCTAGCTAGCCCTAGGCCCTAGCCCTAGCCGCCGCCCTACTAGCCCTACTA"
  test9 = "GCCCTAGCTAGCTAGCCGCCGCCCTACTACTAGCCGCCGCCTAGCCGCCCTACTACTAGGCCCTAG"
  test10 = "CTAGCTACTACTAGCTAGCTAGCTAGCTAGCTACTAGCTACTAGCTAGCCCTAGCTACTAGCTAGCTAGCTAGCTAGGCCGCCCTAGCTAGGCCGCCCTAGCTAGCTAGGCCGCCCTAGCTAGGCCGCCCTAGCTAGCTAGCTACTAGCTACTAGCTAGCCGCCCTAGCCCTACTAG"
  test11 = "GCCCTAGCTACTAGCTAGCTAGCCGCCCTACTAGGCCGCCCTACTACTAGGCCGCCGCCCTAGCTAGGCCGCCCTACTAGCTACTAGCTAGCTACTAGCTACTAGCTACTAGGCCGCCCTACTAGGCCCTACTAGGCCCTAGCCGCCCTAGCTAGGCCGCCCTACTAGGCCCTACTACTAGGCCCTAGCTACTAGCTAGGCCCTAGGCCGCCCTAGGCCCTACTACTACTAGCCGCCGCCCTACTAGGCCCTACTACTAGCCCTAGGCCCTAGCTAGCTACTAGCCGCCCTAGCTAGGCCGCCGCCGCCCTAGGCCGCCCTAGCCGCCCTACTACTACTACTAGCTACTACTAGCTAGCTACTAGCTACTAGGCCGCCGCCGCCCTACTAGGCCCTACTAGCTACTAGCCCTACTACTACTACTAGCCGCCGCCCTAGCTAGCCGCCCTAGGCCCTACTACTACTAGCCGCCCTAGGCCCTACTAGCCCTAGGCCCTAGCCCTAGCTAGCCCTAGCTAGCTAGCCGCCCTACTACTAGCTACTAGCTAGCTAGCTAGGCCCTAGCTAGGCCGCCGCCCTAGGCCCTACTAGCTAGCCGCCCTACTAGGCCGCCCTAGCTAGCCCTAGCCCTAGCCGCCCTAGCTAGCTACTAGCCCTACTAGCTAGCTAGCCCTACTAGCTACTAGCTAGCCCTACTACTAGCCCTACTAGCTACTACTAGCCCTAGGCCCTAGGCCCTAGCTACTACTAGGCCGCCGCCCTACTAGCCGCCGCCCTAGGCCCTACTACTAGGCCGCCGCCCTAGCTAGCCCTAGGCCCTAGCTAGGCCCTAGCCCTACTAGGCCCTAGCTAGCTAGCTAGGCCGCCCTAGCTAGCTAGCCGCCGCCGCCCTAGCCCTAGGCCCTAGCTAGCCGCCGCCCTAGCCCTAGCCGCCCTACTAGCTAGCTACTACTAGCTAGCTACTAGCTACTAGCTAGCCCTAGCCCTAGGCCGCCGCCGCCCTAGCCCTACTACTACTAGCCCTAGGCCCTACTAGCTAGGCCGCCCTAGCCCTAGCTAGCTAGCTAGCTACTACTAGGCCCTAGCTAGCCCTAGGCCGCCCTACTAGCTAGCTACTAGCTAGCTAGCTAGCCGCCCTAGGCCGCCCTAGCCCTAGGCCGCCGCCCTACTACTAGCCCTACTACTAGCTACTAGCTAGCTACTAGCTAGCTAGGCCCTACTAGCTACTAGCCCTAGCTAGCTAGCCCTAGCTAGGCCCTAGCCCTACTAGCCGCCCTAGCCGCCCTACTAGGCCGCCCTAGCTACTAGCTAGCTACTACTAGCCCTAGCCGCCGCCGCCCTACTAGCTAGGCCGCCGCCGCCCTAGCTAGCCCTACTAGCTAGCTAGCTAGCTAGCTAGGCCGCCCTAGCTAGCCCTACTAGCTACTAGGCCCTAGCTACTAGCCCTAGGCCCTACTACTAGCTACTAGCTAGCCCTACTAGCTAGCTAGCCCTAGCTACTAGGCCCTACTAGCTAGCTAGCCCTACTAGCTAGCTACTAGCCCTAGCTAGCTACTAGCCCTAGGCCGCCGCCCTAGCCCTAGCTACTAGCTAGCTAGCTACTAGCTAGCTAGCTAGCCCTACTACTACTAGCCGCCCTAGCTACTACTACTAGCCCTAGCTAGCTAGCCCTACTACTACTAGCTAGCCCTACTAGCTAGCCGCCCTAGCTAGCTAGCTACTAGCCCTACTAGCCCTACTACTAGCTACTAGGCCCTAGGCCGCCCTAGCCCTAGGCCCTACTAGCTACTACTAGCTAGCTAGGCCGCCCTACTACTACTACTAGCTACTACTAGCTAGCTAGCCGCCCTAGCTAGGCCGCCGCCCTAGCTAGCTAGCTAGCTAGCTAGCTACTAGCTAGCTACTAGCTACTAGCCCTAGCTAGCTAGCTAGCTACTAGCTACTAGCTACTAGCCCTAGCCCTAGGCCGCCGCCGCCCTAGCTAGGCCCTAGCTAGCCGCCCTACTAGGCCCTAGCTAGCTACTAGGCCGCCGCCCTACTAGCTAGGCCGCCCTACTAGGCCCTAGCCCTACTAGCTACTAGCCGCCCTACTAGGCCCTAGCTAGCTACTAGCTACTACTAGCCGCCCTAGCCCTAGCTACTAGCTAGCCCTACTACTAGCTAGCTACTAGCTACTAGCCCTACTACTAGCCCTAGCTACTAGGCCCTAGCCGCCCTAGCCCTACTAGGCCGCCCTACTACTAGCCGCCCTACTAGGCCCTAGCTAGCTACTAGCTAGCCCTACTACTAGCTACTAGGCCCTAGCTACTAGCCCTAGCTACTAGCTAGCTAGGCCCTAGCTAGCTAGCTAGCTACTAGCTACTAGCTAGCTAGGCCCTACTAGCTACTAGGCCCTAGCTAGCCGCCCTAGCTAGCTAGCCCTAGCTAGGCCGCCGCCGCCCTACTAGCTACTACTAGCTAGCCGCCCTACTAGCCCTAGCTACTACTAGCTAGGCCGCCCTAGGCCCTACTAGCCCTAGCCCTACTAGCTAGGCCGCCCTAGGCCCTACTACTAGGCCGCCGCCCTACTAGCTAGCTAGCTAGCTAGCCCTACTAGGCCCTAGCCCTAGGCCCTACTACTAGCTAGCTACTACTAGGCCCTAGGCCCTACTAGCTAGCTACTAGCTAGGCCCTAGCTAGCTAGGCCCTAGCTACTAGCCGCCCTAGCTAGCTAGCCCTACTAGGCCCTAGGCCGCCCTACTAGCTAGCCGCCGCCCTAGGCCGCCCTAGCTACTAGCTAGCCGCCCTAGCTAGCTAGCCCTACTAGGCCCTAGCTAGCTAGCTAGGCCCTACTACTACTAGCCCTAGCTAGGCCCTACTAGCTACTAGCTACTAGGCCCTAGCCCTAGGCCGCCCTAGCTACTACTACTAGCCCTAGCTAGGCCCTAGCTAGCTAGCTACTACTAGCCGCCCTACTAGCCCGATTAGCTACTAGGCCGCCCTACTAGCTAGCTAGCTACTAGCTAG"
  ```

## 수행단계

- 문제의 구조를 분석하고, 문제를 해결하기 위한 하향식 접근법과 상향식 접근법을 각각 정리한다.
- dp_exer/simple_dna.py 파일에 주어진 문자열이 패턴 만으로 중첩없이 구성되어 있는지를 검사해 그 결과를 반환하는 함수를 구현한다.
  - 하향식 접근법과 상향식 접근법 각각의 함수를 구현한다.
- 주어진 테스트케이스 11개에 대해서 함께 제공된 패턴만으로 중첩없이 구성되어 있는지를 두 함수 각각에 대해서 검사하고, 그 결과를 출력한다.
- 상향식, 하향식 두 접근 전략을 비교 분석한다.
  - 이 문제의 경우 하향식 접근법을 사용할 때 메모이제이션을 사용해도 큰 도움이 되지 않는다. 그 이유가 무엇인지 정리한다.

## 결과예시

```
수행 시간: 1.9073486328125e-06 초
TC 1 하향식 접근법 : True
수행 시간: 5.7220458984375e-06 초
TC 1 상향식 접근법 : True
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/simple_dna.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식, 하향식 각각의 접근 방법을 사용한 두 개의 함수가 구현되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

```
수행 시간: 1.9073486328125e-06 초
TC1 하향식 접근법 : True
수행 시간: 5.7220458984375e-06 초
TC1 상향식 접근법 : True

수행 시간: 2.86102294921875e-06 초
TC2 하향식 접근법 : True
수행 시간: 9.059906005859375e-06 초
TC2 상향식 접근법 : True

수행 시간: 9.5367431640625e-07 초
TC3 하향식 접근법 : False
수행 시간: 5.9604644775390625e-06 초
TC3 상향식 접근법 : False

수행 시간: 9.5367431640625e-07 초
TC4 하향식 접근법 : False
수행 시간: 5.9604644775390625e-06 초
TC4 상향식 접근법 : False

수행 시간: 4.0531158447265625e-06 초
TC5 하향식 접근법 : True
수행 시간: 7.867813110351562e-06 초
TC5 상향식 접근법 : True

수행 시간: 4.0531158447265625e-06 초
TC6 하향식 접근법 : True
수행 시간: 1.0967254638671875e-05 초
TC6 상향식 접근법 : True

수행 시간: 1.1920928955078125e-06 초
TC7 하향식 접근법 : False
수행 시간: 1.3113021850585938e-05 초
TC7 상향식 접근법 : False

수행 시간: 1.9073486328125e-05 초
TC8 하향식 접근법 : True
수행 시간: 0.00020813941955566406 초
TC8 상향식 접근법 : True

수행 시간: 1.5974044799804688e-05 초
TC9 하향식 접근법 : False
수행 시간: 0.00020194053649902344 초
TC9 상향식 접근법 : False

수행 시간: 0.00013375282287597656 초
TC10 하향식 접근법 : True
수행 시간: 0.0015680789947509766 초
TC10 상향식 접근법 : True

수행 시간: 0.001992940902709961 초
TC11 하향식 접근법 : False
수행 시간: 0.3107450008392334 초
TC11 상향식 접근법 : False
```

### [문제에 대한 이해]

- 하향식 다이나믹 프로그래밍 전략을 사용하기 위한 문제의 구조와 해결 전략을 제시하라.
- 상향식 다이나믹 프로그래밍 전략을 사용하기 위한 문제의 구조와 해결 전략을 제시하라.
- 하향식 접근법과 상향식 접근법을 비교 분석해보라. 성능 차이가 발생하였다면, 그 이유도 함께 제시하라.

### [코드 예시]

```python

```

---

# 문제 6. 최대경로합 (좌에서 우)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

E 연구원은 실험을 통해 이론을 검증한 후, 이 내용을 정리해 해외 유명 진화생물학 저널에 논문을 투고했다. 논문이 실린 저널이 출판된지 한 달쯤 지나서 E 연구원에게 메일이 하나 도착했다. 이 분야에서 연구를 하는 사람이면 누구나 알고 있는 해외 유명 연구자의 메일이었다.

> - 좋은 논문 발표해 주셔서 감사합니다. 정말 좋은 성과라고 생각합니다.
> - 그런데 논문을 꼼꼼히 읽어보던 중에, 재미있는 것을 발견했습니다. 마침 제가 하던 연구와 결합이 가능할 것 같은데, 혹시 시퀀스 몇 개에 대해 패턴으로 쪼갠 결과를 보내주실 수 있으신지요? 그리고 하나의 시퀀스가 주어진 패턴에 대해서 쪼갠 결과가 둘 이상이면, 모두 다 보내주실 수 있으시면 큰 도움이 될 것 같습니다.
> - 제 사견입니다만, 10년 안에 저와 L님이 공동으로 노벨 생리의학상 후보가 될 수 있지 않을까라는 기대도 하게 됩니다. 부디 꼭 부탁드립니다.

## 수행목표

- 패턴과 문자열이 주어졌을 때, 문자열이 패턴 만으로 중첩없이 검사하는 것으로 그치지말고, 패턴을 사용해 문자열을 구성한 방식을 반환하도록 수정된 함수를 구현한다.
  - 예를 들어 패턴이 [‘CT’, ‘TA’, ‘AG’, ‘CTT’, ‘AAG’]로 주어지고, 검사해야 할 문자열이 'CTTAAG'인 경우, 이 문자열은 CTT-AAG로 패턴을 사용해 나눌 수 있다. 그런데 'CTTAAG'는 CT-TA-AG로 패턴을 사용해서 나눌 수 있는 다른 방법이 존재한다. 함수의 반환 결과는 이를 모두 포함한 ['CTT-AAG', 'CT-TA-AG']를 반환해야 한다.
  - 만약 패턴만으로 중첩 없이 입력 문자열을 나눌 수 없는 경우 빈 리스트[]를 반환한다.
- 다음 테스트케이스 3개에 대해서 실행 결과를 출력한다.
  ```python
  patterns = ['CT', 'TA', 'AG', 'CTT', 'AAG']
  test1 = "CTTAAG"
  test2 = "GCCCTACTAGCCCTAGCTAGCCCTAGGCCCTAGCCCTAGCCGCCGCCCTACTAGCCCTACTA"
  test3 = "AGCTCTTAAAGAAGTATAAGCTTCTCTTCTCTTCTTAAGTAAGCTCTTACTCTTAAGCTAGAGAGAGAG"
  ```

## 수행단계

- 하향식 접근법을 사용해 패턴만으로 중첩없이 문자열이 구성되어 있는지를 검사하는 함수를 이전 문제에서 구현한 바 있다. 하향식 접근법으로 구성 가능 여부를 반환하는 대신 패턴으로 구성하는 방법의 목록을 반환하는 함수를 dp_exer/simple_dna2.py 파일에 구현한다.
- 주어진 테스트케이스 각각에 대해서 입력 문자열을 패턴으로 나눈 결과를 출력한다.

## 결과예시

```
TC1을 자른 결과 : ['CT-TA-AG', 'CTT-AAG']

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/simple_dna2.py 파일에 구현이 되어 있는지 확인한다.
  - 하향식 접근방법을 메모이제이션과 함께 사용하여 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과의 예시이다. 결과는 항상 다르게 나오지만, 수행 시간은 거의 지연없이 결과를 확인할 수 있어야 한다.

```
TC1을 자른 결과 : ['CT-TA-AG', 'CTT-AAG']

TC2을 자른 결과 : []

TC3을-자른-결과-:-['AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CT-TA-AG-TA-AG-CT-CT-TA-CT-CT-TA-AG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CT-TA-AG-TA-AG-CT-CT-TA-CT-CTT-AAG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CTT-AAG-TA-AG-CT-CT-TA-CT-CT-TA-AG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CTT-AAG-TA-AG-CT-CT-TA-CT-CTT-AAG-CT-AG-AG-AG-AG-AG']
```

### [문제에 대한 이해]

- 패턴을 자른 결과를 취합하기 위해서 재귀 함수는 어떤 전략을 사용하는가?
  - 파라미터에 뮤터블 객체를 전달해 자른 결과를 취합하는 방식과 반환값을 리스트로 받아서 모든 리스트를확장해 나가는 방식의 구현에 따라 답이 달라진다. 아래 예시 답변은 후자의 경우이다.
  - 문자열의 가장 앞 부분이 주어진 패턴과 매칭 되는 경우, 나머지 부분을 재귀 호출한다.
  - 재귀 호출의 결과가 비어 있지 않은 리스트인 경우 리스트의 모든 결과의 앞에 매칭된 패턴을 추가한다.
  - 재귀 호출의 결과가 리스트인 경우 그대로 빈 리스트를 반환한다.
  - 문자열의 가장 앞 부분이 주어진 패턴과 매칭이 되지 않는 경우 빈 리스트를 반환한다.

### [코드 예시]

```python

```

---

# 문제 7. 바이러스의 등잔 밑

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

바이러스 연구를 위해 신규 도입된 특수한 바이러스 배양 장치는 배양하는 조건을 다양하게 설정해 다양한 목적으로 활용할 수 있는 최첨단 장비이다. 생태 환경을 통제해 바이러스의 세대별 주기가 배양 조건에 따라 서로 다른 진화가 가능한지를 확인하기 위해서 T 연구원은 이 장비를 사용하기로 했다.

‘이것이 장비의 매뉴얼이구나?’

장비의 매뉴얼에는 장비의 사용 방법이 다음과 같이 적혀 있었다.

> - 배양기는 n X 2의 크기이다.
> - 이 장비는 바이러스가 유출되지 못하게 가둬 두는 1X2 크기의 바이오 세이프티 필터와 바이러스가 자유롭게 드나들 수 있는 2X1 크기의 바이오 컴패터블 필터를 바닥에 설치해야 한다.
> - 이 설치 방식에 따라 모두 다른 실험 결과를 얻을 수 있다.
> - 바닥에 필터가 설치되어 있지 않은 영역이 조금이라도 있는 경우 바이러스가 배양기 외부로 유출될 위험이 매우 높으므로, 절대 주의해야 한다.

T 연구원은 이 장비를 사용하기에 앞서 총 몇 종류의 설정이 가능한지 알아야 했다. 실험 계획을 세우기 위해서 반드시 필요한 값이기 때문이었다.

## 수행목표

- 배양기는 n X 2의 구조를 가지고 있다. (가로가 양의 정수 n의 크기이다.) 그리고 배양기 바닥은 1 X 2 또는 2 X 1 크기의 필터로 빠짐없이 채워야 장비가 정상적으로 동작하며, 필터의 종류와 무관하게 필터를 배치한 형태만으로 서로 다른 실험 환경이 설정된다고 할 때, 서로 다른 전체 실험 설정의 수를 계산해 반환하는 함수를 구현한다.
- n = 2, 10, 30, 50, 100일 때 서로 다른 전체 실험 설정의 수를 계산하고, 이를 출력한다.

## 수행단계

- 문제의 구조를 분석한다.
- 다이나믹 프로그래밍 접근 방법을 사용해 문제를 해결하는 방법을 정리한다.
- dp_exer/filtering1.py 파일에 서로 다른 전체 실험 설정의 수를 반환하는 함수를 구현한다.
  - 이 함수는 다이나믹 프로그래밍으로 구현한다. 접근 방법은 각자 선택하되, 시간 복잡도는 O(n) 이하가 되도록 구현하여야 한다.
- n = 2, 10, 30, 50, 100일 때의 결과를 각각 출력한다.

## 결과예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/filtering1.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방법을 사용해서 O(n) 시간 복잡도 이내로 동작하는 알고리즘으로 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- 이 문제의 점화식을 설명과 함께 제시하라.
- 구현한 알고리즘의 시간 복잡도를 설명과 함께 제시하라.

### [코드 예시]

```python

```

---

# 문제 8. 뉴로스티닉스를 좋아하는 바이러스

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

정작 배양기 사용 하가를 받아서 배양기의 덮개를 열어보니, 배양기는 n x 2 구조가 아니라 n x 3 구조였다. 매뉴얼이 옛날 구버전의 것이었는데, 연구소의 인트라넷에 새 버전으로 업데이트가 되지 않았던 것이다.

T 연구원은 뭔가 더 많은 경우를 테스트 할 수 있을 것이라는 생각에 횡재한 기분이었다. 하지만 들뜬 기분도 잠시. 전체 실험 가능한 설정의 수를 다시 계산해야 한다는 생각에 우울감이 몰려왔다. 게다가 문제의 난이도가 n x 2일 때보다 훨씬 복잡해졌음을 직관적으로 깨달을 수 있었다.

'뭐, 일단 부딪혀보고 안되면 프로그래밍 지원 게시판에 도움을 청하면 어떻게 되지 않겠어?'

## 수행목표

- 이전 문제와 달리 이번에는 n X 3 구조의 배양기에 1 x 2 또는 2 x 1 크기의 필터를 빠짐없이 배치해야 한다. (n은 양의 짝수이다.) 이와 같이 배양기의 구조가 변경된 상황에서 필터의 종류와 무관하게 필터를 배치한 형태만으로 서로 다른 실험 환경이 설정된다고 할 때, 서로 다른 전체 실험 설정의 수를 계산해 반환하는 함수를 구현한다.
- 이 함수를 사용해 배양기의 구조가 2 x 3, 4 x 3, ..., 20 x 3 인 10개의 배양기에서 설정 가능한 실험의 총 수를 각각 계산해 출력한다.

## 수행단계

- 문제의 구조를 단계별로 확인해보자.
  - 2 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - 4 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - 6 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - n이 8 이상일 때 배양기에 필터를 배치하는 방법을 작은 크기의 배양기에 필터를 배치하는 방법을 사용해 경우 별로 분류해서 정리해보자.
    - (n - 2) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하는 경우 (배치 A)
    - (n - 4) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하되, 배치 A에 포함되지 않는 경우 (배치 B)
    - (n - 6) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하되, 배치 A와 배치 B에 포함되지 않는 경우 (배치 C)
    - 배치 A, 배치 B, 배치 C와 무관하며, 작은 크기의 배양기에 필터를 배치하는 방법과도 완전히 무관한 별도의 경우
- 이 문제를 상향식 접근 방법으로 해결하는 함수를 dp_exer/filter2.py 파일에 구현한다.
- n = 2, 4, ..., 20일 때의 결과를 출력한다.

## 결과예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/filter2..py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍 접근 방법으로 해결하고 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- n이 홀수인 경우는 어떤 결과가 나오는가?
- 문제의 구조를 하위 문제를 사용해 설명하라.
- n x 3에서 가능한 모든 실험 설정의 수를 case(n)으로 표기할 때, case(n)의 상위 문제와 하위 문제의 관계를 나타내는 점화식을 제시하라.

### [코드 예시]

```python

```

---

# 문제 9. 퀀텀 점프

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

동물 지능 연구그룹을 이끄는 X 그룹장은 어느날 지선생을 찾아갔다. X 그룹장은 지선생이 기가 막힐 정도로 천재라는 사실을 눈치채고 있는 소수의 연구원 중 한 사람이었다. 사실 그것이 아니라도 평소 연구 업무에 크게 도움을 주고 있는 지선생을 연구소의 훌륭한 선배로 받들어 모시는 그런 사람이기도 했다.

"요즘 원숭이들의 규칙 준수 가능성을 확인하기 위해서, 원숭이들 행동을 점수로 평가하고 있어요."

"아니 원숭이랑 생긴 일을 왜 나한테 가지고 와서 그래?"

"그런데, 그 녀석들에게 요즘 가르치고 있는게 있거든요."

"뭔데?"

"정확히 100점을 받으면 바나나를 상으로 주고 있어요."

"뭔 소리야?"

"100점을 초과해버리면 안준단 소리죠."

"너 그러다 원숭이한테 맞겠다."

"여튼, 이거 방법을 좀 알려주셨으면..."

"뭔데?"

"원숭이들이 정확히 100점을 받을 수 있는 가능한 모든 행동 시퀀스를 구하는 방법이 필요해요."

"음. 어렵지는 않은데, 점수표는 좀 조절해야겠네?"

"어떻게요?"

"행동에 점수를 매길 때, 행동 별로 같은 점수가 없도록 만들어주면 좋겠네."

"아, 그래요? 그거야, 뭐 어렵지 않죠. 오히려 실험 결과를 식별하기에는 더 편할 것 같은데요?"

"아... 그런데, 원숭이는 예외없이 바나나를 좋아하는거 맞는거지?"

두 사람은 문제를 검토한 후, 머리를 맞대고 방법을 찾아나가기 시작했다.

## 수행목표

- 점수 배열과 목표 점수가 주어진다. 점수 배열은 각 행동 별 점수를 나타내며, 중복된 값을 포함하지 않는다.
- 목표 점수를 정확히 달성하는데 필요한 행동의 시퀀스를 모두 작성해 반환한다.
  - 목표 점수가 30점이고 행동 점수 배열이 [10, 20]인 경우, 이 함수는 [[0, 0, 0], [0, 1], [1, 0]]을 반환한다. 10점 행동을 3번 연달아하거나, 10점 행동 이후에 20점 행동을 하거나, 20점 행동 이후에 10점 행동을 한 세 가지 경우를 해당 점수의 인덱스를 사용해 만든 리스트의 리스트에 해당한다.
  - 목표 점수가 90점이고 행동 점수 배열이 [40, 20]인 경우, 목표 점수를 달성할 수 있는 가능성이 전무하므로 빈 리스트 []를 반환한다.
- 다음 테스트케이스는 점수 배열과 목표 점수의 튜플로 구성되어 있다. 총 5개의 테스트케이스가 제시되며, 각각의 결과를 출력한다.
  ```python
  testcases = [([15, 20], 10), ([1, 2, 3], 6), ([12, 14, 16, 18, 20], 105), ([13, 17, 19], 56)]
  ```

## 수행단계

- 문제의 구조를 분석한다.
  - 하향식으로 접근하기 위해서 목표 점수를 달성하기 전 단계를 사용해서 상위 문제와 하위 문제의 관계를 정리한다.
  - 상향식으로 접근하기 위해서 가장 작은 문제와 상향식 전개 과정을 정리한다.
- 이 문제를 상향식 접근 방법 및 햐힝식 접근 방법 각각의 방식으로 해결하는 두 개의 함수를 dp_exer/monkey_banana.py 파일에 구현한다.
- 제시된 테스트케이스를 사용해 문제를 해결한 결과를 출력한다.

## 결과예시

```

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/monkey_banana.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식, 하향식 각각의 방법을 사용한 두 가지 모두 구현되어 있어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- 하향식 다이나믹 프로그래밍 해결 전략을 제시해보자. 재귀 호출 함수가 하는 일, 종료 조건, 메모이제이션 변수의 정의, 그리고 목록을 작성하는 방법을 설명해야 한다.
  - 목표 점수에서 취할 수 있는 점수 만큼을 뺀 값을 재귀 호출 한 후, 반환되는 전체 목록에 뺀 점수의 항목을 앞에 각각 붙이고 취합하는 방식으로 구현할 수 있다.
  - 종료 조건은 0점이 되었을 때 (성공), 혹은 점수가 남았으나 취할 수 있는 행동이 없을 때(실패) 이다.
  - 목록을 취합하는 방식은 성공의 경우는 해당 항목을 반환하는 경로에 합치고, 실패의 경우에는 버린다.
  - 메모이제이션은 딕셔너리를 사용하며, ws_memo[i]는 i 점을 받기 위한 행동 시퀀스이다.
- 상향식 다이나믹 프로그래밍으로 문제를 해결할 때, 가장 작은 문제를 정의해보자.
  - 가장 작은 문제는 0점을 달성하는 목록을 구하는 문제이다.
- 상향식 다이나믹 프로그래밍으로 문제를 해결할 때, 이전에 계산한 결과를 저장하는 변수를 정의하고 초기화 하는 방법을 제시해보자.
  - 크기 별 문제의 결과를 저장하기 위해서 target + 1 크기의 배열을 빈 배열로 초기화하면서 생성한다.
- 두 가지 구현 방법의 시간 복잡도를 제시하라.

### [코드 예시]

```python

```

---

# 문제 10. 퀀텀 점프 (2)

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

유전 정보의 코딩을 연구하는 D 연구원은 자나깨나 염기 서열의 배치 특징을 생각하는 삶을 살고 있다. 문득 이런 생각이 들었다.

'어떤 배치 구조가 길면 길수록 어떤 특징이 나타나지 않을까? 일단 염기 서열의 오름차순 배치 구조부터 확인해봐야겠다.'

## 수행목표

- 'C', 'T', 'A', 'G' 네 글자로 구성된 문자열이 주어진다. 이 문자열의 부분 순열 중, C, T, A, G 순으로 배치된 부분 문자열의 최장 길이와 이 부분 순열 패턴을 찾아 출력하는 프로그램을 작성한다.
  - 예를 들어 주어진 문자열이 CTAGTACG인 경우, 이 문자열에서 `__A__ACG`의 오름차순 부분 순열이 가장 긴 오름차순 부분 순열이 된다. (같은 값의 경우 오름차순으로 간주한다.) 이 경우 4와 함께 AACG를 출력한다.
  - CTAGGTACG의 경우 `C__GGT___`, `__AGGT___` 등 여러 개의 길이가 4인 오름차순 부분 순열을 찾을 수 있으며, 이 부분순열이 가장 긴 오름차순 부분 순열이다. 이 경우 4와 함께 찾을 수 있는 부분 순열 중 하나를 출력한다.
- 다음 테스트케이스에는 16개의 문자열이 주어진다. 이 문자열에서 가장 긴 오름차순 부분 순열의 길이와 부분 순열 중 하나를 출력한다.
  ```python
  testcases = ['CTAGTACG', 'CTAGGTACG', 'AAA', 'ACGT', 'TGCA', 'ACTTTTTTTCGGGGGGT', 'ACTTTTTCT', 'ACTTTTTCGGGT', 'ACTTTTTCGGGGGGTTTTTT', 'GCCTGCTGGT', 'CCCATCTTCCGTCATTATAG', 'ACCAAGAAACTGTAATCTCCTTCTTCTCGA', 'TCCGTTCGGCATACCCCCCGGCGGGGATATCGAACTGGAG', 'GTCCGAGGGGCAAGCAAGCGGGTTGACGCATCCTGAAGCTCTTTCACAGG', 'ATGGGTGAAAACCCCCATTAACATAACTGGCGCCGGGAGTTACGAATCTCGTGCTTGAAGAAGGGCAAACTGTTTTACGAGAGGTGGGGACAGACTACCT', 'CAATCATCTGGCCTCCAATTAAGACTTTATGCTGCTGCTAGCCAGAAATTTATTGACCACCACGGATGCGACGGCTCGACGCTGATGGTGTGACGTTGCAAAAGCTGGTCTATGGCTTGGTTTAGTGGTGGCCATGGACCCCTCACTCGTAATTTGTAAATGTAATAATAGGCGCCAAATTCAGTGTCTGATGCTGGTTCCCCAGCTGTCTCTTGCAAGTCGGCGCCAATCGTTTTCCACGGAACGACTTGTCTGCGGCCTATGCATCGTTCGCTAGCCAGTTAAATGGCATATGCTAGTTCACCTAACCACTTCAAAGTATCAGCCCAAGGATTTTCACCAGGTAGGGAAATTATTAGGATCGCTAAGCAACCCACTGTCCGATACGACAGCCCGCTGCCAGCGTTTCATTATAGTCTTGGAATACCGTTCCGTTGTTTTCAAACCGTTCCAACCCCCCTGATGCGCCAGCGTCTAGGTTTGTCGGCGCTAGTGGCCACCAGCGCGTGCCATACACGCGGTGTTGGCCTAATCAGTTGCTAAGTACCTAGAACGACAGCTAACCGAAAGAGAAAACATCGAGCTTTTACGTAATTTCTACACTATACGCCCTGGACGACATACTAGTCTGCGTTTGGTCTATATCTATATGTTCACTCCGAAGCTCTCAGATCTGATACAGACACATGAGGGTCTTGTAGCATTCCTAGAGCTTCTATACGCGTGGTTCGCCGGCCAGGATATGGGTCACACGGGTACATTCAACTCCTACTACGAGAGGGGGTGTTTAAACTATCCGTAAAGCCACAGTAATCGAGATTTACCCATAGGCGACCGATCAAATCGTCTATGGACAGAAGTGGCTCCGCCCGCGAAGCTAACATAAGGTCCAATTACATTGTTACCTAAGCTCTTGTACTAAAATCTAGTGATCATAATCCCGGCCCCGTTATCGCCACCATGGCAATATTTGAACGCGCCCTCGTAGAGCTCATAAGGA']
  ```

## 수행단계

- 문제의 구조를 분석한다.
- 문제의 구조를 사용하는 다이나믹 프로그래밍 접근 방식으로 최장 부분 순열 중 하나를 문자열로 만들어 반환하는 함수를 dp_exer/ascending_pattern.py 파일에 구현한다.
  - 다이나믹 프로그래밍 방식으로 구현하며, 구현한 알고리즘의 시간 복잡도를 확인한다. -
- 테스트케이스로 제시된 16개의 문자열에서 가장 긴 오름차순 부분 문자열 중 하나를 만들어 길이와 함께 출력한다.

## 결과예시

```
Testcase 1
    가장 긴 오름차순 부분 순열의 길이 : 4
    가장 긴 오름차순 부분 순열 중 하나 : AACG

Testcase 2
    가장 긴 오름차순 부분 순열의 길이 : 4
    가장 긴 오름차순 부분 순열 중 하나 : CGGT
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/ascending_pattern.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 접근방법을 사용해 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

  ```
  Testcase 1
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : AACG

  Testcase 2
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : CGGT

  Testcase 3
      가장 긴 오름차순 부분 순열의 길이 : 3
      가장 긴 오름차순 부분 순열 중 하나 : AAA

  Testcase 4
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : ACGT

  Testcase 5
      가장 긴 오름차순 부분 순열의 길이 : 1
      가장 긴 오름차순 부분 순열 중 하나 : T

  Testcase 6
      가장 긴 오름차순 부분 순열의 길이 : 10
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTTTT

  Testcase 7
      가장 긴 오름차순 부분 순열의 길이 : 8
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTT

  Testcase 8
      가장 긴 오름차순 부분 순열의 길이 : 8
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTT

  Testcase 9
      가장 긴 오름차순 부분 순열의 길이 : 15
      가장 긴 오름차순 부분 순열 중 하나 : ACCGGGGGGTTTTTT

  Testcase 10
      가장 긴 오름차순 부분 순열의 길이 : 6
      가장 긴 오름차순 부분 순열 중 하나 : CCGGGT

  Testcase 11
      가장 긴 오름차순 부분 순열의 길이 : 11
      가장 긴 오름차순 부분 순열 중 하나 : CCCCCCGTTTT

  Testcase 12
      가장 긴 오름차순 부분 순열의 길이 : 16
      가장 긴 오름차순 부분 순열 중 하나 : AAAAAACTTTTTTTTT

  Testcase 13
      가장 긴 오름차순 부분 순열의 길이 : 20
      가장 긴 오름차순 부분 순열 중 하나 : CCCCCCCCCCGGGGGGGGGG

  Testcase 14
      가장 긴 오름차순 부분 순열의 길이 : 20
      가장 긴 오름차순 부분 순열 중 하나 : CCGGGGGGGGGGTTTTTTTT

  Testcase 15
      가장 긴 오름차순 부분 순열의 길이 : 39
      가장 긴 오름차순 부분 순열 중 하나 : AAAAACCCCCCCGGGGGGGGGGGGGGGGGGGGGGGGGTT

  Testcase 16
      가장 긴 오름차순 부분 순열의 길이 : 274
      가장 긴 오름차순 부분 순열 중 하나 : AAAAAAAAAAAAAAAACCCCCGGGGGGGGGGGGGGGGGGTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
  ```

### [문제에 대한 이해]

- 문제의 구조를 제시하라.
  - 문자열의 i 번째 글자의 값을 마지막 값으로 반드시 포함하는 가장 긴 부분 순열의 길이를 dp[i]라고 표현하면, 임의의 dp[j]의 값은 j 보다 작은 모든 k에 대해서 다음 모든 값들의 최대값이 되는 구조가 성립한다.
    - 만약 k 번째 글자보다 j 번째 글자가 같거나 더 큰 값의 글자인 경우 : dp[k] + 1
    - 그렇지 않은 경우 : 1
- 가장 긴 오름차순 부분 순열을 찾는 방법을 설명하라.
  - 가장 긴 오름차순 부분 순열의 길이를 문자열의 모든 인덱스에 대해서 갱신할 때, j번 인덱스의 글자로 끝나는 오름차순 부분 순열의 이전 글자는 k번째 인덱스의 글자가
    된다. 이를 모든 인덱스 별로 관리한 다음, 부분 문자열의 길이가 최대가 되는 j에 대해서 역순으로 이전 글자를 이어 붙이는 과정으로 가장 긴 오름차순 부분 순열을 찾을 수 있다.
- 구현한 알고리즘의 시간 복잡도를 제시하라.
  - 모든 글자에 대해서 더 작은 글자를 반복하는 구조이므로 n의 이중 루프 구조를 가진다. O(n^2)에 해당된다.
- 만약 문제의 조건이 가장 긴 '연속된 오름차순 부분 문자열'인 경우 문제를 어떻게 해결할 수 있는지 접근 전략을 제시해보자.
  - 슬라이딩 윈도우, 헤드와 테일 포인터 등을 유지하면서 전체 문자열을 스캔하는 방법 등 적당한 전략을 제시할 수 있는지 확인한다.

### [코드 예시]

```python
def find_lap(input_seq):
    if not input_seq:
        return ''

    dp = [1] * len(input_seq)
    prev = [-1] * len(input_seq)

    max_len = 0
    max_index = 0

    for i in range(1, len(input_seq)):
        for j in range(i):
            if input_seq[j] <= input_seq[i] and dp[j] + 1 > dp[i]:
                dp[i] = dp[j] + 1
                prev[i] = j
                if dp[i] > max_len:
                    max_len = dp[i]
                    max_index = i

    longest_ascending_pattern = ''
    while max_index != -1:
        longest_ascending_pattern += input_seq[max_index]
        max_index = prev[max_index]
    return longest_ascending_pattern[::-1]


def main():

    testcases = ['CTAGTACG', 'CTAGGTACG', 'AAA', 'ACGT', 'TGCA', 'ACTTTTTTTCGGGGGGT', 'ACTTTTTCT', 'ACTTTTTCGGGT', 'ACTTTTTCGGGGGGTTTTTT', 'GCCTGCTGGT', 'CCCATCTTCCGTCATTATAG', 'ACCAAGAAACTGTAATCTCCTTCTTCTCGA', 'TCCGTTCGGCATACCCCCCGGCGGGGATATCGAACTGGAG', 'GTCCGAGGGGCAAGCAAGCGGGTTGACGCATCCTGAAGCTCTTTCACAGG', 'ATGGGTGAAAACCCCCATTAACATAACTGGCGCCGGGAGTTACGAATCTCGTGCTTGAAGAAGGGCAAACTGTTTTACGAGAGGTGGGGACAGACTACCT', 'CAATCATCTGGCCTCCAATTAAGACTTTATGCTGCTGCTAGCCAGAAATTTATTGACCACCACGGATGCGACGGCTCGACGCTGATGGTGTGACGTTGCAAAAGCTGGTCTATGGCTTGGTTTAGTGGTGGCCATGGACCCCTCACTCGTAATTTGTAAATGTAATAATAGGCGCCAAATTCAGTGTCTGATGCTGGTTCCCCAGCTGTCTCTTGCAAGTCGGCGCCAATCGTTTTCCACGGAACGACTTGTCTGCGGCCTATGCATCGTTCGCTAGCCAGTTAAATGGCATATGCTAGTTCACCTAACCACTTCAAAGTATCAGCCCAAGGATTTTCACCAGGTAGGGAAATTATTAGGATCGCTAAGCAACCCACTGTCCGATACGACAGCCCGCTGCCAGCGTTTCATTATAGTCTTGGAATACCGTTCCGTTGTTTTCAAACCGTTCCAACCCCCCTGATGCGCCAGCGTCTAGGTTTGTCGGCGCTAGTGGCCACCAGCGCGTGCCATACACGCGGTGTTGGCCTAATCAGTTGCTAAGTACCTAGAACGACAGCTAACCGAAAGAGAAAACATCGAGCTTTTACGTAATTTCTACACTATACGCCCTGGACGACATACTAGTCTGCGTTTGGTCTATATCTATATGTTCACTCCGAAGCTCTCAGATCTGATACAGACACATGAGGGTCTTGTAGCATTCCTAGAGCTTCTATACGCGTGGTTCGCCGGCCAGGATATGGGTCACACGGGTACATTCAACTCCTACTACGAGAGGGGGTGTTTAAACTATCCGTAAAGCCACAGTAATCGAGATTTACCCATAGGCGACCGATCAAATCGTCTATGGACAGAAGTGGCTCCGCCCGCGAAGCTAACATAAGGTCCAATTACATTGTTACCTAAGCTCTTGTACTAAAATCTAGTGATCATAATCCCGGCCCCGTTATCGCCACCATGGCAATATTTGAACGCGCCCTCGTAGAGCTCATAAGGA']

    for i, tc in enumerate(testcases):
        print(f"Testcase {i + 1}")
        longest_ascending_pattern = find_lap(tc)
        length_of_lap = len(longest_ascending_pattern)
        print(f"    가장 긴 오름차순 부분 순열의 길이 : {length_of_lap}")
        print(f"    가장 긴 오름차순 부분 순열 중 하나 : {longest_ascending_pattern}")
        print()

if __name__ == '__main__':
    main()


```
