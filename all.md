# Algorithm

## Master Story

### 등장 인물

- 지선생 - 60대 초반의 계산연구지원 전문위원. 원래 연구지원부서의 행정 직원이었으며, 연구원들로부터 "행정업무의 신"이라고 불리던 칭송받아온 연구소의 살아있는 역사와 같은 사람이었다. 미국 파견으로 부모와 함께 외국 체류 중 수학을 전공으로 대학에 들어갔으나, 대학시절 컴퓨터에 빠지는 바람에 제때 졸업을 못해서 결국 군 입대를 위해서 귀국을 했고, 제대 후 국내 대학의 행정학과에 다시 입학하고 졸업했다. 이후 첫 직장으로 K 바이오 연구소에 입사한 후, 정년에 가까울 때 까지 행정업무만 30년 가까이 맡아왔다. 연구원들이 컴퓨터를 활용하는 연구에 어려움을 겪는 것을 보고, 스스로 '마법의 화이트보드 괴담'을 만들어낸 후, 화이트보드에 해결하기 힘든 문제를 누군가 적어두면 몰래몰래 힌트와 답을 제공하는 것을 일종의 취미로 삼아왔다. '마법의 화이트보드 괴담'의 정체가 밝혀지고 난 후, 연구소에서는 그를 정년과 무관하게 연구원 생활을 할 수 있는 전문위원 자리를 제안했고 이후 수년 째 연구소의 컴퓨터 알고리즘과 관련된 조언과 지원을 해 주고 있다.
- 닥터 E - 진화생물학을 연구하는 박사 연구원이다.
- 닥터 O - '매드 사이언티스트'라는 별명을 가지고 있는 괴팍한 유전공학 연구자
- 닥터 G - 유전자 분석을 중심으로 다양한 연구를 하고 있다.

### 스토리

K 바이오 연구소는 대한민국에서 생명공학 최고의 연구자들이 모여있는 연구소였다. 이 연구소는 지금까지 수많은 실적을 만들어내 명실공히 세계 유수의 대학, 연구소와 경쟁하면서 지금까지 성장해왔다. 이 과정이 순탄할리는 만무했다. 연구 환경이 계속해서 변화하고 있었기 때문이다. 최근에는 컴퓨터가 연구 활동에 필수 도구로 등장하면서 한 번의 큰 고비가 있었다. 컴퓨터 프로그래밍은 프로그래밍 문법 서적을 참고해서 어떻게든 할 수 있었지만, 연구 활동에 필요한 복잡한 프로그램을 효율적으로 만드는 일은 어느 정도 전문성이 필요했기 때문이다. 연구소는 이를 위해서 전담 직원을 채용하려 하였지만, IT가 흥한 시대에 이런 인력들을 연구소에 채용하고 묶어두는 일은 쉬운 일이 아니었다.

연구소장은 이 문제를 해결하기 위해서 프로그래밍 도움 게시판을 만들었다. 누군가가 자기가 풀기 힘든 문제를 작성하면, 그 문제를 해결할 수 있는 다른 연구원이 거기에 답변을 할 수 있도록 시스템을 만든 것이다. 하지만 정말 쉬운 문제는 답이 달렸지만, 전문가의 도움이 필요한 어려운 문제는 답변없이 문제만 쌓였다. 그 때 한 직원이 연구소장에게 본인의 선택에 따라 익명으로 답변을 제공할 수 있도록 하자는 의견을 냈다. 일단 답변을 달고 난 후 벌어질 귀찮은 일 때문에 답변을 제공하지 않는 사람들이 있을 것이라는 의견이었다. 혹시나 하는 마음에 익명으로 답변을 달 수 있도록 하니, 그 때 부터 하나 둘 씩 답변이 달리기 시작했다. 그리고 그 답변 중 일부는 효율성과 정확성에서 큰 도움이 되었다. 이후 그 게시판은 연구원들의 필수 연구 도구가 되었다.

그렇게 몇 년이 지난 후, 사람들은 언제나 가장 도움이 되는 답을 제시하는 사람이 동일인이라는 사실을 눈치채게 되었다.

---
# 단계 1. 알고리즘에 대해서

## 스토리

닥터 G는 K 바이오 연구소 유전정보 연구그룹에서 유전자 정보를 연구하는 연구자이다. 유전정보 연구그룹에서 지금까지 연구한 수십만 개 정도의 샘플 유전자 염기서열을 조건에 따라 조회하는 일이 잦았다. 조건 중 하나는 사전순 정렬이었다. 닥터 G는 십여년 간 지속적으로 조회 대상 유전자 염기서열이 증가하는 것을 목격해왔고, 이에 따라 사전 순 정렬의 성능이 점점 나빠진다는 사실을 경험해왔다.

물론 매우 길고 많은 유전자 염기서열을 효율적으로 정렬하기 위한 소프트웨어 도구 또는 빅데이터 플랫폼을 사용하는 것도 방법이겠지만, 연구비가 아쉬운 연구그룹의 입장에서 핵심 연구 활동에서 거리가 있는 이런 부분에 예산을 사용하기란 쉬운 결정이 아니었다. 결국 닥터 G는 유전자 목록이 주어졌을 때, 이 유전자 목록을 빠르고 효율적으로 정렬할 수 있는 방법을 일단 찾아보기로 결정했다.

이 과정이 '알고리즘 입문'이라는 사실을 처음에는 알 수 없었다.

---

# 문제 1. 알고리즘이 뭐야?

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 G는 IT 분야에서 일하는 친구에게 자문을 구했다. 그러자 친구가 다음과 같이 답변을 했다.
"의외로 가장 기본적인 접근 방법이 가장 유효한 방법인거 같은데?"
"그러니까 그 방법이 뭐야?"
"좋은 알고리즘을 사용하는 것이지."
"좋은 알고리즘? 아니 알고리즘이 뭐야?"

## 수행목표

- 알고리즘의 기본 개념을 학습한다.
- 다음 문제를 해결하는 알고리즘을 제시하고, 이를 파이썬 프로그램으로 작성한다.
  > - 1에서 n까지 모든 정수를 덧셈한 결과를 계산해 출력한다. (n은 1 이상의 양의 정수)
- 다음 입력에 대한 프로그램 결과를 출력한다.
  - n = 10, 100, 1000, 10000, 100000, 1000000

## 수행단계

- 알고리즘의 기본 개념을 조사한다.
  - 알고리즘의 입력, 출력, 단계, 명확성, 유한성, 일반성과 같은 알고리즘의 특징도 조사하고 숙지한다.
- 1에서 k까지 모든 정수를 덧헴한 결과를 계산해 출력하는 프로그램을 algorithm/sigma.py 파일에 작성한다.
  - 작성한 프로그램의 알고리즘을 기준으로, 알고리즘의 입력, 출력, 단계, 명확성, 유한성, 일반성 등을 확인한다.

## 결과 예시

```
testcase 1: 55
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 닥터 G는 주어진 유전자 염기서열을 사전순으로 정렬하는 프로그램을 다음과 같이 작성했다. 다음 프로그램의 알고리즘이 어떤 문제가 있는지 확인해 제시하라.

```python
def pseudo_sort(arr):
    for i in range(len(arr) - 1):
        if arr[i] > arr[i + 1]:
            arr[i], arr[i + 1] = arr[i + 1], arr[i]
```

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/sigma.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    testcase 1: 55
    testcase 2: 5050
    testcase 3: 500500
    testcase 4: 50005000
    testcase 5: 5000050000
    testcase 6: 500000500000
    ```

### [보너스 과제 확인]

- 제시한 정렬 프로그램의 문제를 정확하게 지적할 수 있는가?
  - 가장 큰 값을 제일 뒤로 보내기만 한다는 점을 지적할 수 있는지 확인한다.

### [문제에 대한 이해]

- 알고리즘의 정의는 무엇인가?
  - 알고리즘의 목적(문제 해결), 알고리즘의 구성(절차 또는 단계의 집합)을 기준으로 답변할 수 있어야 한다.
- 알고리즘의 입력과 출력은 무엇인가?
  - (예시 답변)결과를 생성하는데 사용하는 목적으로 제공되는 주어진 값이 입력이며, 입력을 기반으로 생성된 결과가 출력이다.
- 알고리즘의 입력의 개수는 얼마인가?
  - 입력이 없이 동작하는 알고리즘을 이해할 수 있는지 확인한다.
  - (예시 답변) 0개 이상이다.
- 알고리즘의 출력의 개수는 얼마이며, 알고리즘의 출력은 무엇에 의해 결정되는가?
  - 알고리즘의 출력은 알고리즘 자체 뿐 아니라 입력에 의해서도 결정된다는 사실을 이해하는지 확인한다.
  - (예시 답변) 알고리즘의 출력은 1개 이상이며, 알고리즘의 출력은 알고리즘의 각 단계와 순서, 그리고 입력에 의해서 결정된다.
- 알고리즘의 특징 중 명확성, 유한성, 일반성 중 알고리즘의 단계와 관련이 가장 큰 특징은 무엇인가?
  - 알고리즘의 명확성에 대한 이해를 확인한다.
  - (예시 답변) 알고리즘의 각 단계가 모호하지 않아야 한다는 것이 명확성이므로 명확성이 단계와 관련이 있다.
- 알고리즘의 유한성은 무슨 의미인가? 무엇을 기준으로 유한해야 한다는 의미인가?
  - 알고리즘의 유한성에 대한 이해를 확인한다.
  - (예시 답변)알고리즘은 반드시 종료되어야 한다는 의미이다. 입력이나 출력과 무관하며 알고리즘이 수행되는 단계 또는 수행에 필요한 시간을 기준으로 유한하다는 의미이다.
- 알고리즘의 일반성은 무슨 의미인가?
  - 알고리즘의 일반성에 대한 이래와 알고리즘이 특정 입력에만 동작해서는 안된다는 의미를 이해하고 있는지 확인한다.
  - (예시 답변) 알고리즘은 특정 입력 뿐 아니라, 조건에 맞는 모든 가능한 입력에 대해서도 동일한 규칙으로 동작해야 한다.
- 일반적인 알고리즘은 항상 좋은 것일까?
  - 알고리즘의 일반성이 알고리즘의 제약 조건으로 동작한다는 사실을 이해하고 있는지 확인한다.
  - (예시 답변) 일반적인 알고리즘은 보편적으로 좋지만, 특수한 상황에서 좋은 성능을 내야 하는 경우 일반적인 알고리즘 보다는 특수한 입력에서만 동작하는 특수한 알고리즘이 더 좋을 수 있다.
- 문제에서 제시한 작업 이외의 다른 작업을 제시하고, 이 작업에 대한 알고리즘을 순서도 등의 방법으로 표시해보자. (예를 들어 핸드폰의 배터리를 80%까지 충전하는 작업)
  - 제시한 작업을 명확하게 제시된 단계를 사용해 정확하고 유한하게 동작하도록 알고리즘을 순서도로 제시할 수 있는지 확인한다.
  - 발생 가능한 예외 사항 (예를 들어 배터리의 충전이 전혀 되고 있지 않을 때) 알고리즘이 이를 어떻게 처리할 지를 제시할 수 있어야 한다.
- 제시한 알고리즘에서 입력, 출력, 명확성, 유한성, 일반성 등 알고리즘의 특징을 정리해 제시하라.
  - 알고리즘의 특징을 예시를 들어 제대로 이해하고 있는지 확인한다.

### [코드 예시]

```python
def sigma(n):
    result = 0
    if n < 1:
        return 0
    for i in range(1, n+1):
        result += i
    return result

def main():
    testcases = [10, 100, 1000, 10000, 100000, 1000000]
    for i, n in enumerate(testcases):
        result = sigma(n)
        print(f"testcase {i + 1}: {result}")

if __name__ == "__main__":
    main()
```

---

# 문제 2. 알고리즘의 평가

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

닥터 G는 주어진 유전자 염기서열의 목록을 정렬하는 간단한 정렬 아이디어를 정리한 후 친구에게 보여주었다. 그러자 친구는 아이디어의 오류와 함께 수정한 정렬 알고리즘을 설명해 주면서, 그 정렬 방법이 '버블 정렬' 알고리즘임을 알려주었다.

자리로 돌아온 닥터 G는 버블 정렬 방식으로 유전자의 목록을 정렬하는 프로그램을 작성한 후, 가지고 있는 유전자 목록을 정렬해 보았다. 하지만 꽤 오랜 시간이 걸렸고 뭔가 조금 더 쓸만한 방법을 찾아야겠다고 생각했다.

'아니, 그 전에 알고리즘을 평가하는 방법을 찾아야겠는걸?'

## 수행목표

- 버블 정렬 알고리즘을 구현한다.
- 입력 리스트의 길이가 10, 100, 1000, 10000일 때, 버블 정렬 알고리즘 구현 함수의 실행 시간을 측정해 출력한다.

## 수행단계

- 버블 정렬 방법에 대해서 조사한다.
- 버블 정렬 방식으로 리스트를 정렬하는 프로그램 algorithm/bubble_sort.py을 작성한다.
  - 이 프로그램은 정렬 결과를 출력하는 대신 리스트를 정렬하는데 걸린 시간을 출력한다.
  - 1에서 100 사이의 무작위 정수로 구성된 정해진 길이의 리스트를 만든다. 길이가 각각 10, 100, 1000, 10000일 때 리스트를 정렬하는데 필요한 시간을 출력한다.

## 결과 예시

```
testcase 1 : bubble_sort 수행 시간 - 7.152557373046875e-06 초
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 테스트코드에서 함수를 호출하면 '자동으로' 함수의 실행 시간을 출력하는 방법이 있다. 이 방법을 찾아 적용해보자.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/bubble_sort.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 실행 시간은 입력이 10배가 될 때 대략 실행 소요 시간은 100배 정도의 비율로 증가하는 결과가 정상적인 결과이다.
    ```
    testcase 1 : bubble_sort 수행 시간 - 7.152557373046875e-06 초
    testcase 2 : bubble_sort 수행 시간 - 0.00037288665771484375 초
    testcase 3 : bubble_sort 수행 시간 - 0.03979611396789551 초
    testcase 4 : bubble_sort 수행 시간 - 4.126990079879761 초
    ```

### [보너스 과제 확인]

- 함수 호출 만으로 함수의 실행 시간을 출력할 수 있도록 구현하였는가?
  - 파이썬 데코레이터 등의 방법을 사용해 지시한대로 구현이 되었는지 확인한다.

### [문제에 대한 이해]

- 이 문제에서 입력 데이터와 함수의 실행 시간의 관계에 대해서 설명하라.
  - 입력 데이터가 증가함에 따라 함수의 실행 시간도 증가하고 있음을 이해해야 한다.
- 실제 업무용 시스템에 적용하는 경우라면, 닥터 G가 의도한대로 10만개 정도의 유전자 염기 서열을 정렬하는데 이 정렬 알고리즘을 사용할 수 있을지 의견을 제시해보자.
  - 실행 결과를 바탕으로 10만개 정도 크기의 리스트를 정렬하는데 필요한 시간이 어느 정도인지 제시하고, 이를 기초로 이야기 할 수 있어야 한다.
  - 실제 업무용 시스템에서 사용하기에는 부적절한 성능이라는 늬앙스의 답변이 필요하지만, 이 알고리즘이 느리기 때문에 더 좋은 시스템을 사용해야 한다는 취지의 답변도 무방하다.
- 파이썬에서 함수나 특정 코드의 실행 시간을 측정하는 방법은 무엇인가?
  - 실행 시작과 끝의 시간을 구한 후 그 차이를 실행 시간으로 계산할 수 있다.
  - 이를 위해서 시간을 구하는 방법을 구체적으로 제시할 수 있어야 한다.
- 실행 시간을 지표로 삼아서 알고리즘을 평가할 때, 무엇을 평가할 수 있는가?
  - (예시 답변) 알고리즘의 성능을 평가한다.
- 실행 시간으로 평가 지표로 알고리즘의 성능을 평가하는 방식의 유효성에 대해서 평가해보자.
  - 같은 시스템에서 다른 알고리즘이나 다른 입력에 따른 알고리즘의 성능을 상대적으로는 평가할 수 있는 간이 평가 방식 수준이라는 점을 지적해야 한다.
  - 하지만 같은 시스템이라도 시스템의 상태가 달라지면 값이 달라질 수 있으므로 안정성이 부족한 평가 방법이라는 점과 함께 서로 다른 시스템의 결과를 절대적으로 평가할 수 없다는 한계를 제시해야 한다.
- 실행 시간을 더욱 안정적인 평가 지표로 사용하고자 한다면, 이를 보완하는 방법은 무엇인지 제시해보자.
  - 시스템의 상태를 일정하게 유지하고, 여러 번 반복 테스트한 결과를 아웃라이어를 배제하거나 충분한 횟수의 평균을 사용하는 등의 방법으로 안정성을 추가하는 방법을 제시해야 한다.
- 아무리 보완하더라도 실행 시간을 지표로 삼을 때 한계가 존재한다면, 그 한계는 무엇인지 이야기해보자.
  - 모든 시스템에 대해서 같은 값의 실행 시간을 동등하게 평가할 수 없다는 한계는 극복할 수 없음을 이해해야 한다.

### [코드 예시]

```python
import time
import random

def execute_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 수행 시간 - {end - start} 초")
        return result
    return wrapper

@execute_time
def bubble_sort(arr):
    for i in range(len(arr) - 1):
        for j in range(len(arr) - i - 1):
            if arr[j + 1] < arr[j]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]


def main():
    for i in range(4):
        testcase = [random.randint(1, 100) for _ in range(10 ** (i + 1))]
        print(f"testcase {i + 1} :", end=" ")
        bubble_sort(testcase)

if __name__ == '__main__':
    main()
```

---

# 문제 3. 복잡도

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

10만개의 유전자에 버블 정렬 알고리즘을 적용해본 닥터 G는 이 속도라면 만족할 수 없다는 느낌을 받는다. 그런데, 이 느낌을 체계화하고 싶은 연구원 특유의 감성이 자극받게 된다.

프로그래밍 게시판에 이를 체계화 할 수 있는 방법을 문의하자, '빅 오 노테이션'을 사용해 체계화할 수 있다는 답변을 확인하게 된다.

## 수행목표

- 알고리즘의 효율을 체계적으로 평가하기 위한 체계에 대해서 조사하고, 그 결과를 정리해 공유한다.

## 수행단계

- 알고리즘의 효율을 체계적으로 평가하기 위한 개념인 '복잡도'에 대해서 다음 사항을 조사한다.
  - 시간 복잡도의 개념
  - 빅 오 노테이션의 개념
  - 빅 오 노테이션의 예시 : 다음 각 함수를 빅 오 노테이션으로 표현하라.
    - $f(x)=100$
    - $f(x) =20x+7$
    - $f(x)=-5x^2+7$
    - $f(x)=e^x + 5x^k$, k는 임의의 양의 정수
  - 루프와 시간 복잡도의 관계
  - 대표적인 빅 오 노테이션 : 상수 시간 복잡도, 선형 시간 복잡도, 다항식 시간 복잡도, 로그 시간 복잡도, 선형 로그 시간 복잡도, 지수 시간 복잡도, 계승 시간 복잡도 각각이 무엇이며, 어떤 복잡도가 더 효율적인지에 대한 정리
  - 빅 오메가 노테이션의 개념
  - 공간 복잡도의 개념
- 정리한 내용을 마크다운 형식으로 정리해 algorithm/complexity.md 파일을 작성한다.

## 결과 예시

- 없음

## 참고사항

- 없음

## 제약사항

- 없음

## 개발환경

- 없음

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - 마크다운 형식의 algorithm/complexity.md 파일을 작성하였는지를 확인한다.
- 지시한 내용이 문서에 포함되어 있는가?
  - 문서에 다음 내용이 포함되어 있는지 확인한다.
    - 시간 복잡도의 개념
    - 빅 오 노테이션의 개념과 제시한 함수의 빅 오 노테이션 표현 결과
    - 대표적인 빅 오 노테이션의 표현과 빅 오 노테이션 간 효율성 비교
    - 빅 오메가 노테이션의 정의
    - 공간 복잡도의 개념
- 문서의 내용이 정확한가?
  - 예시 함수의 빅 오 노테이션 표현은 다음과 같다.
    - $f(x)=100$ : $\mathcal{O}(1)$
    - $f(x) =20x+7$ : $\mathcal{O}(x)$
    - $f(x)=-5x^2+7$ : $\mathcal{O}(x^2)$
    - $f(x)=e^x + 5x^k$, k는 임의의 양의 정수 : $\mathcal{O}(e^x)$
  - 대표적인 빅 오 노테이션의 표현과 효율성의 순서는 다음과 같다.
    - 상수 시간 복잡도 : $\mathcal{O}(1)$
    - 선형 시간 복잡도 : $\mathcal{O}(n)$
    - 다항식 시간 복잡도 : $\mathcal{O}(n^k)$, k는 1보다 큰 양의 정수
    - 로그 시간 복잡도 : $\mathcal{O}(\log n)$
    - 선형 로그 시간 복잡도 : $\mathcal{O}(n\log n)$
    - 지수 시간 복잡도 : $\mathcal{O}(c^n)$, c는 1보다 큰 양의 정수
    - 계승 시간 복잡도 : $\mathcal{O}(n!)$
    - 좋은 알고리즘부터 나쁜 알고리즘의 순으로 나열한 순서 : 상수 시간 복잡도 < 로그 시간 복잡도 < 선형 시간 복잡도 < 선형 로그 시간 복잡도 < 다항식 시간 복잡도 < 지수 시간 복잡도 < 계승 시간 복잡도

### [문제에 대한 이해]

- 시간 복잡도는 무엇인가?
  - ‘입력 크기의 변화량을 기준으로 실행 시간의 변화량’이라는 입력 크기의 변화량에 상대적인 지표임을 이야기 할 수 있어야 한다.
- 시간 복잡도로 알고리즘을 평가하는 것은 실행 시간으로 평가하는 것과 비교해 어떤 장점이 있는가?
  - 시간 복잡도는 구조 분석에 해당되며, 그로 인해 테스트 환경에 무관하게 평가할 수 있다는 장점이 있음을 이야기 할 수 있어야 한다.
- 최악의 상황, 최선의 상황, 평균의 상황 각각을 가정하고 알고리즘을 평가한다는 것은 무슨 의미인가?
  - 각각의 상황이 입력에 따라 존재할 수 있으며, 같은 크기의 입력에 대해서 가장 느린 경우 또는 가장 빠른 경우를 평가한다는 의미라는 답변이 필요하다.
- 일반적으로 알고리즘을 평가할 때 최악의 상황, 최선의 상황, 평균의 상황 중 어떤 상황을 가정하는가? 그 이유는 무엇인가?
  - 최악의 상황을 일반적으로 가정하며, 최악의 상황이 더 큰 문제가 되기 때문임을 이야기 할 수 있어야 한다.
- 다항식으로 구성된 함수의 빅 오 노테이션은 어떻게 되는가?
  - (예시 답변)최고차 항의 계수를 제외한 값이다.
- 다항식으로 구성된 함수의 최고차 항의 계수가 음수일 때 빅 오 노테이션은 어떻게 되는가?
  - 항의 계수의 부호와 무관하게 빅 오 노테이션이 표현됨을 이야기 할 수 있어야 한다.
- 알고리즘의 시간 복잡도가 상수 시간 복잡도라면, 그 의미에 대해서 ‘시간 복잡도’라는 표현을 사용하지 말고 표현해보자.
  - 입력의 크기와 상관없이 성능이 일정하다는 취지의 답변인지 확인한다.
- 알고리즘의 시간 복잡도가 선형 시간 복잡도라면, 그 의미에 대해서 ‘시간 복잡도’라는 표현을 사용하지 말고 표현해보자.
  - 입력의 크기와 비례해 실행 속도가 증가한다는 취지의 답변인지 확인한다.
- 어떤 알고리즘의 시간 복잡도가 지수 시간 복잡도일 때, 이 알고리즘의 성능을 ‘시간 복잡도’라는 표현을 사용하지 말고 표현해보자.
  - 입력의 크기가 커질 수록 실행 속도는 지수 스케일에 비례해 증가한다는 취지의 답변인지 확인한다.
- 어떤 문제를 해결하기 위해서 여러 가지 구현 방식이 가능하다. 구현하기 쉽고 누구나 이해할 수 있는 지수 시간 복잡도의 구현 방식과 구현하기 난해하고 거의 모든 사람이 이해할 수 없는 선형 시간 복잡도의 구현 방식이 있다면, 어떤 구현 방식을 사용할지 선택하고 선택의 근거를 제시해보자.
  - 이 문제는 경우마다 다른 답변이 나올 수 있으므로 근거가 합리적이며, 그 근거를 사용한 합리적인 선택인지를 확인한다.
  - (예시 답변)다른 사람과 공유해서 사용해야 하는 경우 알고리즘의 간결성이 중요한 평가 지표가 되기 때문에, 입력의 크기를 제한할 수 있다면 지수 시간 복잡도를 사용할 수 있으며, 그렇지 않다면 선형 시간 복잡도를 사용한다.
- 이전 문제에서 구현한 버블 정렬의 시간 복잡도는 얼마인가?
  - 버블 정렬의 시간 복잡도는 $\mathcal O(n^2)$임을 제시하되, 답 뿐 아니라 왜 그런지도 설명할 수 있는지 확인한다.
- 공간 복잡도는 무엇인가?
  - 알고리즘을 수행할 때 필요한 메모리의 크기도 알고리즘을 평가하는데 사용하는 지표이며, 이를 체계적화하는데 사용된다는 사실을 설명할 수 있는지 확인한다.

---

# 문제 4. 재귀호출과 점화식

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 G는 조금 더 효율적인 정렬 방법을 찾아보기로 했다. 인터넷에서 조사를 해 보니 여러 효율적인 정렬 방법이 소개되고 있었다. 그런데 그 정렬 방법들은 모두 알고리즘을 구현한 함수가 다시 자기 자신을 호출하고 있는 이상한 형태로 되어 있었다.

이러한 형태를 찾아보니 이러한 알고리즘 구현 방식을 '재귀호출'이라 부른다는 사실을 알게 되었다. 문득 고등학교 수학 시간에 수열을 배울 때 비슷한 구조의 수식을 사용해 수열을 정의했던 일이 머리속에 떠올랐다.

## 수행목표

- 재귀 호출의 개념을 학습한다.
- 재귀 호출을 사용해 1에서 n까지의 정수를 더하는 알고리즘을 점화식으로 표현하고, 이를 계산하는 함수를 파이썬으로 구현한다.
- 피보나치 수열을 점화식으로 표현하고, 피보나치 수열의 일반항을 구하는 함수를 파이썬으로 구현한다.
- n의 값이 10, 15, 20, 25, 30일때 1에서 n까지 더한 값과 피보나치 수열의 n번째 항을 구현한 함수를 사용해 출력한다.

## 수행단계

- 재귀 호출과 점화식의 개념에 대해서 조사한다.
  - 재귀 호출에서의 종료조건에 대해서도 조사한다.
  - 재귀 호출에서 입력이 잘못 주어졌을 때 일어나는 일도 확인한다.
- 피보나치 수열은 고대의 여러 서적에서 흔적을 찾을 수 있지만, 이를 제외하면 이탈리아의 수학자 레오나르도 피사노, 일명 피보나치에 의해 13세기 초에 소개된 것으로 알려져있다. 피보나치 수열의 n번째 항 $fib_n$을 다음과 같이 정의한다.
  > - 첫 번째 항 $fib_1 = 1$
  > - 두 번째 항 $fib_2 = 1$
  > - 그 이후의 항은 이전 두 항의 합으로 계산한다.
  > - 피보나치 수열의 아홉번째 항까지를 나열하면 1, 1, 2, 3, 5, 8, 13, 21, 34이다.
- 1에서 n까지 정수의 합을 구하는 알고리즘과 피보나치 수열의 일반항을 구하는 알고리즘에 대해서 각각의 점화식을 정리한다.
- 정리한 점화식을 사용해 다음에 지시하는 바를 algorithm/recursive.py 파일에 구현한다.
  - 1에서 n까지의 모든 정수의 합을 구해서 반환하는 함수 sigma(n)
  - 피보나치 수열의 n번째 항을 계산해 반환하는 함수 fibonacci(n)
  - n = 10, 15, 20, 25, 30일 때의 두 함수의 결과를 각각 출력한다.

## 결과 예시

```
n = 10일 때
  1에서 n까지의 합 : 55
  피보나치 수열의 일반항 : 55
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 어떤 n이 주어지더라도 처리되지 않은 예외가 발생하지 않고 프로그램은 정상적으로 종료되어야 한다.
- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 재귀 알고리즘에서 입력이 잘못 주어지는 경우 다양한 문제가 발생할 수 있다. 이 경우 try ~ except 구문을 사용해 함수가 이를 예외 처리하여 발생한 예외 상황을 명확하게 보여줄 수 있도록 구현을 수정해보자.
- n = 0.5, 0, -1일 때 결과를 출력해보자.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/recursive.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    n = 10일 때
      1에서 n까지의 합 : 55
      피보나치 수열의 일반항 : 55
    n = 15일 때
      1에서 n까지의 합 : 120
      피보나치 수열의 일반항 : 610
    n = 20일 때
      1에서 n까지의 합 : 210
      피보나치 수열의 일반항 : 6765
    n = 25일 때
      1에서 n까지의 합 : 325
      피보나치 수열의 일반항 : 75025
    n = 30일 때
      1에서 n까지의 합 : 465
      피보나치 수열의 일반항 : 832040
    ```
  - 음수, 정수가 아닌 유리수, 0의 경우에도 프로그램이 적절한 결과를 출력하고 프로그램이 처리하지 않은 예외를 발생시키지 않고 종료되는지 확인한다.

### [보너스 과제 확인]

- 이상 입력에 대한 예외 처리가 구현되었는가?
  - try ~ except 구문을 사용해 이상 입력에 대한 예외츨 처리하였는지 확인한다.
  - 0, -1, 0.5 입력에 대해서 예외처리 결과를 출력하였는지 확인한다. 다음은 결과 예시이다.
    ```
    n = 0.5일 때
      예외 발생 : Input must be integer
    n = 0일 때
      예외 발생 : Input must be positive integer
    n = -1일 때
      예외 발생 : Input must be positive integer
    ```

### [문제에 대한 이해]

- 재귀 호출은 어떤 것인지 설명하라.
  - 재귀 호출은 함수가 자기 자신을 다시 호출하는 형태를 말한다.
- 재귀 호출의 종료조건은 무엇인가?
  - 재귀 호출이 종료되는 시점 뿐 아니라, 이 경우에는 자명한 값이 주어질 수 있어야 한다는 부분도 설명할 수 있어야 한다.
- 재귀 호출에서 조건에 맞지 않은 입력이 주어졌을 때 발생할 수 있는 일을 설명하라.
  - 무한 반복, 잘못된 계산 등을 최소한 포함하는 상황을 제시할 수 있는지 확인한다.
- 점화식은 무엇인가? 점화식은 알고리즘을 구현할 때 어떤 형태로 사용되는지를 설명하라.
  - 현재 상태가 이전 상태와 관련이 있을 때, 현재 상태를 이전상태를 사용해 표현한 식을 점화식이라고 한다.
  - 알고리즘을 구현할 때, 현재 상태를 구하기 위한 이전 상태를 재귀 호출하는 형태로 쉽게 알고리즘을 구현할 수 있다.
- 1에서 n까지 더하는 알고리즘의 점화식을 제시하라.
  - $a_n = a_{n-1} + n$을 기본으로 종료조건과 함께 제시할 수 있는지 확인한다.
- 피보나치 수열의 일반항을 구하는 알고리즘의 점화식을 제시하라.
  - $a_n = a_{n - 1} + a_{n - 2}$를 기본으로 종료조건과 함께 제시할 수 있는지 확인한다.
- 구현한 함수의 종료조건에 대해서 설명하라.
  - 각자 구현한 함수의 종료조건에 대해서 설명할 수 있는지 확인한다.

### [코드 예시]

```python
def fibonacci(n):
    if not isinstance(n, int):
        raise TypeError("Input must be integer")
    if n < 1:
        raise ValueError("Input must be positive integer")
    if n == 1 or n == 2:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

def sigma(n):
    if not isinstance(n, int):
        raise TypeError("Input must be integer")
    if n == 1:
        return 1
    if n < 1:
        raise ValueError("Input must be positive integer")
    return n + sigma(n - 1)

def main():
    testcase = [10, 15, 20, 25, 30, 0.5, 0, -1]
    for n in testcase:
        try:
            print(f"n = {n}일 때")
            fib_result = fibonacci(n)
            sig_result = sigma(n)
            print(f"  1에서 n까지의 합 : {sig_result}")
            print(f"  피보나치 수열의 일반항 : {fib_result}")
        except TypeError as e:
            print(f"  예외 발생 : {e}")
        except ValueError as e:
            print(f"  예외 발생 : {e}")

if __name__ == "__main__":
    main()
```

---

# 문제 5. 재귀호출의 구현

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 G는 재귀 호출에 조금 더 익숙해질 필요가 있다는 생각이 들었다. 그때 프로그래밍 지원게시판에 눈에 들어오는 문제가 하나 있었다. 조금 재미있어 보이는 이 문제를 해결하고 나면, 재귀 호출에 꽤 익숙해질 것 같은 확신이 생겨났다. 왜 그런 확신이 생겼는지는 모르겠지만...

## 수행목표

- 닥터 G의 친구이자 동료인 닥터 S는 바이오 필터를 연구하고 있다. 닥터 S가 연구하는 바이오 필터의 성질은 다음과 같다.
  - 바이오 필터는 필터의 격자 크기에 따라 구분이 되며, 격자 크기가 작을수록 작은 바이러스를 차단하는 효과를 나타낸다.
  - 미세필터 하나만 사용하면 정해진 크기 이상의 모든 바이러스를 차단할 수 있지만, 격자 크기가 작을수록 필터의 내구도가 떨어져서 쉽게 망가지는 문제가 있어서 바이어 필터를 여러층으로 배치해서 사용하고 있다.
  - 효율적인 필터 활용을 위해서 필터 배치는 항상 위로 올라갈 수록 격자의 크기가 작아지도록 배치해야 한다.
    - 물론 최종 제품만 이러한 형태로 배치되면 제품화를 할 수는 있지만, 육안으로는 필터의 격자의 크기를 구분할 수 없으므로 실험 또는 제품 생산 과정에서 필터를 옮길 때도 반드시 이 원칙을 지켜야 한다.
- 닥터 S는 필터를 배치하기 위해 3개의 실험판을 사용한다. 필터의 오염을 막기 위해서 3개의 실험판 이외의 장소에 필터를 배치할 수 없다. 이 실험판은 수명이 정해져 있어서 주기적으로 실험판을 교체해야 한다. 다만 3개의 실험판을 동시에 교체하는 경우 바이오 필터를 모두 버려야 하기 때문에 실험판 1 위에 쌓여 있는 바이오 필터를 모두 실험판 2로 옮긴 후 실험판 1을 새 실험판으로 교체하는 방식으로 이루어진다.
- 닥터 S는 n개의 서로 다른 크기의 바이오 필터를 세 개의 실험판 중 하나에 모두 쌓아두었다. 실험판을 교체하기 위해서 이 바이오 필터를 모두 다른 두 개의 실험판 중 하나로 옮겨야 한다. 바이오 필터 하나를 옮기는 회수를 1로 계산할 때 n개의 바이오 필터를 모두 다른 실험판 하나 위로 옮기는데 필요한 바이오 필터의 이동 회수를 구하는 함수를 재귀 호출 방식으로 구현한다.
- n = 3, 5, 10일 때 필요한 바이오 필터의 이동 회수를 출력하라.

## 수행단계

- 바이오 필터의 개수 n = 3일 때 바이오 필터를 다른 실험판으로 옮기는 과정은 다음과 같다.
  - 격자의 크기 순으로 필터를 $f_1$, $f_2$, $f_3$으로 부른다. 격자의 크기가 클 수록 필터의 번호가 커진다.
  - 실험판은 각각 $p_1$, $p_2$, $p_3$으로 부른다. 현재 배치되어 있는 실험판을 $p_1$이라고 하고, $p_2$, $p_3$ 둘 중 어느 쪽으로 이동해도 무방하다.
  - 초기상황 : $p_1$에 아래로부터 $f_3$, $f_2$, $f_1$ 순으로 배치되어 있다. 이를 ([3-2-1, X, X]으로 표시한다.)
  - $p_1$의 가장 위의 필터를 $p_2$로 이동한다. 이를 $p_1 \rightarrow p_2$로 표현한다. 이동 후의 상태는 [3-2, 1, X]이 된다. 이 과정과 결과 상태를 다음과 같이 표현한다.
    - $p_1 \rightarrow p_2$ : [3-2, 1, X]
  - $p_1 \rightarrow p_3$ : [3, 1, 2]
  - $p_2 \rightarrow p_3$ : [3, X, 2-1]
  - $p_1 \rightarrow p_2$ : [X, 3, 2-1]
  - $p_3 \rightarrow p_1$ : [1, 3, 2]
  - $p_3 \rightarrow p_2$ : [1, 3-2, X]
  - $p_1 \rightarrow p_2$ : [X, 3-2-1, X]
  - 이와 같은 과정을 거쳐 총 7번 격자를 이동해서 $p_1$ 위의 바이오 필터를 모두 $p_2$로 옮길 수 있다.
- 위의 이동 과정에서 n = 3일 때의 이동 회수와 n = 2일 때의 이동 회수의 관계를 찾아서 이를 점화식으로 정리한다.
- 이 점화식을 사용해 바이오 필터의 개수가 n일 때 필요한 최소 이동 회수를 계산하는 함수를 구현하고, 그 결과를 출력하는 파이썬 프로그램을 algorithm/moving_filter.py 파일에 작성한다.
  - n은 항상 양의 정수로 주어진다.
  - n = 3, 4, 5, 10, 100일 때 필요한 이동 회수를 출력한다.

## 결과예시

```
3개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 7
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 재귀 호출을 사용해 바이오 필터를 옮기는 순서를 출력하는 함수를 구현한다.
  - 이 때 최초의 실험판의 이름과 목표 실험판의 이름을 명시한다.
- n = 3, 4, 5일 때 이동 과정을 출력한다. 다음은 n = 3일 때의 결과예시이다.

  ```
  3개의 바이오 필터를 p1 실험판에서 p2 실험판으로 옮기는 과정
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p1 -> p2
      p3 -> p1
      p3 -> p2
      p1 -> p2
  ```

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/moving_filter.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    3개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 7
    4개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 15
    5개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 31
    10개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 1023
    100개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 1267650600228229401496703205375
    ```

### [보너스 과제 확인]

- 재귀 호출로 구현한 함수를 사용해 바이오 필터 이동 과정을 정확하게 출력하였는가?

  - 다음은 바이오 필터의 개수가 3, 4, 5개일 때의 출력 결과이다. 결과에서 시작 실험판과 목표 실험판은 반드시 1, 2일 필요는 없다. 다만 반드시 두 실험판은 다른 실험판이어야 한다.

  ```
  3개의 바이오 필터를 p1 실험판에서 p2 실험판으로 옮기는 과정
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p1 -> p2
      p3 -> p1
      p3 -> p2
      p1 -> p2

  4개의 바이오 필터를 p1 실험판에서 p2 실험판으로 옮기는 과정
      p1 -> p3
      p1 -> p2
      p3 -> p2
      p1 -> p3
      p2 -> p1
      p2 -> p3
      p1 -> p3
      p1 -> p2
      p3 -> p2
      p3 -> p1
      p2 -> p1
      p3 -> p2
      p1 -> p3
      p1 -> p2
      p3 -> p2

  5개의 바이오 필터를 p1 실험판에서 p2 실험판으로 옮기는 과정
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p1 -> p2
      p3 -> p1
      p3 -> p2
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p2 -> p1
      p3 -> p1
      p2 -> p3
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p1 -> p2
      p3 -> p1
      p3 -> p2
      p1 -> p2
      p3 -> p1
      p2 -> p3
      p2 -> p1
      p3 -> p1
      p3 -> p2
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p1 -> p2
      p3 -> p1
      p3 -> p2
      p1 -> p2
  ```

### [문제에 대한 이해]

- 바이오 필터가 n개 일 때 바이오 필터를 다른 실험판으로 옮기는 과정을 설명하라. 단 '어떤 실험판의 바이오 필터 1개를 어떤 실험판으로 옮긴다.'와 '어떤 실험판의 바이오 필터 n-1개를 어떤 실험판으로 옮긴다.' 두 가지 형태로만 과정을 단순화해 제시해야 한다.
  - 바이오 필터를 n-1개와 1개의 순서로 다른 실험판에 옮긴 후, n-1개를 가장 큰 격자의 바이오필터 하나로 옮기는 형태의 3단계로 제시하는지 확인한다.
- n개의 바이오 필터가 주어졌을 때, 이동 회수를 구하는데 사용할 수 있는 점화식을 제시하고, 그 점화식이 왜 그렇게 만들어졌는지를 설명하라.
  - n개의 바이오 필터에서 n-1개를 옮기는 횟수, 그리고 남은 1개의 바이오 필터를 옮긴 후, 다시 n - 1개의 바이오 필터를 1개의 바이오 필터 위로 옮기는데 필요한 횟수를 기반해서 점화식을 제시하는지 확인한다.
  - n개의 바이오 필터를 옮기는데 필요한 최소 이동 횟수를 $t_n$이라고 하면, 점화식은 $t_n = 2\times t_{n-1} + 1$이다.
- (보너스 문제를 해결한 경우) 회수를 구하는 대신 옮기는 과정을 출력하기 위해서 어떤 방법으로 알고리즘을 구성하였는가?
  - 재귀 호출 과정에서 횟수를 더하는 대신, 그 과정을 출력하도록 재귀 호출 함수를 수정하였음을 확인한다.
  - 또한 시작 실험판과 목표 실험판의 위치를 명확히 지정하는 알고리즘이 구현되었는지를 확인한다.
- 이 문제를 통해 재귀 호출의 필요성을 이야기해보라.
  - 재귀 호출을 사용하는 구현의 직관성에 대해서 설명할 수 있는지 확인한다.

### [코드 예시]

```python
def moving_count(n):
    if n == 1:
        return 1
    return 2 * moving_count(n - 1) + 1

def moving_guide(src, dest, room, n):
    if n == 0:
        return
    moving_guide(src, room, dest, n - 1)
    print(f"    {src} -> {dest}")
    moving_guide(room, dest, src, n - 1)

def main():
    testcases = [3, 4, 5, 10, 100]
    for tc in testcases:
        print(f"{tc}개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : {moving_count(tc)}")

    testcases = [3, 4, 5]
    for tc in testcases:
        print(f"{tc}개의 바이오 필터를 p1 실험판에서 p2 실험판으로 옮기는 과정")
        moving_guide('p1', 'p2', 'p3', tc)
        print()

if __name__ == '__main__':
    main()
```

---

# 문제 6. 알고리즘의 시간 복잡도

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

바이오 필터 이동 문제를 해결한 닥터 G는 구현한 알고리즘의 시간 복잡도가 어떻게 될지가 갑자기 궁금해졌다. 루프를 사용한 일반적인 알고리즘의 경우는 루프의 중첩 회수를 사용해 시간 복잡도를 계산할 수 있었지만, 재귀 함수의 경우는 시간 복잡도를 어떻게 판단해야 하는지 잘 연상이 되지 않았다. 하지만 알고리즘은 어떤 방식으로건 시간 복잡도를 파악할 수 있어야 좋은 알고리즘인지의 여부를 확인할 수 있으니 이를 피할 수 없었다.

프로그래밍 지원게시판에 이를 어떻게 계산하는지를 물어보기로 했다.

## 수행목표

- 1에서 n까지 모든 정수의 합을 구하는 알고리즘은 다음과 같이 유사코드로 표현할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION sigma(n)
    IF n < 1 THEN RETURN 0
    ELSE IF n == 1 THEN RETURN 1
    ELSE RETURN sigma(n - 1) + n
```

- n개의 양의 정수 중 최대값을 찾는 알고리즘을 다음과 같이 유사코드로 표현할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION max_number1(arr, size)
    result = 0
    FOR i FROM 0 TO size - 1
        IF arr[i] > result THEN
            result = arr[i]
    RETURN result
```

- n개의 정수 중 최대값을 찾는 알고리즘을 다음과 같이 두개 씩 비교한 결과를 취합하는 방식으로 재귀 호출 알고리즘으로 구현할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION max_number2(arr, start, end):
    IF start == end THEN
        RETURN arr[start]
    ELSE
        mid = (end + start) // 2
        leading_max = max_number2(arr, start, mid)
        trailing_max = max_number2(arr, mid + 1, end)
        IF leading_max > trailing_max THEN
            RETURN leading_max
        ELSE
            RETURN trailing_max
```

- 위의 알고리즘을 다음과 같이 조금 더 효율적으로 변경할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION max_number3(arr, start, end):
    IF start == end THEN
        RETURN arr[start]
    ELSE IF start + 1 == end THEN
        IF arr[start] > arr[end] THEN RETURN arr[start]
        ELSE RETURN arr[end]
    ELSE
        mid = (end + start) // 2
        leading_max = max_number3(arr, start, mid)
        trailing_max = max_number3(arr, mid + 1, end)
        IF leading_max > trailing_max THEN
            RETURN leading_max
        ELSE
            RETURN trailing_max
```

- n개의 서로 다른 정수가 오름차순으로 정렬된 리스트 arr에서 특정 값(k)의 인덱스를 찾는 알고리즘을 다음과 같이 구현할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION find_number1(arr, size, k)
    FOR i FROM 0 TO size - 1
        IF arr[i] > k THEN RETURN -1
        IF arr[i] == k THEN RETURN i
    RETURN -1
```

- n개의 서로 다른 정수가 오름차순으로 정렬된 리스트 arr에서 특정 값(k)의 인덱스를 찾는 알고리즘을 다음과 같이 재귀 호출 알고리즘으로 구현할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION find_number2(arr, start, end, k)
    IF start == end THEN
        IF arr[start] == k THEN RETURN start
        ELSE RETURN -1
    mid = (start + end) // 2
    IF arr[mid] > k THEN RETURN find_number2(arr, start, mid, k)
    ELSE RETURN find_number2(arr, mid + 1, end, k)
```

## 수행단계

- algorithm/find_complexity.py 파일에 다음을 구현한다.
  - 주어진 5개의 유사 코드를 파이썬 함수로 구현한다.
  - n = 512일 때 1에서 n까지의 모든 정수의 합을 구하도록 함수를 호출하고, 그 결과를 출력한다.
  - 1에서 10000 범위의 서로 다른 정수로 구성된 길이 512, 511인 무작위 리스트를 두 개 생성한다. 단, 이 리스트에는 반드시 5000이 포함되도록 리스트를 생성한다.
  - 이 두 개의 리스트 각각에 대해서 max_number1, max_number2, max_number3 알고리즘의 결과를 구하도록 함수를 호출하고, 그 결과를 출력한다.
  - 위에서 생성한 두 개의 리스트를 오름차순으로 정렬한 후, 두 개의 리스트 각각에 대해서 값 인덱스 5000을 구하도록 함수를 호출하고, 그 결과를 출력한다.
- 구현한 함수를 대상으로 다음 질문에 대한 답을 마크다운 형식으로 정리해 algorithm/find_complexity.md 파일에 작성한다.
  - sigma 알고리즘의 시간 복잡도를 계산한다.
    - n이 512일 때 함수가 호출되는 회수는 몇 번인가?
    - n이 증가하면 함수의 호출되는 회수는 어떻게 증가하는가?
    - 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - max_number1 알고리즘의 시간 복잡도를 계산한다.
    - n이 512일 때, max_number1 함수가 호출되는 회수는 몇 번인가?
    - n이 증가하면 함수의 호출되는 회수는 어떻게 증가하는가?
    - 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - max_number2 알고리즘의 시간 복잡도를 계산한다.
    - n = 1, 2, 3, 4, 5, 6, 7, 8일 때 max_number2 함수가 호출되는 회수는 각각 몇 번인가?
    - 위 결과를 바탕으로 max_number2에서 입력 리스트의 길이가 n일 때 함수 호출 회수는 몇 번이 될 지를 수식으로 제시하라.
    - 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - max_number3 알고리즘의 시간 복잡도를 계산한다.
    - n = 1, 2, 3, 4, 5, 6, 7, 8일 때 max_number3 함수가 호출되는 회수는 각각 몇 번인가?
    - 위 결과를 바탕으로 max_number3에서 입력 리스트의 길이가 n일 때 함수 호출 회수는 몇 번이 될 지를 수식으로 제시하라.
    - 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - max_number1, max_number2, max_number3 세 알고리즘의 효율성을 평가해보자.
  - find_number1 알고리즘의 시간 복잡도를 계산한다.
    - 리스트의 길이가 512일 때 가장 빠르게 결과를 반환하는 경우는 어떤 경우이며, 이 때의 루프 반복 횟수는 얼마인가?
    - 리스트의 길이가 512일 때 가장 느리게 결과를 반환하는 경우는 어떤 경우이며, 이 때의 루프 반복 횟수는 얼마인가?
    - n이 증가함에 따라 루프의 반복 횟수는 어떻게 되는가?
    - 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - find_number2 알고리즘의 시간 복잡도를 계산한다.
    - 리스트의 길이가 512일 때, 이 함수는 어떤 값의 인덱스를 찾기 위해서 몇 번 호출되는가?
    - 리스트의 길이가 256일 때, 이 함수는 어떤 값의 인덱스를 찾기 위해서 몇 번 호출되는가?
    - 리스트의 길이가 511일 때, 이 함수는 어떤 값의 인덱스를 찾기 위해서 몇 번 호출되는가? 만약 두 가지 이상의 경우가 존재한다면 각각 어떤 경우에 해당하는지를 설명하라.
    - 위의 결과를 바탕으로 리스트의 길이가 $n = 2^k$일 때, 이 함수는 어떤 값의 인덱스를 찾기 위해서 함수가 호출되는 횟수는 몇 번인지 추정해보자.
    - 위의 결과를 바탕으로 리스트의 길이가 $2^{k - 1} + 1$ 이상 $2^{k}$이하의 값일 때 함수가 호출되는 횟수는 몇 번인지 추정해보자.
    - 2^k = n일 때 밑이 2인 log n의 값은 얼마인가?
    - 빅 오 노테이션의 정의를 고려해서 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - find_number1, find_number2 두 알고리즘의 효율성을 평가해보자.
  - 이전 문제에서 구현한 바이오필터 이동 횟수 구하는 재귀 호출 알고리즘의 시간 복잡도를 계산한다.
    - 재귀 호출을 재외한 함수의 시간 복잡도는 어떻게 되는가?
    - 바이오 필터의 개수가 n일 때와 바이오 필터의 개수가 n - 1일 때의 재귀 함수의 총 호출 회수의 관계를 점화식의 형태로 작상하라.
    - 바이오 필터의 개수가 n일 때 재귀 함수의 총 호출 회수는 몇 번인가?
    - 빅 오 노테이션으로 이 알고리즘의 시간 복잡도를 표현하라.

## 결과예시

```
sigma(512)의 결과 : XXX
길이 512의 리스트에서의 최댓값
    max_number1의 결과 : XXX
    max_number2의 결과 : XXX
    max_number3의 결과 : XXX
정렬된 길이 512의 리스트에서 5000의 인덱스 번호
    find_number1의 결과 : XXX
    find_number2의 결과 : XXX
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 이전 문제에서 구현한 적 있는 피보나치 수열의 일반항을 구하는 재귀 호출 알고리즘의 시간 복잡도를 제시하라.
  - 제시한 시간 복잡도의 근거로 함께 제시할 수 있어야 한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/find_complexity.py 파일에 구현이 되어 있는지 확인한다.
  - 시간 복잡도를 분석한 리포트를 algorithm/find_complexity.md 파일에 마크다운 형식으로 작성하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 또한 최댓값과 인덱스의 결과도 무작위 생성된 리스트의 내용에 따라 달라질 수 있지만, 최댓값, 그리고 인덱스 번호는 하나의 리스트에서 모두 동일하게 출력되어야 한다.

    ```
    sigma(512)의 결과 : 131328
    길이 512의 리스트에서의 최댓값
        max_number1의 결과 : 9993
        max_number2의 결과 : 9993
        max_number3의 결과 : 9993
    정렬된 길이 512의 리스트에서 5000의 인덱스 번호
        find_number1의 결과 : 256
        find_number2의 결과 : 256
    길이 511의 리스트에서의 최댓값
        max_number1의 결과 : 9982
        max_number2의 결과 : 9982
        max_number3의 결과 : 9982
    정렬된 길이 511의 리스트에서 5000의 인덱스 번호
        find_number1의 결과 : 274
        find_number2의 결과 : 274
    ```

  - 리포트에서 제시한 각 함수의 시간 복잡도는 다음과 같다.
    - sigma : $\mathcal O(n)$
    - max_number1 : $\mathcal O(n)$
    - max_number2 : $\mathcal O(n)$
    - max_number3 : $\mathcal O(n)$
    - find_number1 : $\mathcal O(n)$
    - find_number2 : $\mathcal O(\log n)$ - 로그의 밑을 2로 표기하거나 밑을 표기하지 않아도 무방하다.
    - 바이오 필터 이동 회수 : $\mathcal O(2^n)$
  - 리포트에서는 max_number1, max_number2, max_number3의 호출 또는 반복 횟수는 달라도 시간 복잡도가 같은 동일한 시간 복잡도를 가진 알고리즘으로 평가할 수 있어야 한다. 다만 실제 성능 자체는 다를 수 있다고 표기할 수 있다.
  - 리포트에서 find_number1 보다 find_number2의 알고리즘이 더 효율적이라고 이야기 할 수 있어야 한다.

### [보너스 과제 확인]

- 피보나치 수열의 시간 복잡도를 계산 방식과 함께 정확히 제시할 수 있는가?
  - 피보나치 수열의 시간 복잡도는 $\mathcal O(2^n)$이다.
  - 충분히 큰 n에 대해서 재귀의 깊이는 n에 가깝고, 각 단계에서 재귀 호출 회수는 두 배씩 증가하므로, 이를 바탕으로 지수 시간 복잡도에 해당함을 설명할 수 있는지 확인한다.

### [문제에 대한 이해]

- 최대값을 찾는 세 함수의 반복 또는 재귀 호출 횟수는 모두 다르다. 그럼에도 불구하고 시간 복잡도가 동일하므로 세 함수의 실제 성능은 동일하다고 이야기 할 수 있는가?
  - 어디까지나 '시간복잡도'를 기준으로 평가한 결과이며, 실제 실행 성능은 다를 수 있다고 이야기 할 수 있어야 한다.
  - 또한 시간 복잡도는 n의 값이 커짐에 따라서 늘어나는 시간의 비율의 스케일을 이야기 하는 것으로 절대 성능과 무관하기 때문에 실제 성능과 차이가 있다고 이야기 할 수도 있다.
- 각 함수가 한 번의 재귀 호출을 할 때, 입력의 크기가 절반으로 줄어드는 경우의 시간 복잡도는 어떻게 될까? 단, 재귀 호출을 제외한 나머지 부분의 시간 복잡도는 상수 시간복잡도라고 가정한다.
  - 로그 시간 복잡도
- 각 함수가 한 번의 재귀 호출을 할 때, 입력의 크기가 절반으로 줄어드는 경우의 시간 복잡도는 어떻게 될까? 단, 재귀 호출을 제외한 나머지 부분의 시간 복잡도는 $\mathcal O(n)$이라고 가정한다.
  - 선형 로그 시간 복잡도 ($\mathcal O(n \log n))$
- 각 함수가 한 번의 재귀 호출을 할 때, 입력의 크기가 1씩 줄어드는 경우의 시간 복잡도는 어떻게 될까? 단, 재귀 호출을 제외한 나머지 부분의 시간 복잡도는 상수 시간복잡도라고 가정한다.
  - 선형 시간 복잡도
- 각 함수가 두 번의 재귀 호출을 할 때, 입력의 크기가 1씩 줄어드는 경우의 시간 복잡도는 어떻게 될까? 단, 재귀 호출을 제외한 나머지 부분의 시간 복잡도는 상수 시간복잡도라고 가정한다.
  - 지수 시간 복잡도

### [코드 예시]

```python
def sigma(n):
    if n < 1:
        return 0
    if n == 1:
        return 1
    return sigma(n - 1) + n

def max_number1(arr, size):
    result = 0
    for i in range(size):
        if arr[i] > result:
            result = arr[i]
    return result

def max_number2(arr, start, end):
    if start == end:
        return arr[start]
    mid = (start + end) // 2
    leading_max = max_number2(arr, start, mid)
    trailing_max = max_number2(arr, mid + 1, end)
    if leading_max > trailing_max:
        return leading_max
    else:
        return trailing_max

def max_number3(arr, start, end):
    if start == end:
        return arr[start]
    if start + 1 == end:
        return arr[start] if arr[start] > arr[end] else arr[end]
    mid = (start + end) // 2
    leading_max = max_number3(arr, start, mid)
    trailing_max = max_number3(arr, mid + 1, end)
    if leading_max > trailing_max:
        return leading_max
    else:
        return trailing_max

def find_number1(arr, size, k):
    for i in range(size):
        if arr[i] > k:
            return -1
        if arr[i] == k:
            return i
    return -1

def find_number2(arr, start, end, k):
    if start == end:
        if arr[start] == k:
            return start
        else:
            return -1
    mid = (start + end) // 2
    if arr[mid] == k:
        return mid
    elif arr[mid] > k:
        return find_number2(arr, start, mid, k)
    else:
        return find_number2(arr, mid + 1, end, k)

import random

def make_distinct_random_list(size):
    arr = [5000]
    while len(arr) < size:
        num = random.randint(1, 10000)
        if num not in arr:
            arr.append(num)
    return arr

def test_c(n):
    if n == 1:
        return 1
    if n % 2 == 0:
        return 2 * test_c(n // 2) + 1
    else:
        return test_c((n + 1) // 2) + test_c((n - 1) // 2) + 1
def main():
    print("sigma(512)의 결과 :", sigma(512))
    size1 = 512
    arr1 = make_distinct_random_list(size1)
    size2 = 511
    arr2 = make_distinct_random_list(size2)

    arr1_sorted = sorted(arr1)
    arr2_sorted = sorted(arr2)
    print("길이 512의 리스트에서의 최댓값")
    print("    max_number1의 결과 :", max_number1(arr1, size1))
    print("    max_number2의 결과 :", max_number2(arr1, 0, size1 - 1))
    print("    max_number3의 결과 :", max_number3(arr1, 0, size1 - 1))
    print("정렬된 길이 512의 리스트에서 5000의 인덱스 번호")
    print("    find_number1의 결과 :", find_number1(arr1_sorted, size1, 5000))
    print("    find_number2의 결과 :", find_number2(arr1_sorted, 0, size1 - 1, 5000))

    print("길이 511의 리스트에서의 최댓값")
    print("    max_number1의 결과 :", max_number1(arr2, size2))
    print("    max_number2의 결과 :", max_number2(arr2, 0, size2 - 1))
    print("    max_number3의 결과 :", max_number3(arr2, 0, size2 - 1))
    print("정렬된 길이 511의 리스트에서 5000의 인덱스 번호")
    print("    find_number1의 결과 :", find_number1(arr2_sorted, size2, 5000))
    print("    find_number2의 결과 :", find_number2(arr2_sorted, 0, size2 - 1, 5000))

if __name__ == '__main__':
    main()
```

---

# 문제 7. 재귀 호출의 구조

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

닥터 G는 마치 체인을 연결한 것 처럼 이루어지는 유전자 변형 과정을 예측하는 작업을 진행하고 있었다. 유전자의 변형 결과는 이전 유전자 변형 결과를 사용해고, 또 그 이전의 결과를 사용하는 방식으로 이루어지는 과정의 시뮬레이션의 필요성을 접하는 순간 얼마전에 알게 된 재귀호출로 이 문제를 해결할 수 있겠다고 생각했다.

이 과정을 통해 시뮬레이션 결과를 예측할 수 있었는데, 긱 딘계의 번호를 출력하는데 문제가 발생했다.
'어? 왜 숫자가 거꾸로 나와?'

닥터 G가 원한 결과는 다음과 같았다.

```
1단계 처리 완료
2단계 처리 완료
...
10단계 처리 완료
```

그런데 화면에 나온 결과는 다음과 같았다.

```
10단계 처리 완료
9단계 처리 완료
...
1단계 처리 완료
```

## 수행목표

- 재귀 호출을 하면서 다음과 같이 출력하는 함수를 구현한다.

```
1
2
3
...
10
```

- 이 함수에서 코드의 순서만 바꾸고 다음과 같이 출력하는 함수를 구현한다.

```
10
9
8
...
1
```

- 파이썬에서 재귀 호출 함수를 구현할 때 주의해야 할 점을 추가로 조사한다.

## 수행단계

- algorithm/recursion_warning.py 파일에 다음 재귀 함수를 구현한다.
  - 재귀 함수는 반복 회수를 파라미터로 받는다. (파라미터는 양의 정수만 주어진다.) 재귀 호출 함수는 현재의 누적 호출 회수룰 다음과 같이 출력한다.
  - 출력 결과는 다음과 같다. 파라미터로 10으로 지정했을 때의 결과이다.
  ```
  1
  2
  3
  ...
  10
  ```
- 위의 재귀 호출 함수와 모든 것이 동일하지만, 코드 상에서 두 줄의 위치만 변경해서 다음과 같이 출력되는 재귀 함수를 구현한다.
  ```
  10
  9
  8
  ...
  1
  ```
- 두 함수의 구현 차이를 확인하고, 어떤 차이가 이러한 결과를 발생시켰는지를 확인한다.
- 파라미터를 2000으로 지정했을 때 어떤 결과가 나오는지 확인한다.
  - 재귀의 깊이가 너무 깊어졌을 때 발생 가능한 문제를 조사한다.
- 재귀 호출에서 재귀 호출의 깊이와 관련된 문제점을 다음 순서로 조사한다.
  - 스택 메모리와 힙 메모리의 개념
  - 파이썬 함수가 메모리를 사용하는 방식
  - 재귀 호출과 공간 복잡도의 관계
  - 재귀 호출의 깊이가 과도하게 길어졌을 때 발생 가능한 문제점 (메모리 사용과 관련된 문제점을 중심으로 조사한다)
  - 파이썬에서 과도한 재귀 호출을 제한하는 이유와 방식

## 결과예시

- 없음

## 참고사항

- 없음

## 제약사항

- 이 문제에 한해서 아무런 제약사항을 두지 않는다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 파이썬에서는 과도한 재귀 호출을 제한하고 있는데, 이 제한을 완화시키는 방법이 있다. 이 방법을 사용해 파라미터가 2000일 때의 결과를 확인할 수 있도록 코드를 수정해보자.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/recursion_warning.py 파일에 구현이 되어 있는지 확인한다.
  - 두 개의 함수가 코드의 순서 이외에 모두 동일한지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    정방향 출력
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    역방향 출력
    10
    9
    8
    7
    6
    5
    4
    3
    2
    1
    큰 수가 입력 되었을 때
    Traceback (most recent call last):
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 25, in <module>
        main()
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 22, in main
        count(10000)
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 7, in count
        count(n - 1)
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 7, in count
        count(n - 1)
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 7, in count
        count(n - 1)
    [Previous line repeated 994 more times]
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 5, in count
        if n == 0:
    RecursionError: maximum recursion depth exceeded in comparison
    ```

### [보너스 과제 확인]

- 재귀 호출의 제한을 완화시키는 코드를 추가하였는가?
  - sys.setrecursionlimit(1000000)와 같이 재귀 호출의 깊이 제한을 충분하게 설정해 두었는지 확인한다.
  - 실행 결과 예외가 발생하지 않아야 한다.

### [문제에 대한 이해]

- 두 함수의 구현의 차이는 무엇인가?
  - 출력과 재귀 호출의 선후 순서의 차이이다.
- 재귀 호출에서 재귀 호출의 위치에 따른 차이를 설명하라.
  - 재귀 호출 이후에 출력을 하는 경우, 가능한 재귀 호출을 다 수행한 후 출력을 역순으로 하면서 거슬러 올라오기 때문에 1부터 10의 순서로 출력하게 된다.
  - 재귀 호출 이전에 출력을 하는 경우, 우선 출력을 한 후 재귀 호출을 하기 때문에 10부터 1의 순서로 출력하게 된다.
- 스택 메모리와 힙 메모리의 개념에 대해서 설명하라.
  - 힙 메모리
    - 동적 메모리 할당을 위해서 사용되는 메모리를 힙 메모리라고 한다.
    - 동적으로 메모리를 할당받는 객체가 생성되거나, 이러한 객체들이 동적으로 메모리의 크기를 추가로 사용할 때 할당되는 메모리 영역이다.
  - 스택 메모리
    - 함수가 호출될 때 함수에 포함된 지역 변수, 매개 변수, 반환 주소값 등을 가지고 있는 스택 프레임이 저장되는 메모리이다.
- 파이썬에서 함수를 호출할 때 어떤 메모리를 고정적으로 추가 사용하게 되는가?
  - 스택 메모리를 추가로 사용하게 된다.
- 재귀 호출이 과도할 때 발생할 수 있는 메모리 오류에 대해서 설명하라.
  - 시스템의 스택의 크기는 고정되어 있다. 이러한 스택 메모리를 과도하게 사용함으로써 공간 복잡도가 증가하고 결국 정해진 크기의 스택 메모리의 용량을 넘어서는 스택 오버플로우 오류의 발생 가능성이 있다.
- 파이썬에서 재귀 호출의 깊이를 제한하고 있는 이유를 설명하라.
  - 스택 오버플로우를 방지해 시스템의 안정성을 확보하기 위해서이다.
- (보너스 문제를 해결한 경우)재귀 호출의 깊이를 완화하는 설정이 가능하다. 이 방법은 만병통치약 처럼 언제나 사용할 수 있는 방법인지 의견을 제시해보자.
  - 이 제한을 풀어버리면 발생 가능한 메모리 오류의 위험성이 커지므로 만병통치약처럼 사용해서는 안된다.

### [코드 예시]

```python
import sys
sys.setrecursionlimit(1000000)

def count(n):
    if n == 0:
        return 0
    count(n - 1)
    print(n)

def count_reverse(n):
    if n == 0:
        return 0
    print(n)
    count_reverse(n - 1)

def main():
    print("정방향 출력")
    count(10)
    print("역방향 출력")
    count_reverse(10)
    print("큰 수가 입력 되었을 때")
    count(10000)

if __name__ == "__main__":
    main()
```

---

# 문제 8. 첫 번째 정렬 알고리즘

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

어느 정도 알고리즘과 재귀 호출 방식에 익숙해진 닥터 G는 재귀 호출을 사용한 효율적인 정렬 알고리즘을 구상하기 시작했다. 닥터 G의 첫 번째 정렬 알고리즘의 아이디어는 다음과 같았다.

> - 목록에서 임의로 하나의 유전자 시퀀스를 선택한다.
> - 선택한 유전자 시퀀스보다 사전순으로 앞에 위치한 항목들의 리스트(즉 작은 값을 가진 항목의 리스트)와, 선택한 유전자 시퀀스보다 사전순으로 뒤에 위치한 항목들의 리스트(즉 큰 값을 가진 항목의 리스트)를 각각 만든다.
> - 두 개의 리스트를 각각 정렬한 다음, 정렬된 작은 값을 가진 항목의 리스트, 선택한 시퀀스, 정렬된 큰 값을 가진 항목의 리스트를 순서대로 이어 붙인다.
>   - 두 개의 리스트를 각각 정렬할 때, 만들고 있는 알고리즘을 재귀 호출해서 정렬한다.
>   - 더 이상 정렬할 필요가 없는 작은 크기의 리스트(즉, 크기가 1 또는 0인 리스트)에 도달할 때 까지 재귀 호출을 반복한다.

## 수행목표

- 닥터 G의 아이디어를 정렬 함수로 구현한다.
  - 단 닥터 G의 아이디어에 사소한 결함이 하나 있다. 이 결함을 찾아내고 이를 수정한 아이디어로 정렬 함수를 구현해야 한다.
- 다음 두 개의 파일에는 숫자와 유전자 시퀀스로 구성된 8개씩의 목록을 포함하고 있으며, 각각의 목록은 testcase 번호, 목록에 포함된 항목의 수, 그리고 각 줄마다 하나씩의 항목에 해당하는 리스트의 내용으로 구성된다. 예를 들어서 5개의 시퀀스를 가진 목록은 파일에 다음과 같이 기록되어 있다.

```
testcase 1
5
CTCAT
TACAG
GACT
TAGGC
ATCTA
```

- 두 개의 파일에 포함된 16개의 목록을 정렬한 후, 그 결과를 수행단계에서 지시한 방식으로 가공해서 출력한다.

## 수행단계

- algorithm/first_sort.py 파일에 닥터 G의 정렬 아이디어대로 주어진 리스트를 정렬하는 함수를 구현한다.
  - 닥터 G의 정렬 아이디어에 숨겨진 결함을 찾아서, 아이디어를 수정한 후 이를 구현한다.
  - 이 함수는 정렬할 대상을 포함하는 리스트만 파라미터로 받는다.
  - 리스트의 항목이 문자열이건 숫자이건 상관없이 동작해야 한다. 문자열의 경우는 사전순으로, 숫자의 경우는 오름차순으로 정렬한 결과를 반환한다.
  - 정렬 후에도 파라미터로 전달한 원래의 리스트의 항목의 순서는 그대로 유지되어야 한다.
- 파일에 포함된 20개의 목록을 정렬한 후, 정렬 결과를 다음과 같이 가공해 출력한다.

  - 숫자의 경우 마지막 자리 수를 이어 붙인 문자열을 생성한다.
  - 문자열의 경우 마지막 글자를 이어 붙인 문자열을 생성한다.
  - 생성한 문자열을 다음 함수를 사용해 '간이 해시값'을 생성한 후 이를 출력한다.

  ```python
  import hashlib

  def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]
  ```

## 결과예시

```
숫자 리스트
testcase 1
    계산한 간이 해시 값 : 827c
(이하 생략)

유전자 시퀀스 리스트
testcase 1
    계산한 간이 해시 값 : d793
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/first_sort.py 파일에 구현이 되어 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    숫자 리스트
    testcase 1
        계산한 간이 해시 값 : 827c
    testcase 2
        계산한 간이 해시 값 : c4ca
    testcase 3
        계산한 간이 해시 값 : b0ba
    testcase 4
        계산한 간이 해시 값 : 827c
    testcase 5
        계산한 간이 해시 값 : 827c
    testcase 6
        계산한 간이 해시 값 : 98be
    testcase 7
        계산한 간이 해시 값 : 3b10
    testcase 8
        계산한 간이 해시 값 : cf21

    유전자 시퀀스 리스트
    testcase 1
        계산한 간이 해시 값 : d793
    testcase 2
        계산한 간이 해시 값 : 0d61
    testcase 3
        계산한 간이 해시 값 : e86a
    testcase 4
        계산한 간이 해시 값 : d793
    testcase 5
        계산한 간이 해시 값 : d793
    testcase 6
        계산한 간이 해시 값 : 4c9a
    testcase 7
        계산한 간이 해시 값 : ed28
    testcase 8
        계산한 간이 해시 값 : 14e9
    ```

### [문제에 대한 이해]

- 닥터 G의 아이디어의 결함은 무엇인가?
  - 피벗에 해당하는 수가 중복해 리스트에 포함된 경우, 정렬된 리스트에 피벗이 단 한번만 반영된다. 이렇게 재귀 호출 과정에서 지속적으로 피벗에 해당하는 숫자의 항목들이 누락되는 문제가 발생한다.

### [코드 예시]

```python
def qsort(arr):
    if len(arr) < 2:
        return arr

    pivot = arr[0]
    left = []
    right = []
    pivot_count = 1

    for i in range(1, len(arr)):
        if arr[i] < pivot:
            left.append(arr[i])
        elif arr[i] > pivot:
            right.append(arr[i])
        else:
            pivot_count += 1
    return qsort(left) + [pivot] * pivot_count + qsort(right)

import hashlib
def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]


def main():
    print("숫자 리스트")
    with open('testcase1.txt', 'r') as f:
        number_list = []
        i = 0
        line = f.readline()
        while True:
            if not line or line[0:8] == 'testcase':
                if i == 0:
                    i += 1
                    line = f.readline()
                else:
                    print(f"testcase {i}")
                    sorted_list = qsort(number_list)
                    result = ''
                    for n in sorted_list:
                        result += str(n % 10)
                    print(f"    계산한 간이 해시 값 : {hash4(result)}")
                    number_list = []
                    i += 1
                    line = f.readline()
                if not line:
                    break

            else:
                number_list.append(int(line.strip()))
            line = f.readline()

    print("\n유전자 시퀀스 리스트")
    with open('testcase2.txt', 'r') as f:
        sequence_list = []
        i = 0
        line = f.readline()
        while True:
            if not line or line[0:8] == 'testcase':
                if i == 0:
                    i += 1
                    line = f.readline()
                else:
                    print(f"testcase {i}")
                    sorted_list = qsort(sequence_list)
                    result = ''
                    for sequence in sorted_list:
                        result += sequence[0]
                    print(f"    계산한 간이 해시 값 : {hash4(result)}")
                    sequence_list = []
                    i += 1
                    line = f.readline()
                if not line:
                    break

            else:
                sequence_list.append(line.strip())
            line = f.readline()

if __name__ == '__main__':
    main()
```

---

# 문제 9. 두 번째 정렬 알고리즘

## 문제 분류

- 중요도 : 4/5
- 난이도 : 4/5
- 목표 수행 시간 : 4시간

## 스토리

첫 번째 정렬 아이디어를 구현하던 닥터 G는 두 번째 정렬 아이디어가 떠올랐다. 이 아이디어는 다음과 같다.

> - 목록을 크기가 같거나, 크기 차이가 1인 두 개의 리스트로 나눈다. 이 때 항목의 크기는 신경쓰지 않고 순서대로 그냥 나눈다.
> - 나눈 두 개의 리스트 각각을 정렬한다.
>   - 두 개의 작은 리스트를 정렬할 때 만들고 있는 알고리즘을 재귀 호출해서 정렬한다.
> - 정렬된 두 개의 리스트를 합친다.
>   - 이 때, 정렬된 두 리스트의 앞에서부터 차례대로 가장 작은 항목을 추가해나가는 방식으로 합친다.

## 수행목표

- 닥터 G의 두 번째 정렬 아이디어를 정렬 함수로 구현한다.
- 다음 두 개의 파일에는 숫자와 유전자 시퀀스로 구성된 8개씩의 목록을 포함하고 있으며, 각각의 목록은 testcase 번호, 목록에 포함된 항목의 수, 그리고 각 줄마다 하나씩의 항목에 해당하는 리스트의 내용으로 구성된다. 예를 들어서 5개의 시퀀스를 가진 목록은 파일에 다음과 같이 기록되어 있다.

```
testcase 1
5
CTCAT
TACAG
GACT
TAGGC
ATCTA
```

- 두 개의 파일에 포함된 16개의 목록을 정렬한 후, 그 결과를 수행단계에서 지시한 방식으로 가공해서 출력한다.

## 수행단계

- algorithm/second_sort.py 파일에 닥터 G의 정렬 아이디어대로 주어진 리스트를 정렬하는 함수를 구현한다.
  - 이 함수는 정렬할 대상을 포함하는 리스트만 파라미터로 받는다.
  - 리스트의 항목이 문자열이건 숫자이건 상관없이 동작해야 한다. 문자열의 경우는 사전순으로, 숫자의 경우는 오름차순으로 정렬한 결과를 반환한다.
  - 정렬 후에도 파라미터로 전달한 원래의 리스트의 항목의 순서는 그대로 유지되어야 한다.
- 파일에 포함된 20개의 목록을 정렬한 후, 정렬 결과를 다음과 같이 가공해 출력한다.

  - 숫자의 경우 마지막 자리 수를 이어 붙인 문자열을 생성한다.
  - 문자열의 경우 마지막 글자를 이어 붙인 문자열을 생성한다.
  - 생성한 문자열을 다음 함수를 사용해 '간이 해시값'을 생성한 후 이를 출력한다.

  ```python
  import hashlib

  def hash4(input):
    return hashlib.md5(input.encode()).hexdigigest()[:4]
  ```

## 결과예시

```
숫자 리스트
testcase 1
    계산한 간이 해시 값 : 827c
(이하 생략)

유전자 시퀀스 리스트
testcase 1
    계산한 간이 해시 값 : d793
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/second_sort.py 파일에 구현이 되어 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    숫자 리스트
    testcase 1
        계산한 간이 해시 값 : 827c
    testcase 2
        계산한 간이 해시 값 : c4ca
    testcase 3
        계산한 간이 해시 값 : b0ba
    testcase 4
        계산한 간이 해시 값 : 827c
    testcase 5
        계산한 간이 해시 값 : 827c
    testcase 6
        계산한 간이 해시 값 : 98be
    testcase 7
        계산한 간이 해시 값 : 3b10
    testcase 8
        계산한 간이 해시 값 : cf21

    유전자 시퀀스 리스트
    testcase 1
        계산한 간이 해시 값 : d793
    testcase 2
        계산한 간이 해시 값 : 0d61
    testcase 3
        계산한 간이 해시 값 : e86a
    testcase 4
        계산한 간이 해시 값 : d793
    testcase 5
        계산한 간이 해시 값 : d793
    testcase 6
        계산한 간이 해시 값 : 4c9a
    testcase 7
        계산한 간이 해시 값 : ed28
    testcase 8
        계산한 간이 해시 값 : 14e9
    ```

### [문제에 대한 이해]

- 두 개의 정렬된 리스트를 병합하는 과정을 설명하라.
  - 두 리스트를 통틀어 가장 작은 항목을 병합된 리스트에 추가하되, 이를 위해서 하나의 리스트를 두 번 이상 반복해서 읽지 않는 방법을 제시하는지 확인한다.

### [코드 예시]

```python
def msort(arr):
    if len(arr) < 2:
        return arr

    mid = len(arr) // 2
    left = msort(arr[:mid])
    right = msort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    merged = []
    left_index = 0
    right_index = 0
    while left_index < len(left) or right_index < len(right):
        if left_index >= len(left):
            merged.append(right[right_index])
            right_index += 1
        elif right_index >= len(right):
            merged.append(left[left_index])
            left_index += 1
        elif left[left_index] <= right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            right_index += 1
    return merged

import hashlib
def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]


def main():
    print("숫자 리스트")
    with open('testcase1.txt', 'r') as f:
        number_list = []
        i = 0
        line = f.readline()
        while True:
            if not line or line[0:8] == 'testcase':
                if i == 0:
                    i += 1
                    line = f.readline()
                else:
                    print(f"testcase {i}")
                    sorted_list = msort(number_list)
                    result = ''
                    for n in sorted_list:
                        result += str(n % 10)
                    print(f"    계산한 간이 해시 값 : {hash4(result)}")
                    number_list = []
                    i += 1
                    line = f.readline()
                if not line:
                    break

            else:
                number_list.append(int(line.strip()))
            line = f.readline()

    print("\n유전자 시퀀스 리스트")
    with open('testcase2.txt', 'r') as f:
        sequence_list = []
        i = 0
        line = f.readline()
        while True:
            if not line or line[0:8] == 'testcase':
                if i == 0:
                    i += 1
                    line = f.readline()
                else:
                    print(f"testcase {i}")
                    sorted_list = msort(sequence_list)
                    result = ''
                    for sequence in sorted_list:
                        result += sequence[0]
                    print(f"    계산한 간이 해시 값 : {hash4(result)}")
                    sequence_list = []
                    i += 1
                    line = f.readline()
                if not line:
                    break

            else:
                sequence_list.append(line.strip())
            line = f.readline()

if __name__ == '__main__':
    main()
```

---

# 문제 10. 두 정렬 알고리즘의 평가

## 문제 분류

- 중요도 : 4/5
- 난이도 : 4/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 J가 조금 더 조사해보니 첫 번째 정렬은 ‘퀵 정렬’, 두 번째 정렬은 ‘병합 정렬’이라는 이름의 유명한 정렬 알고리즘이라는 사실을 알게 되었다. 어느 쪽을 써도 좋은 상황이라면, 둘 중 하나를 선택하기 위해서 두 개의 알고리즘이 매우 큰 리스트를 정렬하는데 쓸만한지를 테스트 해 보고, 둘 중 더 좋은게 어떤 것인지도 확인해보고자 했다.

## 수행목표

- 구현한 두 정렬 알고리즘의 시간 복잡도를 확인한다.
- 두 정렬 알고리즘의 성능을 시간 기준으로 측정해 비교해본다.
  - 길이 100, 1000, 10000, 100000, 1000000인 무작위 리스트를 만들고, 두 정렬 알고리즘의 실행 시간을 출력한다.
- 시간 복잡도와 알고리즘의 실행 시간을 기준으로 두 정렬 알고리즘을 평가한다.

## 수행단계

- 퀵 정렬의 시간 복잡도를 계산해보자.
  - 퀵 정렬의 시간 복잡도를 최악의 경우를 기준으로 계산한다.
- 병합 정렬의 시간 복잡도를 계산해보자.
  - 병합 정렬의 시간 복잡도를 최악의 경우를 기준으로 계산한다.
- algorithm/sort_compare.py 파일에 다음 기능을 수행하는 프로그램을 작성한다.
  - 1에서 10000 사이의 무작위 정수로 구성된 리스트를 5개 만든다. 리스트의 크기는 각각 100, 1000, 10000, 100000, 1000000으로 한다.
  - 이 리스트를 두 정렬 알고리즘을 사용해 정렬하는데 소요된 시간을 측정해 출력한다.
- 계산한 시간 복잡도와 측정된 실행 시간을 교차 검토하고, 그 결과를 확인한다.
  - 만약 교차 검토한 결과가 기대한 바와 다르다면, 그 이유가 무엇인지 조사한다.

## 결과예시

```
길이가 100인 리스트 정렬에 걸린 시간
  퀵 정렬: XXX초
  병합 정렬: XXX초

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/sort_compare.py 파일에 구현이 되어 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    길이가 100인 리스트 정렬에 걸린 시간
        퀵 정렬: 0.00012421607971191406초
        병합 정렬: 0.0001690387725830078초

    길이가 1000인 리스트 정렬에 걸린 시간
        퀵 정렬: 0.0010440349578857422초
        병합 정렬: 0.002103090286254883초

    길이가 10000인 리스트 정렬에 걸린 시간
        퀵 정렬: 0.01375579833984375초
        병합 정렬: 0.025216102600097656초

    길이가 100000인 리스트 정렬에 걸린 시간
        퀵 정렬: 0.13886785507202148초
        병합 정렬: 0.3139970302581787초

    길이가 1000000인 리스트 정렬에 걸린 시간
        퀵 정렬: 1.691460132598877초
        병합 정렬: 4.043997049331665초
    ```

### [문제에 대한 이해]

- 퀵 정렬의 시간 복잡도를 제시하라. 시간 복잡도가 왜 이렇게 제시되었는지도 설명할 수 있어야 한다.
  - 퀵 정렬의 시간 복잡도는 최악의 경우를 기준으로 $\mathcal O(n^2)$임을 제시할 수 있어야 한다.
  - 최악의 경우는 선택한 피벗 숫자가 최대, 혹은 최소값으로 계속 선택되어 리스트를 둘로 나누는 과정에서 극단적인 불균형이 누적되는 경우이다.
- 병합 정렬의 시간 복잡도를 제시하라. 시간 복잡도가 왜 이렇게 제시되었는지도 설명할 수 있어야 한다.
  - 병합 정렬의 시간 복잡도는 항상 $\mathcal O(n \log n)$임을 제시할 수 있어야 한다.
  - 매 단계마다 리스트의 크기는 반으로 줄어들고 ($\mathcal O(\log n)$), 매 단계에서 원래 크기 만큼의 리스트를 병합하기 때문이라는 설명이 제시되었는지 확인한다.
- 시간 복잡도를 기준으로 어떤 정렬 알고리즘이 더 효율적일 것으로 기대되는가?
  - 시간 복잡도 기준으로는 병합 정렬이 더 효율적일 것으로 기대된다.
- 실제 실행 시간을 측정한 결과는 시간 복잡도 기준의 분석 결과와 일치하는가?
  - 그렇지 않다.
- 실제 실행 시간이 왜 그렇게 나오는지 조사한 결과를 제시하라.
  - 일반적인 상황은 최악의 상황이 아니라는 점을 제시하면 정답으로 간주한다.
  - 이외에 하드웨어 최적화, 프로그래밍 언어의 최적화 등을 제시해도 정답으로 간주할 수 있다.
  - 퀵 정렬은 최악의 경우 다항식 시간 복잡도의 알고리즘이지만 평균적으로는 지수 시간 복잡도로 병합 정렬과 비슷하다.
  - 퀵 정렬은 별도의 저장 공간이 필요 없으며, 퀵 정렬의 특성 상 주어진 배열 또는 리스트의 연속적인 부분을 정렬하므로, CPU 등에서 제공하는 캐시가 더욱 효율적으로 활용될 수 있다는 추가적인 장점(Reference Locality)이 있기 때문에, 실질적으로는 주로 퀵 정렬이 사용된다.

### [코드 예시]

```python
def qsort(arr):
    if len(arr) < 2:
        return arr

    pivot = arr[0]
    left = []
    right = []
    pivot_count = 1

    for i in range(1, len(arr)):
        if arr[i] < pivot:
            left.append(arr[i])
        elif arr[i] > pivot:
            right.append(arr[i])
        else:
            pivot_count += 1
    return qsort(left) + [pivot] * pivot_count + qsort(right)

def msort(arr):
    if len(arr) < 2:
        return arr

    mid = len(arr) // 2
    left = msort(arr[:mid])
    right = msort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    merged = []
    left_index = 0
    right_index = 0
    while left_index < len(left) or right_index < len(right):
        if left_index >= len(left):
            merged.append(right[right_index])
            right_index += 1
        elif right_index >= len(right):
            merged.append(left[left_index])
            left_index += 1
        elif left[left_index] <= right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            right_index += 1
    return merged

import random, time

def main():
    for i in range(5):
        list = []
        for _ in range(10 ** (i + 2)):
            list.append(random.randint(1, 10000))

        qsort_start = time.time()
        qsort(list)
        qsort_end = time.time()
        m_sort_start = time.time()
        msort(list)
        m_sort_end = time.time()
        print(f"길이가 {10 ** (i + 2)}인 리스트 정렬에 걸린 시간")
        print(f"    퀵 정렬: {qsort_end - qsort_start}초")
        print(f"    병합 정렬: {m_sort_end - m_sort_start}초")
        print()

if __name__ == "__main__":
    main()
```
# 단계 2. 알고리즘을 구현하기 위한 자료형

## 스토리

! 스토리 추가
!!! 문제 12 TC1, 3 동일

---

# 문제 1. 일단 리스트는 잘 다루어야...

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 G는 유전자 염기서열을 분석하기 위해서 유전자를 순서대로 조각내는 모든 경우의 수를 찾고 있었다. 예를 들어서 'CTA'라는 유전자 염기 서열은 다음과 같이 조각을 낼 수 있다.

```
'CTA'
'C', 'TA'
'CT', 'A'
'C', 'T', 'A'
```

재귀 호출을 사용하면 쉽게 조각낼 수 있을 것만 같았지만, 생각만큼 잘 되지 않아서 고생을 하던 닥터 G는 게시판에 이 문제를 좀 풀어달라고 글을 올렸다.

## 수행목표

- 파이썬 리스트의 사용법을 숙지한다.
- 어떤 리스트가 주어졌을 때, 이 리스트의 모든 원소를 빠짐없이 하나 이상으로 나눈 모든 조합의 리스트를 만들어 반환한다. 리스트를 나눌 때, 리스트의 항목의 순서는 지켜져야 한다.

  - 다음 리스트에는 13개의 테스트케이스가 포함되어 있다. 테스트케이스 별로 결과를 구한 후, 이를 수행단계에서 지시하는대로 변형해 출력한다.

    ```python
    testcases = [['C', 'T', 'A'], [1, 2, 3], [1, 1, 1], [1], ['C'], [1, 1], ['C', 'T', 'A', 'G'], [1, 1, 1, 1], ['C', 'T', 'A', 'G', 'T'], [23, 24, 25, 26, 27], ['CT', 'AG', 'TG', 'GC', 'CA', 'AT'], ['AT', 'TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT', 'G'], ['TTCGTC', 'GCT', 'GTCAGATGC', 'T', 'CGCCAT']]
    ```

## 수행단계

- 다음 기능을 재귀 호출을 사용해 수행하는 함수를 datastructure/list_segmentation.py 파일에 구현한다.

  - 어떤 리스트가 주어진다. 목표는 유전자 염기서열의 모든 조각의 경우의 수를 찾는 것이지만, 굳이 특정 자료형에만 한정한 알고리즘을 만들 필요는 없다.
    - 테스트 케이스는 문자열과 숫자가 주어진다.
  - 이 리스트를 빠진 항목없이 순서대로 나누는 모든 경우의 리스트를 반환하는 함수를 구현한다.

    - 예를 들어서 주어진 입력 리스트가 ['C', 'T', 'A']인 경우, 반환하는 리스트는 다음 4개의 리스트를 가진 리스트이다.

    ```
    [['C'], ['T'], ['A']]
    [['C'], ['T', 'A']]
    [['C', 'T'], ['A']]
    [['C', 'T', 'A']]
    ```

    - 실제로 반환되는 리스트는 세번 중첩된 리스트이다. 위의 입력에서 반환되는 리스트는 다음과 같다.
      - `[[['C'], ['T'], ['A']], [['C'], ['T', 'A']], [['C', 'T'], ['A']], [['C', 'T', 'A']]]`
    - 결과의 리스트의 순서는 구현 방식에 따라 변경될 수 있지만, 각 항목의 순서는 반드시 입력 리스트의 순서를 지켜야 한다.
      - 예를 들어서 위의 결과는 `[[['C'], ['T', 'A']], [['C', 'T'], ['A']], [['C', 'T', 'A']], [['C'], ['T'], ['A']]]`와 같이 순서가 바뀔 수 있지만, 이 리스트의 항목인 `[['C'], ['T', 'A']]`가 `[['T', 'A'], ['C']]` 또는 `[['C'], ['A', 'T']]`가 되어서는 안된다.
    - 제공된 10개의 테스트 케이스에 대해서 반환된 결과 리스트를 다음의 c2h4 함수를 사용해 그 결과를 출력한다.

      ```python
      import hashlib
      def hash4(input):
          return hashlib.sha256(input.encode()).hexdigest()[:4]

      def c2h4(arr):
          arr.sort()
          result = ''
          for mid_list in arr:
              result += '_'
              for inner_list in mid_list:
                  result += '='
                  for element in inner_list:
                      if isinstance(element, int):
                          result += chr((element % 26) + 65) + ','
                      else:
                          result += element + ','
          return hash4(result)
      ```

## 결과 예시

```
Testcase 1의 입력 : ['C', 'T', 'A']
    결과 : 465f
Testcase 2의 입력 : [1, 2, 3]
    결과 : 17ad
Testcase 3의 입력 : [1, 1, 1]
    결과 : 27ce
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - datastructure/list_segmentation.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    Testcase 1의 입력 : ['C', 'T', 'A']
        결과 : 465f
    Testcase 2의 입력 : [1, 2, 3]
        결과 : 17ad
    Testcase 3의 입력 : [1, 1, 1]
        결과 : 27ce
    Testcase 4의 입력 : [1]
        결과 : 3dec
    Testcase 5의 입력 : ['C']
        결과 : 0665
    Testcase 6의 입력 : [1, 1]
        결과 : 608f
    Testcase 7의 입력 : ['C', 'T', 'A', 'G']
        결과 : 56cb
    Testcase 8의 입력 : [1, 1, 1, 1]
        결과 : dda7
    Testcase 9의 입력 : ['C', 'T', 'A', 'G', 'T']
        결과 : 13ab
    Testcase 10의 입력 : [23, 24, 25, 26, 27]
        결과 : bd3e
    Testcase 11의 입력 : ['CT', 'AG', 'TG', 'GC', 'CA', 'AT']
        결과 : 9410
    Testcase 12의 입력 : ['AT', 'TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT', 'G']
        결과 : d3d6
    Testcase 13의 입력 : ['TTCGTC', 'GCT', 'GTCAGATGC', 'T', 'CGCCAT']
        결과 : c588
    ```

### [문제에 대한 이해]

- A, B가 파이썬 리스트일 때, A + B는 어떤 결과가 나오는가?
  - 두 리스트를 연결하는 연산이다.
- A, B가 파이썬 리스트일 때, [A, B]는 어떤 결과가 나오는가?
  - 두 리스트를 항목으로 가지는 새로운 리스트를 생성한다.
- A = [1, 2], B = [3, 4]일 때, A.append(B)의 결과는 무엇인가?
  - A에 B를 추가하는 연산으로, 결과는 [1, 2, [3, 4]]가 된다.
- A, B가 파이썬 리스트일 때, A에 B의 모든 항목을 덧붙인 리스트를 만드는 방법을 설명하라. 예를 들어 A가 [1, 2], B가 [3, 4]인 경우, [1, 2, 3], [1, 2, 4]를 만드는 작업이다.
  - B의 모든 원소를 루프나 리스트 컴프리헨션을 통해서 A에 합치는 과정을 확인한다.

### [코드 예시]

```python
def segmentations(arr, prefix_list = None, result = None):
    if prefix_list == None:
        prefix_list = []
    if result == None:
        result = []
    if not arr:
        result.append(prefix_list)
        return result
    head = arr[0]
    tail = arr[1:]
    segmentations(tail, prefix_list + [[head]], result)
    if prefix_list:
        segmentations(tail, prefix_list[:-1] + [prefix_list[-1] + [head]], result)
    return result

import hashlib
def hash4(input):
    return hashlib.sha256(input.encode()).hexdigest()[:4]

def c2h4(arr):
    arr.sort()
    result = ''
    for mid_list in arr:
        result += '_'
        for inner_list in mid_list:
            result += '='
            for element in inner_list:
                if isinstance(element, int):
                    result += chr((element % 26) + 65) + ','
                else:
                    result += element + ','
    return hash4(result)



def main():
    testcases = [['C', 'T', 'A'], [1, 2, 3], [1, 1, 1], [1], ['C'], [1, 1], ['C', 'T', 'A', 'G'], [1, 1, 1, 1], ['C', 'T', 'A', 'G', 'T'], [23, 24, 25, 26, 27], ['CT', 'AG', 'TG', 'GC', 'CA', 'AT'], ['AT', 'TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT', 'G'], ['TTCGTC', 'GCT', 'GTCAGATGC', 'T', 'CGCCAT']]

    for i, tc in enumerate(testcases):
        result = segmentations(tc)
        print(f"Testcase {i + 1}의 입력 : {tc}")
        print(f"    결과 : {c2h4(result)}")

if __name__ == "__main__":
    main()
```

---

# 문제 2. 파이썬 딕셔너리

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

염기서열을 효과적으로 분할하는데 성공한 닥터 G는 다음에 해야 할 일의 방법을 찾고 있었다.
'이제 각 조각 별로 실험을 진행해야 하는데...'
각 조각 별로 수행하는 실험은 조각마다 서로 다른 프로세스와 시약이 필요한 과정이다. 즉 조각의 수 만큼의 시약을 미리 준비해야 한다. 닥터 G는 얼마만큼의 시약을 미리 준비하기 위해서 패턴 별로 필요한 시약의 수를 출력하는 프로그램을 만들기로 했다.

## 수행목표

- 주어진 리스트를 항목이 빠지지 않게 분할하는 모든 경우의 수를 찾는 이전 문제의 결과에서 시작한다. 그 결과를 사용해 패턴 별로 빈도수를 계산하고 이를 출력한다.
  - 이를 위한 프로그램은 파이썬의 딕셔너리 자료형을 사용한다.
- 예를 들어서 `['C', 'T', 'A']` 염기서열을 `[[['C'], ['T'], ['A']], [['C'], ['T', 'A']], [['C', 'T'], ['A']], [['C', 'T', 'A']]]`과 같이 분할 하였다면, `['C']`, `['A']`를 위한 시약 두 단위와 `['T', 'A']`, `['C', 'T']`, `['C', 'T', 'A']`와 `['A']`를 위한 시약 한 단위를 준비해야 한다.
- 다음 테스트 케이스의 각 리스트에 대해서 항목이 빠지지 않게 분할한 후, 여기에 포함된 모든 패턴에 대해서 빈도수를 계산해 출력하는 프로그램을 만들고, 결과를 출력한다. 이때 결과는 빈도 순으로 출력되어야 한다.

## 수행단계

- 파이썬 딕셔너리의 활용법에 대해서 숙지한다.
  - 파이썬 딕셔너리를 사용해 루프를 만드는 방법을 키, 값, 그리고 키와 값을 동시에 활용하는 루프 각각에 대해서 확인한다.
  - 파이썬 딕셔너리의 경우 파이썬 버전 3.7 이후부터는 딕셔너리의 순서가 보장된다. 람다(lambda) 함수를 사용해 어떤 딕셔너리를 값의 순서로 정렬하는 방법을 조사한다.
- 파이썬의 자료형은 크게 변경 가능한 자료형(mutable)과 변경 불가능한 자료형(immutable)로 나눌 수 있다. 두 자료형이 무엇이며, 어떤 차이가 있는지 조사한다.
  - 특히, 파라미터로 전달되었을 때 두 자료형의 동작 방식의 차이에 대해서도 확인한다.
- 이전 문제의 결과에서 각 분할의 단위 조각 리스트의 빈도수를 파이썬 딕셔너리를 사용해 계산하고 출력하는 프로그램을 datastructure/segment_count.py 파일에 작성한다.
  - 이 딕셔너리의 키는 리스트를 활용해 정한다. 딕셔너리 자체에 사용되는 키는 리스트를 그대로 사용하지 않아도 되지만, 이 딕셔너리에서 키와 값을 가지고 왔을 때, 키를 다시 원래의 리스트로 복원할 수 있어야 한다.
  - 이 딕셔너리는 값을 기준으로 정렬된 딕셔너리로 생성되어야 한다.
- 이전 문제에서 제공된 테스트케이스에 대해서 모든 가능한 분할 조합의 리스트를 만든 후, 빈도수를 계산해 출력한다.

## 결과예시

```
Testcase 1의 입력 : ['C', 'T', 'A']
    segment ['C'] : 2회
    segment ['A'] : 2회
    segment ['T'] : 1회
    segment ['T', 'A'] : 1회
    segment ['C', 'T'] : 1회
    segment ['C', 'T', 'A'] : 1회
Testcase 2의 입력 : [1, 2, 3]
    segment [1] : 2회
    segment [3] : 2회
    segment [2] : 1회
    segment [2, 3] : 1회
    segment [1, 2] : 1회
    segment [1, 2, 3] : 1회
Testcase 3의 입력 : [1, 1, 1]
    segment [1] : 5회
    segment [1, 1] : 2회
    segment [1, 1, 1] : 1회
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - datastructure/segment_count.py 파일에 구현이 되어 있는지 확인한다.
  - 딕셔너리의 키를 리스트를 사용해서 만들었고, 이 키는 리스트로 복원 가능한지 확인한다.
  - 각 패턴의 빈도수를 출력할 때 생성한 딕셔너리를 활용해 출력하는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    Testcase 1의 입력 : ['C', 'T', 'A']
        segment ['C'] : 2회
        segment ['A'] : 2회
        segment ['T'] : 1회
        segment ['T', 'A'] : 1회
        segment ['C', 'T'] : 1회
        segment ['C', 'T', 'A'] : 1회
    Testcase 2의 입력 : [1, 2, 3]
        segment [1] : 2회
        segment [3] : 2회
        segment [2] : 1회
        segment [2, 3] : 1회
        segment [1, 2] : 1회
        segment [1, 2, 3] : 1회
    Testcase 3의 입력 : [1, 1, 1]
        segment [1] : 5회
        segment [1, 1] : 2회
        segment [1, 1, 1] : 1회
    Testcase 4의 입력 : [1]
        segment [1] : 1회
    Testcase 5의 입력 : ['C']
        segment ['C'] : 1회
    Testcase 6의 입력 : [1, 1]
        segment [1] : 2회
        segment [1, 1] : 1회
    Testcase 7의 입력 : ['C', 'T', 'A', 'G']
        segment ['C'] : 4회
        segment ['G'] : 4회
        segment ['T'] : 2회
        segment ['A'] : 2회
        segment ['A', 'G'] : 2회
        segment ['C', 'T'] : 2회
        segment ['T', 'A'] : 1회
        segment ['T', 'A', 'G'] : 1회
        segment ['C', 'T', 'A'] : 1회
        segment ['C', 'T', 'A', 'G'] : 1회
    Testcase 8의 입력 : [1, 1, 1, 1]
        segment [1] : 12회
        segment [1, 1] : 5회
        segment [1, 1, 1] : 2회
        segment [1, 1, 1, 1] : 1회
    Testcase 9의 입력 : ['C', 'T', 'A', 'G', 'T']
        segment ['T'] : 12회
        segment ['C'] : 8회
        segment ['A'] : 4회
        segment ['G'] : 4회
        segment ['G', 'T'] : 4회
        segment ['C', 'T'] : 4회
        segment ['A', 'G'] : 2회
        segment ['A', 'G', 'T'] : 2회
        segment ['T', 'A'] : 2회
        segment ['C', 'T', 'A'] : 2회
        segment ['T', 'A', 'G'] : 1회
        segment ['T', 'A', 'G', 'T'] : 1회
        segment ['C', 'T', 'A', 'G'] : 1회
        segment ['C', 'T', 'A', 'G', 'T'] : 1회
    Testcase 10의 입력 : [23, 24, 25, 26, 27]
        segment [23] : 8회
        segment [27] : 8회
        segment [24] : 4회
        segment [25] : 4회
        segment [26] : 4회
        segment [26, 27] : 4회
        segment [23, 24] : 4회
        segment [25, 26] : 2회
        segment [25, 26, 27] : 2회
        segment [24, 25] : 2회
        segment [23, 24, 25] : 2회
        segment [24, 25, 26] : 1회
        segment [24, 25, 26, 27] : 1회
        segment [23, 24, 25, 26] : 1회
        segment [23, 24, 25, 26, 27] : 1회
    Testcase 11의 입력 : ['CT', 'AG', 'TG', 'GC', 'CA', 'AT']
        segment ['CT'] : 16회
        segment ['AT'] : 16회
        segment ['AG'] : 8회
        segment ['TG'] : 8회
        segment ['GC'] : 8회
        segment ['CA'] : 8회
        segment ['CA', 'AT'] : 8회
        segment ['CT', 'AG'] : 8회
        segment ['GC', 'CA'] : 4회
        segment ['GC', 'CA', 'AT'] : 4회
        segment ['TG', 'GC'] : 4회
        segment ['AG', 'TG'] : 4회
        segment ['CT', 'AG', 'TG'] : 4회
        segment ['TG', 'GC', 'CA'] : 2회
        segment ['TG', 'GC', 'CA', 'AT'] : 2회
        segment ['AG', 'TG', 'GC'] : 2회
        segment ['CT', 'AG', 'TG', 'GC'] : 2회
        segment ['AG', 'TG', 'GC', 'CA'] : 1회
        segment ['AG', 'TG', 'GC', 'CA', 'AT'] : 1회
        segment ['CT', 'AG', 'TG', 'GC', 'CA'] : 1회
        segment ['CT', 'AG', 'TG', 'GC', 'CA', 'AT'] : 1회
    Testcase 12의 입력 : ['AT', 'TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT', 'G']
        segment ['AT'] : 256회
        segment ['G'] : 256회
        segment ['TGA'] : 128회
        segment ['AC'] : 128회
        segment ['TC'] : 128회
        segment ['AGC'] : 128회
        segment ['GGA'] : 128회
        segment ['AA'] : 128회
        segment ['TT'] : 128회
        segment ['TCT'] : 128회
        segment ['TCT', 'G'] : 128회
        segment ['AT', 'TGA'] : 128회
        segment ['TT', 'TCT'] : 64회
        segment ['TT', 'TCT', 'G'] : 64회
        segment ['AA', 'TT'] : 64회
        segment ['GGA', 'AA'] : 64회
        segment ['AGC', 'GGA'] : 64회
        segment ['TC', 'AGC'] : 64회
        segment ['AC', 'TC'] : 64회
        segment ['TGA', 'AC'] : 64회
        segment ['AT', 'TGA', 'AC'] : 64회
        segment ['AA', 'TT', 'TCT'] : 32회
        segment ['AA', 'TT', 'TCT', 'G'] : 32회
        segment ['GGA', 'AA', 'TT'] : 32회
        segment ['AGC', 'GGA', 'AA'] : 32회
        segment ['TC', 'AGC', 'GGA'] : 32회
        segment ['AC', 'TC', 'AGC'] : 32회
        segment ['TGA', 'AC', 'TC'] : 32회
        segment ['AT', 'TGA', 'AC', 'TC'] : 32회
        segment ['GGA', 'AA', 'TT', 'TCT'] : 16회
        segment ['GGA', 'AA', 'TT', 'TCT', 'G'] : 16회
        segment ['AGC', 'GGA', 'AA', 'TT'] : 16회
        segment ['TC', 'AGC', 'GGA', 'AA'] : 16회
        segment ['AC', 'TC', 'AGC', 'GGA'] : 16회
        segment ['TGA', 'AC', 'TC', 'AGC'] : 16회
        segment ['AT', 'TGA', 'AC', 'TC', 'AGC'] : 16회
        segment ['AGC', 'GGA', 'AA', 'TT', 'TCT'] : 8회
        segment ['AGC', 'GGA', 'AA', 'TT', 'TCT', 'G'] : 8회
        segment ['TC', 'AGC', 'GGA', 'AA', 'TT'] : 8회
        segment ['AC', 'TC', 'AGC', 'GGA', 'AA'] : 8회
        segment ['TGA', 'AC', 'TC', 'AGC', 'GGA'] : 8회
        segment ['AT', 'TGA', 'AC', 'TC', 'AGC', 'GGA'] : 8회
        segment ['TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT'] : 4회
        segment ['TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT', 'G'] : 4회
        segment ['AC', 'TC', 'AGC', 'GGA', 'AA', 'TT'] : 4회
        segment ['TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA'] : 4회
        segment ['AT', 'TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA'] : 4회
        segment ['AC', 'TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT'] : 2회
        segment ['AC', 'TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT', 'G'] : 2회
        segment ['TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA', 'TT'] : 2회
        segment ['AT', 'TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA', 'TT'] : 2회
        segment ['TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT'] : 1회
        segment ['TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT', 'G'] : 1회
        segment ['AT', 'TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT'] : 1회
        segment ['AT', 'TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT', 'G'] : 1회
    Testcase 13의 입력 : ['TTCGTC', 'GCT', 'GTCAGATGC', 'T', 'CGCCAT']
        segment ['TTCGTC'] : 8회
        segment ['CGCCAT'] : 8회
        segment ['GCT'] : 4회
        segment ['GTCAGATGC'] : 4회
        segment ['T'] : 4회
        segment ['T', 'CGCCAT'] : 4회
        segment ['TTCGTC', 'GCT'] : 4회
        segment ['GTCAGATGC', 'T'] : 2회
        segment ['GTCAGATGC', 'T', 'CGCCAT'] : 2회
        segment ['GCT', 'GTCAGATGC'] : 2회
        segment ['TTCGTC', 'GCT', 'GTCAGATGC'] : 2회
        segment ['GCT', 'GTCAGATGC', 'T'] : 1회
        segment ['GCT', 'GTCAGATGC', 'T', 'CGCCAT'] : 1회
        segment ['TTCGTC', 'GCT', 'GTCAGATGC', 'T'] : 1회
        segment ['TTCGTC', 'GCT', 'GTCAGATGC', 'T', 'CGCCAT'] : 1회
    ```

### [보너스 과제 확인]

- 함수 호출 만으로 함수의 실행 시간을 출력할 수 있도록 구현하였는가?
  - 파이썬 데코레이터 등의 방법을 사용해 지시한대로 구현이 되었는지 확인한다.

### [문제에 대한 이해]

- 파이썬 딕셔너리에 포함된 항목의 키, 값, 그리고 키와 값을 동시에 사용할 수 있는 루프를 만드는 방법을 각각 설명하라.
  - dict.keys(), dict.values(), dict.items()를 사용해 루프를 만드는 방법을 제시하는지 확인한다.
- 파이썬의 람다 함수를 사용해 딕셔너리를 값을 기준으로 정렬하는 방법을 설명하라.
  - lambda 함수의 개념, 사용법과 이를 사용해 딕셔너리를 정렬하는 방법을 이해하고 있는지 확인한다.
  - sorted_dict = dict(sorted(original_dict.items(), key=lambda item: item[1]))
- 딕셔너리에 값을 추가할 때 다음과 같은 오류가 발생하였다. 그 이유를 설명하라.

  ```
  my_list = [1, 2, 3]
  my_dict = {}
  my_dict[my_list] = 1
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  TypeError: unhashable type: 'list'
  ```

  - mutable 객체는 딕셔너리의 키로 사용할 수 없어서 발생하는 문제이다.

- 파이썬의 mutable 객체와 immutable 객체에 대해서 설명하고, 어떤 자료형이 어떤 객체인지 대표적인 객체 몇 가지의 예를 들어보라.
  - immutable 객체는 한 번 생성된 후 그 상태를 변경할 수 없는 객체이다. int, float, str 등이 여기에 속한다.
  - mutable 객체는 생성 후에 상태를 변경할 수 있는 객체이다. list, dict, set 등이 여기에 속한다.
- 파이썬 함수에서 리스트를 파라미터로 전달한 후, 호출된 함수에서 이 리스트를 수정하는 경우에 발생 가능한 문제는 무엇인가? 그리고 이 문제를 회피하기 위한 방법은 무엇인지 제시하라.
  - mutable 객체를 함수 파라미터로 전달하는 경우, 객체의 포인터가 전달되므로 객체를 조작하면 호출한 함수에서 리스트를 접근할 때, 이 리스트의 값이 변경되어 문제의 발생 여지가 있다. 이를 회피하기 위해서는, 새로운 리스트를 복사해 전달하거나, 호출된 함수에서 리스트를 복사해 사용하면 된다.

### [코드 예시]

```python
# 이전 문제에서 중복 코드는 생략
def counts_per_segment(arr):
    segment_count = {}
    for outer_list in arr:
        for inner_list in outer_list:
            inner_list_tuple = tuple(inner_list)
            if inner_list_tuple not in segment_count:
                segment_count[inner_list_tuple] = 0
            segment_count[inner_list_tuple] += 1



    segment_count = dict(sorted(segment_count.items(), key=lambda x: x[1], reverse=True))
    return segment_count

def main():
    testcases = [['C', 'T', 'A'], [1, 2, 3], [1, 1, 1], [1], ['C'], [1, 1], ['C', 'T', 'A', 'G'], [1, 1, 1, 1], ['C', 'T', 'A', 'G', 'T'], [23, 24, 25, 26, 27], ['CT', 'AG', 'TG', 'GC', 'CA', 'AT'], ['AT', 'TGA', 'AC', 'TC', 'AGC', 'GGA', 'AA', 'TT', 'TCT', 'G'], ['TTCGTC', 'GCT', 'GTCAGATGC', 'T', 'CGCCAT']]

    for i, tc in enumerate(testcases):
        result = segmentations(tc)
        print(f"Testcase {i + 1}의 입력 : {tc}")
        segment_count = counts_per_segment(result)
        for k, v in segment_count.items():
            print(f"    segment {list(k)} : {v}회")

if __name__ == '__main__':
    main()
```

---

# 문제 3. 큐 자료구조

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

연구 지원 조직에서 행정 업무의 이력이 30년에 가까운 지선생은 행정 업무의 달인, 연구소의 산 역사 등으로 불리고 있었다. 하지만 지선생의 뛰어난 업무 성과의 비결 중에 하나는 업무를 효율화하기 위한 온갖 기술들을 사용하는 그 실천력이었다.

지선생이 담당하는 행정 업무는 종종 동시에 여러 일을 처리해야 하는 상황이 발생하곤 한다. 어떤 업무는 검토와 동시에 처리할 수 있는 업무가 있지만, 어떤 업무는 일단 처리한 후 시스템에 입력하고 그 결과를 확인해야 하는 업무도 있다. 때에 따라서는 처리 결과에 따라 이 과정을 몇 번씩 반복해야 하는 그런 업무도 있다.

지선생은 이러한 상황에서 업무를 체계화하기 위한 사무자동화 기술을 발휘해 업무 작업표를 만들고 십수년 전부터 적용해오고 있었다. 다음은 업무 작업표를 활용한 어느 날 오전 지선생의 일과를 정리한 것이다.

| 시간        | 상세                                                                                                                                                 | 대기열   |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |
| 09:00       | 아침에 출근한 지선생은 당장 처리해야 하는 A1, B1, C1 3개의 업무를 확인한다. 이에 지선생은 우선 A1, B1, C1 3개의 업무를 작업표에 차례대로 등록한다.   | A1,B1,C1 |
| 09:00~09:10 | 작업표의 가장 앞에 있는 업무 A1를 자동으로 처리하도록 시스템에 맡기고 난 후, 그 결과를 확인해야 하므로 다시 A1를 작업표에 등록한다.                  | B1,C1,A1 |
| 09:10~09:20 | 작업표의 가장 앞에 있는 업무 B1는 자동으로 처리할 필요가 없는 바로 해결 할 수 있는 업무였다. 그냥 처리하고 끝낸다.                                   | C1,A1    |
| 09:20~09:30 | 작업표의 가장 앞에 있는 업무 C1를 자동으로 처리하도록 시스템에 맡기고 난 후, 그 결과를 확인해야 하므로 다시 C1를 작업표에 등록한다.                  | A1,C1    |
| 09:30       | 그 사이 업무 D1 요청이 들어왔다. 업무 D1을 작업표에 등록한다.                                                                                        | A1,C1,D1 |
| 09:30~09:40 | 작업표의 가장 앞에 있는 업무 A1를 확인하니, 다시 시스템에 맡겨야 한다는 사실을 확인했다. 지선생은 이를 시스템에 다시 넘기고, A1를 작업표에 등록한다. | C1,D1,A1 |
| 09:40~09:50 | 작업표의 가장 앞에 있는 업무 C1를 확인하니, 업무가 종료되었음을 확인했다.                                                                            | D1,A1    |
| 09:50~10:00 | 작업표의 가장 앞에 있는 업무 D1를 확인하니, 바로 처리하고 끝낼 수 있는 업무였다.                                                                     | A1       |
| 10:00~10:10 | 작업표의 가장 앞에 있는 업무 A1를 확인하니, 업무가 종료되었음을 확인했다.                                                                            |          |
| 10:10       | 작업표가 비어 있으므로, 지선생은 커피 한 잔의 여유를 즐기러 휴게실로 향했다.                                                                         |

## 수행목표

- 지선생의 업무 작업표의 관리 함수를 다음과 같이 구현한다.
  - 지선생이 해야 할 일은 두 글자로 표현된다. 두 글자는 알파벳 또는 0에서 9 사이의 숫자로 구성된다. 위의 예시에서 `A1`, `B1`, `C1`, `D1`이 여기에 해당된다.
  - 업무를 수행하는데 필요한 각 사이클은 모두 동일한 시간으로 주어진다. 위의 예시에서는 10분이지만, 프로그램에서는 분 단위의 임의의 값으로 주어진다.
  - 각 업무는 시작 시간과 필요한 사이클을 가지고 있다. 위의 예시에서 `A1` 업무의 시작 시간은 0번 사이클 이후(즉 일과 시작 시점), 필요한 사이클은 3이며, `D1` 업무의 시작 시간은 3번 사이클 이후, 필요한 사이클은 1이다.
    - 업무 시작 시간은 전체 사이클에서 몇 번째 사이클에 해당 업무가 시작되는지를 나타낸다.
  - 위의 예시에서 지선생의 업무 목록은 다음과 같이 표현된다. `A1,0,3,B1,0,1,C1,0,2,D1,3,1`
  - 주어진 업무의 개수는 100개 이하이다.
  - 이 함수는 지선생의 하나의 업무 목록과 업무의 한 사이클의 시간(분)을 파라미터로 받아서 지선생이 업무 시작 몇 분 만에 휴식을 취할 수 있는지, 그리고 그 때까지의 업무 대기열 전체를 이어붙인 문자열을 반환한다.
    - 위의 예시에서 지선생이 최초로 휴식을 취하는 시점은 업무 시작 70분 시점이고, 이 때 까지의 각 사이클 종료 시점의 업무 대기열에 해당하는 `B1C1A1`, `C1A1`, `A1C1`, `C1D1A1`, `D1A1`, `A1`을 모두 이어붙인 `B1C1A1C1A1A1C1C1D1A1D1A1A1`을 반환한다.
    - 아직 시작시간이 되지 않아서 업무 작업표에 등록되지 않은 업무가 남아 있다 할 지라도 쉬는 시간이 발생한다면, 그 시점을 휴식 시간으로 하여 그 때의 결과를 반환한다.
- 첨부파일에는 15개의 작업 일정이 포함되어 있다. 이 15개의 작업 일정에 대해서 작업표 관리 함수가 반환한 결과를 수행단계의 지시에 따라 가공해 출력한다.
  - 첨부파일의 각 줄이 하나의 작업 일정에 해당한다.
  - 업무 1사이클의 소요 시간은 1분으로 한다.

## 수행단계

- 큐 자료구조에 대해서 조사한다.
  - 큐 자료구조에서 데이터를 더하고 빼는 방법에 대해서도 조사한다.
  - 파이썬의 `collections` 모듈의 `deque`에 대해서 조사한다.
- 수행 목표에서 주어진 문제를 큐 자료구조를 사용해 구현한다.
  - 어느 시점의 업무 대기열은 `deque`를 사용해 구현한다.
  - 리스트에 항목을 꺼낼 때는 반드시 첫 번째 항목만 꺼낼 수 있고, 리스트에 항목을 추가할 때는 반드시 리스트의 마지막에만 항목을 더할 수 있다.
- 각 작업 일정의 한 사이클은 1분이라고 할 때, 작업표 관리 함수가 반환한 결과 중 시간의 값과 대기열 목록을 이어붙인 문자열의 간이 해시 값(다음 `hash4` 함수의 결과)을 출력하는 프로그램을 `datastructure/scheduler.py` 파일에 작성한다.

  ```python
  import hashlib

  def hash4(input):
      return hashlib.md5(input.encode()).hexdigigest()[:4]
  ```

## 결과예시

```
testcase 1
  최초의 휴식 시간은 7분 후 입니다.
  각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 0f4e 입니다.

testcase 2
  최초의 휴식 시간은 17분 후 입니다.
  각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 7ec1 입니다.

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - datastructure/scheduler.py 파일에 구현이 되어 있는지 확인한다.
  - 작업 대기열을 구현하기 위해서 collections의 deque를 사용하였는지 확인한다.
  - 큐를 사용하는 기본 원칙을 준수하였는지 확인한다. deque 객체에 데이터를 추가할 때는 append, 데이터를 빼 올때는 popleft를 사용해야 한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    testcase 1
      최초의 휴식 시간은 7분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 0f4e 입니다.

    testcase 2
      최초의 휴식 시간은 17분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 7ec1 입니다.

    testcase 3
      최초의 휴식 시간은 0분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 d41d 입니다.

    testcase 4
      최초의 휴식 시간은 73분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 0f01 입니다.

    testcase 5
      최초의 휴식 시간은 0분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 d41d 입니다.

    testcase 6
      최초의 휴식 시간은 26분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 500b 입니다.

    testcase 7
      최초의 휴식 시간은 25분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 500b 입니다.

    testcase 8
      최초의 휴식 시간은 99분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 0770 입니다.

    testcase 9
      최초의 휴식 시간은 97분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 da89 입니다.

    testcase 10
      최초의 휴식 시간은 143분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 1434 입니다.

    testcase 11
      최초의 휴식 시간은 1126분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 56c8 입니다.

    testcase 12
      최초의 휴식 시간은 767분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 b98c 입니다.

    testcase 13
      최초의 휴식 시간은 781분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 e29e 입니다.

    testcase 14
      최초의 휴식 시간은 9844분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 6df9 입니다.

    testcase 15
      최초의 휴식 시간은 186분 후 입니다.
      각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 459e 입니다.
    ```

### [문제에 대한 이해]

- 큐 자료구조란 무엇인가?
  - 선입선출(First In, First Out; FIFO)의 원칙을 따르는 자료구조를 말한다.
- 큐 자료구조에서 큐 객체를 다루는 두 가지 기본적인 기능에 대해서 제시하고 동작 방식을 설명하라.
  - enqueue와 dequeue 두 기능에 대해서 선입 선출 방식으로 데이터를 추가하고 빼는 방식을 제시하는지 확인한다.
- 리스트로 큐 자료구조를 구현하는 방법을 설명하라.
  - 리스트로 큐 자료구조를 구현하려면 데이터를 추가할 때는 append, 데이터를 빼서 가지고 올 때는 pop함수를 사용해 리스트를 생성, 사용한다.
- 리스트로 큐 자료구조를 구현하는 대신 collections 모듈의 deque를 사용할 때의 이점을 프로그램의 성능과 관련지어 제시하라.
  - 리스트의 pop은 시간복잡도가 $\mathcal O(n)$인데 비해 deque의 popleft를 사용할 때는 $\mathcal O(1)$로 시간복잡도 측면에서 유리하다.

### 코드 예시

```python
from collections import deque
import random
import hashlib

def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]

def manage_job(job_list, minute_per_cycle):
    job_segment = job_list.strip().split(',')
    job_startings = {}
    for i in range(len(job_segment) // 3):
        name = job_segment[i * 3]
        start = int(job_segment[i * 3 + 1])
        cycle = int(job_segment[i * 3 + 2])
        if start not in job_startings:
            job_startings[start] = []
        job_startings[start].append((name, cycle))
    job_waiting = deque()
    total_cycle = 0
    result = ''
    while True:
        if total_cycle in job_startings:
            for job in job_startings[total_cycle]:
                job_waiting.append(job)
        if len(job_waiting) == 0:
            break
        job = job_waiting.popleft()
        cycle_remain = job[1] - 1
        if cycle_remain > 0:
            job_waiting.append((job[0], cycle_remain))
        result += ''.join(job_in_waitinglist[0] for job_in_waitinglist in job_waiting)
        total_cycle += 1
    return total_cycle * minute_per_cycle, result

def main():
    with open('scheduler_testcases.txt', 'r') as f:
        i = 0
        while True:
            tcline = f.readline()
            if not tcline or len(tcline.strip()) == 0:
                break
            caseline = f.readline()
            t, w = manage_job(caseline.strip(), 1)
            print(tcline.strip())
            print(f"  최초의 휴식 시간은 {t}분 후 입니다.")
            print(f"  각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 {hash4(w)} 입니다.")
            print()

if __name__ == '__main__':
    main()
```

---

# 문제 4. 순환 큐

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

자신의 업무를 체계화해서 효율적으로 업무를 수행하고 있는 지선생도 업무 작업표에 과도한 업무가 쌓여 있는 상황은 도저히 견딜 수 없었다. 그리하여 업무 작업표에 등록된 업무의 수가 정해진 수에 도달하면 그 상황에 추가되는 업무는 없는 샘 치기로 했다.

예를 들어 업무 목록이 `A1,0,3,B1,0,1,C1,0,2,D1,3,1`로 주어지고 작업표에 등록할 수 있는 최대 업무의 수가 2라고 할 때, 업무의 흐름은 다음과 같이 달라지게 된다.

| 시간        | 상세                                                                                                                                                                                                                                | 대기열 |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ |
| 09:00       | 아침에 출근한 지선생은 당장 처리해야 하는 A1, B1, C1 3개의 업무를 확인한다. 이에 지선생은 우선 A1, B1, C1 3개의 업무를 작업표에 차례대로 등록하던 중, 최대 등록 가능한 2개의 업무가 등록된 이후 C1 업무는 무시하고 등록하지 않는다. | A1,B1  |
| 09:00~09:10 | 작업표의 가장 앞에 있는 업무 A1를 자동으로 처리하도록 시스템에 맡기고 난 후, 그 결과를 확인해야 하므로 다시 A1를 작업표에 등록한다.                                                                                                 | B1,A1  |
| 09:10~09:20 | 작업표의 가장 앞에 있는 업무 B1는 자동으로 처리할 필요가 없는 바로 해결 할 수 있는 업무였다. 그냥 처리하고 끝낸다.                                                                                                                  | A1     |
| 09:20~09:30 | 작업표의 가장 앞에 있는 업무 A1을 확인하니, 다시 시스템에 맡겨야 한다는 사실을 확인했다. 지선생은 이를 처리한 후 시스템에 다시 넘기고, A1을 작업표에 다시 등록한다.                                                                 | A1     |
| 09:30       | 그 사이 업무 D1 요청이 들어왔다. 업무 D1을 작업표에 등록한다.                                                                                                                                                                       | A1,D1  |
| 09:30~09:40 | 작업표의 가장 앞에 있는 업무 A1을 확인하니, 업무가 종료되었음을 확인했다.                                                                                                                                                           | D1     |
| 09:40~09:50 | 작업표의 가장 앞에 있는 업무 D1를 확인하니, 바로 처리하고 끝낼 수 있는 업무였다.                                                                                                                                                    |        |
| 09:50       | 작업표가 비어 있으므로, 지선생은 커피 한 잔의 여유를 즐기러 휴게실로 향했다.                                                                                                                                                        |

- 09:00 : 아침에 출근한 지선생은 당장 처리해야 하는 A1, B1, C1 3개의 업무를 확인한다. 이에 지선생은 우선 A1, B1, C1 3개의 업무를 작업표에 차례대로 등록하던 중, 최대 등록 가능한 2개의 업무가 등록된 이후 C1 업무는 무시하고 등록하지 않는다. (현재 업무 대기열은 A1, B1)
- 09:00 ~ 09:10 : 작업표의 가장 앞에 있는 업무 A1을 자동으로 처리하도록 시스템에 맡기고 난 후, 그 결과를 확인해야 하므로 다시 A1을 작업표에 등록한다. (현재 대기열은 B1, A1)
- 09:10 ~ 09:20 : 작업표의 가장 앞에 있는 업무 B1는 자동으로 처리할 필요가 없는 바로 해결 할 수 있는 업무였다. 그냥 처리하고 끝낸다. (현재 대기열은 A1)
- 09:20 ~ 09:30 : 작업표의 가장 앞에 있는 업무 A1을 확인하니, 다시 시스템에 맡겨야 한다는 사실을 확인했다. 지선생은 이를 처리한 후 시스템에 다시 넘기고, A1을 작업표에 다시 등록한다. (현재 대기열은 A1)
- 09:30 ~ 09:40 : 어느새 업무 D1 요청이 들어왔다. 우선 업무 D1를 작업표에 등록하고 (현재 대기열은 A1, D1) 작업표의 가장 앞에 있는 업무 A1을 확인하니, 업무가 종료되었음을 확인했다. (현재 대기열은 D1)
- 09:40 ~ 09:50 : 작업표의 가장 앞에 있는 업무 D1를 확인하니, 바로 처리하고 끝낼 수 있는 업무였다. (현재 대기열은 비어있다.)
- 09:50 : 작업표가 비어 있으므로, 지선생은 커피 한 잔의 여유를 즐기러 휴게실로 향했다.

닥터 G는 조금 더 효율적인 정렬 방법을 찾아보기로 했다. 인터넷에서 조사를 해 보니 여러 효율적인 정렬 방법이 소개되고 있었다. 그런데 그 정렬 방법들은 모두 알고리즘을 구현한 함수가 다시 자기 자신을 호출하고 있는 이상한 형태로 되어 있었다.

이러한 형태를 찾아보니 이러한 알고리즘 구현 방식을 '재귀호출'이라 부른다는 사실을 알게 되었다. 문득 고등학교 수학 시간에 수열을 배울 때 비슷한 구조의 수식을 사용해 수열을 정의했던 일이 머리속에 떠올랐다.

## 수행목표

- 지선생의 변경된 방침을 반영하는 함수를 다음과 같이 구현한다.

  - 지선생이 해야 할 일은 두 글자로 표현된다. 두 글자는 알파벳 또는 0에서 9 사이의 숫자로 구성된다. 위의 예시에서 `A1`, `B1`, `C1`, `D1`이 여기에 해당된다.
  - 업무를 수행하는데 필요한 각 사이클은 모두 동일한 시간으로 주어진다. 위의 예시에서는 10분이지만, 프로그램에서는 분 단위의 임의의 값으로 주어진다.
  - 각 업무는 시작 시간과 필요한 사이클을 가지고 있다. 위의 예시에서 `A1` 업무의 시작 시간은 0번 사이클 이후(즉 시작 시점), 필요한 사이클은 3이며, `D1` 업무의 시작 시간은 3번 사이클 이후, 필요한 사이클은 1이다.
    - 업무 시작 시간은 전체 사이클에서 몇 번째 사이클에 해당 업무가 시작되는지를 나타낸다.
  - 위의 예시에서 지선생의 업무 목록은 다음과 같이 표현된다. `A1,0,3,B1,0,1,C1,0,2,D1,3,1`
  - 주어진 업무의 개수는 100개 이하이다.
  - 작업표에 등록된 업무의 수가 지정된 최대 등록 업무수에 도달하면, 더 이상 업무를 등록하지 않는다. 이렇게 무시된 업무는, 나중에 등록 업무의 수에 여유가 생기더라도 추가하지 않고 마지막까지 무시된다.
  - 이 함수는 지선생의 하나의 업무 목록과 업무의 한 사이클의 시간(분), 그리고 작업표에 등록되는 업무의 최대 개수를 파라미터로 받아서 지선생이 업무 시작 몇 분 만에 휴식을 취할 수 있는지와 그 때까지 등록하지 않고 무시한 업무의 개수, 그리고 그 때까지의 업무 대기열 전체를 이어붙인 문자열을 반환한다.
    - 위의 예시에서 지선생이 최초로 휴식을 취하는 시점은 업무 시작 50분 시점이고, 등록되지 않고 무시된 업무는 `C1` 하나이다. 함수는 50과 1, 그리고 이 때 까지의 각 사이클 종료 시점의 업무 대기열에 해당하는 `B1A1`, `A1`, `A1`, `D1`을 모두 이어붙인 `B1A1A1A1D1`을 반환한다.
    - 아직 시작시간이 되지 않아서 업무 작업표에 등록되지 않은 업무가 남아 있다 할 지라도 쉬는 시간이 발생한다면, 그 시점을 휴식 시간으로 하여 결과를 출력한다. 또한 아직 시작하지 않은 업무는 무시된 업무로 계산하지 않는다.

- 첨부파일에는 15개의 작업 일정이 포함되어 있다. 이 15개의 작업 일정에 대해서 작업표 관리 함수가 반환한 결과를 수행단계의 지시에 따라 가공해 출력한다.
  - 첨부파일의 각 줄이 하나의 작업 일정에 해당한다.
  - 테스트 케이스는 순서대로 1번에서 15번으로 번호를 붙일 때, n번 테스트 케이스는 동시에 등록 가능한 최대 작업의 수를 n으로 한다. 단, 첫 번째 테스트 케이스에 동시에 등록 가능한 작업의 수는 2로 한다.
  - 업무 1사이클의 소요 시간은 1분으로 한다.

## 수행단계

- 순환 큐 자료구조에 대해서 조사한다.
  - 순환 큐를 사용할 때의 이점이 무엇인지 조사한다.
  - 파이썬 리스트를 사용해 순환큐를 구현하는 방법에 대해서 조사한다.
  - 순환 큐에서 데이터를 추가하고 가지고 오는 방법에 대해서 조사한다.
- 수행 목표에서 주어진 문제를 순환 큐를 사용해 구현한다.
  - 어느 시점의 업무 대기열은 파이썬의 리스트로 구현한다. 이전 문제에서 사용한 `collections` 모듈을 사용할 수 없다.
- 각 작업 일정의 한 사이클은 1분이라고 하고, 각 테스트케이스의 등록 가능한 최대 업무의 수는 테스트케이스 1은 2개, 나머지는 테스트케이스의 번호와 동일할 때, 작업표 관리 함수가 반환한 결과 중 시간의 값, 무시된 작업의 수와 대기열 목록을 이어붙인 문자열의 간이 해시 값(다음 `hash4` 함수의 결과)을 출력하는 프로그램을 `datastructure/lazy_scheduler.py` 파일에 작성한다.

  ```python
  import hashlib

  def hash4(input):
      return hashlib.md5(input.encode()).hexdigigest()[:4]
  ```

## 결과 예시

```
testcase 1
    최초의 휴식 시간은 5분 후 입니다.
    무시된 작업은 1개 입니다.
    각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 a166 입니다.

testcase 2
    최초의 휴식 시간은 12분 후 입니다.
    무시된 작업은 1개 입니다.
    각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 19b5 입니다.
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - datastructure/lazy_scheduler.py 파일에 구현이 되어 있는지 확인한다.
  - 순환 큐를 사용해 구현하였는지의 여부를 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    testcase 1
        최초의 휴식 시간은 5분 후 입니다.
        무시된 작업은 1개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 a166 입니다.

    testcase 2
        최초의 휴식 시간은 12분 후 입니다.
        무시된 작업은 1개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 19b5 입니다.

    testcase 3
        최초의 휴식 시간은 0분 후 입니다.
        무시된 작업은 0개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 d41d 입니다.

    testcase 4
        최초의 휴식 시간은 19분 후 입니다.
        무시된 작업은 16개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 d2be 입니다.

    testcase 5
        최초의 휴식 시간은 0분 후 입니다.
        무시된 작업은 0개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 d41d 입니다.

    testcase 6
        최초의 휴식 시간은 26분 후 입니다.
        무시된 작업은 0개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 500b 입니다.

    testcase 7
        최초의 휴식 시간은 25분 후 입니다.
        무시된 작업은 0개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 500b 입니다.

    testcase 8
        최초의 휴식 시간은 8분 후 입니다.
        무시된 작업은 91개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 771f 입니다.

    testcase 9
        최초의 휴식 시간은 31분 후 입니다.
        무시된 작업은 21개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 f7b3 입니다.

    testcase 10
        최초의 휴식 시간은 46분 후 입니다.
        무시된 작업은 20개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 1e36 입니다.

    testcase 11
        최초의 휴식 시간은 239분 후 입니다.
        무시된 작업은 39개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 7216 입니다.

    testcase 12
        최초의 휴식 시간은 139분 후 입니다.
        무시된 작업은 37개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 a13c 입니다.

    testcase 13
        최초의 휴식 시간은 93분 후 입니다.
        무시된 작업은 87개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 bafa 입니다.

    testcase 14
        최초의 휴식 시간은 1617분 후 입니다.
        무시된 작업은 85개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 894f 입니다.

    testcase 15
        최초의 휴식 시간은 32분 후 입니다.
        무시된 작업은 83개 입니다.
        각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 0d1d 입니다.
    ```

### [문제에 대한 이해]

- 순환 큐란 무엇인가?
  - 순환 큐는 큐의 끝이 시작점과 연결된 데이터 구조이다.
  - 기본적인 선입선출(FIFO) 큐의 원리를 따르지만, 고정된 크기를 가지고, 큐가 '순환'하는 형태로 동작한다.
  - 큐가 가득 찬 상태에서 항목을 삽입되면, 삽입이 되지 않거나 큐의 시작 부분(가장 오래된 항목)을 덮어쓰는 방식으로 선택적으로 동작한다.
- 순환 큐가 일반 큐에 비해서 어떤 이점을 가지고 있는가?
  - 고정된 크기로 메모리를 효율적으로 관리할 수 있다는 장점을 포함해서 순환 큐의 이점을 제시할 수 있는지 확인한다.
- 리스트를 사용해 순환 큐를 구현하는 방법에 대해서 설명하라.
  - 여러가지 방법으로 구현할 수 있다. 큐와 시작과 끝을 가리키는 포인터 성격의 변수로 관리하는 방법 등 순환큐의 성질을 유지하는 방식을 제시하는지 확인한다.

### [코드 예시]

```python
import hashlib

def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]


def append_job_circular_queue(job, front, rear, job_waiting, maximum_waiting):
    if (rear + 1) % maximum_waiting == front:
        return front, rear
    if front == -1:
        front = 0
        rear = 0
        job_waiting[rear] = job
    else:
        rear = (rear + 1) % maximum_waiting
        job_waiting[rear] = job
    return front, rear

def pop_job_circular_queue(front, rear, job_waiting, maximum_waiting):
    if front == -1:
        return front, rear, None
    if front == rear:
        return -1, -1, job_waiting[front]
    return (front + 1) % maximum_waiting, rear, job_waiting[front]

def manage_job_with_maximum_waiting(job_list, minute_per_cycle, maximum_waiting):
    job_segment = job_list.strip().split(',')
    job_startings = {}
    for i in range(len(job_segment) // 3):
        name = job_segment[i * 3]
        start = int(job_segment[i * 3 + 1])
        cycle = int(job_segment[i * 3 + 2])
        if start not in job_startings:
            job_startings[start] = []
        job_startings[start].append((name, cycle))
    job_waiting = [('', -1) for _ in range(maximum_waiting)]
    front = -1
    rear = -1
    total_cycle = 0
    result = ''
    ignored = 0
    while True:
        if total_cycle in job_startings:
            for job in job_startings[total_cycle]:
                next_front, next_rear = append_job_circular_queue(job, front, rear, job_waiting, maximum_waiting)
                if rear != next_rear:
                    front = next_front
                    rear = next_rear
                else:
                    ignored += 1
        if front == -1:
            break

        front, rear, current_job = pop_job_circular_queue(front, rear, job_waiting, maximum_waiting)
        cycle_remain = current_job[1] - 1
        if cycle_remain > 0:
            front, rear = append_job_circular_queue((current_job[0], cycle_remain), front, rear, job_waiting, maximum_waiting)

        if front <= rear:
            result += ''.join(job_in_waitinglist[0] for job_in_waitinglist in job_waiting[front:rear + 1])
        else:
            result += ''.join(job_in_waitinglist[0] for job_in_waitinglist in job_waiting[front:] + job_waiting[:rear + 1])
        total_cycle += 1
    return total_cycle * minute_per_cycle, ignored, result



def main():
    with open('scheduler_testcases.txt', 'r') as f:
        i = 0
        while True:
            i += 1
            if i == 1:
                maximum_job = 2
            else:
                maximum_job = i

            tcline = f.readline()
            if not tcline or len(tcline.strip()) == 0:
                break
            caseline = f.readline()
            t, ignore, w = manage_job_with_maximum_waiting(caseline.strip(), 1, maximum_job)
            print(tcline.strip())
            print(f"    최초의 휴식 시간은 {t}분 후 입니다.")
            print(f"    무시된 작업은 {ignore}개 입니다.")
            print(f"    각 사이클의 대기열을 이어붙인 결과의 간이 해시 값은 {hash4(w)} 입니다.")
            print()


if __name__ == '__main__':
    main()

```

---

# 문제 5. 스택 (1)

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 K는 인공지능을 사용한 단백질 신약 후보 물질의 탐사와 관련한 연구 성과를 논문으로 정리해 제출했다.

피어 리뷰 과정에서 논문을 리뷰하는 익명의 지구 어딘가의 연구 동료는 다음과 같이 다소 의외의 리뷰 결과를 회신했다.

> - 좋은 논문 제출해 주셔서 감사합니다. 그런데 귀하의 논문에 사용된 수식에 문제가 있습니다. 괄호가 제대로 닫히지 않은 수식이 일부 발견되었습니다. 중요한 문제는 아니지만 이런 실수가 박사님의 논문의 품격에 어울리지 않는다고 판단되어, 이를 수정하신 후 재투고 해 주시기를 요청드립니다.

## 수행목표

- K 박사의 논문에 포함된 수식은 다음과 같이 정의된다.

  - 수식은 대괄호(`[]`), 중괄호(`{}`), 소괄호(`()`)를 포함하고 있다.
  - 일반적인 수식과 달리 각 괄호 사이에는 우선 순위가 주어지지 않는다.
  - 수식이 지켜야 하는 규칙은 괄호의 순서가 꼬이지 않고 합이 맞아야 한다는 것이다.
  - 다음은 규칙에 맞는 수식의 예시이다.

    - `(2+[{4-7}+4*[3+5]-2]/6)`
    - `2-((3*[(3+5)]/6))`
    - `([{}])` - 이 오로지 괄호의 합이 맞는지에 따라 평가하므로, 규칙에 맞는 수식으로 판정한다.

  - 다음은 규칙에 맞지 않는 수식의 예시이다.
    - `[2*{4-3]/2}`
    - `(5+(3/2)`

- 어떤 수식이 주어졌을 때 이 수식의 괄호가 올바르게 사용되었는지를 조사하는 함수를 구현한다.
- 첨부한 파일에 20개의 수식이 포함되어 있다. 각 수식이 올바른 수식인지 검사하고, 그 결과를 출력한다.

## 수행단계

- 스택 자료구조에 대해서 조사한다.

  - 파이썬에서 별도의 모듈 또는 라이브러리를 사용하지 않고 리스트를 사용해 스택을 구현하는 방법을 찾는다.

- 수행 목표에서 주어진 문제를 스택 자료구조를 사용해 확인하는 함수를 datastructure/equation_inspector.py 파일에 구현한다.

  - 이 함수는 정상적인 수식은 True를, 그렇지 않은 수식은 False를 반환한다.

- 첨부한 파일에는 20개의 수식이 포함되어 있다. 각각의 수식은 'testcase 번호', 그리고 수식 각 한 줄 씩 두 줄로 구성된다. 각 수식에 대해서 검사한 결과를 출력한다.

## 결과예시

```
testcase 1
  유효한 수식입니다.

testcase 2
  유효한 수식입니다.

testcase 3
  유효한 수식입니다.

testcase 4
  유효하지 않은 수식입니다.

testcase 5
  유효하지 않은 수식입니다.
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 하나의 열린 괄호 바로 앞에 열린 괄호가 있고, 닫힌 괄호 바로 뒤에 닫힌 괄호가 있는 경우 의미없이 반복 중첩된 괄호 쌍 하나로 정의한다.

  - 예를 들어 수식이 `3*{(5+2)}`라면 `5+2`를 를 감싸고 있는 괄호가 하나의 의미없이 반복 중첩된 괄호쌍이 된다.
  - 수식이 `3*{{(5+2)}}`인 경우에도 이 수식에서 의미없이 반복 중첩된 괄호 쌍은 하나이다. `{{(X)}}`는 하나의 괄호쌍으로 간주한다.

  - 수식 `(2+[{4-7}+4*[3+5]-2]/6)`의 의미없이 반복 중첩된 괄호 쌍의 수는 0이다.
  - 수식 `2-((3*[(3+5)]/6))`의 의미없이 반복 중첩된 괄호 쌍의 수는 2이다.
  - 수식 `([{}])`의 의미없이 반복 중첩된 괄호 쌍의 수는 1이다.

- 주어진 테스트 예제에서 수식이 유효한 경우에 의미없이 반복 중첩된 괄호 쌍의 수를 출력하도록 구현을 수정해보자. 이 문제 역시 스택을 사용해 해결해야 한다. 보너스 과제를 포함한 결과 예시는 다음과 같다.

  ```
  testcase 1
    유효한 수식입니다.
    의미없이 중첩된 괄호 쌍의 수 : 0

  testcase 2
    유효한 수식입니다.
    의미없이 중첩된 괄호 쌍의 수 : 2

  testcase 3
    유효한 수식입니다.
    의미없이 중첩된 괄호 쌍의 수 : 1

  testcase 4
    유효하지 않은 수식입니다.

  testcase 5
    유효하지 않은 수식입니다.
  (이하 생략)
  ```

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?

  - datastructure/equation_inspector.py 파일에 구현이 되어 있는지 확인한다.
  - 파이썬 리스트를 사용해 구현한 스택을 문제 해결해 활용하였는지 확인한다.

- 제약사항을 준수하였는가?

  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.

- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.

  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    testcase 1
      유효한 수식입니다.

    testcase 2
      유효한 수식입니다.

    testcase 3
      유효한 수식입니다.

    testcase 4
      유효하지 않은 수식입니다.

    testcase 5
      유효하지 않은 수식입니다.

    testcase 6
      유효한 수식입니다.

    testcase 7
      유효하지 않은 수식입니다.

    testcase 8
      유효한 수식입니다.

    testcase 9
      유효한 수식입니다.

    testcase 10
      유효하지 않은 수식입니다.

    testcase 11
      유효하지 않은 수식입니다.

    testcase 12
      유효한 수식입니다.

    testcase 13
      유효하지 않은 수식입니다.

    testcase 14
      유효한 수식입니다.

    testcase 15
      유효한 수식입니다.

    testcase 16
      유효하지 않은 수식입니다.

    testcase 17
      유효하지 않은 수식입니다.

    testcase 18
      유효한 수식입니다.

    testcase 19
      유효하지 않은 수식입니다.

    testcase 20
      유효한 수식입니다.
    ```

### [보너스 과제 확인]

- 보너스 과제에서 지시한 대로 문제를 해결하였는가?

  - 스택을 이용해서 문제를 해결하였는지 확인한다.

  - 결과 예시는 다음과 같다.

    ```
    testcase 1
      유효한 수식입니다.
      의미없이 중첩된 괄호 쌍의 수 : 0

    testcase 2
      유효한 수식입니다.
      의미없이 중첩된 괄호 쌍의 수 : 2

    testcase 3
      유효한 수식입니다.
      의미없이 중첩된 괄호 쌍의 수 : 1

    testcase 4
      유효하지 않은 수식입니다.

    testcase 5
      유효하지 않은 수식입니다.

    testcase 6
      유효한 수식입니다.
      의미없이 중첩된 괄호 쌍의 수 : 0

    testcase 7
      유효하지 않은 수식입니다.

    testcase 8
      유효한 수식입니다.
      의미없이 중첩된 괄호 쌍의 수 : 7

    testcase 9
      유효한 수식입니다.
      의미없이 중첩된 괄호 쌍의 수 : 3

    testcase 10
      유효하지 않은 수식입니다.

    testcase 11
      유효하지 않은 수식입니다.

    testcase 12
      유효한 수식입니다.
      의미없이 중첩된 괄호 쌍의 수 : 24

    testcase 13
      유효하지 않은 수식입니다.

    testcase 14
      유효한 수식입니다.
      의미없이 중첩된 괄호 쌍의 수 : 53

    testcase 15
      유효한 수식입니다.
      의미없이 중첩된 괄호 쌍의 수 : 78

    testcase 16
      유효하지 않은 수식입니다.

    testcase 17
      유효하지 않은 수식입니다.

    testcase 18
      유효한 수식입니다.
      의미없이 중첩된 괄호 쌍의 수 : 122

    testcase 19
      유효하지 않은 수식입니다.

    testcase 20
      유효한 수식입니다.
      의미없이 중첩된 괄호 쌍의 수 : 950
    ```

### [문제에 대한 이해]

- 스택 자료구조에 대해서 설명하라.
- 파이썬 리스트를 사용해 스택 자료구조를 구현하는 방법에 대해서 설명하라. 스택과 관련된 핵심에 해당하는 두 가지 기능의 구현 방법을 포함해야 한다.
- 이 문제를 해결하는데 스택을 사용한 방법에 대해서 설명하라.

### [코드 예시]

```python
def is_valid_expression(expression):
    bracket_mapping = {')': '(', '}': '{', ']': '['}
    stack = []

    for char in expression:
        if char in bracket_mapping:
            if not stack or stack[-1] != bracket_mapping[char]:
                return False
            stack.pop()
        elif char in bracket_mapping.values():
            stack.append(char)

    return not stack

def count_meaningless_brackets(expression):
    bracket_mapping = {')': '(', '}': '{', ']': '['}
    stack = []
    previous_bracket = False
    previous_continuous_bracket = False
    count = 0

    for char in expression:
        if char in bracket_mapping:
            if not stack or stack[-1] != bracket_mapping[char]:
                return False
            if previous_bracket and not previous_continuous_bracket:
                count += 1
                previous_continuous_bracket = True
            stack.pop()
            previous_bracket = True
        else:
            previous_continuous_bracket = False
            previous_bracket = False
            if char in bracket_mapping.values():
                stack.append(char)

    return count

def main():
    with open("tcs_equation_inspecter.txt", "r") as f:
        equation = ''
        testcase = ''
        while True:
            line = f.readline()
            if not line or line[:8] == 'testcase':
                if equation != '':
                    inspect_result = is_valid_expression(equation)
                    if inspect_result:
                        print(testcase)
                        print('  유효한 수식입니다.')
                        repeated_bracket_pair = count_meaningless_brackets(equation)
                        print('  의미없이 중첩된 괄호 쌍의 수 :', repeated_bracket_pair)
                        print()
                    else:
                        print(testcase)
                        print('  유효하지 않은 수식입니다.\n')
                if not line:
                    break
                testcase = line.strip()
                equation = ''
            else:
                equation += line.strip()

if __name__ == "__main__":
    main()


```

---

# 문제 6. 스택 (2)

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

"요즘, 유전자 조작의 공식화 작업은 잘 진행되고 있어요?"

연구 그룹장이 닥터 K가 진행하고 있는 작업의 진행 상황을 물어보자, 닥터 K가 답했다.

"네. 어느 정도 마무리되었습니다."

대답과 함께 닥터 K는 공식화 작업의 잠정적 결론을 다음과 같이 설명했다.

> - 유전자 염기 서열은 `'C'`, `'T'`, `'A'`, `'G'` 네 종류의 염기의 조합으로 표현된다. 유전자 조합은 이 염기 서열을 변형하는 과정인데, 닥터 K는 유전자를 조합할 때 다음 세 가지 방법을 사용한다.
>   - 이어붙이기 : 두 유전자 염기 서열을 이어 붙인다. 유전자 A의 염기 서열이 `CT`, 유전자 B의 염기 서열이 `GC`인 경우, 유전자 A와 유전자 B를 이어 붙이면 `CTGC`가 된다.
>   - 걸러내기 : 주어진 유전자에서 특정 패턴을 제거하는 과정이다. 주어진 유전자의 처음부터 차례대로 패턴이 존재하는지를 검사하고, 해당 패턴을 찾으면 이 패턴을 제거한 후, 제거한 유전자에서 처음부터 다시 검사를 시작한다. 더 이상 패턴을 찾을 수 없으면 걸러내기 작업을 종료한다. 예를 들어 주어진 유전자 염기 서열이 `ACCTTACTG`이고 제거할 패턴이 `CT`인 경우 결과는 `AAG`가 된다.
>   - 조합하기 : 두 유전자의 염기 서열에 포함된 염기를 처음부터 순서대로 번갈아가면서 조합한다. 이 때 두 유전자 중 하나에서 더 이상 조합할 염기가 없으면 작업을 종료한다. 예를 들어 `CTA`와 `GC`를 조합하면 `CGTCA`가 되고, `GC`와 `CTA`를 조합하면 `GCCT`가 된다.
> - 이 조합법을 공식으로 표현하기 위해서 이어 붙이기는 `+`, 걸러내기는 `-`, 그리고 조합하기는 `*` 부호를 사용한다.
>   - 단, `*`가 `+`, `-`에 우선순위를 가지는 수학의 사칙연산과 달리, 무조건 순서대로 조합을 진행해야 하며, 순서를 바꾸기 위해서는 괄호`()`를 사용한다.

"그러면, 이제 그 공식을 입력하면, 최종 예측 결과 염기 서열을 출력할 수 있는거야?"

거듭된 질문에 닥터 K가 난감한 표정을 지었다.

아, 그건 좀…"

"문제가 무엇인지 알 것 같은데? 혹시 우선 순위에 따라서 조합을 해 보는게 어려운거 아니야?"

"네. 공식이 조금만 복잡해져도 괄호가 많아져서…"

"그러면, 일단 수식을 연산자를 피연산자 뒤로 보내는 형태로 수식의 표기법을 조금 변형해보면 어때?"

## 수행목표

- 다음 기능을 수행하는 함수를 스택을 사용해 구현한다.

  - 문자열로 주어진 유전자 조작 공식에 대해서, 연산자를 피연산자의 뒤로 보내는 방식으로 괄호를 사용하고 표현하는 문자열로 변경하여 이를 반환한다. 주어진 유전자 조작 공식과 반환하는 변경 형식 모두 문자열이다. 다음은 입력에 따른 출력의 예시이다.

    | 입력        | 출력      |
    | ----------- | --------- |
    | `A+B*C`     | `AB+C*`   |
    | `A+(B*C)`   | `ABC*+`   |
    | `A+B*(C+D)` | `AB+CD+*` |

* 첨부한 파일에 포함된 20개의 유전자 조작 공식에 대해서 각각을 변환한 결과를 출력한다.

## 수행단계

- 수행목표에서 제시된 유전자 조작 공식을 변형하는 함수를 datastructure/operand_first.py 파일에 구현한다. 이 때 다음 사항을 참고한다.

  - 구현에 스택을 사용한다.
  - 공식에 사용되는 유전자 패턴은 한 글자의 영어 알파벳으로 표현된다.
  - 주어진 유전자 조작 공식은 모두 유효하다.
  - 유전자 패턴을 나타내는 영어 알파벳, 괄호 문자 (`(`, `)`), 연산자(`+`, `-`, `*`) 이외의 문자는 모두 무시한다.

- 첨부한 파일에는 20개의 유전자 조작 공식이 들어 있다. 하나의 유전자 조작 공식은 다음과 같이 구성되어 있다.

  - 첫 번째 줄 - testcase 번호
  - 두 번째 줄 이후 - 유전자 조작 공식. 긴 유전자 조작 공식은 두 줄 이상으로 구성되어 있으며, 이전 줄과 이어 붙여서 하나의 유전자 조작 공식을 구성한다.

- 첨부한 파일의 20개의 유전자 조작 공식을 문제에서 지시한 형식으로 변환한 문자열에 대해서, 다음 함수를 이용해 구한 간이 해시값을 출력한다.

  ```python
  import hashlib

  def hash4(input):
      return hashlib.md5(input.encode()).hexdigigest()[:4]
  ```

## 결과예시

```
testcase 1:b5bd
testcase 2:7588
testcase 3:2767
testcase 4:f91d
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 이렇게 변형한 수식을 통해 입력 패턴에 따른 최종 유전자 조작 결과를 미리 확인해보는 것이 닥터 K와 보스의 희망사항이다. 공식에 사용된 유전자 패턴이 연산자를 뒤로 보내는 방식으로 변형된 공식과 함께 주어졌을 때, 유전자 조작 결과를 계산해 반환하는 함수를 구현한다.

  - 이 함수도 스택을 사용해 구현한다.

- 공식에 사용된 각 유전자의 패턴이 다음과 같을 때, 첨부한 유전자 조작 공식 20개의 유전자 조작 결과를 출력한다.

  ```python
  patterns = {
      'A': 'CT',
      'B': 'GC',
      'C': 'ATT',
      'D': 'GCG',
      'E': 'CCG',
  }
  ```

* 다음은 일부 결과의 예시이다.

  ```
  testcase 1:b5bd
      유전자 조작 결과 : CATTGTC
  testcase 2:7588
      유전자 조작 결과 : CTGACT
  testcase 3:2767
      유전자 조작 결과 : GACTGTGCG
  testcase 4:f91d
      유전자 조작 결과 : CCGG
  (이하 생략)
  ```

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?

  - datastructure/operand_first.py 파일에 구현이 되어 있는지 확인한다.
  - 스택을 사용해 구현하였는지 확인한다.

- 제약사항을 준수하였는가?

  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.

- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.

  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    testcase 1:b5bd
    testcase 2:7588
    testcase 3:2767
    testcase 4:f91d
    testcase 5:ac0c
    testcase 6:284c
    testcase 7:7678
    testcase 8:b978
    testcase 9:0c8a
    testcase 10:aaee
    testcase 11:c479
    testcase 12:0118
    testcase 13:c6b1
    testcase 14:9fca
    testcase 15:94e3
    testcase 16:b23b
    testcase 17:5dd2
    testcase 18:609e
    testcase 19:3de1
    testcase 20:a202
    ```

### [보너스 과제 확인]

- 보너스 과제를 지시한 대로 해결하였는가?

  - 변형된 공식을 파라미터로 받아 스택을 사용해 문제를 해결하도록 구현하였는지 확인한다.

  - 결과 예시는 다음과 같다.

    ```
    testcase 1:b5bd
        유전자 조작 결과 : CATTGTC
    testcase 2:7588
        유전자 조작 결과 : CTGACT
    testcase 3:2767
        유전자 조작 결과 : GACTGTGCG
    testcase 4:f91d
        유전자 조작 결과 : CCGG
    testcase 5:ac0c
        유전자 조작 결과 : CGCCTGC
    testcase 6:284c
        유전자 조작 결과 : GACTGTCCCCCCGACT
    testcase 7:7678
        유전자 조작 결과 : CGCCCCTCT
    testcase 8:b978
        유전자 조작 결과 : ACCCTGTCTA
    testcase 9:0c8a
        유전자 조작 결과 : ACACCGGCAGCTTC
    testcase 10:aaee
        유전자 조작 결과 : TCGTTCCGCTCT
    testcase 11:c479
        유전자 조작 결과 : CCGGAGCCAGC
    testcase 12:0118
        유전자 조작 결과 : GCCACGTTCG
    testcase 13:c6b1
        유전자 조작 결과 : TCCTCCTTCTCCG
    testcase 14:9fca
        유전자 조작 결과 : TCCTCCCGTTATTGCGGC
    testcase 15:94e3
        유전자 조작 결과 : AGGGACCATT
    testcase 16:b23b
        유전자 조작 결과 : ACGCCGCGGCCGAGCGATTGGCGGAGCGATT
    testcase 17:5dd2
        유전자 조작 결과 : CGCCGGTCCGGCCCTCTCCGCTCTGCGCCCGCCCCCGGGTGACTGTCGCCCGC
    testcase 18:609e
        유전자 조작 결과 : CAACCTCTT
    testcase 19:3de1
        유전자 조작 결과 : CACAGGGTGCCTCGC
    testcase 20:a202
        유전자 조작 결과 : AAAGTGGTCCGTGACGGA
    ```

### [문제에 대한 이해]

- 연산자를 피연산자 뒤로 보내는 변형이 계산 과정의 구현에 어떤 방식으로 도움이 되는지를 설명하라.
- 연산자를 피연산자 뒤로 보내는 변형 과정에서 스택의 구조를 어떻게 활용하였는지 설명하라.
- (보너스 과제를 해결한 경우)변형된 공식을 사용해 유전자 조작 결과를 예측하는 함수의 동작 방식을 설명하라.

### [코드 예시]

```python
import hashlib

def infix_to_postfix(expression):
    oper = ['+', '-', '*']
    bracket = ['(', ')']
    stack = []
    result = []

    for char in expression:
        if char == ' ':
            continue
        if char not in oper and char not in bracket:
            result.append(char)
        elif char == '(':
            stack.append(char)
        elif char == ')':
            while stack and stack[-1] != '(':
                result.append(stack.pop())
            stack.pop()
        else:
            while stack and stack[-1] != '(':
                result.append(stack.pop())
            stack.append(char)

    while stack:
        result.append(stack.pop())

    return ''.join(result)

def calculate(patterns, expression):
    stack = []
    oper = ['+', '-', '*']
    for char in expression:
        if char == ' ':
            continue
        if char not in oper:
            stack.append(patterns[char])
        elif char == ' ':
            continue
        else:
            pattern2 = stack.pop()
            pattern1 = stack.pop()
            if char == '+':
                stack.append(pattern1 + pattern2)
            elif char == '-':
                before_remove = pattern1
                while True:
                    pattern1 = pattern1.replace(pattern2, '')
                    if before_remove == pattern1:
                        break
                    before_remove = pattern1
                stack.append(pattern1)
            elif char == '*':
                result = ''
                for i in range(min(len(pattern1), len(pattern2))):
                    result += pattern1[i] + pattern2[i]
                if len(pattern1) > len(pattern2):
                    result += pattern1[len(pattern2)]
                stack.append(result)
    return stack.pop()

import hashlib
def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]

with open("opf_testcases.txt", "r") as f:
    equation = ''
    testcase = ''
    while True:
        line = f.readline()
        if not line or line[:8] == 'testcase':
            if equation != '':
                pnr_result = infix_to_postfix(equation)
                print(f"{testcase}:{hash4(pnr_result)}")
                print(f"    유전자 조작 결과 : {calculate(patterns, pnr_result)}")
            if not line:
                break
            testcase = line.strip()
            equation = ''
        else:
            equation += line.strip()
```

---

# 문제 7. 연결된 리스트

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

연구소에는 수많은 실험 장비들이 있다. 이 장비 중 일부는 연속성을 가진 장비가 있다. 세균 배양기의 예를 들자면, 거의 해마다 새로운 배양 장비를 도입하고 있고, 조금이라도 뒤에 도입된 세균 배양기는 이전에 도입된 세균 배양기의 후속 장비의 성격을 지니게 된다. 만약 세균 배양기를 신규 도입하는 안에 대해서 검토를 한다면, 특정 시점에 도입된 세균 배양기를 선택한 후, 후속 도입 장비들의 리스트를 만든 후 검토를 하게 된다.

물론 데이터베이스에 도입 시기와 장비의 이름 또는 분류명을 조건으로 쿼리를 실행해서 목록을 만들 수는 있지만, 제조사마다 장비의 이름이 다르고, 또 같은 장비를 시기 별로 부르는 분류명도 종종 변하는 일이 있어서 목록을 만드는 일이 매우 번거롭고 시간이 오래 걸리는 일이 되고 있다.

지선생은 지금부터라도 이전 모델과 후속 도입 모델을 연결할 수 있는 체계를 연구소의 시스템에 도입하기로 결정했다.

## 수행목표

- 각 장비의 정보를 저장하는 자료구조를 파이썬 클래스를 사용해 구현한다. 클래스의 이름은 `Device`로 한다.
- 구현한 파이썬 클래스의 객체를 노드로 가지는 연결된 리스트(linked list)를 만든다. 연결된 리스트를 관리하기 위해서 다음 기능을 수행하는 함수를 구현한다. 각 함수의 상세한 내용은 수행단계의 설명을 참고한다.
  - 연결된 리스트를 출력하는 함수
  - 연결된 리스트에 노드를 추가하는 함수들
  - 연결된 리스트에서 노드를 삭제하는 함수들
  - 리스트에서 특정 위치의 노드를 반환하는 함수
  - 역순의 리스트를 생성하는 함수
- 구현한 클래스와 함수를 아래 수행단계에서 제시하는 테스트 코드를 적용하고 그 결과를 출력한다.

## 수행단계

- 연결된 리스트(linked list)에 대해서 조사한다.
- 각 장비 별 정보를 저장한 객체를 생성할 수 있는 파이썬 클래스 `Device`를 구현한다. 이 클래스는 두 개의 멤버 변수를 가진다.
  - 장비의 모델명 (`model_name`)
  - 후속 장비 노드를 가리키는 변수 (`next`)
- 클래스 `Device`를 다룰 수 있는 다음 함수들을 구현한다. `Device` 클래스와 이 함수들은 `datastructure/device_list.py` 파일에 구현한다.
  - `add_node_first(head: Device, model_name: str) -> Device`
    - `model_name`을 모델명으로 하는 `Device`의 객체를 생성하고, `head` 노드로부터 연결된 리스트의 첫 번째 노드로 삽입하고, 삽입한 노드를 반환한다.
    - `head`가 `None`인 경우, 객체를 생성한 후 반환한다.
  - `add_node_last(head: Device, model_name: str) -> Device`
    - `model_name`을 모델명으로 하는 `Device`의 객체를 생성하고, `head` 노드로부터 연결된 리스트의 가장 마지막에 삽입하고 `head` 노드를 반환한다.
    - `head`가 `None`인 경우, 객체를 생성한 후 반환한다.
  - `add_node(head: Device, model_before: str, model_name: str) -> Device`
    - `model_name`을 모델명으로 하는 `Device`의 객체를 생성하고, `head` 노드로부터 연결된 리스트에서 모델명이 `model_before`인 노드의 다음에 삽입하고 `head`를 반환한다.
    - 리스트에 `model_before`에 해당하는 모델이 둘 이상 있는 경우, 첫 번째 노드의 다음에 삽입한다.
    - `head`가 `None`이거나 리스트에 `model_before`에 해당하는 모델이 없는 경우, `add_node_last`와 동일하게 동작한다.
  - `remove_first(head: Device) -> Device`
    - `head` 노드로부터 연결된 리스트의 첫 번째 노드를 삭제하고, 새로운 첫 번째 노드를 반환한다.
    - 노드를 삭제할 수 없거나, 삭제 후 연결된 리스트가 빈 리스트인 경우 `None`을 반환한다.
  - `remove_last(head: Device) -> Device`
    - `head` 노드로부터 연결된 리스트의 마지막 노드를 삭제하고, 첫 번째 노드를 반환한다.
    - 노드를 삭제할 수 없거나, 삭제 후 연결된 리스트가 빈 리스트인 경우 `None`을 반환한다.
  - `remove_models(head: Device, model_name: str) -> Device`
    - `head` 노드로부터 연결된 리스트에서 모델명이 `model_name`인 모든 노드를 삭제하고, 첫 번째 노드를 반환한다.
    - `head`가 `None`이거나 삭제 후 연결된 리스트가 빈 리스트인 경우 `None`을 반환한다.
  - `node_at(head: Device, location: int) -> Device`
    - `head` 노드로부터 연결된 리스트에서 `location` 번째 노드를 반환한다.
    - `location`이 `0`이면 `head` 노드를, `1`이면 그 다음 노드를 의미한다.
    - `head`가 `None`이거나, 지정한 숫자가 리스트의 범위를 벗어나는 경우 `None`을 반환한다.
  - `nodes_in_list(head: Device) -> str`
    - `head` 노드로부터 연결된 리스트에서 순서대로 모델명을 이어붙인 문자열을 반환한다. 예를 들어 리스트에 연결된 모델명의 순서가 ‘A1’, ‘A2’, ‘A3’인 경우 `A1A2A3`을 반환한다.
    - `head`가 `None`인 경우 빈 문자열을 반환한다.
  - `reverse(head: Device) -> Device`
    - `head` 노드로부터 연결된 리스트에 대해서, 역순의 연결된 리스트를 생성하고 새로 생성된 리스트의 첫 번째 노드를 반환한다. 이 때, 원래 `head` 노드로부터 연결된 리스트도 변함없이 유효한 리스트를 유지해야 한다.
    - `head`가 None인 경우 `None`을 반환한다.
- 이렇게 구현한 클래스와 함수에 대해서 다음 코드를 추가하고 실행한 결과를 출력한다.

  ```python
  import hashlib

  def hash4(input: str) -> str:
      return hashlib.md5(input.encode()).hexdigest()[:4]

  def main():
      result = []
      head = add_node_last(None, 'A1')
      head = add_node_last(head, 'A2')
      head = add_node_last(head, 'A3')
      head = add_node_last(head, 'A4')
      head = add_node_last(head, 'A3')
      head = add_node_first(head, 'A6')
      head = add_node_last(head, 'A7')
      head = add_node(head, 'A3', 'A8')
      result.append(nodes_in_list(head))
      result.append(nodes_in_list(reverse(head)))
      head = add_node_last(None, 'B1')
      head = add_node_last(head, 'B2')
      head = add_node_last(head, 'B3')
      head = add_node_last(head, 'B4')
      head = add_node_last(head, 'BR')
      head = add_node_last(head, 'BR')
      head = add_node_last(head, 'B5')
      head = add_node_last(head, 'B6')
      head = add_node_first(head, 'BR')
      head = add_node_first(head, 'BR')
      head = add_node_first(head, 'BR')
      head = add_node_last(head, 'BR')
      head = add_node_last(head, 'BR')
      head = add_node_last(head, 'BR')
      head = remove_models(head, 'BR')
      result.append(nodes_in_list(head))
      result.append(nodes_in_list(reverse(head)))
      head = add_node_last(None, 'C1')
      head = remove_first(head)
      head = add_node_first(head, 'C2')
      head = remove_last(head)
      head = add_node_first(head, 'C3')
      head = add_node_first(head, 'C4')
      head = remove_first(head)
      head = add_node_first(head, 'C5')
      head = add_node_first(head, 'C6')
      head = remove_last(head)
      head = add_node_first(head, 'C7')
      head = add_node_first(head, 'C8')
      node = node_at(head, 2)
      result.append(nodes_in_list(node))
      result.append(nodes_in_list(reverse(node)))
      head = None
      for i in range(10000):
          model_name = 'D' + str(i % 987)
          head = add_node_first(head, model_name)
      head = add_node_last(node_at(head, 5), 'DN')
      result.append(nodes_in_list(reverse(head)))
      result.append(nodes_in_list(head))
      head = remove_models(head, 'D0')
      result.append(nodes_in_list(reverse(head)))
      result.append(nodes_in_list(head))
      for result in result:
          print(hash4(result), result[:20])

  if __name__ == '__main__':
      main()
  ```

## 결과예시

```
aebc A6A1A2A3A8A4A3A7
5447 A7A3A4A8A3A2A1A6
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - datastructure/device_list.py 파일에 구현이 되어 있는지 확인한다.
  - 노드를 파이썬 클래스로 제작하였으며, 각 노드들은 연결된 리스트 형태로 연결이 관리되도록 구현되었는지 확인한다.
  - 문제에서 지시한 함수들이 지시한 바대로 적절히 구현되어 있는지 확인한다.
    - 각 함수들의 파라미터로 전달되는 Device의 객체들이 None인 경우에도 예외가 발생하지 않는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    aebc A6A1A2A3A8A4A3A7
    5447 A7A3A4A8A3A2A1A6
    1b8d B1B2B3B4B5B6
    70c2 B6B5B4B3B2B1
    d895 C6C5
    0c53 C5C6
    e537 DND0D1D2D3D4D5D6D7D8
    40f9 D124D123D122D121D120
    b1e5 DND1D2D3D4D5D6D7D8D9
    1589 D124D123D122D121D120
    ```

### [문제에 대한 이해]

- 연결된 리스트가 무엇인지 설명하라.
  - 연결된 리스트는 데이터 항목이 노드 형태로 저장되며, 각 노드가 다음 노드를 가리키는 포인터 또는 참조를 통해 서로 연결되어 있는 선형적인 데이터 구조이다.
  - 연결된 리스트의 각 노드는 데이터와 다음 노드를 가리키는 포인터(단일 연결 리스트의 경우) 또는 이전과 다음 노드를 모두 가리키는 포인터(이중 연결 리스트의 경우)를 포함한다.
- 연결된 리스트가 가지는 장점은 무엇인가?
  - 동적으로 크기를 조정할 수 있고, 메모리를 효율적으로 사용할 수 있으며, 효율적으로 삽입, 삭제가 가능하다는 장점이 있다.
- 연결된 리스트의 단점은 무엇인가?
  - 인덱스를 사용해 접근이 불가하므로 일부 기능이 비효율적이며, 포인터 또는 참조로 인해 추가적인 메모리가 필요하다는 단점이 있다.

### [코드 예시]

```python
class Device:
    def __init__(self, model_name):
        self.model_name = model_name
        self.next = None

def add_node_first(head: Device, model_name: str) -> Device:
    new_node = Device(model_name)
    new_node.next = head
    return new_node

def add_node_last(head: Device, model_name: str) -> Device:
    new_node = Device(model_name)
    if head == None:
        return new_node

    cur = head
    while True:
        if cur.next == None:
            cur.next = new_node
            break
        cur = cur.next
    return head

def add_node(head: Device, model_before: str, model_name: str) -> Device:
    new_node = Device(model_name)
    if head == None:
        return new_node
    cur = head
    while True:
        if cur.model_name == model_before:
            new_node.next = cur.next
            cur.next = new_node
            break
        if cur.next == None:
            cur.next = new_node
            break
        cur = cur.next
    return head

def remove_first(head: Device) -> Device:
    if head == None:
        return None
    return head.next

def remove_last(head: Device) -> Device:
    if head == None:
        return None
    if head.next == None:
        return None
    cur = head
    while True:
        if cur.next.next == None:
            cur.next = None
            break
        cur = cur.next
    return head

def remove_models(head: Device, model_name: str) -> Device:
    if head == None:
        return None
    while head.model_name == model_name:
        head = head.next
        if head == None:
            return None
    cur = head
    while True:
        if cur.next == None:
            break
        if cur.next.model_name == model_name:
            cur.next = cur.next.next
            continue
        cur = cur.next
    return head

def node_at(head: Device, location: int) -> Device:
    if head == None:
        return None
    if location == 0:
        return head
    cur = head
    for _ in range(location):
        if cur.next == None:
            return None
        cur = cur.next
    return cur

def nodes_in_list(head: Device) -> str:
    result = ''
    cur = head
    while cur != None:
        result += cur.model_name
        cur = cur.next
    return result

def reverse(head: Device) -> Device:
    if head == None:
        return None
    if head.next == None:
        return Device(head.model_name)
    reverse_head = None
    while head != None:
        reverse_head = add_node_first(reverse_head, head.model_name)
        head = head.next
    return reverse_head

import hashlib

def hash4(input: str) -> str:
    return hashlib.md5(input.encode()).hexdigest()[:4]

def main():
    result = []
    head = add_node_last(None, 'A1')
    head = add_node_last(head, 'A2')
    head = add_node_last(head, 'A3')
    head = add_node_last(head, 'A4')
    head = add_node_last(head, 'A3')
    head = add_node_first(head, 'A6')
    head = add_node_last(head, 'A7')
    head = add_node(head, 'A3', 'A8')
    result.append(nodes_in_list(head))
    result.append(nodes_in_list(reverse(head)))
    head = add_node_last(None, 'B1')
    head = add_node_last(head, 'B2')
    head = add_node_last(head, 'B3')
    head = add_node_last(head, 'B4')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'B5')
    head = add_node_last(head, 'B6')
    head = add_node_first(head, 'BR')
    head = add_node_first(head, 'BR')
    head = add_node_first(head, 'BR')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'BR')
    head = remove_models(head, 'BR')
    result.append(nodes_in_list(head))
    result.append(nodes_in_list(reverse(head)))
    head = add_node_last(None, 'C1')
    head = remove_first(head)
    head = add_node_first(head, 'C2')
    head = remove_last(head)
    head = add_node_first(head, 'C3')
    head = add_node_first(head, 'C4')
    head = remove_first(head)
    head = add_node_first(head, 'C5')
    head = add_node_first(head, 'C6')
    head = remove_last(head)
    head = add_node_first(head, 'C7')
    head = add_node_first(head, 'C8')
    node = node_at(head, 2)
    result.append(nodes_in_list(node))
    result.append(nodes_in_list(reverse(node)))
    head = None
    for i in range(10000):
        model_name = 'D' + str(i % 987)
        head = add_node_first(head, model_name)
    head = add_node_last(node_at(head, 5), 'DN')
    result.append(nodes_in_list(reverse(head)))
    result.append(nodes_in_list(head))
    head = remove_models(head, 'D0')
    result.append(nodes_in_list(reverse(head)))
    result.append(nodes_in_list(head))
    for result in result:
        print(hash4(result), result[:20])

if __name__ == '__main__':
    main()

```

---

# 문제 8. 최후의 승자는?

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

세균을 연구하는 연구원 V는 일반적인 세균과 달리, 숙주의 자원을 독차지하기 위해서 경쟁자를 제거하는 성질을 가진 독특한 세균을 발견했다. 이 세균에 대해서 조금 더 자세히 연구한 결과 이 세균은 다음과 같은 성질을 가지고 있다는 가설을 수립했다.

> - 이 세균은 자원을 원형으로 둘러싼 후에 서로 경쟁을 시작한다.
> - 이 세균 중 한 마리가 시계 방향으로 독소를 1 만큼 전달하기 시작한다. 전달 받은 세균은 거기에 자신의 독소를 더해 독소의 양이 1 증가하며, 이 독소를 다시 시계방향으로 전달한다. 하지만, 독소가 치사량에 전달하면 독소를 전달하지 못하고 이 세균은 소멸한다.
> - 세균이 소멸한 경우, 소멸한 세균의 시계방향 바로 옆의 세균은 다시 농도가 낮은 독소를 전달한다.
> - 이 과정을 세균 개체가 단 하나만 남을 때 까지 반복한다.

연구원 V는 가설 검증을 위해서 실험을 설계했다. 연구원 V는 k마리의 세균의 독소가 더해지면, 세균이 소멸하도록 실험 환경을 조절할 수 있었다. 가설 검증을 위해서는 총 n마리의 세균이 있을 때, 어떤 세균이 살아남는지를 예측한 다음 실제로 그 세균이 살아남는지 확인하면 된다.

우선 7마리의 세균을 배치하고, 처음 전달을 시작한 세균을 포함해 3마리가 독소를 더하면 세균이 소멸되도록 환경을 설정한 후 실험을 시작했다. 관찰 결과는 다음과 같았다. (아래 숫자는 처음 독소 전달을 시작한 세균을 1번으로, 시계 방향으로 번호를 붙인 것이다.)

> - 3번 세균 소멸 → 6번 세균 소멸 → 2번 세균 소멸 → 7번 세균 소멸 → 5번 세균 소멸 → 1번 세균 소멸
> - 마지막 생존자는 4번 세균

이는 실험 전 예측한 결과와 동일했다. 이 정도는 종이에 7마리의 세균을 배치하고 하나씩 제거하는 방법으로 쉽게 확인할 수 있는 수준이다. 하지만 이런 간단한 실험으로 가설을 검증하기에는 부족하다고 판단한 연구원 V는 실험 규모를 1 ≤ n ≤ 100000, 1 ≤ k ≤ 1000까지 확장하기로 한다. (n, k는 모두 정수이다.)

물론 이 정도 규모에서는 종이에 그림을 그리면서 확인하는게 쉽지 않은 탓에 간단한 프로그램을 작성해 결과를 예측해보기로 하였다. 그런데, 연구원 V는 난감한 상황에 처하게 되었다.

## 수행목표

- 세균이 n 마리 (n은 10000이하의 양의 정수)가 있고 k 마리의 독소가 추가된 시점에 세균이 소멸할 때 최후에 생존한 세균의 번호가 몇 번인지를 반환하는 함수를 구현한다.
  - 이 함수의 시간 복잡도는 $\mathcal O(n)$으로 구현해야 한다.
  - 세균은 원형으로 배치되며, 처음 독소를 전달하기 시작하는 세균을 1번으로 하고, 시계방향으로 차례로 n번까지 번호를 부여한다.
- 다음 테스트케이스에 대해서 결과를 출력한다. 테스트케이스는 총 12개로 테스트케이스의 각 쌍은 세균의 수 n과 세균이 사망하게 되는 독소의 농도 k의 값이다.

  ```python
  testcases = [(7, 3), (15, 5), (1, 10), (10, 1), (15, 5), (5, 15), (30, 30), (1000, 1), (1000, 39), (100000, 100), (100000, 333), (100000, 1000)]
  ```

## 수행단계

- 연구원 V는 먼저 이 문제를 파이썬 리스트로 해결하기로 하고 다음과 같은 함수를 작성했다. n = 100000, k = 1000일 때의 함수의 실행 시간을 출력하고 확인하자. 또한, 이 구현의 시간복잡도도 계산해보자.
  ```python
  def remove_rival_list(n, k):
      virus = [True] * n
      count = n
      cur = 0
      while count > 1:
          i = 0
          while i < k:
              if virus[cur]:
                  i += 1
              cur = (cur + 1) % n
          virus[(cur - 1) % n] = False
          count -= 1
      for i in range(n):
          if virus[i]:
              return i + 1
  ```
- 연구원 V는 리스트로 구현한 함수의 문제를 해결하기 위해서 재귀호출을 사용하는 다음과 같은 함수를 작성했다. 이 함수의 시간복잡도를 계산한 후, n = 100000, k = 1000일 때 발생하는 문제점을 확인해보자.
  ```python
  def remove_rival_recursive(n, k):
      if n == 1:
          return 0
      else:
          return (remove_rival_recursive(n - 1, k) + k) % n
  ```
- 재귀호출을 사용할 때의 문제가 발생하지 않고, 리스트 구현보다 빠르게 동작하는 `remove_rival_fast(n, k)` 함수를 `datastructure/remove_rival.py` 파일에 구현한다.
  - 수행 목표에서 제시한 테스트케이스 12개의 결과를 각 테스트케이스 별 함수 실행시간과 함께 출력한다.
  - 선형 시간 복잡도의 성능을 가지는 알고리즘으로 구현해야 한다. 단 시간 복잡도를 계산할 때 k는 입력의 크기와 무관한 상수로 가정한다.

## 결과예시

```
testcase 1
    실행 시간: 6.198883056640625e-06 sec
    winner : 4

testcase 2
    실행 시간: 8.344650268554688e-06 sec
    winner : 1
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - datastructure/remove_rival.py 파일에 구현이 되어 있는지 확인한다.
  - 선형 시간복잡도의 함수로 구현되었는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 실행 시간은 다르게 출력되겠지만, 마지막 테스트케이스도 일반적인 환경에서 수 초 이내에 종료되는게 정상이다.

    ```
    testcase 1
        실행 시간: 6.198883056640625e-06 sec
        winner : 4

    testcase 2
        실행 시간: 8.344650268554688e-06 sec
        winner : 1

    testcase 3
        실행 시간: 9.5367431640625e-07 sec
        winner : 1

    testcase 4
        실행 시간: 0.0 sec
        winner : 10

    testcase 5
        실행 시간: 7.867813110351562e-06 sec
        winner : 1

    testcase 6
        실행 시간: 2.86102294921875e-06 sec
        winner : 1

    testcase 7
        실행 시간: 2.9802322387695312e-05 sec
        winner : 29

    testcase 8
        실행 시간: 0.0 sec
        winner : 1000

    testcase 9
        실행 시간: 0.0016491413116455078 sec
        winner : 188

    testcase 10
        실행 시간: 0.34204888343811035 sec
        winner : 3365

    testcase 11
        실행 시간: 1.5977790355682373 sec
        winner : 99509

    testcase 12
        실행 시간: 4.368833780288696 sec
        winner : 98669
    ```

### [문제에 대한 이해]

- 파이썬 리스트를 사용해 구현한 함수의 시간 복잡도를 근거와 함께 제시하라.
  - 두 개의 루프로 구성되며, 각각의 루프가 n과 선형적으로 반복 회수가 증가하므로 시간 복잡도가 $\mathcal O(n^2)$임을 설명할 수 있어야 한다.
- 재귀 호출을 사용해 구현한 경우에 발생하는 문제는 무엇인가?
  - 재귀 깊이와 관련된 문제를 지적하는지 확인한다.
- 이 문제를 선형 시간 복잡도 함수로 구현하는데 사용한 방법을 설명하라.
  - 순환 연결 리스트를 사용해서 해결하는 방법을 기대하였으나, 선형 시간 복잡도로 구현한 다른 방법을 제시하는 경우 정답으로 인정한다.
- 구현한 함수가 선형 시간 복잡도임을 설명하라.
  - 순환 연결 리스트로 구현한 경우의 분석은 다음과 같다.
  - 순환 연결 리스트를 만드는 과정에서 n개의 요소를 추가하므로 $\mathcal O(n)$의 시간 복잡도를 가진다.
  - 라이벌을 제거하는 과정은 k에 비례해서 순환 회수가 증가하지만, k는 정해진 상수이므로 무시할 수 이기 때문에 마찬가지로 $\mathcal O(n)$의 시간 복잡도를 가진다.
  - 두 선형 시간 복잡도 작업이 병렬적으로 배치되어 있기 때문에 구현한 함수는 $\mathcal O(n)$의 시간 복잡도를 가진다.

### [코드 예시]

```python
import time

def execute_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print(f"    실행 시간: {time.time() - start} sec")
        return result
    return wrapper

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def create_circular_linked_list(n):
    head = Node(1)
    prev = head
    for i in range(2, n + 1):
        new_node = Node(i)
        prev.next = new_node
        prev = new_node
    prev.next = head  # 마지막 노드가 첫 번째 노드를 가리키도록 설정
    return head

@execute_time
def remove_rival_fast(n, k):
    if k == 1:
        return n
    head = create_circular_linked_list(n)
    prev = None
    curr = head

    while curr.next != curr:
        for _ in range(k - 1):
            prev = curr
            curr = curr.next
        prev.next = curr.next
        curr = curr.next

    return curr.data


def main():
    testcases = [(7, 3), (15, 5), (1, 10), (10, 1), (15, 5), (5, 15), (30, 30), (1000, 1), (1000, 39), (100000, 100), (100000, 333), (100000, 1000)]
    for i, (n, k) in enumerate(testcases):
        print(f"testcase {i + 1}")
        last_virus = remove_rival_fast(n, k)
        print(f"    winner : {last_virus}")
        print()


if __name__ == "__main__":
    main()
```

---

# 문제 9. 꼬여버린 데이터의 실마리를 찾아라

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

‘아, 이거 큰일났네?’

지선생은 연결된 리스트를 다루는 코드를 작성하다가 뭔가 크게 꼬였다는 사실을 발견했다. 연결된 리스트의 마지막 노드의 다음 노드는 None을 가리켜야 하는데, 실수로 리스트의 중간 노드 어딘가를 가리키게 되었다. 이렇게 잘못 구성된 리스트를 탐색하면 무한반복하는 경우가 발생해버리게 된다.

디버깅을 위해서 생성한 수많은 리스트 중 어떤 리스트가 이런 잘못 만들어진 연결된 리스트인지를 확인해야 한다. 물론, 리스트를 탐색하면서 한 번 방문한 리스트에 표시할 수 있는 변수를 추가하거나, 방문한 리스트들의 목록을 저장한 후 한 번 방문한 리스트를 다시 방문했는지 일일이 확인하는 방법으로 처리할 수 있지만, 몇몇 리스트는 길이가 너무 길어서 이런 실행 시간이나 사용하는 메모리의 양을 생각했을 때 좋은 방법이 아니었다.

## 수행목표

- 연결된 리스트에 순환구조가 생성되었는지를 검사하는 함수를 다음 제약 조건 하에 구현한다.
  - 메모리를 매우 효율적으로 사용해야 하며, 검사하는데 필요한 시간도 선형 시간 복잡도 이내여야 한다.
- 수행단계에서 지시한 대로 5개의 리스트를 만들고, 이 리스트들에 대한 검사 결과를 출력한다.

## 수행단계

- datastructure/device_list.py 파일에 구현한, 장비 관리를 위한 연결 리스트 클래스 및 함수를 사용한다.
  - 단 datastructure/check_circle.py 파일에 아래 내용을 구현하며, 필요한 경우 device_list.py 파일에 구현한 클래스 및 함수를 옮겨오지 않고 사용한다.
- 어떤 리스트의 첫 번째 노드 head를 파라미터로 받아서 이 리스트에 순환구조가 존재하는지 확인하는 함수를 구현한다.
  - 시간 복잡도는 $\mathcal O(n)$, 공간 복잡도는 $\mathcal O(1)$인 함수로 구현한다.
  - 검사 가능한 리스트의 길이는 시스템이 생성 가능한 길이의 리스트인 경우 특별히 제한하지 않는다.
- 다음과 같이 생성된 4개의 연결된 리스트를 만든다.

  - 연결된 리스트 1 : 길이가 1000인 연결된 리스트를 만든다. 이 리스트에 포함된 장비는 연결 순서대로 A0, A1, ..., A999까지의 이름을 가진다. 리스트를 생성한 후, 이 연결된 리스트의 마지막 노드의 다음 노드를 리스트의 51번째 노드로 연결한다.
  - 연결된 리스트 2 : 길이가 1000인 연결된 리스트를 만든다. 이 리스트에 포함된 장비는 연결 순서대로 B0, B1, ..., B999까지의 이름을 가진다.
  - 연결된 리스트 3 : 길이가 5001인 연결된 리스트를 만든다. 이 리스트에 포함된 장비는 연결 순서대로 C0, C1, ..., C5000까지의 이름을 가진다. 리스트를 생성한 후, 이 연결된 리스트의 마지막 노드의 다음 노드를 리스트의 51번째 노드로 연결한다.
  - 연결된 리스트 4 : 길이가 1000인 연결된 리스트를 만든다. 이 리스트에 포함된 장비는 연결 순서대로 D0, D1, ..., D999까지의 이름을 가진다. 리스트를 생성한 후, 이 연결된 리스트의 마지막 노드의 다음 노드를 리스트의 첫 번째 노드로 연결한다.
  - 연결된 리스트 5 : 길이가 5001인 연결된 리스트를 만든다. 이 리스트에 포함된 장비는 연결 순서대로 E0, E1, ..., E5000까지의 이름을 가진다. 리스트를 생성한 후, 이 연결된 리스트의 마지막 노드의 다음 노드를 리스트의 첫 번째 노드로 연결한다.

- 위와 같이 생성한 4개의 연결된 리스트에 대해서 순환 여부를 검사하고 그 결과를 출력한다.

## 결과예시

```
list1 :  cyclic
    순환 연결한 노드의 모델 이름 : A999
list2 :  non-cyclic

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 이 문제에서처럼 단순한 순환 구조는 다행히 문제의 노드를 찾아서 연결만 제거하면 쉽게 수정할 수 있다. 문제는 이 노드가 무엇인지 확인해야 한다는 점이다. 순환 구조가 있는 리스트의 경우, 연결을 제거할 노드를 반환하도록 함수를 수정하고, 이 노드의 모델명을 출력해보자.
  - 생성한 5개의 연결된 리스트에 대해서 그 결과를 함께 출력한다.
  - 시간 복잡도 및 공간 복잡도는 수정 전과 다르지 않아야 한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - datastructure/check_circle.py 파일에 구현이 되어 있는지 확인한다.
  - device_list.py 파일에 구현한 클래스 및 함수를 import하여 구현하고 있는지 확인한다.
  - 지시한 대로 4개의 순환 구조가 있는 리스트, 하나의 순환 구조가 없는 리스트를 만들었는지 확인한다.
  - 구현한 함수의 시간 복잡도와 공간 복잡도가 각각 선형 시간 복잡도 및 상수 공간 복잡도로 구현되었는지를 확인한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.
  ```
  list1 :  cyclic
  list2 :  non-cyclic
  list3 :  cyclic
  list4 :  cyclic
  list5 :  cyclic
  ```

### [보너스 과제 확인]

- 순환을 제거할 노드를 반환하도록 함수가 구현되었는가?
  - 순환이 있는 네 개의 리스트 모두 마지막 노드 (A999, C5000, D999, E5000)를 반환하도록 구현이 되어야 한다.
  - 시간 복잡도 및 공간 복잡도가 증가 없이 구현되었는지를 확인한다. (선형 시간 복잡도, 상수 시간 복잡도)
  - 실행 결과의 예시는 다음과 같다.
  ```
  list1 :  cyclic
    순환 연결한 노드의 모델 이름 : A999
  list2 :  non-cyclic
  list3 :  cyclic
    순환 연결한 노드의 모델 이름 : C5000
  list4 :  cyclic
    순환 연결한 노드의 모델 이름 : D999
  list5 :  cyclic
    순환 연결한 노드의 모델 이름 : E5000
  ```

### [문제에 대한 이해]

- 순환을 정해진 크기의 메모리만 사용하면서 확인하는 방법을 제시하라.
  - 두 개의 속도가 다른 포인터를 사용해 탐색하는 방식으로 구현하는 경우의 답변은 다음과 같다.
  - 리스트를 탐색할 때 포인터 두 개를 하나는 노드 1개씩, 다른 하나는 노드 2개씩을 건너뛰게 하면, 순환이 있는 연결된 리스트에서는 두 포인터가 같은 노드를 가리키는 시점이 온다.
- 구현한 알고리즘의 시간 복잡도 및 공간 복잡도가 각각 선형 시간 복잡도, 상수 공간 복잡도인 이유를 설명하라.
  - 두 개의 속도가 다른 포인터를 사용해 탐색하는 방식으로 구현하는 경우의 답변은 다음과 같다.
  - 두 로핀터가 연결된 리스트의 각 노드를 1번만 방문하고 순환 여부를 찾을 수 있으므로 선형 시간 복잡도이다.
  - 이를 위해서 저장하는 별도 변수가 두 개의 탐색용 포인터 뿐 이므로 공간 복잡도는 상수의 값으로 고정된다.
- (보너스 문제를 해결한 경우)순환 구조의 시작 노드와 이전 노드를 같은 시간 및 공간 복잡도 내에서 찾는 방법을 설명하라.
  - 느린 포인터를 리스트의 시작 지점으로 보낸 후, 두 포인터를 한 번씩 이동해서 만나는 지점이 순환의 시작 지점이다. 이 때 빠른 포인터의 이전 노드를 추가해서 함께 관리하는 경우 연결을 제거할 노드를 특정할 수 있다.

### [코드 예시]

```python
from device_list import add_node_last, Device

def make_list_with_size(size: int, prefix: str) -> Device:
    head = None
    for i in range(size):
        head = add_node_last(head, f"{prefix}{i}")
    return head

def find_cycle(head: Device) -> Device:
    slow = fast = head
    while True:
        if slow.next == None or fast.next == None or fast.next.next == None:
            return None, None
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    slow = head
    before = None
    while True:
        if slow == fast:
            break
        before = fast
        slow = slow.next

        fast = fast.next
    if before == None:
        cur = head
        while cur.next != head:
            cur = cur.next
        before = cur
    return slow, before


def main():
    list1 = make_list_with_size(1000, 'A')
    list2 = make_list_with_size(1000, 'B')
    list3 = make_list_with_size(5001, 'C')
    list4 = make_list_with_size(1000, 'D')
    list5 = make_list_with_size(5001, 'E')

    cur = list1
    circular_linked_node = None
    i = 0
    while True:
        if i == 50:
            circular_linked_node = cur
        if cur.next == None:
            break
        cur = cur.next
        i += 1
    cur.next = circular_linked_node

    cur = list3
    circular_linked_node = None
    i = 0
    while True:
        if i == 50:
            circular_linked_node = cur
        if cur.next == None:
            break
        cur = cur.next
        i += 1
    cur.next = circular_linked_node

    cur = list4
    while True:
        if cur.next == None:
            break
        cur = cur.next
    cur.next = list4

    cur = list5
    while True:
        if cur.next == None:
            break
        cur = cur.next
    cur.next = list5


    is_cyclic_list1, before_cyclic_list1 = find_cycle(list1)
    is_cyclic_list2, before_cyclic_list2 = find_cycle(list2)
    is_cyclic_list3, before_cyclic_list3 = find_cycle(list3)
    is_cyclic_list4, before_cyclic_list4 = find_cycle(list4)
    is_cyclic_list5, before_cyclic_list5 = find_cycle(list5)

    print("list1 : ", 'cyclic' if is_cyclic_list1 else 'non-cyclic')
    if is_cyclic_list1:
        print("    순환 연결한 노드의 모델 이름 :", before_cyclic_list1.model_name)
    print("list2 : ", 'cyclic' if is_cyclic_list2 else 'non-cyclic')
    if is_cyclic_list2:
        print("    순환 연결한 노드의 모델 이름 :", before_cyclic_list2.model_name)
    print("list3 : ", 'cyclic' if is_cyclic_list3 else 'non-cyclic')
    if is_cyclic_list3:
        print("    순환 연결한 노드의 모델 이름 :", before_cyclic_list3.model_name)
    print("list4 : ", 'cyclic' if is_cyclic_list4 else 'non-cyclic')
    if is_cyclic_list4:
        print("    순환 연결한 노드의 모델 이름 :", before_cyclic_list4.model_name)
    print("list5 : ", 'cyclic' if is_cyclic_list5 else 'non-cyclic')
    if is_cyclic_list5:
        print("    순환 연결한 노드의 모델 이름 :", before_cyclic_list5.model_name)

if __name__ == "__main__":
    main()
```

---

# 문제 10. 앞으로도, 뒤로도.

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

연결된 장비 관리를 체계화하던 지선생은, 이전 도입된 장비로부터 후속 장비를 조회하는 경우 뿐 아니라, 후속 장비의 이전 도입 장비를 조회하는 일도 잦다는 사실을 알게 되었다. 하지만, 현재 구현한 연결된 리스트의 경우는 이전 도입된 장비를 조회하는 과정이 비효율적이라는 점 때문에 연결된 리스트의 구조를 수정해서 이 과정을 효율적으로 변경하기로 결심한다.

## 수행목표

연결된 리스트 상의 특정 노드의 이전 노드를 조회하는 작업의 시간복잡도가 $\mathcal O(1)$이 되도록 연결된 리스트를 수정한다.

## 수행단계

- datastructure/device_list.py 파일에 구현된 연결된 리스트에서 특정 노드가 주어졌을 때 이 이전 노드를 찾는 방법과 이 방법의 시간 복잡도를 정리한다.
- 이중으로 연결된 리스트(double linked list)에 대해서 조사한다.
  - 이중으로 연결된 리스트에서 특정 노드가 주어졌을 때, 이 이전 노드를 찾는 방법의 시간 복잡도는 얼마인가?
- datastructure/device_list_new.py 파일에 각 장비 별 정보를 저장한 객체를 생성할 수 있는 파이썬 클래스 `Device`를 구현한다. 이 클래스는 이전 문제와 달리 세 개의 멤버 변수를 가진다.
  - 장비의 모델명
  - 이전 장비 노드를 가리키는 변수 (`before`)
  - 후속 장비 노드를 가리키는 변수 (`next`)
- 클래스 `Device`를 다룰 수 있는 다음 함수들을 구현한다. `Device` 클래스와 이 함수들은 `datastructure/device_new_list.py` 파일에 구현한다.
  - `add_node_first(head: Device, model_name: str) -> Device`
    - `model_name`을 모델명으로 하는 `Device`의 객체를 생성하고, `head` 노드로부터 연결된 리스트의 첫 번째 노드로 삽입하고, 삽입한 노드를 반환한다.
    - `head`가 `None`인 경우, 객체를 생성한 후 반환한다.
  - `add_node_last(head: Device, model_name: str) -> Device`
    - `model_name`을 모델명으로 하는 `Device`의 객체를 생성하고, `head` 노드로부터 연결된 리스트의 가장 마지막에 삽입하고 `head` 노드를 반환한다.
    - `head`가 `None`인 경우, 객체를 생성한 후 반환한다.
  - `add_node(head: Device, model_before: str, model_name: str) -> Device`
    - `model_name`을 모델명으로 하는 `Device`의 객체를 생성하고, `head` 노드로부터 연결된 리스트에서 모델명이 `model_before`인 노드의 다음에 삽입하고 `head`를 반환한다.
    - 리스트에 `model_before`에 해당하는 모델이 둘 이상 있는 경우, 첫 번째 노드의 다음에 삽입한다.
    - `head`가 `None`이거나 리스트에 `model_before`에 해당하는 모델이 없는 경우, `add_node_last`와 동일하게 동작한다.
  - `remove_first(head: Device) -> Device`
    - `head` 노드로부터 연결된 리스트의 첫 번째 노드를 삭제하고, 새로운 첫 번째 노드를 반환한다.
    - 노드를 삭제할 수 없거나, 삭제 후 연결된 리스트가 빈 리스트인 경우 `None`을 반환한다.
  - `remove_last(head: Device) -> Device`
    - `head` 노드로부터 연결된 리스트의 마지막 노드를 삭제하고, 첫 번째 노드를 반환한다.
    - 노드를 삭제할 수 없거나, 삭제 후 연결된 리스트가 빈 리스트인 경우 `None`을 반환한다.
  - `remove_models(head: Device, model_name: str) -> Device`
    - `head` 노드로부터 연결된 리스트에서 모델명이 `model_name`인 모든 노드를 삭제하고, 첫 번째 노드를 반환한다.
    - `head`가 `None`이거나 삭제 후 연결된 리스트가 빈 리스트인 경우 `None`을 반환한다.
  - `node_at(head: Device, location: int) -> Device`
    - `head` 노드로부터 연결된 리스트에서 `location` 번째 노드를 반환한다.
    - `location`이 `0`이면 `head` 노드를, `1`이면 그 다음 노드를 의미한다.
    - `head`가 `None`이거나, 지정한 숫자가 리스트의 범위를 벗어나는 경우 `None`을 반환한다.
  - `nodes_in_list(head: Device) -> str`
    - `head` 노드로부터 연결된 리스트에서 순서대로 모델명을 이어붙인 문자열을 반환한다. 예를 들어 리스트에 연결된 모델명의 순서가 ‘A1’, ‘A2’, ‘A3’인 경우 `A1A2A3`을 반환한다.
    - `head`가 `None`인 경우 빈 문자열을 반환한다.
  - `reverse(head: Device) -> Device`
    - `head` 노드로부터 연결된 리스트에 대해서, 역순의 연결된 리스트를 생성하고 새로 생성된 리스트의 첫 번째 노드를 반환한다. 이 때, 원래 `head` 노드로부터 연결된 리스트도 변함없이 유효한 리스트를 유지해야 한다.
    - `head`가 None인 경우 `None`을 반환한다.
  - `before_node(after_node: Device) -> Device`
    - 주어진 `after_node`의 이전 노드를 반환한다. 이 함수의 시간 복잡도는 $\mathcal O (1)$이어야 한다.
    - 만약 `after_node`가 None이거나 이전 노드가 없는 경우 None을 반환한다.
  - `remove_node(target: Device) -> bool, Device`
    - 리스트에서 target 노드를 삭제한다.
    - 첫 번째 반환값은 노드 삭제의 성공, 실패 여부와 무관하게 이 노드가 포함된 연결된 리스트의 첫 번째 항목이 변경되었는지의 여부를 반환한다. 삭제 후 리스트가 빈 리스트가 되었거나 첫 번째 항목이 변경되는 경우 True를 반환한다.
    - 첫 번째 반환값이 True인 경우, 두 번째 반환값은 새로운 첫 번째 항목의 노드를 반환한다. (빈 리스트가 된 경우 None)
    - 첫 번째 반환값이 False인 경우, 두 번째 반환값은 None이다.
    - 이 함수의 시간 복잡도는 $\mathcal O (1)$이어야 한다.
- 이렇게 구현한 클래스와 함수에 대해서 다음 코드를 추가하고 실행한 결과를 출력한다.

```python


import hashlib

def hash4(input: str) -> str:
    return hashlib.md5(input.encode()).hexdigest()[:4]

def main():
    result = []
    head = add_node_last(None, 'A1')
    head = add_node_last(head, 'A2')
    head = add_node_last(head, 'A3')
    head = add_node_last(head, 'A4')
    head = add_node_last(head, 'A3')
    head = add_node_first(head, 'A6')
    head = add_node_last(head, 'A7')
    head = add_node(head, 'A3', 'A8')
    result.append(nodes_in_list(head))
    result.append(nodes_in_list(reverse(head)))
    head = add_node_last(None, 'Z1')
    _, head = remove_node(head)
    result.append(nodes_in_list(head))
    head = add_node_last(None, 'Z1')
    head = add_node_last(head, 'Z2')
    head = add_node_last(head, 'Z3')
    head = add_node_last(head, 'Z4')
    _, head = remove_node(head)
    result.append(nodes_in_list(head))
    head = add_node_last(None, 'Z1')
    head = add_node_last(head, 'Z2')
    head = add_node_last(head, 'Z3')
    head = add_node_last(head, 'Z4')
    will_remove_node = node_at(head, 2)
    remove_node(will_remove_node)
    result.append(nodes_in_list(head))
    will_remove_node = node_at(head, 2)
    remove_node(will_remove_node)
    result.append(nodes_in_list(head))
    head = add_node_last(None, 'B1')
    head = add_node_last(head, 'B2')
    head = add_node_last(head, 'B3')
    head = add_node_last(head, 'B4')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'B5')
    head = add_node_last(head, 'B6')
    head = add_node_first(head, 'BR')
    head = add_node_first(head, 'BR')
    head = add_node_first(head, 'BR')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'BR')
    head = remove_models(head, 'BR')
    result.append(nodes_in_list(head))
    result.append(nodes_in_list(reverse(head)))
    head = add_node_last(None, 'C1')
    head = remove_first(head)
    head = add_node_first(head, 'C2')
    head = remove_last(head)
    head = add_node_first(head, 'C3')
    head = add_node_first(head, 'C4')
    head = remove_first(head)
    head = add_node_first(head, 'C5')
    head = add_node_first(head, 'C6')
    head = remove_last(head)
    head = add_node_first(head, 'C7')
    head = add_node_first(head, 'C8')
    node = node_at(head, 2)
    result.append(nodes_in_list(node))
    result.append(nodes_in_list(reverse(node)))
    head = None
    for i in range(10000):
        model_name = 'D' + str(i % 987)
        head = add_node_first(head, model_name)
    head = add_node_last(node_at(head, 5), 'DN')
    result.append(nodes_in_list(reverse(head)))
    result.append(nodes_in_list(head))
    head = remove_models(head, 'D0')
    result.append(nodes_in_list(reverse(head)))
    result.append(nodes_in_list(head))
    new_head = before_node(node_at(head, 99))
    result.append(nodes_in_list(reverse(new_head)))

    for result in result:
        print(hash4(result), result[:20])

if __name__ == '__main__':
    main()


```

## 결과예시

```
aebc A6A1A2A3A8A4A3A7
5447 A7A3A4A8A3A2A1A6
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 주어진 노드를 포함하는 이중으로 연결된 리스트 전체의 역순 리스트를 생성하고, 이 리스트의 첫 번째 노드를 반환하는 `reverse_all(node: Device) -> Device` 함수를 구현한다. 이 함수는 다음과 같은 조건을 만족해야 한다.
  - 이 노드가 포함된 전체 리스트의 역순 리스트를 생성한다. 예를 들어 어떤 리스트가 node1 -> node2 -> node3일 때 reverse(node2)는 node3 -> node2의 리스트를 생성해 반환하지만, reverse_all은 node3 -> node2 -> node1의 리스트를 생성해 반환한다.
  - 이 과정에서 원래의 리스트는 그 구조가 유지되어야 한다.
  - 이 과정에서 원래 리스트의 각 노드는 단 1번만 방문한다.
- 모델명이 M1, M2, M3, M4, M5인 노드가 순서대로 연결된 이중으로 연결된 리스트를 만든다. 이 리스트의 세 번째 노드(모델명 M3) node3에 대해서 nodes_in_list(reverse_all(node3))와 nodes_in_list(head)의 반환값을 출력하라. (head는 처음에 생성한 이중으로 연결된 리스트의 첫 번째 노드이다.)

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - datastructure/device_new_list.py 파일에 구현이 되어 있는지 확인한다.
  - 이전 노드를 찾는 함수와 노드를 삭제하는 함수의 시간 복잡도가 상수 시간 복잡도로 구현되어 있는지를 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    aebc A6A1A2A3A8A4A3A7
    5447 A7A3A4A8A3A2A1A6
    d41d
    63c1 Z2Z3Z4
    5589 Z1Z2Z4
    b681 Z1Z2
    1b8d B1B2B3B4B5B6
    70c2 B6B5B4B3B2B1
    d895 C6C5
    0c53 C5C6
    e537 DND0D1D2D3D4D5D6D7D8
    40f9 D124D123D122D121D120
    b1e5 DND1D2D3D4D5D6D7D8D9
    1589 D124D123D122D121D120
    bfe3 DND1D2D3D4D5D6D7D8D9
    ```

### [보너스과제 확인]

- 지시한대로 보너스 과제를 해결하였는가?
  - 원래의 리스트의 구조를 유지하면서 리스트 전체의 역순의 리스트를 생성하는지 확인한다.
  - 이 과정에서 원래의 리스트의 각 노드를 한 번씩만 방문하는지 확인한다.
  - 결과는 다음과 같다.
  ```
  M5M4M3M2M1
  M1M2M3M4M5
  ```

### [문제에 대한 이해]

- 이중으로 연결된 리스트의 구조를 설명하라.
  - 이중으로 연결된 리스트는 각 노드의 다음 노드 뿐 아니라 이전 노드에 대한 참조를 각 노드가 갖는다.
- 이중으로 연결된 리스트에서 리스트의 처음과 끝이 아닌 위치에 노드를 삽입하는 과정을 설명하라.
  - 삽입하는 순서가 잘못되어 리스트의 노드 간 연결이 훼손되지 않도록 노드를 삽입할 수 있는지 확인한다.
- 이중으로 연결된 리스트에서 리스트의 처음과 끝이 아닌 노드를 제거하는 과정을 설명하라.
  - 삭제하는 순서가 잘못되어 리스트의 노드 간 연결이 훼손되지 않도록 노드를 삭제할 수 있는지 확인한다.
- 이전 노드를 빠르게 찾을 수 있다는 점 이외에 원래의 연결된 리스트에 비해서 이중으로 연결된 리스트의 장점을 제시하라.
  - 중간 노드로부터 모든 노드를 찾을 수 있어 시작 노드가 주어지지 않더라도 전체 연결된 리스트의 노드를 사용하는 함수를 실행할 수 있다.

### [코드 예시]

```python

class Device:
    def __init__(self, model_name):
        self.model_name = model_name
        self.next = None
        self.before = None

def add_node_first(head: Device, model_name: str) -> Device:
    new_node = Device(model_name)
    if head == None:
        return new_node
    head.before = new_node
    new_node.next = head
    return new_node



def add_node_last(head: Device, model_name: str) -> Device:
    new_node = Device(model_name)
    if head == None:
        return new_node
    cur = head
    while True:
        if cur.next == None:
            cur.next = new_node
            new_node.before = cur
            break
        cur = cur.next
    return head

def add_node(head: Device, model_before: str, model_name: str) -> Device:
    new_node = Device(model_name)
    if head == None:
        return new_node
    cur = head
    while True:
        if cur.model_name == model_before:
            new_node.next = cur.next
            new_node.before = cur
            cur.next = new_node
            if new_node.next != None:
                new_node.next.before = new_node
            break
        if cur.next == None:
            cur.next = new_node
            new_node.before = cur
            break
        cur = cur.next
    return head

def remove_first(head: Device) -> Device:
    if head == None:
        return None
    if head.next == None:
        return None
    head.next.before = None
    return head.next


def remove_last(head: Device) -> Device:
    if head == None:
        return None
    if head.next == None:
        return None
    cur = head
    while True:
        if cur.next.next == None:
            cur.next = None
            break
        cur = cur.next
    return head

def remove_models(head: Device, model_name: str) -> Device:
    if head == None:
        return None
    while head.model_name == model_name:
        head = head.next
        if head == None:
            return None
    cur = head
    while True:
        if cur.next == None:
            break
        if cur.next.model_name == model_name:
            cur.next = cur.next.next
            if cur.next != None:
                cur.next.before = cur
            continue
        cur = cur.next
    return head

def node_at(head: Device, location: int) -> Device:
    if head == None:
        return None
    if location == 0:
        return head
    cur = head
    for _ in range(location):
        if cur.next == None:
            return None
        cur = cur.next
    return cur

def nodes_in_list(head: Device) -> str:
    result = ''
    cur = head
    while cur != None:
        result += cur.model_name
        cur = cur.next
    return result

def reverse(head: Device) -> Device:
    if head == None:
        return None
    if head.next == None:
        return Device(head.model_name)
    reverse_head = None
    while head != None:
        reverse_head = add_node_first(reverse_head, head.model_name)
        head = head.next
    return reverse_head

def before_node(after_node: Device) -> Device:
    if after_node == None:
        return None
    return after_node.before

def remove_node(target: Device) -> (bool, Device):
    if target == None:
        return False, None
    if target.before == None:
        if target.next == None:
            return True, None
        target.next.before = None
        return True, target.next
    if target.next == None:
        target.before.next = None
        return False, None
    target.before.next = target.next
    target.next.before = target.before
    return False, None

def reverse_all(node: Device) -> Device:
    head = Device(node.model_name)
    cur = node.next
    while cur != None:
        head = add_node_first(head, cur.model_name)
        cur = cur.next
    cur = node.before
    while cur != None:
        head = add_node_last(head, cur.model_name)
        cur = cur.before
    return head

import hashlib

def hash4(input: str) -> str:
    return hashlib.md5(input.encode()).hexdigest()[:4]



def main():
    result = []
    head = add_node_last(None, 'A1')
    head = add_node_last(head, 'A2')
    head = add_node_last(head, 'A3')
    head = add_node_last(head, 'A4')
    head = add_node_last(head, 'A3')
    head = add_node_first(head, 'A6')
    head = add_node_last(head, 'A7')
    head = add_node(head, 'A3', 'A8')
    result.append(nodes_in_list(head))
    result.append(nodes_in_list(reverse(head)))
    head = add_node_last(None, 'Z1')
    _, head = remove_node(head)
    result.append(nodes_in_list(head))
    head = add_node_last(None, 'Z1')
    head = add_node_last(head, 'Z2')
    head = add_node_last(head, 'Z3')
    head = add_node_last(head, 'Z4')
    _, head = remove_node(head)
    result.append(nodes_in_list(head))
    head = add_node_last(None, 'Z1')
    head = add_node_last(head, 'Z2')
    head = add_node_last(head, 'Z3')
    head = add_node_last(head, 'Z4')
    will_remove_node = node_at(head, 2)
    remove_node(will_remove_node)
    result.append(nodes_in_list(head))
    will_remove_node = node_at(head, 2)
    remove_node(will_remove_node)
    result.append(nodes_in_list(head))
    head = add_node_last(None, 'B1')
    head = add_node_last(head, 'B2')
    head = add_node_last(head, 'B3')
    head = add_node_last(head, 'B4')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'B5')
    head = add_node_last(head, 'B6')
    head = add_node_first(head, 'BR')
    head = add_node_first(head, 'BR')
    head = add_node_first(head, 'BR')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'BR')
    head = add_node_last(head, 'BR')
    head = remove_models(head, 'BR')
    result.append(nodes_in_list(head))
    result.append(nodes_in_list(reverse(head)))
    head = add_node_last(None, 'C1')
    head = remove_first(head)
    head = add_node_first(head, 'C2')
    head = remove_last(head)
    head = add_node_first(head, 'C3')
    head = add_node_first(head, 'C4')
    head = remove_first(head)
    head = add_node_first(head, 'C5')
    head = add_node_first(head, 'C6')
    head = remove_last(head)
    head = add_node_first(head, 'C7')
    head = add_node_first(head, 'C8')
    node = node_at(head, 2)
    result.append(nodes_in_list(node))
    result.append(nodes_in_list(reverse(node)))
    head = None
    for i in range(10000):
        model_name = 'D' + str(i % 987)
        head = add_node_first(head, model_name)
    head = add_node_last(node_at(head, 5), 'DN')
    result.append(nodes_in_list(reverse(head)))
    result.append(nodes_in_list(head))
    head = remove_models(head, 'D0')
    result.append(nodes_in_list(reverse(head)))
    result.append(nodes_in_list(head))
    new_head = before_node(node_at(head, 99))
    result.append(nodes_in_list(reverse(new_head)))

    for result in result:
        print(hash4(result), result[:20])

    head = add_node_last(None, 'M1')
    head = add_node_last(head, 'M2')
    head = add_node_last(head, 'M3')
    head = add_node_last(head, 'M4')
    head = add_node_last(head, 'M5')
    node3 = node_at(head, 2)
    print(nodes_in_list(reverse_all(node3)))
    print(nodes_in_list(head))

if __name__ == '__main__':
    main()
```

---

# 문제 11. 계통도를 만드는 방법

## 문제 분류

- 중요도 : 4/5
- 난이도 : 4/5
- 목표 수행 시간 : 4시간

## 스토리

생물의 진화를 연구하는 E 연구원은 진화 과정에서 구성되는 진화적 조상과 진화적 자손의 관계를 체계적으로 관리하기 위해서 데이터베이스를 구성하는 작업을 하고 있다. 생물 A가 생물 B로 진화한 경우 생물 A를 진화적 부모, 생물 B를 진화적 자식이라고 할 때, 일반적으로 하나의 진화적 부모로부터 여러 진화적 자식이 발생하며, 하나의 진화적 자식은 단 하나의 진화적 부모를 가지고 있다. 또한 자식, 자식의 자식, 그리고 그 자식 등 진화로 관계가 맺어지는 모든 생물은 단 하나의 근본적 부모를 공유하고 있다.

일반적으로 데이터를 체계화해서 관리하는 관계형 데이터베이스의 경우는 이러한 형태의 관계를 관리하기에 적합하지 않으므로, 닥터 E는 이를 위한 적당한 자료 구조를 찾아보고 있었다. 다른 연구원들과 마찬가지로 E 연구원 역시 프로그래밍 지원 게시판에 도움을 청했다.

## 수행목표

- 진화적 부모와 자식의 관계, 그리고 이 관계가 중첩되는 하나의 진화 계통도를 표현할 수 있는 자료구조를 구현한다. 이 자료구조는 다음과 같은 특성 및 기능을 제공해야 한다.
  > - 계통도 자료구조의 특징
  >   - 하나의 부모는 0개 이상의 자식을 가질 수 있다.
  >   - 자식은 반드시 단 하나의 부모를 가진다. 단 진화의 계통에서 최상위에 위치한 생물은 부모를 가지지 않는다.
  >   - 계통도에 등록된 생물은 고유한 이름을 가진다.
  > - 이 계통도가 제공하는 기능
  >   - 부모의 이름과 자식의 이름을 사용해 계통도에 생물을 추가하는 기능
  >   - 이 계통도에서 주어진 이름에 해당하는 노드를 반환하는 기능
  >   - 이 계통도에서 최상위 조상과 진화 단계가 가장 먼 자손 사이의 단계를 반환 (부모와 자식 사이의 단계를 1로 한다.)
  >   - 이 계통도에서 최상위 조상과 진화 단계가 가장 먼 자손의 이름을 반환
  >   - 이 계통도에 특정한 이름의 생물이 포함되어 있는지를 확인하는 기능
- 다음 그림의 계통도를 가지는 4개의 트리를 생성한다. 아래 계통도는 모두 최초의 조상은 A0이다.
  - 계통도 1
    ![](2_9_1.png)
  - 계통도 2
    ![](2_9_2.png)
  - 계통도 3
    ![](2_9_3.png)
  - 계통도 4
    ![](2_9_4.png)
- 생성한 트리 자료구조에서 다음의 값을 구현한 함수를 사용해 트리 별로 출력한다.
  - 트리의 높이
  - 최상위 조상으로부터 진화의 단계가 가장 먼 자손(들)의 이름
  - 최상위 조상의 자식 중 가장 진화 단계가 긴 자손을 가진 자식(들)의 이름
  - 계통도 내의 모든 생물(들)의 이름
  - 각 계통도에 'A12'이라는 이름의 자손이 존재하는지의 여부
  - 각 계통도에서 'A5'라는 이름의 생물종을 루트로 하는 서브트리의 높이

## 수행단계

- 트리 자료구조에 대해서 조사한다.
- datastructure/evolution_tree.py 파일에 계통도 상에서 하나의 생물종을 표현하는 노드 객체를 생성하는데 사용하는 파이썬 클래스 Species를 구현한다.
  - 각 생물의 이름을 저장하는 변수를 갖는다.
  - 노드의 자식 노드를 참조하는 변수를 갖는다.
- 같은 파일에 파이썬 클래스 Species로 생성한 객체들을 연결해 계통도로 동작하도록 다음과 같은 함수를 구현한다.

  - add_child(species_name: str, parent: Species) -> Species
    - 계통도에 species_name을 이름으로 하는 생물종을 추가한다. 추가하는 생물종은 parent 노드의 자식이 된다.
    - 만약 parent가 None인 경우, 새로운 트리를 생성한다.
    - 반환값은 추가된 노드이다.
    - 각 생물종은 고유한 이름을 가진다는 조건이 있지만, 자식을 추가할 때 이름의 중복 여부는 확인하지 않는다.
  - node_with_name(species_name: str, node: Species) -> Species

    - 계통도의 최상위 노드 node를 파라미터로 받아 계통도에 주어진 이름을 가진 노드를 반환한다.
    - 해당 이름의 노드가 없다면 None을 반환한다.
    - 주어진 노드는 계통도 트리의 가장 최상위 노드일 수도, 그렇지 않을 수도 있다. 최상위 노드가 아닌 경우, 조상 노드는 고려하지 않고 주어진 노드를 최상위 노드로 하는 트리에 대해서 동작한다.

  - level_of_children(node: Species) -> int

    - 주어진 노드의 자손 중, 거리가 가장 먼 자손 까지의 거리를 계산해 반환한다.
    - 부모와 자식 사이의 거리는 1이며, 자식 노드가 없는 경우는 0을 반환한다.
    - node가 None인 경우 None을 반환한다.

  - decendant_all(node: Species) -> list[str]

    - 주어진 노드의 모든 자손 생물종(직접 진화한 자식 뿐 아니라, 그 이하로 진화한 모든 생물종)의 이름을 사전순으로 정렬된 리스트로 반환한다.

  - farthest_children_name(node: Species) -> list[str]

    - 주어진 노드의 자손 중, 거리가 가장 먼 자손의 이름의 리스트를 반환한다.
    - 반환하는 리스트의 길이는 1 이상이다. 자식이 없는 경우에는 거리가 0인 노드의 이름, 즉 자신의 이름을 가진 리스트를 반환하며, 같은 거리의 자식이 여럿 존재하면 2 이상의 값을 가진다.
    - node가 None인 경우 None을 반환한다.

  - is_descendant(species_name: str, node: Species) -> bool

    - 주어진 노드 node의 자손 중에 species_name을 이름으로 하는 생물이 존재하면 True, 그렇지 않다면 False를 반환한다.
    - 노드의 수가 n일 때, 이 함수의 시간 복잡도는 O(n) 미만이어야 한다.

  - 문제에서 주어진 4개의 그림을 진화 계통도라고 할 때, 진화 계통도의 트리를 생성한다.

    - 네 개의 트리 모두 최상위 조상의 이름은 A0이다.
    - 조금 이상하게 보일 수 있지만, 분명히 조상의 이름이 A0인 트리의 그림들이다.

  - 문제에서 요구한 답을 구현한 함수의 반환 결과만을 사용해 구해서 출력한다.
    - 여러 생물의 이름을 출력할 때 순서는 고려하지 않는다.

## 결과예시

```
계통도 1
    트리의 높이 : 5
    최상위 조상으로부터 진화의 단계가 가장 먼 자손(들)의 이름 : A15, A16
    최상위 조상의 자식 중 가장 진화 단계가 긴 자손을 가진 자식(들)의 이름 : A1
    계통도 내 모든 생물(들)의 이름 : A0, A1, A4, A10, A11, A5, A12, A14, A15, A16, A6, A2, A7, A3, A8, A9, A13
    A12는 계통도 내에 있습니다.
    A5 생물종을 루트로 하는 서브트리의 높이 : 3
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - datastructure/evolution_tree.py 파일에 구현이 되어 있는지 확인한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 하나의 부모가 0개 이상 제한없는 수의 자식 노드를 가질 수 있는 구조로 구현하였는지 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

```
계통도 1
    트리의 높이 : 5
    최상위 조상으로부터 진화의 단계가 가장 먼 자손(들)의 이름 : A15, A16
    최상위 조상의 자식 중 가장 진화 단계가 긴 자손을 가진 자식(들)의 이름 : A1
    계통도 내 모든 생물(들)의 이름 : A0, A1, A4, A10, A11, A5, A12, A14, A15, A16, A6, A2, A7, A3, A8, A9, A13
    A12는 계통도 내에 있습니다.
    A5 생물종을 루트로 하는 서브트리의 높이 : 3
계통도 2
    트리의 높이 : 5
    최상위 조상으로부터 진화의 단계가 가장 먼 자손(들)의 이름 : A9, A10
    최상위 조상의 자식 중 가장 진화 단계가 긴 자손을 가진 자식(들)의 이름 : A2
    계통도 내 모든 생물(들)의 이름 : A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10
    A12는 계통도 내에 없습니다.
    A5 생물종을 루트로 하는 서브트리의 높이 : 0
계통도 3
    트리의 높이 : 1
    최상위 조상으로부터 진화의 단계가 가장 먼 자손(들)의 이름 : A1, A2, A3, A4, A5, A6, A7, A8, A9
    최상위 조상의 자식 중 가장 진화 단계가 긴 자손을 가진 자식(들)의 이름 : A1, A2, A3, A4, A5, A6, A7, A8, A9
    계통도 내 모든 생물(들)의 이름 : A0, A1, A2, A3, A4, A5, A6, A7, A8, A9
    A12는 계통도 내에 없습니다.
    A5 생물종을 루트로 하는 서브트리의 높이 : 0
계통도 4
    트리의 높이 : 9
    최상위 조상으로부터 진화의 단계가 가장 먼 자손(들)의 이름 : A9
    최상위 조상의 자식 중 가장 진화 단계가 긴 자손을 가진 자식(들)의 이름 : A1
    계통도 내 모든 생물(들)의 이름 : A0, A1, A2, A3, A4, A5, A6, A7, A8, A9
    A12는 계통도 내에 없습니다.
    A5 생물종을 루트로 하는 서브트리의 높이 : 4
```

### [문제에 대한 이해]

- 트리 자료구조에 대해서 설명하라.
- 트리 자료구조를 구현하기 위해서 부모 노드와 자식 노드 간의 참조 구조를 어떻게 구현하였는가?

### [코드 예시]

```python
class Species:
    def __init__(self, name):
        self.name = name
        self.children = []

def add_child(species_name: str, parent: Species) -> Species:
    new_species = Species(species_name)
    if parent != None:
        parent.children.append(new_species)
    return new_species

def node_with_name(species_name: str, node: Species) -> Species:
    if node == None:
        return None
    if node.name == species_name:
        return node
    for child in node.children:
        result = node_with_name(species_name, child)
        if result != None:
            return result
    return None

def level_of_children(node: Species) -> int:
    if node == None:
        return None
    if len(node.children) == 0:
        return 0
    level_of_direct_children = []
    for child in node.children:
        level_of_direct_children.append(level_of_children(child))
    return max(level_of_direct_children) + 1

def descendant_all(node: Species) -> list[str]:
    if node == None:
        return []
    result = [node.name]
    for child in node.children:
        result += descendant_all(child)
    return result

def farthest_children_name_and_level(node: Species) -> (list[str], int):
    if node == None:
        return None, None
    result = [node.name]
    max_level = 0
    for child in node.children:
        child_names, child_level = farthest_children_name_and_level(child)
        if child_level > max_level:
            max_level = child_level
            result = child_names
        elif child_level == max_level:
            result += child_names
    return result, max_level + 1

def farthest_children_name(node: Species) -> list[str]:
    return farthest_children_name_and_level(node)[0]

def is_descendant(species_name: str, node: Species) -> bool:
    if node == None:
        return False
    if node.name == species_name:
        return True
    for child in node.children:
        if is_descendant(species_name, child):
            return True
    return False

def main():
    root1 = add_child('A0', None)
    add_child('A1', root1)
    add_child('A2', root1)
    add_child('A3', root1)
    add_child('A4', root1.children[0])
    add_child('A5', root1.children[0])
    add_child('A6', root1.children[0])
    add_child('A7', root1.children[1])
    add_child('A8', root1.children[2])
    add_child('A9', root1.children[2])
    add_child('A10', root1.children[0].children[0])
    add_child('A11', root1.children[0].children[0])
    add_child('A12', root1.children[0].children[1])
    add_child('A13', root1.children[2].children[1])
    add_child('A14', root1.children[0].children[1].children[0])
    add_child('A15', root1.children[0].children[1].children[0].children[0])
    add_child('A16', root1.children[0].children[1].children[0].children[0])

    root2 = add_child('A0', None)
    add_child('A1', root2)
    add_child('A2', root2)
    add_child('A3', root2.children[1])
    add_child('A4', root2.children[1])
    add_child('A5', root2.children[1].children[1])
    add_child('A6', root2.children[1].children[1])
    add_child('A7', root2.children[1].children[1].children[1])
    add_child('A8', root2.children[1].children[1].children[1])
    add_child('A9', root2.children[1].children[1].children[1].children[1])
    add_child('A10', root2.children[1].children[1].children[1].children[1])

    root3 = add_child('A0', None)
    add_child('A1', root3)
    add_child('A2', root3)
    add_child('A3', root3)
    add_child('A4', root3)
    add_child('A5', root3)
    add_child('A6', root3)
    add_child('A7', root3)
    add_child('A8', root3)
    add_child('A9', root3)

    root4 = add_child('A0', None)
    add_child('A1', root4)
    add_child('A2', root4.children[0])
    add_child('A3', root4.children[0].children[0])
    add_child('A4', root4.children[0].children[0].children[0])
    add_child('A5', root4.children[0].children[0].children[0].children[0])
    add_child('A6', root4.children[0].children[0].children[0].children[0].children[0])
    add_child('A7', root4.children[0].children[0].children[0].children[0].children[0].children[0])
    add_child('A8', root4.children[0].children[0].children[0].children[0].children[0].children[0].children[0])
    add_child('A9', root4.children[0].children[0].children[0].children[0].children[0].children[0].children[0].children[0])



    testcases = [root1, root2, root3, root4]

    for i, tc in enumerate(testcases):
        print(f"계통도 {i + 1}")
        print(f"    트리의 높이 : {level_of_children(tc)}")
        print(f"    최상위 조상으로부터 진화의 단계가 가장 먼 자손(들)의 이름 : {', '.join(farthest_children_name(tc))}")
        max_height_child_name = []
        max_height = -1
        for child in tc.children:
            height_of_child = level_of_children(child)
            if height_of_child > max_height:
                max_height = height_of_child
                max_height_child_name = [child.name]
            elif height_of_child == max_height:
                max_height_child_name.append(child.name)
        max_height_child_name_str = ', '.join(max_height_child_name)
        if max_height == -1:
            print(f"    최상위 조상의 자식이 없습니다.")
        else:
            print(f"    최상위 조상의 자식 중 가장 진화 단계가 긴 자손을 가진 자식(들)의 이름 : {max_height_child_name_str}")
        decendant_names = ', '.join(descendant_all(tc))
        print(f"    계통도 내 모든 생물(들)의 이름 : {decendant_names}")
        has_decentent_A12 = is_descendant('A12', tc)
        if has_decentent_A12:
            print(f"    A12는 계통도 내에 있습니다.")
        else:
            print(f"    A12는 계통도 내에 없습니다.")
        node_A5 = node_with_name('A5', tc)
        print(f"    A5 생물종을 루트로 하는 서브트리의 높이 : {level_of_children(node_A5)}")

if __name__ == '__main__':
    main()
```

---

# 문제 12. 뿌리를 찾아주마

## 문제 분류

- 중요도 : 4/5
- 난이도 : 4/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 E는 성공적으로 계통도를 트리로 만들고, 이를 체계화된 데이터로 관리할 수 있게 되었다. 매우 복잡한 계통도에서 어떤 노드를 선택하면, 그 노드의 진화적 자손의 목록을 쉽고 빠르게 찾을 수 있었다. 닥터 E의 보스가 그 결과를 보더니 매우 흡족해하면서 물었다.
"물론 조상의 목록도 제공되는거지?"

## 수행목표

- 이진 트리 형태로 진화 계통도가 주어졌을 때, 계통도에 포함된 특정 노드의 모든 조상의 목록을 반환하는 함수를 구현한다. 반환하는 모든 조상의 목록은 가장 거리가 먼 조상부터 차례대로 정렬되어 있어야 한다.
- 다음 첨부파일에 포함된 10개의 트리에 대해서 각 트리에서 가장 먼저 제시되는 노드의 모든 조상의 목록을 출력한다.

## 수행단계

- 트리의 형태 중 특별한 구조를 가지고 있으며, 그 구조 덕분에 매우 유용하게 사용되는 여러 종류의 트리 구조가 있다. 그 중 가장 대표적인 구조인 이진 트리(Binary tree)에 대해서 조사해보자.
- 다음 기능을 하는 프로그램을 datastructure/evolution_binarytree.py 파일에 구현한다.
  - 이전 문제에서 단 하나의 진화적 부모는 최대 2개 까지의 진화적 자식을 가질 수 있다는 조건을 더해 이진 트리의 형태로 계통도 트리를 구현한다.
  - 부모 노드가 왼쪽 자식 노드, 오른쪽 자식 노드를 참조할 수 있는 형태로 트리의 노드를 구성하는 객체의 파이썬 클래스를 구현한다.
  - add_child(species_name: str, parent: Species, is_left_child: bool) -> Species 함수를 구현한다.
    - 이진 트리에 species_name 이름의 객체를 생성하고 추가한다.
    - 추가하는 위치는 parent 노드의 왼쪽(is_left_child가 True인 경우) 또는 오른쪽(is_left_child가 False인 경우) 자식으로 한다.
    - 추가하려는 위치에 다른 자식 노드가 있는 경우는 추가하지 않고 None을 반환한다.
    - parent가 None인 경우, is_left_child의 값은 무시하고 새로운 트리를 생성한다.
    - 추가한 노드를 반환한다.
  - ancestor_list(node: Species, root: Species) -> list[str] 함수를 구현한다.
    - 이 함수는 주어진 루트 노드 root의 계통도에서 주어진 노드의 조상 노드(들)의 리스트를 반환한다.
    - 리스트의 항목의 순서는 주어진 노드로부터 먼 노드부터 차례로 이루어진다.
- 첨부한 파일은 10개의 트리를 포함하고 있으며, 각각의 트리는 다음과 같이 파일 내에서 표현된다.
  - 각 트리는 testcase 번호 줄로 시작한다.
  - 각 줄이 하나의 노드이며, 노드의 위치와 이름으로 구성되어 있다. 위치에서 O은 최상위 노드를 의미하며, l은 왼쪽 자식 노드, r은 오른쪽 자식 노드를 의미한다. 예시는 다음과 같다.
    - O : 루트 노드
    - Ol : 루트의 왼쪽 자식 노드
    - Orlr : 루트의 오른쪽 자식 노드의 왼쪽 자식 노드의 오른쪽 자식 노드
  - 트리에 포함된 각 노드의 순서는 무작위로 섞여서 제공된다. 생성된 트리에는 주어진 노드가 모두 포함되어야 한다.
- 첨부한 파일로 생성한 10개의 트리에 대해서 첨부 파일의 첫 번째 노드에 대해서 ancestor_list 함수의 결과를 구한 후, 이 결과로 생성한 트리의 루트 노드를 파라미터로 다음 함수의 결과를 출력한다.

  ```python
  # root가 제공된 데이터에서 생성된 트리의 루트이고, ancestor_list : ancestor_list 함수가 반환한 조상들의 목록일 때
  # hash4s_from_tree_and_list(ancestor_list, root)의 결과를 출력한다.

  import hashlib
  def hash4s_from_tree_and_list(arr, root):
      tree_string = tree_to_string(root)
      return hashlib.sha256(str(arr).encode()).hexdigest()[:4] + hashlib.sha256(tree_string.encode()).hexdigest()[:4]

  def tree_to_string(node: Species) -> list[str]:
      if node == None:
          return []
      result = node.name
      if node.left == None:
          result += '_l_'
      else:
          result += tree_to_string(node.left)
      if node.right == None:
          result += '_r_'
      else:
          result += tree_to_string(node.right)
      return result

  ```

## 결과예시

```
Testcase 1
    출력결과 : 39fa

Testcase 2
    출력결과 : 16bf
(이하 생략)
```

## 참고사항

- 간이 해시값으로 바꾸기 전의 Testcase 1의 원래 결과는 `['a0']`이다.
- 간이 해시값으로 바꾸기 전의 Testcase 4의 원래 결과는 `['a0', 'b0', 'c0']`이다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - datastructure/evolution_binarytree.py 파일에 구현이 되어 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    Testcase 1
        출력결과 : 39fa

    Testcase 2
        출력결과 : 16bf

    Testcase 3
        출력결과 : 4f53

    Testcase 4
        출력결과 : 9b7f

    Testcase 5
        출력결과 : d495

    Testcase 6
        출력결과 : d0cf

    Testcase 7
        출력결과 : f915

    Testcase 8
        출력결과 : e8ce

    Testcase 9
        출력결과 : f103

    Testcase 10
        출력결과 : e3e3
    ```

### [문제에 대한 이해]

- 이진 트리는 무엇인지 설명하라.
- 구현한 모든 조상의 목록을 찾는 함수의 시간 복잡도는 얼마인지 설명해보라.
- 문제에서 제시한 트리의 노드는 부모 노드가 자식 노드의 참조를 가지고 있다. 여기에 더해서, 자식 노드도 부모 노드의 참조를 가지고 있다면, 모든 조상의 목록을 찾는 방법은 무엇이며 이 방법의 시간 복잡도는 어떻게 될까?
- 효율적인 구현을 위해서 부모에서 자식, 자식에서 부모 양방향의 참조를 모두 가지도록 구현할 때 트리에 노드를 추가하는 함수는 어떤 과정으로 동작하는지를 설명하라.
- 문제에서 주어진 트리 데이터는 트리 상의 노드의 순서를 무작위로 섞어서 제공하고 있다. 이 데이터를 사용해 트리를 만들 때 어떤 방법으로 트리를 만들었는가?
- 이 문제에서는 이진 트리의 각각의 노드의 위치를 O, l, r 세 글자를 조합해서 표현하고 있다. 이와 유사한 방식으로 이진 트리가 아닌 일반 트리의 각각의 노드의 위치를 표현하고자 한다면, 어떤 방식으로 표현할 수 있을까?

### [코드 예시]

```python
class Species:
    def __init__(self, name):
        self.name = name
        self.left = None
        self.right = None


def add_child(species_name: str, parent: Species, is_left: bool) -> Species:
    new_species = Species(species_name)
    if parent != None:
        if is_left:
            if parent.left != None:
                return None
            else:
                parent.left = new_species
        else:
            if parent.right != None:
                return None
            else:
                parent.right = new_species
    return new_species

def ancestor_list(node: Species, root: Species) -> list[str]:
    if node == None or root == None:
        return None
    if node == root:
        return []
    if root.left != None:
        result = ancestor_list(node, root.left)
        if result != None:
            return [root.name] + result
    if root.right != None:
        result = ancestor_list(node, root.right)
        if result != None:
            return [root.name] + result
    return None

def make_tree(nodes: list[(str, str)]):
    check_node_location = nodes[0][0]
    nodes.sort(key=lambda x: len(x[0]))

    root = add_child(nodes[0][1], None, True)
    check_node = None
    if check_node_location == 'O':
        check_node = root
    for i in range(1, len(nodes)):
        location = nodes[i][0]
        name = nodes[i][1]
        parent = root
        discovery_str = ''
        for j in range(1, len(location) - 1):
            if location[j] == 'l':
                parent = parent.left
                discovery_str += 'l'
            else:
                parent = parent.right
                discovery_str += 'r'

        if location[-1] == 'l':
            added_node = add_child(name, parent, True)

        else:
            added_node = add_child(name, parent, False)
        if location == check_node_location:
            check_node = added_node
    return root, check_node

import hashlib
def hash4_from_list(arr):
    return hashlib.sha256(str(arr).encode()).hexdigest()[:4]

def main():
    with open("tree_example.txt", "r") as f:
        lines = f.readlines()

    testcases = []
    testcase = []
    for line in lines:
        if line[:8] == 'Testcase':
            if testcase != []:
                testcases.append(testcase)
                testcase = []
        else:
            testcase.append(line.strip().split(','))
    testcases.append(testcase)

    for i, tc in enumerate(testcases):
        root, check_node = make_tree(tc)
        ancestor_nodes = ancestor_list(check_node, root)
        print(f"Testcase {i+1}")
        print(ancestor_nodes)
        print(f"    모든 조상들의 목록의 간이 해시값 : {hash4_from_list(ancestor_nodes)}")
        print()
```

# 문제 13. 바이러스의 네트워크

## 문제 분류

- 중요도 : 4/5
- 난이도 : 4/5
- 목표 수행 시간 : 4시간

## 스토리

바이러스는 매우 빠르게 돌연변이가 발생하는 것으로 알려져 있다. 바이러스를 연구하는 연구원 V와 생물의 진화를 연구하는 닥터 E는 이 과정을 공동으로 연구하고 있다. 그 결과 바이러스가 숙주에 들어가면 숙주가 가진 유전적 특성에 따라 돌연변이 프로세스가 정의된다는 사실을 알게 되었다.

두 연구원은 바이러스의 돌연변이 프로세스를 하나의 흐름도로 그려내고자 한다. 다양한 바이러스와 그 돌연변이를 일일이 손으로 그릴 수 없기 때문에 이를 위한 소프트웨어를 개발하기로 하였으며, 우선 이 흐름도를 컴퓨터에 표현하고 저장할 방법을 찾아야 한다. 두 박사는 이를 위한 적절한 방식을 찾기 위해서 프로그래밍 게시판에 도움을 청하기로 했다.

## 수행목표

- 두 연구원의 돌연변이 데이터는 돌연변이를 다음과 같이 표현한다.
  - 바이러스의 이름은 소문자로 구성된다.
  - 프로세스의 이름은 대문자로 표현한다. 프로세스의 이름은 문제 풀이와 무관하지만, 이해를 돕기 위해서 사용한다.
  - 바이러스 `x`가 돌연변이 프로세스 F를 통해서 `y`로 변이하는 경우를 `F(x) = y`로 표현한다.
  - 돌연변이의 프로세스의 특징은 다음과 같다.
    - `F(x) = y`, `G(y) = z`일 때 `G(F(x)) = z` : 두 번의 연속된 돌연변이를 의미한다.
    - `F(x) = y`일 때 `G(y) = x`가 성립하더라도 F와 G는 서로 다른 돌연변이 프로세스이다.
    - F와 G가 서로 다른 프로세스라 할 지라도 `F(x)`과 `G(x)`의 결과가 동일할 수 있다.
    - `x`과 `y`이 서로 다른 바이러스이고, F와 G가 서로 다른 프로세스라 할 지라도 `F(x)`과 `G(y)`의 결과가 동일할 수 있다.
  - 다음의 경우는 돌연변이가 아니다.
    - `F(x) = x`
    - 단 이 경우에도 `x`는 다른 프로세스에 따라 돌연변이가 발생할 수 있다.
- 첨부한 파일에는 바이러스 돌연변이의 흐름의 10회 분의 조사 결과가 수록되어 있다.
  - 첨부한 파일 각각에 대해서 10개의 흐름도를 파이썬 클래스의 객체로 구현한다.
  - 모든 조사에는 `start`라는 이름의 바이러스가 포함되어 있다. 이 `start`가 어떤 과정을 거쳐서든 도달할 수 있는 모든 돌연변이 바이러스의 이름을 사전순으로 정렬한 리스트를 반환하는 메소드를 구현한 후, 리스트를 수행단계에서 제시한 방식으로 출력한다.

## 수행단계

- 객체 사이의 관계를 표현하는데 사용되는 그래프 자료구조에 대해서 조사한다.
  - 그래프를 구현하는 방식 중에 '인접 리스트'를 사용해서 구현하는 방식에 대해서 조사한다.
  - 파이썬에서 '인접 리스트' 방식으로 그래프를 구현하는 방법에 대해서 조사한다.
- 인접 리스트 방식으로 돌연변이 프로세스 그래프를 저장하고 필요한 기능을 제공하는 파이썬 클래스 VirusMutations을 datastructure/virus_mutation.py 파일에 구현한다.
  - 이 그래프에 바이러스의 이름은 저장되어야 하지만, 프로세스의 이름은 저장할 필요는 없다.
  - 다음의 기능을 가지는 클래스의 메소드를 추가한다.
    - 그래프에 추가된 꼭짓점의 수를 반환하는 메소드
    - 그래프에 추가된 변의 수를 반환하는 메소드
    - 그래프에 하나의 돌연변이 프로세스를 추가하는 메소드 (변이 전 바이러스의 이름과 변이 후 바이러스의 이름을 파라미터로 받는다.)
    - 바이러스의 이름을 파라미터로 받아서, 돌연변이 프로세스를 한 번 이상 반복한 결과로 도달 가능한 모든 돌연변이 바이러스의 목록을 반환하는 메소드 (단, 하나의 바이러스가 중복해서 포함되지 않아야 한다.)
      - start라는 이름의 바이러스가 없거나, start에서 다른 바이러스로 변이할 수 없는 경우 빈 리스트([])를 반환한다.
- 첨부한 파일은 바이러스 돌연변이 흐름에 대한 데이터 10개를 포함하고 있으며, 각각의 데이터는 다음과 같이 구성된다.
  - 각 데이터는 'Testcase 번호' 줄로 시작한다.
  - 시작 줄 다음부터 한 줄에 하나씩의 바이러스 돌연변이 프로세스가 기재된다.
    - aaaaa,bbbbb는 바이러스 aaaaa가 1회의 프로세스를 거쳐서 bbbbb로 변이한다는 의미이다.
    - 다음 예시 데이터는 start라는 이름의 바이러스를 포함해 바이러스가 5개 (start, aaaaa, bbbbb, ccccc, ddddd)를 꼭짓점으로 가지고, 바이러스 간의 돌연변이 프로세스 7개를 변으로 가지는 그래프를 표현하는 데이터이다. (start에서 start로의 변화는 돌연변이에 해당하지 않으며, bbbbb에서 ccccc로의 변이 프로세스는 두 가지 종류가 있음을 나타낸다.) 이 데이터에서 바이러스 start는 돌연변이 프로세스를 통해서 최종적으로 aaaaa, bbbbb, ccccc 세 종류의 바이러스로 변이할 수 있다.
    ```
    Testcase 1
    start,start
    start,aaaaa
    start,bbbbb
    aaaaa,bbbbb
    aaaaa,ccccc
    bbbbb,ccccc
    bbbbb,ccccc
    ddddd,ccccc
    ```
  - 첨부한 10개의 흐름도에 대해서 바이러스 돌연변이 흐름의 그래프 객체를 생성한다.
  - start라는 이름의 바이러스가 변이할 수 있는 모든 바이러스의 중복되지 않은 목록을 구한 후, 이 리스트를 다음 함수를 사용해 가공한 결과를 그래프에 포함된 꼭짓점과 변의 수, 이 리스트에 포함된 바이러스의 수와 함께 출력한다.

## 결과예시

```
Testcase 1
    꼭짓점의 수 : 5
    변의 수 : 7
    start에서 도달 가능한 변이 바이러스의 수 : 3
    start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : b943

Testcase 2
    꼭짓점의 수 : 4
    변의 수 : 5
    start에서 도달 가능한 변이 바이러스의 수 : 0
    start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : d41d
(이하 생략)
```

## 참고사항

- 유전자의 출력 순서는 정렬해서 출력할 필요가 없다. 단, 유전자 목록에 유전자는 중복되지 않아야 한다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 주어진 예시에서 aaaaa를 bbbbb로 바꾸는 하나의 돌연변이 프로세스는 bbbbb를 aaaaa로도 바꿀 수 있다고 가정하자. 파이썬 클래스와 메소드를 변경하지 않고 그래프에 꼭짓점과 변을 추가하여 그래프를 생성하는 방법만 수정해서 이 가정을 반영한 그래프를 10개 생성하고, start에서 도달 가능한 모든 변이 바이러스의 목록을 구한 후, 이를 가공한 결과를 리스트에 포함된 바이러스의 수와 함께 출력해보자.
  - 예를 들어서 위의 수행과정에서 예시를 든 5개의 바이러스를 꼭짓점으로 가지는 그래프의 경우, start에서 도달할 수 있는 변이는 aaaaa, bbbbb, ccccc, ddddd, start 다섯 개의 바이러스가 되며, 이 때의 출력 결과는 다음과 같다.
  ```
  Testcase 1
    start에서 도달 가능한 변이 바이러스의 수 : 5
    start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : 7a8d
  (이하 생략)
  ```

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - datastructure/virus_mutation.py 파일에 구현이 되어 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    Testcase 1
        꼭짓점의 수 : 5
        변의 수 : 7
        start에서 도달 가능한 변이 바이러스의 수 : 3
        start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : b943

    Testcase 2
        꼭짓점의 수 : 4
        변의 수 : 5
        start에서 도달 가능한 변이 바이러스의 수 : 0
        start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : d41d

    Testcase 3
        꼭짓점의 수 : 5
        변의 수 : 6
        start에서 도달 가능한 변이 바이러스의 수 : 0
        start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : d41d

    Testcase 4
        꼭짓점의 수 : 10
        변의 수 : 10
        start에서 도달 가능한 변이 바이러스의 수 : 6
        start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : c799

    Testcase 5
        꼭짓점의 수 : 30
        변의 수 : 97
        start에서 도달 가능한 변이 바이러스의 수 : 29
        start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : 702a

    Testcase 6
        꼭짓점의 수 : 42
        변의 수 : 30
        start에서 도달 가능한 변이 바이러스의 수 : 3
        start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : d0e9

    Testcase 7
        꼭짓점의 수 : 85
        변의 수 : 80
        start에서 도달 가능한 변이 바이러스의 수 : 8
        start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : 20f4

    Testcase 8
        꼭짓점의 수 : 38
        변의 수 : 78
        start에서 도달 가능한 변이 바이러스의 수 : 29
        start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : 67e7

    Testcase 9
        꼭짓점의 수 : 40
        변의 수 : 79
        start에서 도달 가능한 변이 바이러스의 수 : 5
        start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : a36a

    Testcase 10
        꼭짓점의 수 : 300
        변의 수 : 991
        start에서 도달 가능한 변이 바이러스의 수 : 144
        start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : 537a
    ```

### [보너스 과제의 확인]

- 보너스 과제를 지시한 대로 구현하였는가?
  - 그래프 클래스의 구현은 변경하지 않고, 그래프 객체를 생성하는 과정만으로 방향성이 없는 그래프를 구성할 수 있는가?
- 보너스 과제의 결과가 정확한가?

  - 보너스 과제의 출력 결과는 다음과 같다.

  ```
  Testcase 1
      start에서 도달 가능한 변이 바이러스의 수 : 5
      start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : 7a8d

  Testcase 2
      start에서 도달 가능한 변이 바이러스의 수 : 0
      start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : d41d

  Testcase 3
      start에서 도달 가능한 변이 바이러스의 수 : 5
      start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : 7a8d

  Testcase 4
      start에서 도달 가능한 변이 바이러스의 수 : 10
      start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : 47e2

  Testcase 5
      start에서 도달 가능한 변이 바이러스의 수 : 30
      start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : c5ff

  Testcase 6
      start에서 도달 가능한 변이 바이러스의 수 : 3
      start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : d0e9

  Testcase 7
      start에서 도달 가능한 변이 바이러스의 수 : 71
      start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : 70f2

  Testcase 8
      start에서 도달 가능한 변이 바이러스의 수 : 38
      start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : ca02

  Testcase 9
      start에서 도달 가능한 변이 바이러스의 수 : 40
      start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : 0db5

  Testcase 10
      start에서 도달 가능한 변이 바이러스의 수 : 150
      start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : b54a
  ```

### [문제에 대한 이해]

- 그래프 자료구조에서 꼭짓점, 변, 방향성의 개념에 대해서 설명하라.
- 인접 리스트를 사용해 파이썬에서 그래프를 구현하는 방식에 대해서 설명하라.
- 그래프 자료구조에서는 같은 꼭짓점을 연결하는 변이 존재할 수 있는가? 예제 그래프에서는 같은 꼭짓점을 존재할 수 없도록 문제에서 제시한 제약 조건은 무엇인가?
- 어떤 그래프에서 꼭짓점의 도달 가능한 모든 꼭짓점의 목록을 중복없이 구하는 과정에 대해서 설명하라.
- (보너스 과제를 해결한 경우)그래프 클래스를 수정하지 않고 그래프의 방향성을 제거하기 위해서 어떤 방법을 사용하였는가?

### [코드 예시]

```python

class VirusMutations:
    def __init__(self):
        self.vertices = {}
        self.vertex_count = 0
        self.edge_count = 0

    def add_process(self, before, after):
        if before not in self.vertices:
            self.vertices[before] = []
            self.vertex_count += 1
        if after not in self.vertices:
            self.vertices[after] = []
            self.vertex_count += 1
        self.vertices[before].append(after)
        self.edge_count += 1

    def edge_count_in_graph(self):
        return self.edge_count

    def vertex_count_in_graph(self):
        return self.vertex_count

    def final_mutation_list(self, start, result=None):
        if result == None:
            result = []
        if start not in self.vertices:
            return result
        for vertex in self.vertices[start]:
            if vertex not in result:
                result.append(vertex)
                self.final_mutation_list(vertex, result)
        return result

import hashlib
def hash4_from_list(input):
    input.sort()
    return hashlib.md5(','.join(input).encode()).hexdigest()[:4]

def main():
    testcases = []
    with open('virus_mutation_data.txt', 'r') as f:
        lines = f.readlines()
    tc = None
    for line in lines:
        if line[:8] == 'Testcase':
            if tc != None:
                testcases.append(tc)
            tc = []
        else:
            segments = line.strip().split(',')
            if len(segments) == 2 and segments[0] != segments[1]:
                tc.append((segments[0], segments[1]))

    if tc != None:
        testcases.append(tc)

    print("----- 방향성이 있는 경우 -----")
    for i, tc in enumerate(testcases):
        print("Testcase", i + 1)
        vc = VirusMutations()
        for before, after in tc:
            vc.add_process(before, after)
        print(f"    꼭짓점의 수 : {vc.vertex_count_in_graph()}")
        print(f"    변의 수 : {vc.edge_count_in_graph()}")
        virus_from_start = vc.final_mutation_list('start')
        print(f"    start에서 도달 가능한 변이 바이러스의 수 : {len(virus_from_start)}")
        print(f"    start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : {hash4_from_list(virus_from_start)}")
        print()

    print("----- 방향성이 없는 경우 -----")
    for i, tc in enumerate(testcases):
        print("Testcase", i + 1)
        vc = VirusMutations()
        for before, after in tc:
            vc.add_process(before, after)
            vc.add_process(after, before)
        virus_from_start = vc.final_mutation_list('start')
        print(f"    start에서 도달 가능한 변이 바이러스의 수 : {len(virus_from_start)}")
        print(f"    start에서 도달 가능한 변이 바이러스 목록의 간이 해시값 : {hash4_from_list(virus_from_start)}")
        print()

if __name__ == "__main__":
    main()
```
# 단계 3. 수와 논리

## 스토리

! 스토리 추가

---

# 문제 1. 소수를 찾아라!
## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

진화를 연구하는 닥터 E는 유전자만 확인하면 두 생물이 같은 조상을 가지고 있다는 것을 확인할 수 있는 방법을 찾기 위해서 온갖 시뮬레이션을 거듭하고 있다. 두 생물의 유전자를 비교할 때 비교 회수를 줄이기 위해서 '소수'에 해당하는 길이의 유전자 패턴을 비교해 보기로 한 닥터 E는 특정 숫자 까지의 소수의 목록을 만들고 있었다.

닥터 E에게 이 정도는 굳이 프로그래밍 게시판의 도움을 받을 필요가 없었다. 다음과 같이 소수를 구하기로 했다.

> * 2부터 n 까지 각 수에 대해서 2부터 그 수의 제곱근까지 나눠보며 소수인지를 판별한다.

이 방법을 통해서 모든 소수를 구할 수는 있었지만, 천만 이하의 모든 소수를 구하는데 정말 오랜 시간이 걸렸다. 좀 더 빠르게 구할 수 있는 방법이 없을까 고민하던 닥터 E는 결국 프로그래밍 지원 게시판의 도움을 청하게 되었다.

## 수행목표
- 어떤 수 n(2 이상의 양의 정수)가 주어졌을 때, n이하의 모든 소수(prime number)를 빠르게 찾는 함수를 구현한다.
- 이 함수를 사용해 천만 이하의 모든 소수를 찾고, 이를 지시한대로 가공해 출력한다.

## 수행단계

- 소수는 양의 정수 중 1과 자기 자신 이외의 약수를 가지지 않는 수를 말한다. 우선 닥터 E의 아이디어를 구현한 후, 10000000이하의 모든 소수를 구하는데 필요한 실행 시간을 측정한다.
- 소수의 성질을 사용해 주어진 수 n 이하의 모든 소수의 리스트를 반환하는 함수를 number/prime_numbers.py 파일에 구현한다.
  - 이 함수의 시간 복잡도는 닥터 E가 제시한 방법보다 더 작아야 한다. 참고로 일반적인 n에 대해서 n 이하의 모든 소수를 구하는 가장 빠른 알고리즘은 $\mathcal O( n/ \log \log n)$으로 알려져 있고, 출제자가 원하는 시간 복잡도는 $\mathcal O(n \log \log n)$ 수준이다. 천만 이하의 모든 소수를 구할 때, 닥터 E의 아이디어로 100초 정도 걸리는 환경에서라면, 구현한 결과는 대략 2초 내외에서 답을 얻을 수 있어야 한다.

- 1000 이하의 모든 소수와 3000000 이하의 모든 소수의 목록을 구한 후, 각각에 대해 소수의 개수 및 모든 소수의 합을 실행 시간과 함께 출력한다.

## 결과 예시
```
prime_numbers_fast 수행 시간 - 0.00011205673217773438 초
1000 이하의 모든 소수는 168개이며, 소수의 합은 76127 입니다.
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- n이하의 소수의 개수가 k개라고 할 때, $k < (n + 1) / \ln n$으로 알려져 있다. $f(n) = (n + 1) / \ln n$이라고 할 때, 공간 복잡도가 $\mathcal O (f(n))$인 n 이하의 소수를 모두 구하는 함수를 구현하라.
  - 공간 복잡도를 제한함으로써 이 프로그램의 실행 시간은 조금 더 걸리게 되겠지만, 기본적으로 동일한 아이디어에서 공간을 절약하는 방법을 제시해야 한다.


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/prime_numbers.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 시간은 10000000 이하의 모든 소수를 구하는데 일반적인 시스템에서 3초 이내로 결과를 확인할 수 있어야 한다. 만약 에라토스테네스의 채 또는 이에 준하는 방식으로 구현하였다면 이 정도 시간 내에 결과를 확인할 수 있다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    prime_numbers_fast 수행 시간 - 0.00011205673217773438 초
    1000 이하의 모든 소수는 168개이며, 소수의 합은 76127 입니다.
    prime_numbers_fast 수행 시간 - 1.6674668788909912 초
    10000000 이하의 모든 소수는 664579개이며, 소수의 합은 3203324994356 입니다.
    ```

### [보너스 과제 확인]

* 공간 효율적인 소수의 목록을 구하는 함수를 구현하였는가?

  * 소수를 구하는데 필요한 공간이 n에 따라 선형적으로 증가하지 않도록 구현하였는지 확인한다.

  * 실행 시간은 원래의 구현보다 조금 더 걸릴 수 있지만, 최대 3배 이상은 걸리지 않는 것이 정상적이다.

  * 결과는 다음과 같다.

    ````
    prime_numbers_fast 수행 시간 - 0.00011110305786132812 초
    1000 이하의 모든 소수는 168개이며, 소수의 합은 76127 입니다.
    prime_numbers_fast 수행 시간 - 1.6865458488464355 초
    10000000 이하의 모든 소수는 664579개이며, 소수의 합은 3203324994356 입니다.
    공간 효율적으로 구현한 경우
    prime_numbers_with_small_memory 수행 시간 - 4.216782093048096 초
    10000000 이하의 모든 소수는 664579개이며, 소수의 합은 3203324994356 입니다.
    ````

    

### [문제에 대한 이해]

- 닥터 E의 아이디어와 구현에 사용한 아이디어를 비교하고, 두 아이디어의 성능의 차이에 대해서도 설명하라.
- (보너스 과제를 해결한 경우)어떤 방법으로 공간을 절약하며 구현하였는지 방법을 제시하라.

### [코드 예시]

```python
import time

def execute_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 수행 시간 - {end - start} 초")
        return result
    return wrapper

@execute_time
def prime_numbers_fast(n):
    if n < 2:
        return []
    sieve = [True] * (n + 1)
    sieve[0] = False
    sieve[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if sieve[i] == True:
            for j in range(i + i, n + 1, i):
                sieve[j] = False
    return [i for i in range(2, n + 1) if sieve[i] == True]

def prime_numbers_with_segment(start, end, primes = None):
    if primes == None:
        primes = []
    if start == 0:
        if end < 2:
            primes == 0
            return        
        sieve = [True] * (end + 1)
        sieve[0] = False
        sieve[1] = False
        for i in range(2, int(end ** 0.5) + 1):
            if sieve[i] == True:
                for j in range(i + i, end + 1, i):
                    sieve[j] = False
        for i in range(2, end + 1):
            if sieve[i] == True:
                primes.append(i)
        return    
    number_cnt = end - start + 1
    sieve = [True] * (number_cnt)
    for prime in primes:        
        check_start = (start // prime) * prime
        if check_start < start:
            check_start += prime
        for i in range(check_start, end + 1, prime):
            sieve[i - start] = False
    for i in range(number_cnt):
        if sieve[i] == True:
            primes.append(i + start)

import math
@execute_time
def prime_numbers_with_small_memory(n):
    step_size_by_number = int((n) / math.log(n, 2))
    start = 0
    result = []
    while True:
        if start + step_size_by_number > n:
            prime_numbers_with_segment(start, n, result)
            break
        prime_numbers_with_segment(start, start + step_size_by_number - 1, result)
        start += step_size_by_number
    return result

@execute_time
def prime_numbers_slow(n):
    result = []
    if n < 2:
        return result
    for i in range(2, n + 1):
        is_prime = True
        for j in range(2, int(i ** 0.5 + 1)):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            result.append(i)
    return result

import hashlib
def hash4(prime_list: list):
    prime_list.sort()
    print(prime_list)
    return hashlib.sha256(str(prime_list).encode()).hexdigest()[:4]

def main():
    target = 1000
    primes = prime_numbers_fast(target)
    print(f"{target} 이하의 모든 소수는 {len(primes)}개이며, 소수의 합은 {sum(primes)} 입니다.")    
    target = 10000000
    primes = prime_numbers_fast(target)    
    print(f"{target} 이하의 모든 소수는 {len(primes)}개이며, 소수의 합은 {sum(primes)} 입니다.")    
    print("공간 효율적으로 구현한 경우")
    primes = prime_numbers_with_small_memory(target)
    print(f"{target} 이하의 모든 소수는 {len(primes)}개이며, 소수의 합은 {sum(primes)} 입니다.")    

if __name__ == "__main__":
    main()


```

---

# 문제 2. 소인수 분해

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

요즘의 첨단 기술 연구는 연구의 질적인 부분만 신경쓸 수 없다. 신경써야 하는 많은 요소 중에 데이터의 보안도 매우 중요하다. K 바이오 연구소에서는 모든 데이터를 암호화해서 보관하고 있다.

데이터를 암호화할 때 가장 중요한 부분은 데이터를 복원의 난이도이며, 일반적인 암호화 기술에서 이 난이도는 소인수 분해를 얼마나 빨리 하느냐에 따라 그 난이도가 결정된다. 온갖 괴팍한 행동으로 매드 사이언티스트라는 별명을 가진 닥터 O는 연구소의 암호화 방식의 안전성이 궁금해졌다. 닥터 O는 연구소의 암호화 방식을 확인한 후, 이를 복원하는 난이도를 확인하는 작업에 들어갔다.

## 수행목표

- 어떤 수 n이 주어졌을 때, 이 수를 소인수 분해하는 함수를 구현한다.

## 수행단계

- 소인수 분해에 대해서 조사한다.
- 어떤 수를 소인수 분해하는 함수를 number/factorization.py 파일에 구현한다.
- 1000이상 10000이하의 정수를 소인수 분해 한 후, 소인수 분해를 밑의 오름차순 지수 형태의 곱으로 나타낼 때의 밑과 지수 각각을 이어붙여 만든 숫자를 모두 더해서 출력한다.  예시는 다음과 같다.
  - 2940을 소인수 분해하면 $2 \times 2 \times 3 \times 5 \times 7 \times 7 = 2^2 \times 3^1 \times 5^1 \times 7^2$이고, 이를 23572112로 표현한다.
  - 1024은 $2^{10}$이고, 이를 210으로 표현한다. 


## 결과예시
- 다음 결과는 1000이상 1010에 대한 결과이다.
	- 2533, 71113111, 23167111, 175911, 225121, 3567111을 더한 결과이다.
```
1000 이상 1005 이하의 정수를 소인수 분해 한 결과를 사용해서 만든 수를 모두 더하면 98250898입니다.
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 암호를 위한 소인수 분해는 매우 큰 두 소수의 곱으로 만들어진 수백 자리의 숫자를 소인수 분해를 빠르게 할 수 있어야 한다. 이를 위해서 어떤 수를 $a \times b$로 나타낼 때, a와 b의 차이가 가장 작은 a와 b를 빠르게 구하는 방법이 필요하다. 주어진 수가 홀수이고 a, b가 반드시 소수라는 조건이 없을 때, 주어진 수에서 a, b의 쌍을 찾는 함수를 구현하고, 100000000이상 100000019 이하의 홀수에 대해서 a와 b, 그리고 그 차를 출력하라. ($a \leq b$)

  - 홀수인 모든 정수에 대해서 $n=a^2-b^2$인 두 정수 a, b가 반드시 존재한다. 이 특성을 사용해보자.

  - 결과 예시는 다음과 같다.

    ```
    100000001을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 17와 5882353이며, 그 차이는 5882336입니다.
    (이하 생략)
    ```

    


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/factorization.py 파일에 구현이 되어 있는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    1000 이상 10000 이하의 정수를 소인수 분해 한 결과를 사용해서 만든 수를 모두 더하면 5974465885091입니다.
    ```

### [보너스 과제 확인]

* 지시한 대로 구현하였는가?

  * $n = a^2 - b^2 = (a + b)(a - b)$라는 조건을 사용해서 최대한 큰 a부터 차례로 확인해 두 수의 조합을 찾아냈는지 확인한다.

* 결과는 정확한가?

  * 출력 예시는 다음과 같다.

    ```
    100000001을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 17와 5882353이며, 그 차이는 5882336입니다.
    100000003을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 643와 155521이며, 그 차이는 154878입니다.
    100000005을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 105와 952381이며, 그 차이는 952276입니다.
    100000007을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 1와 100000007이며, 그 차이는 100000006입니다.
    100000009을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 149와 671141이며, 그 차이는 670992입니다.
    100000011을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 6031와 16581이며, 그 차이는 10550입니다.
    100000013을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 827와 120919이며, 그 차이는 120092입니다.
    100000015을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 5와 20000003이며, 그 차이는 19999998입니다.
    100000017을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 9243와 10819이며, 그 차이는 1576입니다.
    100000019을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 7와 14285717이며, 그 차이는 14285710입니다.
    ```

    

### [문제에 대한 이해]

- 소인수 분해란 무엇인가?
- 어떤 수를 소인수로 분해하는데 사용한 방법을 설명하라.
- 보너스 과제에 소개한 두 수의 곱을 찾는 방법은 페르마의 분해법이라고 부른다. 이 방법을 사용해서 소인수 분해를 한다면, 어떤 방식으로 소인수 분해를 할 수 있을까?
- (보너스 과제를 해결한 경우)어떤 방식으로 가장 가까운 두 수의 곱을 찾아내었는지 설명하라.
- (보너스 과제를 해결한 경우)아주 큰 두 소수의 곱으로 만들어진 수백자리의 숫자를 소인수 분해할 때, 이 방법이 효과적인 이유를 설명하라.

### [코드 예시]

```python
import math

def find_closest_divisors(n):
    a = math.ceil(math.sqrt(n))
    b_square = a * a - n
    b = int(math.sqrt(b_square))
    while b * b != b_square:
        a += 1
        b_square = a * a - n
        b = int(math.sqrt(b_square))
    small_divisor = a - b
    large_divisor = a + b
    return small_divisor, large_divisor

def prime_numbers_fast(n):
    if n < 2:
        return []
    sieve = [True] * (n + 1)
    sieve[0] = False
    sieve[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if sieve[i] == True:
            for j in range(i + i, n + 1, i):
                sieve[j] = False
    return [i for i in range(2, n + 1) if sieve[i] == True]

def factorization(n):
    upper_bound = int(math.sqrt(n))
    primes = prime_numbers_fast(upper_bound)
    result = []
    for prime in primes:
        while n % prime == 0:
            result.append(prime)
            n //= prime
    if n != 1:
        result.append(n)
    return result

def main():
    start = 1000
    end = 10000
    result = 0
    for i in range(start, end + 1):
        factors = factorization(i)
        factors.sort()
        base = ''
        upper = ''
        before = -1
        before_upper = 0
        for j in factors:
            if before != j:
                if before != -1:
                    base += str(before)
                    upper += str(before_upper)
                before = j
                before_upper = 1
            else:
                before_upper += 1
        base += str(before)
        upper += str(before_upper)
        result += int(base + upper)
    print(f"{start} 이상 {end} 이하의 정수를 소인수 분해 한 결과를 사용해서 만든 수를 모두 더하면 {result}입니다.")
    
    for i in range(1, 20 ,2):
        n = 100000000 + i
        small_divisor, large_divisor = find_closest_divisors(n)
        print(f"{n}을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 {small_divisor}와 {large_divisor}이며, 그 차이는 {large_divisor - small_divisor}입니다.")

if __name__ == '__main__':
    main()

```

---

# 문제 3. 입력 신호의 패턴의 전체 수를 찾아라.

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

신경의 신호 전달을 연구하고 있는 N 연구원은 다양한 신호 강도의 입력 패턴에 따른 신경 세포의 반응을 실험하고 있다. 이를 위해서 정해진 횟수 만큼 입력 전기의 세기를 추가하고 줄일 수 있는 모든 입력 신호 패턴에 대한 반응 결과를 기록하고 있다.

실험을 위해서 현재의 설정의 총 몇 개의 패턴이 존재하는지 확인할 필요가 있다. N 연구원은 이를 계산하는 방법을 찾다가, 컴퓨터 프로그램으로 수를 세어보기로 결정했다.

## 수행목표

- 입력하는 값 n은 입력 전기 신호의 세기를 더하고 빼는 횟수이다. 아래 그림은 n이 2일 때와 3일 때의 생성되는 모든 입력 패턴과 생성 가능한 전체 패턴의 수를 보여준다.

	![image-20240112184255620](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240112184255620.png)
	
- 입력 신호의 조절은 다음과 같은 특성을 가진다.

  - 시작할 때 보다 더 낮은 세기의 신호를 입력할 수 없다.
  - 마지막에는 반드시 입력할 때와 동일한 수준의 신호로 마무리된다.
  - 입력하는 n은 신호를 더하고 빼는 각각의 횟수이다. 즉 n = 2라는 의미는 신호의 세기를 두 번 증가시킬 수 있고, 두 번 감소시킬 수 있다는 의미이다.

- 양의 정수 n에 대해서 생성 가능한 모든 패턴의 수를 계산해 출력하는 함수를 구현한다.

- n이 1이상, 10 이하일 때 각각의 경우의 전체 패턴의 수를 출력한다.

## 수행단계

- 입력 전기 신호를 더하고 빼는 순서에 따라 달라지는 전체 패턴의 개수를 계산해 반환하는 함수를 number/input_pattern.py 파일에 구현한다.
  - 재귀 호출을 사용해서 구현한다.

- n = 1, 2, ..., 10일 때 구현한 함수를 사용해 전체 패턴의 수를 출력한다.

## 결과예시

```
n = 1일 때의 전체 패턴의 개수 : 1
n = 2일 때의 전체 패턴의 개수 : 2
n = 3일 때의 전체 패턴의 개수 : 5
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 실무에서 사용할 프로그램을 작성하거나 알고리즘 문제를 해결할 때 수학지식을 사용해 하나의 공식으로 해결할 수 있는 경우, 실행 시간을 크게 줄일 수 있다는 장점이 있다. 이 문제를 알고리즘 문제가 아닌 '수학' 문제로 가정하고 주어진 n에 대해서 만들 수 있는 모든 입력 신호 패턴의 수를 계산하는 과정을 정리한 후, 파이썬 함수로 구현한다.
  - 계산하는 과정을 설명할 수 있어야 한다.

- n = 100일 때의 결과를 출력한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/input_pattern.py 파일에 구현이 되어 있는지 확인한다.
  - 재귀 호출을 사용해 문제를 해결하고 있는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    n = 1일 때의 전체 패턴의 개수 : 1
    n = 2일 때의 전체 패턴의 개수 : 2
    n = 3일 때의 전체 패턴의 개수 : 5
    n = 4일 때의 전체 패턴의 개수 : 14
    n = 5일 때의 전체 패턴의 개수 : 42
    n = 6일 때의 전체 패턴의 개수 : 132
    n = 7일 때의 전체 패턴의 개수 : 429
    n = 8일 때의 전체 패턴의 개수 : 1430
    n = 9일 때의 전체 패턴의 개수 : 4862
    n = 10일 때의 전체 패턴의 개수 : 16796
    ```

### [보너스 과제의 확인]

* 문제의 수학적 구조를 사용해 해답을 구하는 함수를 구현하고, 결과를 정확하게 출력하였는가?

  * 이 문제를 수학적으로 해결하는 방법은 조합론을 사용해 카탈란 수를 구하는 방법이다.

  * 만약, 이 방법을 해결하는데 '카탈란 수를 구한다'로 답을 하는 경우 보너스 과제를 해결한 것으로 인정하지 않는다.

    * 조합론적 접근을 포함해 이 값을 수하는 수학적 유도 과정을 제시한 경우에 이를 정답으로 인정한다.

  * 결과는 다음과 같다.

    ```
    n = 100일 때의 전체 패턴의 개수 : 896519947090131496687170070074100632420837521538745909320
    ```

    

### [문제에 대한 이해]

- 재귀 호출을 사용해 이 문제를 해결하는 알고리즘을 설명하라.
- 구현한 알고리즘의 시간 복잡도를 근거를 사용해 추정해보라.
- (보너스 과제를 해결한 경우)이와 같이 해결하는 수학적 유도 과정을 설명하라.
  - 여러가지 방법이 존재한다.
  - 주어진 n에 대한 패턴의 수를 $F$라고 표현할 때, 이 패턴을 구성 가능한 경우를 패턴의 조합으로 나누고 더해서 점화식을 구할 수 있다. ($F=F_0F_{n-1} + F_1F_{n-2}+...+F_{n-1}F_0$)
  - 전체 조합에서 유효하지 앟은 조합을 빼는 방식으로도 접근할 수 있다. ($F=_{2n}\mathcal C_{n} - _{2n}\mathcal C_{n + 1}$)
  

### 코드 예시

```python
def factorial(n):
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)

def binomial_coefficient(n, k):
    return factorial(n) // (factorial(k) * factorial(n - k))

def catalan_number(n):
    return binomial_coefficient(2 * n, n) // (n + 1)

def pattern_cnt(change_remain, current_level = 0):
    if change_remain == 0:
        return 1
    result_from_minus = 0
    if current_level > 0:
        result_from_minus = pattern_cnt(change_remain, current_level - 1)
        if result_from_minus == -1:
            return -1
    result_from_plus = pattern_cnt(change_remain - 1, current_level + 1)
    if result_from_plus == -1:
        return -1
    return result_from_minus + result_from_plus

def main():
    for i in range(1, 11):
        print(f"n = {i}일 때의 전체 패턴의 개수 : {pattern_cnt(i)}")
    print(f"n = 100일 때의 전체 패턴의 개수 : {catalan_number(100)}")

if __name__ == '__main__':
    main()
```

---

# 문제 4. 원주율을 구하라.

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

K 바이오 연구소는 여러 외국의 연구소와 제휴하고 있다. 다음 상황은 K 바이오 연구소와 교류하는 어떤 나라의 생명공학 연구소에서 발생한 상황이다.

어떤 닥터 V가 연구하는 특이한 세균을 그 나라의 생명공학 연구소에서도 관심을 가지고 연구하고 있었다. (과정2의 '최후의 승자는?' 문제 참고) 이 세균은 여러 개체가 모이면 완벽한 원을 그리고 숙주를 둘러싸는 독특한 행동 패턴을 보이고 있기 때문에, 이를 현미경으로 관찰한 후, 이 원의 지름을 측정하면 원주의 길이를 구할 수 있고 세균 하나의 크기를 바탕으로 총 몇 마리의 세균이 여기에 모였는지를 추정할 수 있다. 반대로, 다른 값들을 알면 세균 모두가 이 숙주를 중심으로 둘러싸는 행동 패턴을 가지고 있는지를 알 수도 있다.

문제는, 이 나라는 교육과정에서 원주의 길이를 구하기 위한 파이($\pi$)의 값을 대충 3으로 가르키고 있다는 점이었다. 연구원 누군가는 조금 더 상세한 값을 알 수도 있었건만 불행히도 모인 사람들 중에는 이 값을 아는 사람이 아무도 없었다.

뭔가 말도 안되는 상황이 벌어지긴 했지만, 어딘가에는 이해되지 않는 상황이 발생할 수도 있는 법이다. 여튼, 누군가는 이 문제를 해결해야 하는 상황이었다.

## 수행목표

- '시뮬레이션' 방식으로 원주율을 구하는 함수를 구현한다.
- 1000000번 반복한 시뮬레이션을 통해서 구한 원주율을 출력한다. 

## 수행단계

- 다음 정보를 바탕으로 원주율 $\pi$를 구하는 시뮬레이션을 설계한다.
  - 면적이 $s_a$인 영역 A가 있다.
  - 영역 A의 내부에 완전히 포함되는 영역 B가 있고, B의 면적은 $s_b$이다.
  - 이 때 영역 A에 임의의 한 점을 찍었을 때, 이 점이 영역 B에 속할 확률은 $\frac {s_b}{s_a}$이다.

- 설계한 시뮬레이션을 주어진 회수 n번 반복해서 원주율 $\pi$의 근사값을 구하는 함수를 number/find_pi.py 파일에 구현한다.
- n = 10, 100, 1000, 10000, 100000, 1000000, 10000000일 때 구한 원주율 $\pi$의 근사치를 출력한다.

## 결과 예시

```
10번 반복한 시뮬레이션에서 pi의 근사값 : 3.2
100번 반복한 시뮬레이션에서 pi의 근사값 : 3.4
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 임의의 함수 `f(x)`는 `x`가 0과 1 사이의 임의의 실수일 때, 항상 값을 구할 수 있는 함수이다. 예를 들어서 $f(x) = x^2$인 경우, 다음과 같이 함수가 정의된다.

  ```python
  def f(x):
    return x ** 2
  ```

- 이 임의의 함수에 대해서 $\int_{0}^{1} f(x) \, dx$값의 근사값을 정해진 횟수 n번의 반복 시뮬레이션으로 구하는 함수를 구현한다.

  - 이 함수는 반복 횟수와 함수를 파라미터로 받는다.

- 다음 2개의 함수에 대해서, 이 함수의 결과를 n = 10, 100, 1000, 10000, 100000, 1000000, 10000000번 반복한 결과를 출력한다.

  - $f(x) = x^2$
  - $f(x) = e^x$


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/find_pi.py 파일에 구현이 되어 있는지 확인한다.
  - 몬테카를로 시뮬레이션 등 반복 시뮬레이션을 통해 근사값을 구했는지를 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 값은 원주율 (3.141592...)와 유사한 값이 나와야 한다.

    ```
    10번 반복한 시뮬레이션에서 pi의 근사값 : 3.2
    100번 반복한 시뮬레이션에서 pi의 근사값 : 3.4
    1000번 반복한 시뮬레이션에서 pi의 근사값 : 3.2
    10000번 반복한 시뮬레이션에서 pi의 근사값 : 3.1508
    100000번 반복한 시뮬레이션에서 pi의 근사값 : 3.14628
    1000000번 반복한 시뮬레이션에서 pi의 근사값 : 3.140296
    10000000번 반복한 시뮬레이션에서 pi의 근사값 : 3.1417912
    ```

### [보너스 과제의 확인]

* 지시한 대로 구현하였는가?

  * 몬테카를로 시뮬레이션 등 반복 시뮬레이션을 통해 정적분의 근사값을 구했는지를 확인한다.

* 적절한 근사치를 출력하였는가?

  * 결과는 다음과 같다. 값은 0.33333..., 1.171828...에 가까운 근사값으로 출력되어야 한다.

    ```
    10번 반복한 시뮬레이션에서 pi의 근사값 : 3.2
    10번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.5500721179178474
    10번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.4492977677230885
    100번 반복한 시뮬레이션에서 pi의 근사값 : 3.2
    100번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.2739763706032174
    100번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.7495884141066214
    1000번 반복한 시뮬레이션에서 pi의 근사값 : 3.116
    1000번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.32056474136739793
    1000번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.7118812561429846
    10000번 반복한 시뮬레이션에서 pi의 근사값 : 3.134
    10000번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.33287100052375435
    10000번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.7244660892433876
    100000번 반복한 시뮬레이션에서 pi의 근사값 : 3.13624
    100000번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.33354984684205685
    100000번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.720112470713169
    1000000번 반복한 시뮬레이션에서 pi의 근사값 : 3.139604
    1000000번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.3335768134336369
    1000000번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.7178456076707131
    10000000번 반복한 시뮬레이션에서 pi의 근사값 : 3.1425068
    10000000번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.33342251486598445
    10000000번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.7183020515153062
    ```

    

### [문제에 대한 이해]

- 시뮬레이션을 통해서 원주율을 구하는 과정을 설명하라.
- 실제 원주율의 값은 3.141592...로 시작하는 무리수이다. 시뮬레이션을 통해서 얻은 값과 실제 원주율의 값의 차이는 어디에서 기인하는가?
- 차이를 줄일 수 있는 방법에 대해서 설명해보자.
- (보너스 과제를 해결한 경우)함수의 정적분을 시뮬레이션으로 해결한 방법에 대해서 설명하라.

### [코드 예시]

```python
import random

def pi_simulation(n):
    cnt = 0
    for _ in range(n):
        x = random.random()
        y = random.random()
        if x ** 2 + y ** 2 <= 1:
            cnt += 1
    return 4 * cnt / n

def integral_simulation(n, func):
    start = 0
    end = 1
    sum = 0
    for _ in range(n):
        x = random.uniform(start, end)
        sum += func(x)
    return (end - start) * sum / n

import math
def main():
    end = 7
    func1 = lambda x: x ** 2
    func2 = lambda x: math.e ** x
    for i in range(1, end + 1):
        print(f"{10 ** i}번 반복한 시뮬레이션에서 pi의 근사값 : {pi_simulation(10 ** i)}")
        print(f"{10 ** i}번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : {integral_simulation(10 ** i, func1)}")
        print(f"{10 ** i}번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : {integral_simulation(10 ** i, func2)}")

if __name__ == '__main__':
    main()

```

---

# 문제 5. 텔로미어 복제 매커니즘을 검증하자.

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

유전자 서열의 마지막에 위치한 반복적인 DNA 서열을 텔로미어라고 부른다. 이 부분은 유전 정보의 내용과 무관한 반복적인 내용으로 채워져 있으므로, 과거에는 의미없는 자리 채우기 역할만 한다고 추정되었으나, 최신 연구 결과 안정적인 DNA 복제에 기여하며 세포 분열이 반복될 수록 짧아지는 특성이 있어 생물의 노화와 관련이 있다는 증거가 발견되고 있다.

생물의 노화 현상을 연구하는 닥터 A는 DNA의 텔로미어 부분을 인공적으로 복제하는 방법을 찾고 있다. 닥터 A가 오랜 연구끝에 텔로미어 인공 자가복제 매커니즘에 대한 아이디어를 발견했는데, 이 아이디어를 통해서 텔로미어를 다음과 같이 복제할 수 있을 것으로 추정했다.

> - 한 번 복제하면 입력 패턴의 길이만큼 반복해 복제한다.
> - 예를 들어서 일반적인 텔로미어의 염기서열은 `TTAGGG`가 반복되는데, 이 여섯개의 염기로 이루어진 서열을 닥터 A의 매커니즘으로 복제하면 `TTAGGG`가 6번 반복되는 길이 36의 텔로미어가 생성된다.
> - 다시 한 번 반복하면 36의 텔로미어가 36번 반복되는 길이 $36^2 = 6^4 = 1296$의 텔로미어가 생성된다.

이 매커니즘이 정상적으로 동작하려면, 복제된 유전자를 해독해서 복제 회수에 따른 길이의 예측값과, 입력 패턴이 마지막까지 반복되는지를 확인하면 된다. 하지만 이 매커니즘을 5번만 반복해도 $6^{32} = 7958661109946400884391936$라는 어마어마한 길이의 패턴이 생성되기 때문에 해독하는데 걸리는 시간이 너무 길어진다는 문제가 있었다. 반면, 닥터 A는 여러번 반복해서 복제해도 안정적으로 매커니즘이 동작한다는 것을 입증하고 싶었기 때문에 반복 횟수를 늘리면 늘렸지 줄이고 싶은 생각은 추호도 없었다.

그래서 유전자 전체를 해독하기 전에, 빠른 사전 조사를 위해서 복제된 텔로미어를 정해진 길이만큼 앞에서부터 차례로 잘라서 버리고 최종적으로 남은 부분의 유전자 염기서열을 확인해보기로 했다. 예를 들어서 두 번 복제한 1296 길이의 텔로미어를 길이 23씩 잘라서 버리는 과정을 반복하면 마지막에는 길이 8인 DNA가 남고, 이 DNA의 염기서열이 `GGTTAGGG`라면, 일단 첫 번째 관문은 넘어선 것으로 하자는 것이다. 

그런데, 길이가 $6^{32}$ 정도 되는 유전자를 길이 23씩 잘라서 버리는 과정을 반복하고 나면 마지막에 남은 DNA의 길이가 어떻게 될 지를 미리 예측하는 일도 절대로 쉬운 일이 아니었다. 고민 끝에 닥터 A도 프로그래밍 지원 게시판의 문을 두드리게 되었다.

## 수행목표

- 입력 패턴의 길이가 n, 복제 반복 회수가 r일 때, 생성되는 복제 패턴의 길이는 $n^{2^r}$가 된다. 이렇게 생성된 복제 패턴을 정해진 길이 d 단위로 잘라내고 남은 DNA 염기서열의 길이를 구한다. 

  - n, r, d는 모두 양의 정수이다.
  - 예를 들어서 길이(n)가 6인 패턴을 3번 복제하면(r), 생성되는 복제 패턴의 길이는 $6^{2^3}=6^{8}=1679616$이다.
  - 이 염기서열을 앞에서부터 차례로 길이 43(d)의 조각을 반복해 잘라서 버리고 나면 남은 염기서열은 1679616을 43으로 나눈 나머지인 36의 길이를 가진다.

- 다음 튜플의 리스트로 제공되는 10개의 값에 대해서 결과를 출력한다. 각 튜플은 순서대로 n, r, d의 값이다.

  ```python
  testcases = [
      (6, 3, 43),
      (1, 1, 1),
      (1, 20, 1),
      (2, 20, 65535),
      (6, 10, 43),
      (6, 25, 43),
      (23, 19, 17),
      (81, 10, 1039),
      (33, 3, 1000000007),
      (1079, 30, 8887)
  ]
  ```

## 수행단계

- 모듈러 연산(Modular Arithmetic)에 대해서 조사한다.
- 두 수가 주어졌을 때, 두 수를 곱한 수의 모듈러 연산의 결과와 두 수의 모듈러 연산 결과의 곱의 관계에 대해서 조사한다.
- 모듈러 연산을 $a \mod b$라고 표현할 때, $n^k \mod d$를 빠르게 계산하는 함수를 number/remainder_of_telomere.py 파일에 구현한다.
- 이 함수를 사용해 제공된 테스트케이스 10개의 결과를 구하고, 이를 출력한다.

## 결과예시

```
Testcase 1의 결과 : 36
Testcase 2의 결과 : 0
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 곱셈과 모듈러 연산은 몇 가지 특징을 더 가지고 있다. 그 중 하나는 다음과 같다.
  - $n \times 0 = 0$이고, $0\mod k = 0$이므로 $a \mod k = 0$인 경우 어떤 b에 대해서도 $(a \times b)\mod k = 0$

- 이와 같은 모듈러 연산의 특징, 그리고 거듭제곱 연산의 특징을 사용하면 훨씬 더 빠르게 동작하는 함수를 구현할 수 있다. 이를 구현하고 `(n, r, k)=(1079,30,8887)`,  `(n, r, k) = (6, 1000, 43)`일 때의 결과를 출력하라.
  - 두 경우 모두 일반적인 테스트 환경에서 '눈 깜짝할 사이'에, 아무리 느린 환경에서도 1초 이내에 계산 결과를 출력해야 한다. `(n, r, k)=(1079,30,8887)`은 마지막 테스트케이스이며 기존 구현과 성능 차이를 비교해보자.


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/remainder_of_telomere.py 파일에 구현이 되어 있는지 확인한다.
  - 곱셈에 대한 모듈러 연산의 분배법칙을 사용하도록 구현이 되어 있는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    Testcase 1의 결과 : 36
    Testcase 2의 결과 : 0
    Testcase 3의 결과 : 0
    Testcase 4의 결과 : 1
    Testcase 5의 결과 : 6
    Testcase 6의 결과 : 36
    Testcase 7의 결과 : 1
    Testcase 8의 결과 : 345
    Testcase 9의 결과 : 408608399
    Testcase 10의 결과 : 135
    ```

### [보너스 과제 확인]

* 보너스 과제를 지시한대로 정확히 해결하였는가?

  * 거듭제곱과 모듈러 연산의 특수한 성질을 사용해 문제를 해결하였는지 확인한다.

  * 다음의 결과가 거의 시간 지연없이 출력되는지 확인한다.

    ```
    (n, r, k) = (1079, 30, 8887)일 때 빠른 함수의 결과 : 135
    (n, r, k) = (6, 100, 43)일 때 빠른 함수의 결과 : 6
    ```

    

### [문제에 대한 이해]

- 모듈러 연산은 무엇인가?
- 곱셈에 대한 모듈러 연산의 분배법칙에 대해서 설명하라.
- 덧셈과 뺄셈에 대해서도 모듈러 연산의 분배법칙이 성립하는가?
- 거듭제곱의 모듈러 연산을 빠르게 계산하기 위해서 사용한 방법을 설명하라.
- (보너스 과제를 해결한 경우)결과를 더 빨리 얻기 위해서 추가로 사용한 거듭제곱과 모듈러 연산의 특징은 무엇인가?

### [코드 예시]

```python
def remainder_of_telomere(n, k, d):
    return modular_of_exponatial(n, 2 ** k, d)

def modular_of_exponatial(n, k, d):
    result = 1
    for _ in range(k):
        result = (result * n) % d        
    return result

def fast_remainder_of_telomere(n, k, d):
    return fast_modular_of_exponatial(n, 2 ** k, d)

def fast_modular_of_exponatial(n, k, d):
    result = 1    
    n = n % d

    while k > 0:
        if k % 2 == 1:
            result = (result * n) % d
        k = k // 2
        n = (n ** 2) % d
    return result

  def main():
    testcases = [
        (6, 3, 43),
        (1, 1, 1),
        (1, 20, 1),
        (2, 20, 65535),
        (6, 10, 43),
        (6, 25, 43),
        (23, 19, 17),
        (81, 10, 1039),
        (33, 3, 1000000007),
        (1079, 30, 8887)
    ]
    for i, tc in enumerate(testcases):
        result = remainder_of_telomere(*tc)
        print(f"Testcase {i + 1}의 결과 : {result}")

if __name__ == '__main__':
    main()

```

---

# 문제 6. 바이오 반도체의 가능성

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

미생물을 연구하는 닥터 S는 우연히 재미있는 미생물 하나를 발견했다. 이 미생물은 두 개의 수용체를 가지고 있으며, 평소에는 특정 신호를 항상 발생시키는데, 두 개의 수용체 모두에 다른 개체에서 발생한 신호를 연결하면 발생하던 신호가 사라지는 신기한 매커니즘을 가지고 있었다.

이를 본 닥터 S는 다음과 같이 생각했다.

'어라? 이것만 있으면 반도체를 만들 수 있지 않을까?'

## 수행목표

- 논리식에서 주로 다음과 같은 표현을 사용한다.

  | 연산      | 표현  |
  | --------- | ----- |
  | `A AND B` | `AB`  |
  | `A OR B`  | `A+B` |
  | `NOT A`   | `A'`  |

- 닥터 S가 발견한 미생물은 마치 NAND 연산처럼 동작한다. `A NAND B` 연산을 `A@B`로 표시하기로 하자. 주어진 논리식을 괄호와 NAND 연산만으로 변형해서 출력하는 함수를 구현한다.

- 다음 테스트케이스에 포함된 논리식을 NAND 연산만으로 표현해 출력한다.

## 수행단계

- 논리식을 구성하는 기본 연산인 AND, OR, NOT에 대해서 조사한다.

  - 파이썬에서 AND, OR, NOT 연산의 결과는 무엇인지 확인한다.

- NAND 연산에 대해서 조사한다.

  - AND, OR, NOT 연산을 NAND 연산으로 표현하는 방법에 대해서 조사한다.

- 어떤 논리식이 문자열로 주어졌을 때 이 논리식을 괄호와 NAND 연산만으로 표현한 새로운 논리식 문자열을 반환하는 함수를 logic/convert_into_nandonly.py 파일에 구현한다.

  - 연산의 우선 순위는 괄호, NOT, 기타의 순서이다. AND와 OR가 섞여 있는 경우, 순서대로 계산한다.

- 테스트케이스로 제공된 논리식을 변형한 결과를 출력한 결과와 해당 식의 입력에 따른 진리표를 출력한다. 이 진리표는 NAND의 결과만으로 계산해야 한다. 

  - 진리표는 다음과 같은 형식의 표를 말한다. 아래 표에서 T는 True, F는 False이다.

    - `AB`

      | A    | B    | 결과 |
      | ---- | ---- | ---- |
      | T    | T    | T    |
      | T    | F    | F    |
      | F    | T    | F    |
      | F    | F    | F    |

    - `A(B'+C)`

      | A    | B    | C    | 결과 |
      | ---- | ---- | ---- | ---- |
      | T    | T    | T    | T    |
      | T    | T    | F    | F    |
      | T    | F    | T    | T    |
      | T    | F    | F    | T    |
      | F    | T    | T    | F    |
      | F    | T    | F    | F    |
      | F    | F    | T    | F    |
      | F    | F    | F    | F    |

      


## 결과예시

```
testcase 1
    입력 - A'
    변환 결과 - (A@A)
    진리표
        A 결과
        F T
        T F

testcase 2
    입력 - AB
    변환 결과 - ((A@B)@(A@B))
    진리표
        A B 결과
        F F F
        F T F
        T F F
        T T T

testcase 3
    입력 - A+B
    변환 결과 - ((A@A)@(B@B))
    진리표
        A B 결과
        F F F
        F T T
        T F T
        T T T

testcase 4
    입력 - A'A
    변환 결과 - (((A@A)@A)@((A@A)@A))
    진리표
        A 결과
        F F
        T F
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - logic/convert_into_nandonly.py 파일에 구현이 되어 있는지 확인한다.
  - 논리식을 계산하는데 nand 이외의 다른 논리연산을 수행하지 않아야 한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 

    ```
    testcase 1
        입력 - A'
        변환 결과 - (A@A)
        진리표
            A 결과
            F T
            T F
    
    testcase 2
        입력 - AB
        변환 결과 - ((A@B)@(A@B))
        진리표
            A B 결과
            F F F
            F T F
            T F F
            T T T
    
    testcase 3
        입력 - A+B
        변환 결과 - ((A@A)@(B@B))
        진리표
            A B 결과
            F F F
            F T T
            T F T
            T T T
    
    testcase 4
        입력 - A'A
        변환 결과 - (((A@A)@A)@((A@A)@A))
        진리표
            A 결과
            F F
            T F
    
    testcase 5
        입력 - A'+A
        변환 결과 - (((A@A)@(A@A))@(A@A))
        진리표
            A 결과
            F T
            T T
    
    testcase 6
        입력 - A'B'
        변환 결과 - (((A@A)@(B@B))@((A@A)@(B@B)))
        진리표
            A B 결과
            F F T
            F T F
            T F F
            T T F
    
    testcase 7
        입력 - A+B'*C
        변환 결과 - ((((A@A)@((B@B)@(B@B)))@C)@(((A@A)@((B@B)@(B@B)))@C))
        진리표
            A B * C 결과
            F F F F F
            F F F T T
            F F T F F
            F F T T T
            F T F F F
            F T F T F
            F T T F F
            F T T T F
            T F F F F
            T F F T T
            T F T F F
            T F T T T
            T T F F F
            T T F T T
            T T T F F
            T T T T T
    
    testcase 8
        입력 - (AB)(CD)
        변환 결과 - ((((A@B)@(A@B))@((C@D)@(C@D)))@(((A@B)@(A@B))@((C@D)@(C@D))))
        진리표
            A B C D 결과
            F F F F F
            F F F T F
            F F T F F
            F F T T F
            F T F F F
            F T F T F
            F T T F F
            F T T T F
            T F F F F
            T F F T F
            T F T F F
            T F T T F
            T T F F F
            T T F T F
            T T T F F
            T T T T T
    
    testcase 9
        입력 - (A+B)C(D+B)
        변환 결과 - ((((((A@A)@(B@B))@C)@(((A@A)@(B@B))@C))@((D@D)@(B@B)))@(((((A@A)@(B@B))@C)@(((A@A)@(B@B))@C))@((D@D)@(B@B))))
        진리표
            A B C D 결과
            F F F F F
            F F F T F
            F F T F F
            F F T T F
            F T F F F
            F T F T F
            F T T F T
            F T T T T
            T F F F F
            T F F T F
            T F T F F
            T F T T T
            T T F F F
            T T F T F
            T T T F T
            T T T T T
    
    testcase 10
        입력 - (A'B')'
        변환 결과 - ((((A@A)@(B@B))@((A@A)@(B@B)))@(((A@A)@(B@B))@((A@A)@(B@B))))
        진리표
            A B 결과
            F F F
            F T T
            T F T
            T T T
    
    testcase 11
        입력 - (A'+B)''+(CD'(B'+A')')'
        변환 결과 - (((((((A@A)@(A@A))@(B@B))@(((A@A)@(A@A))@(B@B)))@((((A@A)@(A@A))@(B@B))@(((A@A)@(A@A))@(B@B))))@(((((A@A)@(A@A))@(B@B))@(((A@A)@(A@A))@(B@B)))@((((A@A)@(A@A))@(B@B))@(((A@A)@(A@A))@(B@B)))))@((((((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))@(((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A))))))@((((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))@(((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))))@(((((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))@(((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A))))))@((((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))@(((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))))))
        진리표
            A B C D 결과
            F F F F T
            F F F T T
            F F T F T
            F F T T T
            F T F F T
            F T F T T
            F T T F T
            F T T T T
            T F F F T
            T F F T T
            T F T F T
            T F T T T
            T T F F T
            T T F T T
            T T T F T
            T T T T T
    
    testcase 12
        입력 - (A+B)(C+D)(A+C)(B+D)+(AD)
        변환 결과 - ((((((((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C)))@(((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C))))@((B@B)@(D@D)))@(((((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C)))@(((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C))))@((B@B)@(D@D))))@((((((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C)))@(((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C))))@((B@B)@(D@D)))@(((((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C)))@(((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C))))@((B@B)@(D@D)))))@(((A@D)@(A@D))@((A@D)@(A@D))))
        진리표
            A B C D 결과
            F F F F F
            F F F T F
            F F T F F
            F F T T F
            F T F F F
            F T F T F
            F T T F T
            F T T T T
            T F F F F
            T F F T T
            T F T F F
            T F T T T
            T T F F F
            T T F T T
            T T T F T
            T T T T T
    ```

### [문제에 대한 이해]

* AND, OR, NOT 연산의 진리표를 작성해보라.
* NAND는 연산은 어떤 연산인가?
* AND, OR, NOT 각각을 NAND로 변환하는 방법을 설명하라.
* 어떤 방법으로 주어진 논리식을 변환하고, 결과를 계산하였는지 설명하라.

### [코드 예시]

```python

def is_symbol(char):
    return char not in ['+', "'", '(', ')', '*', '@']

def make_logic_eqstack(expression):
    expression = expression.strip().replace(' ', '')
    expression_with_and = ''

    for i in range(len(expression) - 1):
        expression_with_and += expression[i]
        if expression[i] == "'" or is_symbol(expression[i]):
            if expression[i + 1] == "(" or is_symbol(expression[i + 1]):
                expression_with_and += '*'
        if expression[i] == ')':
            if expression[i + 1] == '(' or is_symbol(expression[i + 1]):
                expression_with_and += '*'
    expression_with_and += expression[-1]
    stack = []
    result = []
    for char in expression_with_and:
        if char == "'":
            result.append(char)
        elif is_symbol(char):
            result.append(char)
        elif char == '(':
            stack.append(char)
        elif char == ')':
            while stack and stack[-1] != '(':
                result.append(stack.pop())
            stack.pop()
        else:
            while stack and stack[-1] != '(':
                result.append(stack.pop())
            stack.append(char)
    while stack:
        result.append(stack.pop())
    return result

def calculate_nand(op1, op2):
    if op1 and op2:
        return False
    else:
        return True

def convert_not_to_nand(operand):
    result = f"({operand}@{operand})"
    return result    

def convert_and_to_nand(operand1, operand2):
    result = f"({operand1}@{operand2})@({operand1}@{operand2})"
    return result

def convert_or_to_nand(operand1, operand2):
    result = f"({operand1}@{operand1})@({operand2}@{operand2})"
    return result

def calculate(expression, input_tf: dict):
    st = make_logic_eqstack(expression)
    result = []
    for char in st:
        if char not in ['@']:
            result.append(input_tf[char])
        else:
            operand2 = result.pop()
            operand1 = result.pop()
            result.append(calculate_nand(operand1, operand2))
    return result[0]

def converted_to_nand_only(expression):
    st = make_logic_eqstack(expression)
    changed_result = []

    for char in st:
        if char not in ['+', '*', "'"]:
            changed_result.append(char)
        else:
            if char == "'":
                operand1 = changed_result.pop()
                changed_result.append(convert_not_to_nand(operand1))
            else:
                operand2 = changed_result.pop()
                operand1 = changed_result.pop()
                if char == '+':
                    changed_result.append("(" + convert_or_to_nand(operand1, operand2) + ")")
                elif char == '*':
                    changed_result.append("(" + convert_and_to_nand(operand1, operand2) + ")")
    return changed_result[0]

def format_tf_head(str):
    result = ''
    for c in str:
        if c == '0':
            result += "F "
        elif c == '1':
            result += "T "
        else: 
            result += c + " "
    return result

def main():
    testcase = [
        "A'",
        "AB",
        "A+B",
        "A'A",
        "A'+A",
        "A'B'",
        "A+B'*C",
        "(AB)(CD)",
        "(A+B)C(D+B)",
        "(A'B')'",
        "(A'+B)''+(CD'(B'+A')')'",
        "(A+B)(C+D)(A+C)(B+D)+(AD)",
    ]

    
    for i in range(len(testcase)):
        print("testcase", i + 1)
        print(f"    입력 - {testcase[i]}")
        converted_result = converted_to_nand_only(testcase[i])
        print(f"    변환 결과 - {converted_result}")
        variables = []
        for c in testcase[i]:
            if c not in ["'", "+", "(", ")"] and c not in variables:
                variables.append(c)
        tf_case_num = 2 ** len(variables)
        print("    진리표")
        print("        " + " ".join(variables) + " 결과")
        for j in range(tf_case_num):
            j_bin_str = bin(j)[2:]
            j_bin_str = '0' * (len(variables) - len(j_bin_str)) + j_bin_str
            input_tf = {}
            for k in range(len(variables)):
                input_tf[variables[k]] = bool(int(j_bin_str[k]))
            nand_only_result = calculate(converted_result, input_tf)
            row_head = format_tf_head(j_bin_str)
            print(f"        {row_head}{'T' if nand_only_result else 'F'}")
        print()


if __name__ == "__main__"
    main()
```

---

# 문제 7. 커플 사이의 외로운 솔로

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

연구소에는 매일 수많은 횟수의 실험이 반복되며, 이를 위해서 다양한 시약을 사용한다. 실험 시 발생할 수 있는 문제의 사후 분석을 위해서 연구소는 반드시 매 실험에 사용되는 시약의 샘플을 2개씩 별도로 보관해서 관리하도록 규정하고 있다.

연구지원팀의 W 선임행정원의 업무 중에는 이렇게 제출된 시약의 샘플 목록을 관리하는 일을 하고 있다. 각 샘플은 시약의 화학적 조성에 따라 고유번호로 관리되기 때문에 이 목록에는 항상 같은 숫자가 반드시 짝수 개씩 적혀 있어야 하며, 전체 목록의 길이는 항상 짝수여야 한다. 그렇게 몇 년을 관리해오던 W 선임행정원이 우연히 이 목록이 홀수임을 알게 되었다.

시스템의 로그를 들여다보면서 어떤 문제가 있었는지 확인해보니, 시스템의 장애로 인해서 전체 목록에서 숫자 단 하나가 저장되지 않았다는 것을 알게 되었다. 하지만, 로그에 이 번호가 적혀 있지 않은 탓에 어떤 숫자가 누락되었는지 확인하기가 영 쉽지 않았다. 이미 몇 년째 쌓여있는 목록의 길이는 어마어마하게 길었지만, 시스템의 메모리가 충분치 않아서 이를 확인하는 프로그램을 만들기가 쉽지 않았기 때문이다.

그런 W 선임행정원을 지켜보던 같은 팀 지선생이 W 선임행정원에게 조언을 했다.

"비트 연산을 사용해봐."

## 수행목표

- 양의 정수로 구성된 목록이 주어진다. 이 목록은 2 * n + 1개의 숫자가 들어 있고, n개는 같은 숫자가 두 번 씩 반복해서, 그리고 나머지 하나의 숫자는 홀로 존재하는 숫자이다.
- 홀로 존재하는 숫자를 찾는 함수를 구현한다.
  - 함수의 시간 복잡도는 $\mathcal O (n)$, 함수가 추가로 사용하는 메모리의 공간 복잡도는 $\mathcal O(1)$로 구현한다.

- 1에서 1000000까지 숫자의 리스트에서 무작위의 숫자 하나만 홀로 존재하는 길이 1999999의 리스트를 생성한다. 이 리스트에 숫자들의 순서도 무작위로 섞여 있어야 한다. 이 함수를 사용해 홀로 존재하는 숫자를 찾아서 출력한다.

## 수행단계

- XOR 연산에 대해서 조사한다.
- XOR 연산의 특성을 사용해서 주어진 리스트에서 홀로 존재하는 단 하나의 숫자를 찾는 함수를 number/find_solo.py 파일에 구현한다.
  - 함수가 추가로 사용하는 메모리의 공간 복잡도가 상수 복잡도라는 의미는, 생성되어 파라미터로 전달받은 리스트 이외로 추가로 사용하는 공간의 복잡도가 상수 복잡도라는 의미이다.

- 길이가 999999인 리스트를 만든다. 이 리스트는 1에서 100000 사이의 숫자로 구성되는데, 반드시 숫자 단 하나만 홀수 번 포함되어 있고 나머지 숫자는 모두 포함되도록 생성되어야 한다. 
  - 이 리스트는 무작위 순서로 만들어져야 하며, 어떤 숫자가 홀수 번 포함되어 있는지 미리 알 수 있도록 생성한다.

- 구현한 함수를 사용해 리스트에서 홀수 번 존재하는 숫자를 찾아 이를 출력한다.

## 결과예시

```
리스트에서 찾은 외로운 숫자는 XXX이며, 이는 예상대로 XXX입니다.
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 또 평온한 나날을 보내던 W 선임행정원에게 문제가 생겼다. 이번에도 똑같은 일이 벌어졌는데, 이전과 달리 이번에는 두 개의 숫자가 누락되었다. 다행히 시스템의 로그에 누락된 두 개의 시약 번호 중 하나는 찾을 수 있었다. 새롭게 리스트를 뒤지는 일 없이 문제에서 구현한 함수와 찾아낸 시약 번호를 사용해 나머지 하나의 누락된 시약의 번호를 찾는 함수를 구현한다.
  - 이전 문제의 함수의 동작을 제외한 추가적으로 사용하는 시간 복잡도와 공간 복잡도는 모두 상수 복잡도여야 한다.

- 문제에서와 동일한 방법으로 두 개의 숫자가 누락된 길이 999998인 리스트를 생성하고, 제거된 숫자 하나를 사용해 나머지 숫자 하나를 출력하라. 

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/find_solo.py 파일에 구현이 되어 있는지 확인한다.
  - 함수의 시간 복잡도는 $\mathcal O (n)$, 함수가 추가로 사용하는 메모리의 공간 복잡도는 $\mathcal O(1)$로 구현되어있는지를 확인한다.
  
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다. 어떤 숫자를 골라내었느냐에 따라 결과는 다르지만 제거한 숫자와 동일한 숫자를 찾을 수 있어야 한다.
  ```
  리스트에서 찾은 외로운 숫자는 29608이며, 이는 예상대로 29608입니다.
  ```

### [보너스 과제 해결 확인]

- 보너스 과제를 지시한대로 해결하였는가?

  - 추가적으로 리스트를 탐색하지 않고 원래 문제의 결과를 활용해 정답을 구했는지를 확인한다.
  - 추가적으로 사용하는 시간 및 공간이 고정되어 있어야 한다.

- 결과예시는 다음과 같다. 결과보다는 반드시 코드가 지시한대로 구현되어 있는지 확인해야 한다. 

  ```
  리스트에서 제거한 숫자는 95362과 3154이며, 이 중 95362을 알고 있을 때 찾은 나머지 숫자는 3154입니다.
  ```

### [문제에 대한 이해]

- XOR 연산은 어떤 연산인가?
- 이 문제를 해결하기 위해서 XOR 연산의 어떤 특성을 사용하였는가?
- 만약 전체 리스트에서 홀수인 수가 2개 있다고 가정해보자. 이때 XOR 연산의 결과는 무엇인가?
- (보너스 과제를 해결한 경우)문제를 해결하는데 사용한 방법을 설명하라.

### [코드 예시]

```python
def find_solo(arr):
    result = 0
    for i in arr:
        result ^= i
    return result

def find_second_solo(xor_result, n):
    return n ^ xor_result

def make_sample_list(size):
    arr = []
    for i in range((size + 1) // 2):
        random_number = random.randint(1, 100000)
        arr.append(random_number)
        arr.append(random_number)
    random.shuffle(arr)
    removed = arr.pop()
    return arr, removed

def make_sample_list2(size):
    arr = []
    for i in range((size + 1) // 2):
        random_number = random.randint(1, 100000)
        arr.append(random_number)
        arr.append(random_number)
    random.shuffle(arr)
    removed1 = arr.pop()
    removed2 = arr.pop()
    return arr, removed1, removed2

import random
def main():
    n = 999999
    arr, removed = make_sample_list(n)
    solo = find_solo(arr)
    print(f"리스트에서 찾은 외로운 숫자는 {solo}이며, 이는 예상대로 {removed}입니다.")

    n = 999998
    arr, removed1, removed2 = make_sample_list2(n)
    xor_result = find_solo(arr)
    solo = find_second_solo(xor_result, removed1)
    print(f"리스트에서 제거한 숫자는 {removed1}과 {removed2}이며, 이 중 {removed1}을 알고 있을 때 찾은 나머지 숫자는 {solo}입니다.")


if __name__ == '__main__':
    main()
```

---

# 문제 8. 빠르게 차이를 확인하라

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

세포의 약물 반응을 연구하는 C 연구원은 특정 기능의 새로운 후보 물질을 세포에 투여한 후 기존 물질과 얼마나 차이가 나는지를 확인하고 있다. 다만 세포마다 약물에 반응하는 방법이 다르기 때문에, 같은 세포에서 분열된 두 개의 세포 쌍을 대상으로 두 개의 약물의 결과가 얼마나 다른지를 다음과 같이 확인하기로 했다.

> - 서로 같은 성질을 가진 세포는 리스트에서 같은 위치에 표현된다.
> - 약물에 양성 반응을 보인 세포는 1, 음성 반응을 보인 세포는 0으로 표시된다. 예를 들어서 3개의 세포가 각각 기존 약품에 양성, 음성, 음성의 반응을 보이고, 새로운 후보 물질 A에 양성, 양성, 양성의 반응을 보이면, 각각 [1, 0, 0], [1, 1, 1]로 표현한다.
> - 두 약물의 차이는 서로 다른 결과가 나온 횟수로 계량한다. 즉 위의 예시에서 두 약물의 차이는 2이다. 이 차이를 '반응 거리'라고 부르기로 한다. 
> - 만약 다른 후보 물질 B를 4개의 세포를 대상으로 실험한 결과가 [0, 1, 1, 0]과 [1, 1, 0, 0]이라면 반응 거리는 2가 된다. 
> - 정규화 반응 거리는 이 값을 실험에 사용한 세포 수로 나눈 값이다. 후보 물질 A의 정규화 반응 거리는 2/3, 후보 물질 B의 정규화 반응 거리는 2/4 = 1/2 이므로 두 후보 물질 중 후보 물질 A의 결과가 더 큰 차이가 난다고 이야기 할 수 있다.

실험 결과가 이와 같이 리스트로 출력되도록 실험 장비의 설정을 요청하고, 그 다음날 출근해 보니, 약간 어긋난 방식으로 설정이 되어 있었다. 1과 0으로 표현된 리스트 대신, 각각을 이진수를 십진수로 바꾸는 방식의 숫자가 나오도록 실험이 설정되어 있었다. 예를 들어 위의 첫 번째 경우는 [1, 0, 0] 과 [1, 1, 1] 대신 4와 7이, 두 번째 경우는 [0, 1, 1, 0]과 [1, 1, 0, 0] 대신 6과 12가 출력된다.

설정을 정정해달라고 다시 메일을 쓰니, 이런 답신이 도착했다.

'설정을 수정하지 않고도 거리를 구할 수 있습니다.'

## 수행목표

* 어떤 두 수가 주어졌을 때 두 수의 반응거리는 두 수를 이진수로 바꾼 다음 같은 위치 비트의 값이 다른 경우의 합으로 정의한다. 
  * 예를 들어 두 수가 4와 7인 경우, 두 수를 이진수로 바꾸면 100, 111이며, 대응되는 비트의 값이 2개가 다르므로 거리는 2이다.
  * 두 수를 이진수로 바꾼 후 자릿수가 다르다면, 가장 오른쪽 자리부터 비교를 시작한다.
    * 6, 12의 경우 이진수로 바꾸면 110, 1100이고, 이를 오른쪽부터 대응되는 비트끼리 비교해보면 거리는 2이다. (6을 0110이라고 생각하고 비교하는 것과 동일하다.)
    * 6, 20의 경우 이진수로 바꾸면 110, 10100이고, 이를 오른쪽부터 대응되는 비트끼리 비교해보면 거리는 2이다. (6을 00100이라고 생각하고 비교하는 것과 동일하다.) 
  * 두 수의 반응거리를 계산할 때 반드시 XOR 연산을 사용해야 한다.
  * 모든 비교는 20개의 세포를 대상으로 진행되었으며, 실험 결과로 제공되는 두 수는 모두 0 이상 $2^{20} - 1$ 이하의 정수이다.
* 다음 첨부 파일에는 세 개의 테스트케이스가 들어 있다.
  * 첫 번째 테스트케이스에는 5개의 후보 물질에 대한 실험, 두 번째 테스트케이스는 1000개의 후보 물질에 대한 실험, 그리고 마지막 테스트케이스는 10000개의 후보 물질에 대한 실험이다.
  * 각각의 테스트케이스에서 기존 물질과 가장 차이가 큰 반응을 보인 (즉 기존 물질과 반응거리가 가장 먼) 후보 물질의 번호들의 합을 출력한다. 각 테스트케이스에서 첫 번째 테스크테이스를 1번으로 한다.

## 수행단계

- number/distance.py 파일에 두 수로 표현된 의 '반응거리'를 계산하는 함수를 구현한다.

  - 반응거리를 구할 때 분모는 1000개의 세포를 대상으로 진행되었으므로 1000이 된다.
  - 두 수의 반응거리를 계산할 때 반드시 XOR 연산을 사용한다.

- 테스트케이스는 1번 행 부터 5번 행 까지가 첫 번째, 6번 행부터 1005번 행 까지가 두 번째, 1006번 행 부터 11005번 행 까지가 세 번째 테스트케이스이다. 각 줄에는 후보 물질과 기존 물질 각각의 결과를 컴마로 구분된 두 개의 숫자로 출력하고 있다.

- 예를 들어 5개의 후보 물질을 기존 물질과 비교한 실험 결과가 다음과 같이 주어질 때의 거리는 다음과 같다.

  | 결과 A | 결과 B | 결과 A 이진표현 | 결과 B 이진표현 | 반응 거리 | 정규화 반응 거리 |
  | ------ | ------ | --------------- | --------------- | --------- | ---------------- |
  | 26     | 13     | 11010           | 1101            | 4         | 0.4              |
  | 173    | 717    | 10101101        | 1011001101      | 3         | 0.3              |
  | 17     | 142    | 10001           | 10001110        | 6         | 0.6              |
  | 123    | 13     | 1111011         | 1101            | 5         | 0.5              |
  | 154    | 77     | 10011010        | 1001101         | 6         | 0.6              |

  * 그러므로 3번째와 5번째가 가장 거리가 크며, 이 때는 이 익덱스들의 합인 8을 출력한다.

## 결과예시

```
testcase 1의 결과 : 8
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/distance.py 파일에 구현이 되어 있는지 확인한다.
  - 두 수의 반응 거리를 계산하는 과정에서 XOR 연산을 사용하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    testcase 1의 결과 : 8
    testcase 2의 결과 : 1862
    testcase 3의 결과 : 269
    ```

### [문제에 대한 이해]

- XOR 연산으로 두 수의 반응 거리를 계산하는 방식과 이 때 사용된 XOR 연산의 특징을 설명하라.

### [코드 예시]

```python

def distance(arr):
    max = -1
    count = 0
    idx = []
    for i, (n1, n2) in enumerate(arr):                
        xor_result = n1 ^ n2
        count = bin(xor_result).count('1')
        if count > max:
            max = count
            idx = [i + 1]
        elif count == max:
            idx.append(i + 1)
    return idx, max

# bin 함수를 사용하지 않는 경우. 실행 시간이 조금 더 걸린다.
def distance2(arr):
    max = -1
    idx = []
    for i, (n1, n2) in enumerate(arr):                
        xor_result = n1 ^ n2
        count = 0
        while xor_result > 0:
            if xor_result % 2 == 1:
                count += 1
            xor_result //= 2
        if count > max:
            max = count
            idx = [i + 1]
        elif count == max:
            idx.append(i + 1)
    return idx, max

@execute_time


def make_test_list(size):
    arr = []
    for i in range(size):
        n1 = random.randint(0, 1023)
        n2 = random.randint(0, 2 ** 20 - 1)
        # n1 = random.randint(0, 1023)
        # n2 = random.randint(0, 1023)
        arr.append((n1, n2))
    return arr

def main():
    with open("new_chemical_test.txt", "r") as f:
        lines = f.readlines()
        testcases = []
        tc1 = []
        for i in range(5):
            tc1.append(tuple(map(int, lines[i].split(','))))
        testcases.append(tc1)
        tc2 = []
        for i in range(5, 1005):
            tc2.append(tuple(map(int, lines[i].split(','))))
        testcases.append(tc2)
        tc3 = []
        for i in range(1005, 11005):
            tc3.append(tuple(map(int, lines[i].split(','))))
        testcases.append(tc3)

    for i, tc in enumerate(testcases):        
        idx, _ = distance(tc)
        print(f"testcase {i + 1}의 결과 : {sum(idx)}")

if __name__ == '__main__':
    main()
```

# 단계 3. 문제 해결 접근의 기초

## 스토리

! 스토리 추가

---

# 문제 1. 모든 조합을 찾아라.

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

유전자 염기서열은 'C', 'T', 'A', 'G' 네 개의 염기로 모든 유전 정보를 코딩하고 있다. 서로 다른 유전자 염기 서열은 서로 다른 유전 정보를 의미하기 때문에, C, T, A, G 네 글자로 만들 수 있는 문자열이 유전자에 포함된 유전 정보라고 말할 수 있고, 문자열이 달라지면 다른 유전 정보를 의미한다고 말할 수도 있다.

닥터 G와 같은 연구 그룹에서 유전자 염기서열의 결과로 각 개체가 달라지는 현상을 연구하는 D 연구원은 네 가지 염기로 만들 수 있는 유전 정보에 대해서 확인해보고자 한다.

## 수행목표

- 사용할 문자의 리스트를 파라미터로 받는 다음 세 종류의 함수를 구현한다. (리스트에 포함된 문자는 중복되지 않는다.)

  - 이 문자를 사용해 구성할 수 있는 모든 '조합'의 목록을 반환하는 함수
  - 이 문자를 한 번씩 사용해 만들 수 있는 모든 단어의 목록을 반환하는 함수
  - 이 문자를 최대 한 번만 사용해 만들 수 있는 모든 단어의 목록을 반환하는 함수

- 'C', 'T', 'A', 'G' 네 개의 문자가 주어졌을 때 위 세 함수를 사용해 구한 목록의 길이와 목록을 출력한다.

## 수행단계

- 완전 탐색법에 대해서 조사한다.
- 완전 탐색법으로 주어진 리스트에 포함된 문자를 사용해서 구성할 수 있는 모든 조합을 반환하는 함수, 리스트에 포함된 문자를 한 번씩 사용해서 구성할 수 있는 모든 단어의 목록을 반환하는 함수, 리스트에 포함된 문자를 최대 한 번씩 사용해서 구성할 수 있는 모든 단어의 목록을 반환하는 함수를 basic_approach/every_case.py 파일에 구현한다.
- ['C', 'T', 'A', 'G'] 리스트에 대한 세 함수의 결과에 대해서, 이 목록을 sort 함수로 정렬한 후 그 결과를 출력한다.

## 결과 예시

- 생략

## 참고사항

- 이 문제에서는 허용되지 않지만, itertools 모듈을 사용하면 이런 종류의 문제를 쉽게 해결할 수 있다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 그 어떤 생물의 유전자도 단순하게 구성되지 않는다. 조금 더 현실적인 유전 정보의 목록을 구하기 위해서 다음과 같은 함수를 구현해보자.

  - 중복되지 않은 문자로 구성된 리스트에 대해서, 리스트에 포함된 문자를 각각 최대 n번까지 사용해서 만들 수 있는 모든 단어의 목록을 반환하는 함수

- ['C', 'T', 'A', 'G'] 리스트에 포함된 문자를 각각 최대 2번까지 사용해서 만들 수 있는 모든 단어의 목록과 단어의 개수를 출력한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/every_case.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.

  - 조합에는 빈 리스트가 포함되어야 하며, 단어에는 빈 문자열 단어가 포함되어서는 안된다.

  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    모든 조합 목록의 길이는 16입니다.
        모든 조합의 목록 : [[], ['C'], ['T'], ['C', 'T'], ['A'], ['C', 'A'], ['T', 'A'], ['C', 'T', 'A'], ['G'], ['C', 'G'], ['T', 'G'], ['C', 'T', 'G'], ['A', 'G'], ['C', 'A', 'G'], ['T', 'A', 'G'], ['C', 'T', 'A', 'G']]

    한 번씩 사용해 만든 모든 단어의 수는 24입니다.
        모든 단어의 목록 : ['CTAG', 'CTGA', 'CATG', 'CAGT', 'CGTA', 'CGAT', 'TCAG', 'TCGA', 'TACG', 'TAGC', 'TGCA', 'TGAC', 'ACTG', 'ACGT', 'ATCG', 'ATGC', 'AGCT', 'AGTC', 'GCTA', 'GCAT', 'GTCA', 'GTAC', 'GACT', 'GATC']

    최대 한 번씩 사용해 만든 모든 단어의 수는 64입니다.
        모든 단어의 목록 : ['CTAG', 'TAG', 'CAG', 'AG', 'CTG', 'TG', 'CG', 'G', 'CTGA', 'TGA', 'CGA', 'GA', 'CTA', 'TA', 'CA', 'A', 'CATG', 'ATG', 'CAGT', 'AGT', 'CGT', 'GT', 'CAT', 'AT', 'CT', 'T', 'CGTA', 'GTA', 'CGAT', 'GAT', 'TCAG', 'TCG', 'TCGA', 'TCA', 'TACG', 'ACG', 'TAGC', 'AGC', 'TGC', 'GC', 'TAC', 'AC', 'TC', 'C', 'TGCA', 'GCA', 'TGAC', 'GAC', 'ACTG', 'ACGT', 'ACT', 'ATCG', 'ATGC', 'ATC', 'AGCT', 'GCT', 'AGTC', 'GTC', 'GCTA', 'GCAT', 'GTCA', 'GTAC', 'GACT', 'GATC']
    ```

### [보너스 과제 확인]

- 각각의 문자를 최대 n번까지 사용해서 만들 수 있는 모든 단어를 반환하는 함수를 구현하고, 입력에 대해서 정확한 결과를 출력하였는가?

  - 결과 예시는 다음과 같다. 전체 목록의 출력은 일부만 포함하고 있다.

    ```
    최대 두 번씩 사용해 만든 모든 단어의 수는 7364입니다.
        모든 단어의 목록 : ['CTAGCTAG', 'TAGCTAG', 'CAGCTAG', 'AGCTAG', 'CTGCTAG', 'TGCTAG', 'CGCTAG', 'GCTAG', 'CTACTAG', 'TACTAG', 'CACTAG', 'ACTAG', 'CTCTAG', 'TCTAG', 'CCTAG', 'CTAG', 'CTAGTAG', 'TAGTAG', 'CAGTAG', ...
    (이하 생략)
    ```

### [문제에 대한 이해]

- 완전 탐색법이란 무엇인가?
- 모든 조합, 모든 단어를 구하기 위해서 어떤 방법을 사용하였는가?
- 중복이 없이 목록을 구하기 위해서 사용한 메커니즘을 설명하라.
- 구현한 알고리즘의 시간 복잡도를 제시하라.
- (재귀 호출로 구현한 경우)재귀 호출을 사용하지 않은 알고리즘을 제시해보라.
- (재귀 호출로 구현하지 않은 경우)재귀 호출을 사용하는 알고리즘을 제시해보라.

### [코드 예시]

```python
def every_combinations(letters):
    if len(letters) == 0:
        return []
    if len(letters) == 1:
        return [[], [letters[0]]]
    result = []
    following_result = every_combinations(letters[1:])
    for combination in following_result:
        result.append(combination)
        result.append([letters[0]] + combination)
    return result

def every_permutations(letters):
    if len(letters) == 0:
        return []
    if len(letters) == 1:
        return [letters[0]]
    result = []
    for i in range(len(letters)):
        head = letters[i]
        rest = letters[:i] + letters[i + 1:]
        following_result = every_permutations(rest)
        for combination in following_result:
            result.append(head + combination)
    return result

def every_words(letters):
    if len(letters) == 1:
        return [letters[0]]
    result = []
    for i in range(len(letters)):
        following_result = every_words(letters[:i] + letters[i + 1:])
        for combination in following_result:
            if letters[i] + combination not in result:
                result.append(letters[i] + combination)
            if combination not in result:
                result.append(combination)
    return result

def every_words_with_max_count_per_letter(letters, max_count):
    letters_extended = letters * max_count
    return every_words(letters_extended)


def main():
    letters = ['C', 'T', 'A', 'G']
    every_combinations_result = every_combinations(letters)
    print(f"모든 조합 목록의 길이는 {len(every_combinations_result)}입니다.")
    print(f"    모든 조합의 목록 : {every_combinations_result}\n")
    every_permutations_result = every_permutations(letters)
    print(f"한 번씩 사용해 만든 모든 단어의 수는 {len(every_permutations_result)}입니다.")
    print(f"    모든 단어의 목록 : {every_permutations_result}\n")
    every_words_result = every_words(letters)
    print(f"최대 한 번씩 사용해 만든 모든 단어의 수는 {len(every_words_result)}입니다.")
    print(f"    모든 단어의 목록 : {every_words_result}\n")
    every_words_result_with_max_2 = every_words_with_max_count_per_letter(letters, 2)
    print(f"최대 두 번씩 사용해 만든 모든 단어의 수는 {len(every_words_result_with_max_2)}입니다.")
    print(f"    모든 단어의 목록 : {every_words_result_with_max_2}")

if __name__ == "__main__":
    main()

```

---

# 문제 2. 넘어가면 폭발합니다.

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

C 연구원은 세포 약물 반응과 관련된 새로운 후보 물질을 찾고 있다. 이번에는 기존 화합물을 조합해서 새로운 후보 물질을 찾고 있는데, 그 중 특정 성분 B 때문에 골치가 아픈 상황이었다. 조합의 결과로 나온 물질에 이 성분이 부족하면 효과가 없는데, 이 성분이 어떤 값을 넘어가면 물질의 매우 불안정해져서 폭발 가능성이 있기 때문이다.

C 연구원은 조합할 재료 물질들에 이 성분의 양을 리스트로 만든 후, 조합 후 목표 양에 따라서 조합할 수 있는 모든 방법을 먼저 찾아두기로 했다. 그리고 그 방법을 찾기 위해서 프로그래밍 지원 게시판에 도움을 청했다.

## 수행목표

- 양의 정수를 항목으로 가지는 리스트와 목표 값이 주어졌을 때, 합이 목표값과 동일한 모든 조합의 인덱스의 리스트의 리스트를 반환하는 함수를 구현한다.

  - 예를 들어 주어진 리스트가 [1, 2, 3, 4, 5]이고, 목표값이 5인 경우 2 + 3, 1 + 4, 5 3 가지 조합이 가능하다. 이 때 이들의 인덱스에 해당하는 [[1, 2], [0, 3], [4]]를 반환한다.

- 다음 리스트들은 총 10개의 테스트케이스의 튜플이다. 각각의 테스트케이스에 대해서 전체 조합의 수와 첫 10개의 조합을 출력한다. (조합의 수가 10개 이하인 경우, 전체를 출력한다.)

  - 각 테스트케이스 튜플의 첫 번째 값은 화합물에 포함된 성분 B의 양의 목록이며, 두 번째 값은 목표값이다.

  - 출력되는 리스트는 숫자를 항목으로 가지는 내부 리스트의 경우는 오름차순으로 정렬하고, 리스트를 항목으로 가지는 외부 리스트의 경우는 파이썬에서 리스트 간의 크기를 정하는 기본 원칙에 따라 정렬한다. 파이썬에서 리스트 간의 크기를 정하는 기본 원칙은 일반적으로 sort 함수의 결과이며, 참고사항을 참고한다.

  - 위의 예시에서는 전체 조합의 수는 3, 그리고 조합은 [0, 3], [1, 2], [4] 순서로 출력되어야 한다.

    ```python
    tc1 = ([1, 2, 3, 4, 5], 5)
    tc2 = ([1, 2, 3, 4, 5], 6)
    tc3 = ([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 6)
    tc4 = ([1, 2, 3, 4, 5], 15)
    tc5 = ([1, 2, 3, 4, 5], 16)
    tc6 = ([5, 3, 5, 6, 3, 5, 3, 3, 6, 6, 3, 4, 5, 4, 4, 6, 5, 6, 5, 6, 3, 5, 5, 3, 3, 5, 4, 4, 5, 5], 20)
    tc7 = ([20, 18, 18, 15, 11, 14, 15, 11, 16, 18, 18, 15, 12, 15, 11, 20, 17, 16, 18, 20, 13, 13, 20, 18, 12, 14, 17, 11, 10, 13, 17, 19, 14, 15, 16, 19, 13, 18, 20, 17, 18, 11, 16, 19, 16, 14, 18, 17, 19, 14, 19, 12, 16, 16, 15, 17, 15, 10, 17, 15, 20, 10, 20, 17, 11, 18, 19, 15, 18, 20, 19, 18, 14, 18, 14, 14, 10, 20, 14, 19, 15, 20, 10, 11, 11, 11, 12, 15, 20, 13, 18, 10, 10, 19, 12, 16, 14, 20, 10, 18], 40)
    tc8 = ([20, 18, 18, 15, 11, 14, 15, 11, 16, 18, 18, 15, 12, 15, 11, 20, 17, 16, 18, 20, 13, 13, 20, 18, 12, 14, 17, 11, 10, 13, 17, 19, 14, 15, 16, 19, 13, 18, 20, 17, 18, 11, 16, 19, 16, 14, 18, 17, 19, 14, 19, 12, 16, 16, 15, 17, 15, 10, 17, 15, 20, 10, 20, 17, 11, 18, 19, 15, 18, 20, 19, 18, 14, 18, 14, 14, 10, 20, 14, 19, 15, 20, 10, 11, 11, 11, 12, 15, 20, 13, 18, 10, 10, 19, 12, 16, 14, 20, 10, 18], 60)
    tc9 = ([2481, 8036, 3389, 3790, 1044, 4305, 4907, 5996, 3004, 6500, 9786, 6862, 7324, 1150, 8408, 8334, 7769, 3037, 2345, 1126, 4308, 9188, 2480, 7235, 5217, 3103, 7233, 5720, 5271, 2273, 8331, 2292, 8739, 1733, 9435, 1924, 3320, 5345, 1882, 4347, 8143, 5551, 9293, 8634, 1585, 7123, 7119, 8689, 2786, 1729, 1734, 9367, 4808, 188, 1857, 7509, 2708, 7546, 6561, 3511, 6187, 6927, 5803, 6529, 4065, 9270, 5555, 4860, 6915, 3287, 3093, 8325, 2572, 9825, 994, 9806, 8642, 3831, 3411], 10005)
    tc10 = ([[4224, 2041, 1569, 8560, 9851, 5415, 6248, 1357, 6937, 2822, 3464, 7678, 3209, 657, 5501, 738, 223, 471, 4389, 1648, 1973, 6075, 9541, 341, 308, 174, 7478, 5547, 770, 9271, 6213, 6488, 7256, 5624, 281, 8023, 8185, 6738, 624, 8544, 7372, 564, 1367, 5879, 278, 9189, 3304, 5705, 4936, 6785, 9983, 7050, 6214, 7025, 7313, 8274, 3167, 271, 9306, 7421, 9549, 3684, 7470, 9244, 6777, 1663, 3463, 1669, 8575, 5044, 4105, 5520, 8797, 9588, 2981, 9806, 7911, 4315, 1533, 7284, 9412, 2675, 2242, 1478, 6462, 2964, 1187, 3002, 3840, 1314, 9641, 1093, 7458, 5014, 6746, 4487, 3686, 7536, 7211, 2992, 4625, 1888, 3512, 7846, 1085, 2032, 3463, 1339, 3146, 5946, 8545, 3850, 6284, 7175, 4946, 3891, 3696, 5901, 3769, 7254, 6134, 2548, 2954, 8147, 1863, 8697, 1114, 4628, 1113, 6924, 2244, 7082, 9041, 9684, 3257, 9028, 4802, 3651, 8607, 4120, 1915, 4657, 9032, 8416, 7016, 2890, 8121, 3314, 8456, 8463, 3153, 7461, 7012, 1523, 3716, 9030, 6701, 5595, 3761, 2883, 1871, 8128, 5137, 8696, 1842, 7012, 1975, 5970, 10000, 8254, 6488, 8952, 6113, 8962, 4640, 9718, 7544, 2588, 4404, 9106, 9010, 9593, 7653, 5193, 5092, 4153, 8618, 6224, 2450, 1034, 9120, 1235, 9237, 1492, 6334, 9749, 6685, 7967, 5115, 4413, 7441, 7057, 2803, 3486, 1781, 8377, 4469, 8804, 2546, 7849, 7258, 2610, 6745, 3422, 9129, 7795, 2303, 2739, 5187, 7639, 4356, 7242, 6361, 9227, 5979, 6719, 3003, 3234, 3647, 6834, 4357, 8801, 8065, 3672, 7061, 8221, 8307, 1942, 7166, 8879, 8239, 1130, 7193, 7824, 9197, 5484, 3046, 2601, 5965, 2849, 3185, 4330, 6693, 6125, 9560, 5937, 1091, 5416, 1353, 3079, 6696, 1337, 3840, 1122, 1998, 1344, 4899, 3210, 6789, 7279, 2013, 2760, 9202, 1610, 7475, 3865, 7003, 4602, 2445, 7947, 9600, 6436, 3425, 5776, 1463, 7570, 2492, 2437, 1620, 4681, 1474, 3410, 4991, 4079, 6735, 1482, 4100, 2170, 8753, 4141, 1070, 1031, 6600, 5325, 3066, 5173, 1923, 1544, 9497, 3334, 9486, 3335, 6918, 4339, 3424, 4596, 2760, 7717, 2665, 1036, 3910, 8601, 7826, 6350, 9490, 7367, 2798, 5080, 5634, 2502, 2840, 3645, 9736, 7048, 1995, 3749, 9745, 5144, 8842, 1874, 4692, 5789, 8889, 2311, 2731, 4821, 2670, 9755, 2267, 2489, 6850, 1244, 5953, 5043, 2350, 4510, 5758, 7953, 4292, 8274, 4197, 7604, 8554, 1580, 4539, 7634, 3422, 7471, 7748, 3606, 8036, 2657, 3513, 7720, 3461, 3657, 7083, 5948, 8136, 9568, 5479, 7497, 2874, 4557, 5486, 6092, 6259, 9792, 4979, 4055, 7793, 2422, 8134, 3147, 4141, 2514, 9874, 4264, 1314, 3107, 6323, 3982, 8473, 1048, 7287, 3000, 3216, 7100, 2413, 7494, 2116, 2552, 7122, 2226, 2318, 6061, 1472, 8641, 8978, 4025, 2864, 7647, 9478, 5256, 7498, 3082, 3284, 1036, 6102, 2239, 1050, 5662, 3818, 7911, 2080, 8815, 2663, 6517, 3274, 3942, 7235, 9393, 4001, 4578, 3158, 2044, 4068, 9196, 7463, 3758, 6054, 5170, 6334, 9821, 7579, 5085, 7787, 9647, 7485, 7008, 5339, 1691, 4341, 4866, 5041, 4006, 4162, 5596, 3074, 7537, 5408, 5739, 1658, 1528, 9282, 2392, 1628, 3107, 7026, 8404, 4547, 1903, 8500, 4672, 4884, 3667, 7894, 5808, 2158, 8974, 1726, 7373, 4515, 1060, 6552, 7660, 6115, 8777, 5265, 8599, 5219, 3587, 9810, 3456, 9508, 7737, 4132, 3951, 9727, 7423, 4700, 6450, 4452, 7200, 8296, 9258, 1510, 5533, 2017, 6778, 9216, 3116, 8426, 4884, 2010, 4531, 7832, 6423, 6701, 4691, 5919, 3423, 3335, 9939, 8006, 6470, 2373, 1127, 2307, 4054, 3862, 1844, 3184, 9856, 3246, 1964, 8490, 9038, 5988, 9885, 5040, 1250, 4864, 6588, 1940, 1878, 7012, 5063, 7101, 1606], 961])

    ```

## 수행단계

- 백트래킹에 대해서 조사한다.
- 리스트에서 항목의 합이 주어진 값이 되는 모든 조합을 찾는 함수를 basic_approach/mixing_chemical.py 파일에 구현한다.

  - 이 함수는 백트래킹을 사용해서 조합에 검토하지 않은 남은 항목에 있더라도 더 이상 검토할 필요가 없다고 판단된다면 해당 항목은 검토하지 않도록 구현한다.
  - 백트래킹이 정상적으로 적용되지 않은 경우, 테스트케이스 중 일부에서 조합을 찾는데 매우 긴 시간이 걸리게 될 것이다.

- 제공된 테스트케이스를 사용해 결과를 구하고, 결과 목록의 갯수와 정렬된 내부 리스트의 정렬된 외부 리스트를 기준으로 첫 10개의 조합 방법의 목록을 출력한다.

## 결과예시

```
testcase 1
    모든 조합의 수 : 3
    첫 10개의 조합 : [[0, 3], [1, 2], [4]]

testcase 2
    모든 조합의 수 : 3
    첫 10개의 조합 : [[0, 1, 2], [0, 4], [1, 3]]
(이하 생략)
```

## 참고사항

- 파이썬에서 리스트의 크기를 정하는 원칙은 다음과 같다. 파이썬 3.9 버전 기준으로 sort 함수는 이 원칙을 기준으로 정렬된다.

  - 첫 번째 원소를 비교한다. 만약 첫 번째 원소가 동일하다면, 그 다음 원소를 비교하는 방식으로 같은 길이까지 비교한다.

  - 같은 길이까지 항목이 모두 동일한 경우, 그 다음에는 짧은 리스트가 더 작다.

  - 다음 결과를 참고하자.

    ```python
    >>> [1, 2, 3] > [2, 2, 3]
    False
    >>> [1, 2, 3] > [1, 3, 3]
    False
    >>> [1, 2, 3] > [1, 2, 3, 4]
    False
    >>> [1, 2, 3] == [1, 2, 3]
    True
    ```

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/mixing_chemical.py 파일에 구현이 되어 있는지 확인한다.
  - 백트래킹을 사용해서 탐색 도중에 목표양을 초과한 경우 더 이상 탐색하지 않도록 구현되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    testcase 1
        모든 조합의 수 : 3
        첫 10개의 조합 : [[0, 3], [1, 2], [4]]

    testcase 2
        모든 조합의 수 : 3
        첫 10개의 조합 : [[0, 1, 2], [0, 4], [1, 3]]

    testcase 3
        모든 조합의 수 : 20
        첫 10개의 조합 : [[0, 1, 2], [0, 1, 5, 6], [0, 1, 7], [0, 2, 6], [0, 3, 5], [0, 4], [0, 5, 8], [0, 6, 7], [0, 9], [1, 2, 5]]

    testcase 4
        모든 조합의 수 : 1
        첫 10개의 조합 : [[0, 1, 2, 3, 4]]

    testcase 5
        조합이 존재하지 않습니다.

    testcase 6
        모든 조합의 수 : 18723
        첫 10개의 조합 : [[0, 1, 2, 4, 11], [0, 1, 2, 4, 13], [0, 1, 2, 4, 14], [0, 1, 2, 4, 26], [0, 1, 2, 4, 27], [0, 1, 2, 6, 11], [0, 1, 2, 6, 13], [0, 1, 2, 6, 14], [0, 1, 2, 6, 26], [0, 1, 2, 6, 27]]

    testcase 7
        모든 조합의 수 : 6050
        첫 10개의 조합 : [[0, 15], [0, 19], [0, 22], [0, 28, 57], [0, 28, 61], [0, 28, 76], [0, 28, 82], [0, 28, 91], [0, 28, 92], [0, 28, 98]]

    testcase 8
        모든 조합의 수 : 415130
        첫 10개의 조합 : [[0, 1, 4, 7], [0, 1, 4, 14], [0, 1, 4, 27], [0, 1, 4, 41], [0, 1, 4, 64], [0, 1, 4, 83], [0, 1, 4, 84], [0, 1, 4, 85], [0, 1, 7, 14], [0, 1, 7, 27]]

    testcase 9
        모든 조합의 수 : 54
        첫 10개의 조합 : [[0, 8, 48, 50], [2, 19, 20, 53, 74], [2, 19, 35, 72, 74], [3, 4, 13, 31, 49], [3, 4, 44, 49, 54], [3, 44, 50, 53, 56], [4, 5, 13, 33, 44, 53], [4, 8, 19, 48, 53, 54], [4, 9, 29, 53], [4, 13, 22, 31, 53, 54, 74]]

    testcase 10
        모든 조합의 수 : 2
        첫 10개의 조합 : [[15, 16], [16, 25, 41]]
    ```

### [문제에 대한 이해]

- 백트래킹의 개념을 설명하라.
- 구현한 코드에서 백트래킹을 사용한 부분을 찾아 설명하라.
- 만약 입력 리스트가 정렬되어 있다면 구현한 함수의 성능은 어떻게 될 것인지 설명해보자.

### [코드 예시]

```python
def chemical_combination(chemicals, target_amount, current_combinations = None, current_idx = 0):
    if current_combinations == None:
        current_combinations = []
    if target_amount == 0:
        return current_combinations
    if target_amount < 0:
        return None
    if current_idx == len(chemicals):
        return None
    result = []

    current_chemical = chemicals[current_idx]
    if current_chemical == target_amount:
        result.append(current_combinations + [current_idx])
    elif current_chemical < target_amount:
        result_with_current = chemical_combination(chemicals, target_amount - current_chemical, current_combinations + [current_idx], current_idx + 1)
        if result_with_current != None:
            result += result_with_current
    result_without_current = chemical_combination(chemicals, target_amount, current_combinations, current_idx + 1)
    if result_without_current != None:
        result += result_without_current
    return result

def main():
    tc1 = ([1, 2, 3, 4, 5], 5)
    tc2 = ([1, 2, 3, 4, 5], 6)
    tc3 = ([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 6)
    tc4 = ([1, 2, 3, 4, 5], 15)
    tc5 = ([1, 2, 3, 4, 5], 16)
    tc6 = ([5, 3, 5, 6, 3, 5, 3, 3, 6, 6, 3, 4, 5, 4, 4, 6, 5, 6, 5, 6, 3, 5, 5, 3, 3, 5, 4, 4, 5, 5], 20)
    tc7 = ([20, 18, 18, 15, 11, 14, 15, 11, 16, 18, 18, 15, 12, 15, 11, 20, 17, 16, 18, 20, 13, 13, 20, 18, 12, 14, 17, 11, 10, 13, 17, 19, 14, 15, 16, 19, 13, 18, 20, 17, 18, 11, 16, 19, 16, 14, 18, 17, 19, 14, 19, 12, 16, 16, 15, 17, 15, 10, 17, 15, 20, 10, 20, 17, 11, 18, 19, 15, 18, 20, 19, 18, 14, 18, 14, 14, 10, 20, 14, 19, 15, 20, 10, 11, 11, 11, 12, 15, 20, 13, 18, 10, 10, 19, 12, 16, 14, 20, 10, 18], 40)
    tc8 = ([20, 18, 18, 15, 11, 14, 15, 11, 16, 18, 18, 15, 12, 15, 11, 20, 17, 16, 18, 20, 13, 13, 20, 18, 12, 14, 17, 11, 10, 13, 17, 19, 14, 15, 16, 19, 13, 18, 20, 17, 18, 11, 16, 19, 16, 14, 18, 17, 19, 14, 19, 12, 16, 16, 15, 17, 15, 10, 17, 15, 20, 10, 20, 17, 11, 18, 19, 15, 18, 20, 19, 18, 14, 18, 14, 14, 10, 20, 14, 19, 15, 20, 10, 11, 11, 11, 12, 15, 20, 13, 18, 10, 10, 19, 12, 16, 14, 20, 10, 18], 60)
    tc9 = ([2481, 8036, 3389, 3790, 1044, 4305, 4907, 5996, 3004, 6500, 9786, 6862, 7324, 1150, 8408, 8334, 7769, 3037, 2345, 1126, 4308, 9188, 2480, 7235, 5217, 3103, 7233, 5720, 5271, 2273, 8331, 2292, 8739, 1733, 9435, 1924, 3320, 5345, 1882, 4347, 8143, 5551, 9293, 8634, 1585, 7123, 7119, 8689, 2786, 1729, 1734, 9367, 4808, 188, 1857, 7509, 2708, 7546, 6561, 3511, 6187, 6927, 5803, 6529, 4065, 9270, 5555, 4860, 6915, 3287, 3093, 8325, 2572, 9825, 994, 9806, 8642, 3831, 3411], 10005)
    tc10 = ([[4224, 2041, 1569, 8560, 9851, 5415, 6248, 1357, 6937, 2822, 3464, 7678, 3209, 657, 5501, 738, 223, 471, 4389, 1648, 1973, 6075, 9541, 341, 308, 174, 7478, 5547, 770, 9271, 6213, 6488, 7256, 5624, 281, 8023, 8185, 6738, 624, 8544, 7372, 564, 1367, 5879, 278, 9189, 3304, 5705, 4936, 6785, 9983, 7050, 6214, 7025, 7313, 8274, 3167, 271, 9306, 7421, 9549, 3684, 7470, 9244, 6777, 1663, 3463, 1669, 8575, 5044, 4105, 5520, 8797, 9588, 2981, 9806, 7911, 4315, 1533, 7284, 9412, 2675, 2242, 1478, 6462, 2964, 1187, 3002, 3840, 1314, 9641, 1093, 7458, 5014, 6746, 4487, 3686, 7536, 7211, 2992, 4625, 1888, 3512, 7846, 1085, 2032, 3463, 1339, 3146, 5946, 8545, 3850, 6284, 7175, 4946, 3891, 3696, 5901, 3769, 7254, 6134, 2548, 2954, 8147, 1863, 8697, 1114, 4628, 1113, 6924, 2244, 7082, 9041, 9684, 3257, 9028, 4802, 3651, 8607, 4120, 1915, 4657, 9032, 8416, 7016, 2890, 8121, 3314, 8456, 8463, 3153, 7461, 7012, 1523, 3716, 9030, 6701, 5595, 3761, 2883, 1871, 8128, 5137, 8696, 1842, 7012, 1975, 5970, 10000, 8254, 6488, 8952, 6113, 8962, 4640, 9718, 7544, 2588, 4404, 9106, 9010, 9593, 7653, 5193, 5092, 4153, 8618, 6224, 2450, 1034, 9120, 1235, 9237, 1492, 6334, 9749, 6685, 7967, 5115, 4413, 7441, 7057, 2803, 3486, 1781, 8377, 4469, 8804, 2546, 7849, 7258, 2610, 6745, 3422, 9129, 7795, 2303, 2739, 5187, 7639, 4356, 7242, 6361, 9227, 5979, 6719, 3003, 3234, 3647, 6834, 4357, 8801, 8065, 3672, 7061, 8221, 8307, 1942, 7166, 8879, 8239, 1130, 7193, 7824, 9197, 5484, 3046, 2601, 5965, 2849, 3185, 4330, 6693, 6125, 9560, 5937, 1091, 5416, 1353, 3079, 6696, 1337, 3840, 1122, 1998, 1344, 4899, 3210, 6789, 7279, 2013, 2760, 9202, 1610, 7475, 3865, 7003, 4602, 2445, 7947, 9600, 6436, 3425, 5776, 1463, 7570, 2492, 2437, 1620, 4681, 1474, 3410, 4991, 4079, 6735, 1482, 4100, 2170, 8753, 4141, 1070, 1031, 6600, 5325, 3066, 5173, 1923, 1544, 9497, 3334, 9486, 3335, 6918, 4339, 3424, 4596, 2760, 7717, 2665, 1036, 3910, 8601, 7826, 6350, 9490, 7367, 2798, 5080, 5634, 2502, 2840, 3645, 9736, 7048, 1995, 3749, 9745, 5144, 8842, 1874, 4692, 5789, 8889, 2311, 2731, 4821, 2670, 9755, 2267, 2489, 6850, 1244, 5953, 5043, 2350, 4510, 5758, 7953, 4292, 8274, 4197, 7604, 8554, 1580, 4539, 7634, 3422, 7471, 7748, 3606, 8036, 2657, 3513, 7720, 3461, 3657, 7083, 5948, 8136, 9568, 5479, 7497, 2874, 4557, 5486, 6092, 6259, 9792, 4979, 4055, 7793, 2422, 8134, 3147, 4141, 2514, 9874, 4264, 1314, 3107, 6323, 3982, 8473, 1048, 7287, 3000, 3216, 7100, 2413, 7494, 2116, 2552, 7122, 2226, 2318, 6061, 1472, 8641, 8978, 4025, 2864, 7647, 9478, 5256, 7498, 3082, 3284, 1036, 6102, 2239, 1050, 5662, 3818, 7911, 2080, 8815, 2663, 6517, 3274, 3942, 7235, 9393, 4001, 4578, 3158, 2044, 4068, 9196, 7463, 3758, 6054, 5170, 6334, 9821, 7579, 5085, 7787, 9647, 7485, 7008, 5339, 1691, 4341, 4866, 5041, 4006, 4162, 5596, 3074, 7537, 5408, 5739, 1658, 1528, 9282, 2392, 1628, 3107, 7026, 8404, 4547, 1903, 8500, 4672, 4884, 3667, 7894, 5808, 2158, 8974, 1726, 7373, 4515, 1060, 6552, 7660, 6115, 8777, 5265, 8599, 5219, 3587, 9810, 3456, 9508, 7737, 4132, 3951, 9727, 7423, 4700, 6450, 4452, 7200, 8296, 9258, 1510, 5533, 2017, 6778, 9216, 3116, 8426, 4884, 2010, 4531, 7832, 6423, 6701, 4691, 5919, 3423, 3335, 9939, 8006, 6470, 2373, 1127, 2307, 4054, 3862, 1844, 3184, 9856, 3246, 1964, 8490, 9038, 5988, 9885, 5040, 1250, 4864, 6588, 1940, 1878, 7012, 5063, 7101, 1606], 961])
    testcases = [tc1, tc2, tc3, tc4, tc5, tc6, tc7, tc8, tc9, tc10]
    for i, tc in enumerate(testcases):
        print(f"testcase {i + 1}")
        combinations = chemical_combination(*tc)
        if len(combinations) == 0:
            print("    조합이 존재하지 않습니다.")
        else:
            print(f"    모든 조합의 수 : {len(combinations)}")
            print(f"    첫 10개의 조합 : {combinations[:10]}")
        print()


if __name__ == "__main__":
    main()

```

---

# 문제 3. 빠르게 찾는다

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

유전자 목록을 정렬해서 관리할 수 있게 된 닥터 G는 여전히 답답한 부분이 남아 있었다. 어떤 유전자 염기서열을 사용해서, 그 유전자 염기 서열이 목록에 있는지, 만약 목록에 없다면 사전순으로 주어진 유전자 염기 서열의 이전, 이후 유전자 염기 서열이 어떤 것인지 알고 싶었다. 그것도 매우 빠르게.

처음부터 차례대로 비교해보기에는 유전자 목록이 너무 많았고, 영어 사전처럼 중간 중간에 첫 글자 인덱스가 붙어 있으면 좋겠지만 그런 것도 준비되어 있지 않았기 때문이다.

생각이 영어 사전에 미치자, 영어 사전에서 단어를 찾는 방법을 활용하면 좋겠다는 생각이 들었다. 아무 페이지나 펼쳐서 그 페이지의 단어와 비교해 앞에서 찾을지 뒤에서 찾을지를 결정하고, 다시 이를 반복하면서 목표 페이지를 찾아가는 방식을 떠올린 것이다.

## 수행목표

- 정렬된 리스트와 찾고자 하는 값이 주어질 때, 그 값이 리스트에 포함되어 있는 경우 그 값의 인덱스를 반환하고, 그 값이 리스트에 없는 경우 만약 그 값이 있었다면 위치해야 할 인덱스를 반환하는 함수를 구현한다.

  - 예를 들어 입력 인덱스가 주어진 리스트가 ['ACT', 'CTA', 'TTA'] 일 때 찾고자 하는 값이 'CTA'이면 1을 반환한다.

  - 주어진 리스트가 [1, 3, 5, 7, 7, 9]일 때 찾고자 하는 값이 6이면 3을 반환한다.

- 첨부한 파일은 10개의 테스트케이스가 포함되어 있다. 각각의 테스트케이스의 실행 결과를 출력한다.

## 수행단계

- 분할 정복 (divide and conquer) 방법에 대해서 조사한다.
- 분할 정복 방식으로 정렬된 리스트에서 찾고자 하는 값의 인덱스 또는 찾고자 하는 값이 있어야 했을 인덱스의 값을 반환하는 함수를 basic_approach/find_from_ordered_data.py 파일에 구현한다.

  - 이 함수의 시간 복잡도는 선형 시간 복잡도 미만이어야 한다.

- 첨부한 파일에 포함된 테스트케이스는 'testcase 번호'가 기록된 줄로 구분되며, 각각의 테스트케이스는 다음과 같이 구성되어 있다.

  - 첫 줄은 찾고자 하는 값이다.

  - 두 번째 줄 부터는 한 줄에 하나씩 목록의 항목이다. 항목이 숫자인 경우 숫자의 리스트로 생성해 실행하고, 그렇지 않은 경우 문자열의 리스트로 생성해 실행한다.

- 테스트케이스 각각에 대한 결과를 출력한다.

## 결과예시

```
testcase 1 result : 4
testcase 2 result : 4
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/find_from_ordered_data.py 파일에 구현이 되어 있는지 확인한다.
  - 분할 정복 방식을 사용해 선형 시간 복잡도 미만의 시간 복잡도로 결과를 찾을 수 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 테스트케이스 8의 경우, 구현 방식에 따라 95, 96, 97 셋 중 어느 값도 나올 수 있다.

    ```
    testcase 1 result : 4
    testcase 2 result : 4
    testcase 3 result : 2
    testcase 4 result : 0
    testcase 5 result : 8
    testcase 6 result : 7
    testcase 7 result : 1
    testcase 8 result : 96
    testcase 9 result : 4
    testcase 10 result : 10
    testcase 11 result : 442
    testcase 12 result : 183
    ```

### [문제에 대한 이해]

- 분할 정복 방식에 대해서 설명하라.
- 분할 정복 방식으로 주어진 문제를 해결한 방법을 설명하라.
- 이 문제의 경우, 문제의 조건만으로 복수의 결과가 정답이 되는 경우가 있다. 96의 인덱스를 찾는 테스트케이스 8의 데이터에 96이 3번 반복해 나오기 때문이다. 구체적으로는 95, 96, 97 셋 중 어느 인덱스를 제시해도 정답인데, 이 세 개의 값중 왜 그 수를 출력했는지 사용한 분할 정복 방식의 흐름을 사용해 설명하라.
- 구현한 함수의 시간 복잡도를 제시하라.

### [코드 예시]

```python
def find_index(arr, k, start, end):
    if start > end:
        return start

    mid = (start + end) // 2
    if arr[mid] == k:
        return mid
    elif arr[mid] > k:
        return find_index(arr, k, start, mid - 1)
    else:
        return find_index(arr, k, mid + 1, end)

def line_into_int_or_str(line):
    line = line.strip()
    if line.isdigit():
        return int(line)
    else:
        return line

def main():
    testcases = []
    with open("sorted_list.txt", "r") as f:
        lines = f.readlines()

    start_lines = []
    end_lines = []
    for i in range(len(lines)):
        if lines[i][:8] == "testcase":
            start_lines.append(i)
            if i != 0:
                end_lines.append(i - 1)
    end_lines.append(len(lines) - 1)
    tc_num = 0
    for i in range(len(start_lines)):
        tc_num += 1
        start = start_lines[i]
        end = end_lines[i]
        k = line_into_int_or_str(lines[start + 1])
        arr = []
        for j in range(start + 2, end + 1):
            arr.append(line_into_int_or_str(lines[j]))
        result = find_index(arr, k, 0, len(arr) - 1)
        print(f"testcase {tc_num} result : {result}")

    for i, (tc, k, size) in enumerate(testcases):
        print(f"testcase {i + 1}: {find_index(tc, k, 0, size - 1)}")


if __name__ == "__main__":
    main()
```

---

# 문제 4. 가장 전기가 잘 통하는 구간은 어디일까? (1)

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

신경과 신경 사이에 정보를 주고받을 때 생물은 전기 신호를 사용한다. 신경 세포를 연구하는 연구원 N은 신경 연결의 전기적 특성을 확인하기 위해서 선형으로 연결된 신경 세포의 여러 구간에서 전압을 측정했다. 이 전압의 합이 가장 큰 구간이 신호가 활발하게 발생하는 구간으로 가정하고 추가 실험을 진행하려고 하고 있다.

측정 결과를 받아든 연구원 N은 순간 멈칫했다.

'어라, 그런데 전압의 합이 가장 큰 구간은 어떻게 찾지?'

양수와 음수를 넘나드는 긴 전압 목록은 보기만 해도 머리가 아파왔다.

## 수행목표

- 숫자로 구성된 리스트가 주어지면, 이 리스트에서 합이 가장 큰 연속된 구간을 찾아서, 시작과 끝 인덱스와 이 때의 합의 값을 반환하는 함수를 구현한다.

- 다음 15개의 리스트에 대해서 실행한 결과를 출력한다.

  ```python
  tc1 = [5, -1, 2, 3, -1, 3, -4, 3, -6]
  tc2 = [2, -5, 2, -4]
  tc3 = [1, 1, 1, 1, 1]
  tc4 = [-1, -1, -1, -1, -1]
  tc5 = [0, 0, 0]
  tc6 = [-100, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -100, 54]
  tc7 = [100]
  tc8 = [-100]
  tc9 = [5, -1, 2, 3, -1, 3, -4, 3, -100, 5, -1, 2, 3, -1, 3, -4, 3, -6]
  tc10 = [5, -29, -74, 96, 70, 20, 81, -24, 5, -70, 56, -65, -53, 83, -81, -25, -6, -20, 61, 18, 3, -2, 75, 32, -46, -49, 92, -70, -85, 13, 40, 37, 80, -52, -25, 11, 90, -56, 4, 57, -18, -9, -88, -24, 28, -5, -41, -92, 8, 47, -13, -85, -86, 1, 52, -32, 24, -33, -56, -86, -22, -9, 17, 82, -66, 4, -91, 84, -27, 52, -82, 82, 84, -29, -38, 36, -76, 72, -41, 35, 57, -21, -7, -47, 50, -12, 25, -61, -43, -9, 13, -65, -17, 48, 81, 39, 75, -45, -6, 93]
  tc11 = [58, -9, 13, -14, -59, 57, -97, 25, 62, 44, 13, -66, -51, 61, 3, 91, -60, -38, 42, -74, -43, -26, -18, -12, -47, 63, 92, -23, -36, -96, 60, -71, -43, 46, -46, 10, 99, -83, 5, 89, 28, -7, 67, -7, 99, -70, -28, 43, -81, 70, 48, 90, -68, -65, -100, -54, 24, -42, -54, -50, -26, -24, -55, -43, -26, 18, 56, -32, -67, 12, -12, 10, 17, -36, 23, -21, 8, -53, -4, -89, 8, 29, -19, 84, -37, 72, 15, -78, 11, -44, 8, 87, -65, -88, 92, -37, -74, -30, -74, 4]
  tc12 = [166, -363, -551, -715, -628, -789, -588, -401, -100, -79, 56, -693, -29, -558, -529, -671, -772, 134, -565, -214, 148, -308, -304, -543, 75, -779, -264, -487, -365, -593, -253, -744, -435, -550, 75, 103, 67, 158, 183, -71, -378, -554, -351, -644, -610, 141, -181, 68, -299, -6, -97, -535, 124, -15, -778, -91, -227, -445, -477, -423, -1, -216, -79, -722, -660, -711, -686, -3, -790, 111, -488, -773, 35, -656, -771, 117, -44, -153, -11, -461, -165, -778, -135, -748, -404, -356, -64, -601, -137, -25, -602, -448, -699, -334, 24, -559, -68, -500, -122, -79]
  tc13 = [30, 22, -12, -5, 1, -21, 13, 1, -18, -16, -9, -16, 13, 29, -18, -6, -24, 13, 3, -23, -11, 0, 13, 19, -18, 7, 11, 14, -25, 24, -24, -20, -29, 2, -27, 18, -2, 27, 7, 21, 15, -20, -25, -25, -23, -23, 12, 6, -16, 13, 8, 18, -19, 11, -20, 9, 24, 13, 15, -15, -5, -9, 22, 30, -15, -11, 13, -8, -24, 18, 1, 27, -10, -28, -1, 30, 0, -6, 19, -18, -18, 3, 27, 2, 28, -22, -11, 22, 12, -23, -12, 21, -24, -20, -11, -27, 10, 10, 24, -16, 6, -5, -19, 1, 7, 15, 11, -21, 3, 17, -28, 12, 0, 7, 20, 7, 29, 23, -9, -30, -11, 0, 14, -24, -2, 11, 1, -4, -24, -13, 26, -3, -19, 11, -4, 28, 17, 8, -30, 8, -27, -30, 18, -12, 8, -24, 21, 11, 2, 28, -17, 26, 10, 27, -21, -24, -20, -2, -9, -13, 24, -26, -29, 3, 19, -27, -5, 8, 15, 27, 23, 21, 8, -14, 20, 8, -6, -24, 0, 10, -15, -20, -11, -19, 2, -10, -4, 20, -3, 16, 5, 6, 23, -25, -12, 30, -19, 25, -26, 22, -24, 20, 2, -19, -3, 10, 26, -3, -5, 2, 9, -30, 5, -21, -7, -18, 12, 11, 29, -7, -29, 5, 1, 4, 21, -21, -6, 7, 11, -14, 3, 13, 26, 4, 2, 4, -14, 19, 18, -27, 17, -30, 2, 18, 11, -23, 5, -13, 29, 25, 17, -4, 23, -8, 21, -2, -13, -27, 14, -25, -20, -1, 19, 9, 6, -21, -24, -15, -29, 0, -4, 28, -13, -5, 28, -22, -9, -18, -17, -19, 7, 10, -9, -11, -24, 3, 14, -22, -25, 7, 15, 15, 23, -2, -26, 24, 29, -28, 2, -9, -23, 1, 5, -19, 28, 5, -20, 27, -3, 0, 15, 14, -2, -7, 6, -1, 9, 22, -29, -29, 8, 5, -13, -23, 16, 15, -14, -26, -7, 22, 1, 9, 6, 23, 0, 14, -1, -11, 26, -22, -7, 24, -8, 24, -9, 21, -30, 6, -29, -19, -5, -10, -14, 1, 24, 26, -28, 22, -18, 27, -12, 16, 9, -22, -15, -17, 10, 29, -9, -20, 26, 24, 27, -22, 18, 24, -12, 27, 19, -27, 20, 16, -30, -29, 1, -12, -13, 8, 9, 9, 26, -7, -22, 19, 4, -11, -26, -1, -10, 7, 17, 19, 21, 2, 27, 21, 24, 19, 0, 28, 23, -24, -20, -8, 2, 19, 29, 8, -12, -24, -8, -12, 29, 1, -4, 19, -26, 15, 5, -26, -22, -25, 29, -7, -24, -1, -26, -1, -1, -4, -30, 10, 22, 0, 7, 18, -29, 30, 30, 28, 18, -28, 6, -18, 6, 19, -29, -8, -9, -28, -17, -29, -21, 21, -21, -30, 0, 26, 26, -16, -25, -12, 25, -14, -5, -6, -20, -8, 14, 2, -13, -19, -15, 30, 19, -12, -26, 12, 13, 13, -22, -26, 9, -2, 7, 3, 27, 30, -27, -30, -8, -16, -3, 27, -19, -1, 6, 6, 28, 16, -14, 19, -3, -20, 22, -25, 4, -21, 27, 1, 14, -27, 28, 20, -19, 12, -21, 21, 14, -22, -26, -5, -23, 15, 12, 14, 7, -7, 10, 22, -2, -9, 27, 3, 13, -16, -6, -15, -17, 9, 14, -30, 27, 23, 4, -26, -5, 30, 0, 8, 13, 21, -27, -7, -13, -7, 12, -4, -2, 25, 15, 3, 2, -5, -11, 30, 28, -4, 9, -27, -23, 1, -17, -18, 26, 13, -18, 30, -3, 15, 14, 0, -20, 5, 28, -11, 9, -25, 2, -19, 25, -22, -27, -13, -19, 4, 20, 25, 22, -15, 13, -26, 11, 22, -17, -11, 2, -26, -4, 0, 3, 27, 16, -8, 11, 9, -24, -10, 28, 4, 11, -14, -29, -12, -17, -3, 26, 28, 21, -18, 7, 19, 23, -11, -13, -21, 4, 21, -22, -15, -5, 0, -13, 15, 23, -18, 9, 26, 8, -15, -10, 9, 29, -25, -16, -13, 25, -8, 20, -18, -30, -23, 13, -27, 30, 16, 30, 9, 13, -15, -30, 0, 23, -16, -26, -1, -26, 1, 20, -24, 23, -3, 26, 6, -4, -4, 8, -4, -15, 10, 16, 21, 21, 30, -21, 11, -28, -23, 0, -19, 15, -11, -24, -1, -25, 20, -15, 21, -1, 30, 2, 20, 16, 4, -27, -27, 8, -7, -15, 28, -24, -29, -13, -9, 26, 28, 23, 24, -15, -5, -27, 17, 14, 10, 17, 17, 11, -4, -21, 20, 14, -6, 16, 29, 9, 28, 0, -6, 8, 24, -9, -10, -27, -2, -13, 10, -4, -12, -2, 10, -18, -8, -13, -14, 5, -20, -2, -13, -28, 3, -20, -9, -29, -17, -26, 11, -15, -3, -5, 16, -5, -23, 19, 24, 20, -15, 10, 3, -27, -22, 9, -29, -15, -25, 12, -7, 12, 12, 28, 12, -21, -23, -24, 1, -20, -21, 8, 27, 10, 20, 7, 1, -23, -19, 17, 4, 13, -18, 11, -21, 8, -9, 16, 16, 13, -18, -17, 28, -5, 29, 25, -24, -12, 18, 19, 1, -15, 3, 24, 9, -18, 7, -27, -1, 17, -16, 9, 22, -30, 21, 13, 25, 18, 13, -30, -1, 3, 28, -8, 2, 9, 24, 21, -12, 7, 5, -16, 19, 27, -28, -26, -19, -30, 9, 8, 11, -21, -4, -23, 4, -21, -29, 1, 29, -5, 7, 6, -9, 1, -6, -4, 16, -17, -30, -30, 2, 25, 26, 7, 6, 6, 10, 5, 27, -29, -13, 3, 26, -3, -2, 9, 4, -23, 21, 16, 6, 26, 24, 17, 13, 6, 11, 18, 19, 30, -26, 5, 11, 7, -28, -14, 8, 5, 7, -7, 3, -30, 29, -14, 22, 20, 24, 17, 28, 25, 14, 13, -4, 30, -1, -16, 29, 7, -22, 22, -18, -23, -2, 14, -28, 26, -14, 16, 25, 0, 7, -13, -4, 6, -4, 10, -15, -4, -12, -19, 18, -25, -8, -26, 14, -8, -30, -20, 2, -21, 7, -28, 14, -3, 12]
  tc14 = [45, 20, 29, 41, 6, -9, 38, 4, -9, 33, 40, -7, 14, -10, 46, -7, 41, 29, 6, 38, -5, -1, 22, 17, 49, 4, 29, 4, 20, 20, 50, 12, 0, 14, 33, 15, 43, 39, 35, -6, -5, 0, 6, 29, 5, 28, 50, 47, -7, 32, 0, 12, 16, 1, 24, -5, -9, 6, 6, 9, 19, 25, 48, 31, 21, 24, 32, 24, -2, 40, -5, 34, 26, 31, 28, 28, 26, 12, 19, 43, 3, 40, 12, 3, -3, -4, 8, 31, 15, 44, 23, 35, -1, -1, 31, 0, 50, 20, 39, 24, -9, -9, -8, -2, 6, 33, 19, 35, 44, 33, 1, 16, 8, 22, -5, 46, -5, 17, 6, -10, 5, 35, 13, -4, 9, 8, 6, -7, 24, 13, 4, 23, 27, 21, -1, -10, -2, 13, 2, 48, 22, 39, 20, 26, 6, 43, 44, -8, 3, 9, 15, 8, 9, 12, 33, 37, 23, 39, 40, 5, 25, 48, 28, 10, 38, 20, 1, -4, 41, -7, 11, -4, 2, 7, 29, 38, 32, 43, 14, 45, 18, 45, 35, 48, -7, 25, 49, 24, 39, 19, 18, 24, -7, 17, 32, -1, 38, 25, 45, 15, 14, 45, 45, -6, 23, 24, 33, 38, 0, 39, 50, 42, 33, 12, 31, 41, 33, 12, -3, -2, 28, 7, 37, 32, 13, 5, 13, 39, 16, 0, 9, 18, 12, 2, -8, 44, 16, 46, 7, 22, 47, 24, 43, 43, 4, 48, 41, 13, 40, -7, 14, 1, -10, 4, 29, 33, 37, -10, 25, -9, 49, 10, 49, 48, 3, 27, 36, -1, 10, 19, -1, 3, 38, 3, 38, 45, 22, 33, 31, 13, 15, 1, 46, 37, 0, 18, 24, 36, 20, 17, 38, -4, 2, 19, 37, 31, 9, 44, 30, 24, 26, 17, -8, 36, 32, 30, 40, 39, 4, -1, 7, 7, 24, 41, 43, 18, 19, 31, 47, -7, 17, 24, 38, 43, 43, 34, 44, 49, 37, 3, 10, 39, 23, 14, 49, 38, 43, 16, -1, 8, 44, -3, 38, 47, 30, -3, -6, 17, -9, -9, 42, 5, -2, -2, 28, 49, 32, 7, 37, 28, -10, 6, 46, 26, 6, 18, 44, 32, 45, -5, 16, 39, 44, 24, 20, 25, 47, 4, 19, -6, 27, 22, -3, 9, 1, 3, 33, 30, 1, 34, 32, 35, 16, 28, 17, 43, 39, 42, 36, 21, -3, 17, 12, 37, 20, 34, 1, 24, 39, 19, 21, 21, 47, 38, 41, -6, 48, 18, 29, 42, 50, 2, 0, 41, 25, 31, 11, 32, 31, 31, -4, 8, 20, 33, 26, 13, 10, 25, 0, 20, 33, 41, -4, 2, 22, 3, 16, 1, 36, 36, -6, 12, -2, 17, 43, 45, 16, 37, 26, 44, 15, 27, 33, 35, -4, 49, 38, 17, 3, 22, -7, 33, -4, 36, 13, 15, 30, 19, 16, 9, 34, 4, 14, 39, -6, -3, -8, 6, 50, 13, 34, 21, 34, 19, -4, 25, 25, 0, 0, 39, 0, 49, 38, 39, 45, 44, 14, 9, 43, 21, 11, 6, 36, 44, 31, -5, 34, 16, 20, 25, 20, 11, 13, 39, -8, 48, 39, 9, 44, 9, 35, 31, 29, 13, 37, 10, 15, 17, 34, 41, 26, 27, -1, 18, 16, 31, 3, 33, 14, -7, -10, 37, 19, 32, 50, 48, 3, 1, 4, 3, -7, 26, 47, 4, 29, -2, -8, 18, -4, 13, 9, 31, 12, 11, 1, 29, 4, -2, -8, 36, 24, 24, 40, 14, 33, 48, -4, 35, -5, 9, -3, -4, 46, 31, 18, 23, 23, -9, 38, 45, 2, 31, 16, 38, 9, 1, 50, 37, 40, 24, 19, 39, 30, 18, 6, 44, 4, 20, 42, 50, 0, 3, 4, -8, 17, 49, 17, 6, 41, 48, 6, 40, 36, 1, -7, 7, 11, 25, 9, 36, -5, 13, 17, -3, 49, 24, 31, -6, 0, -7, -10, 6, 47, -2, 46, 26, 26, 3, 4, -6, 45, 20, -2, 44, 11, 15, 39, 9, 13, 23, 17, 33, 7, 6, 37, -8, 34, 27, 43, -2, 9, 42, -1, 14, 12, 6, -9, 47, 7, 44, 36, 31, 45, 32, 2, 25, 49, 5, 27, 3, 43, 14, 21, -6, 45, -5, 32, 49, 22, 23, 44, 14, 49, 22, 32, 7, 17, 40, 32, 36, 7, 20, 9, -4, 17, 39, 29, 40, -10, 5, 37, 20, 3, 13, 30, 31, 41, 38, 5, 12, 35, 32, 20, 7, -7, 49, 27, 2, 13, 42, 27, -8, 4, -10, 28, 8, -5, 39, 40, 0, 47, 30, 45, 29, 2, 45, 46, -6, 40, 10, 43, 17, -10, -2, 8, 22, 36, 46, 17, -9, 33, 24, -5, 5, 36, 7, 48, 13, -7, 28, 16, -7, 22, -3, 12, 35, -3, 11, -6, 25, 35, 41, 13, 50, 36, -4, 8, -8, -1, 38, 0, 7, 40, 47, 13, 25, 46, 35, 21, 7, 31, 9, 18, 17, 4, 14, 10, 8, 40, 20, 21, 21, 44, 10, 14, -2, 12, 20, -4, 6, 45, 10, 33, -6, 22, 44, 14, 11, 4, 9, 31, 38, 11, 42, 33, 25, 1, 10, 44, 49, 18, -4, -9, 48, -6, 17, -1, 43, 5, 42, 37, 43, 37, 31, 23, 31, 27, 8, -9, 27, 45, 20, 26, -6, 27, 39, 8, 45, 22, -5, 29, 41, 15, 2, 6, 3, 13, 16, 46, 10, 36, 24, 22, 9, 18, 41, 21, -1, 44, 24, 12, 31, 40, 31, 30, 26, 47, 31, 6, -8, -7, 8, 41, 5, 13, -6, -3, 1, -4, 0, 17, 25, 15, 25, 4, 8, 24, 13, -6, 7, 20, 6, 21, 43, 9, 18, 10, 28, 33, 25, 46, -1, 20, 40, 23, 33, 11, 50, 16, -5, 44, 28, 41, 40, 23, -5, 24, 8, 6, 8, 33, 43, 45, 43, 25, 26, 0, 30, -7, 7, 23, 1, 4, 27, 46, 5, 29, 20, -6, 40, 40, 16, -7, 39, -5, 28, 6, 45, 5, 43]
  tc15 = [-1, 0, 0, -1, 0, 1, 1, 0, 0, 1, -1, 0, -1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 0, -1, 1, 1, -1, -1, -1, -1, 1, 0, 0, 0, 1, 0, -1, 1, -1, 1, 0, 0, 0, 1, 0, 0, -1, 1, -1, 1, 1, -1, 1, 1, 0, 1, -1, 1, 1, 0, -1, 1, -1, 1, 1, 1, -1, 0, 0, 0, -1, -1, 1, -1, 0, 1, 1, -1, -1, 0, 0, -1, 1, 1, 0, -1, -1, -1, 1, -1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, -1, 0, 0, 0, -1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, -1, -1, -1, -1, 0, -1, 0, 0, 0, 1, 0, 0, 1, 1, 1, -1, 0, -1, 1, 0, -1, -1, -1, 0, 0, -1, -1, 0, 1, 1, -1, 1, 1, -1, 0, 1, -1, 1, 1, -1, 0, 1, 1, 1, 1, 0, -1, -1, 0, 0, 1, 0, 1, -1, -1, 1, 0, 0, 1, 0, 0, 1, 1, -1, -1, -1, 1, 1, 0, 0, -1, 1, -1, 1, -1, 1, 0, 1, 1, 0, 1, 0, 0, -1, 0, -1, -1, -1, -1, 1, 0, 0, 1, -1, 0, -1, 1, 1, -1, 1, 0, 0, 0, -1, -1, -1, -1, 0, -1, 0, 0, 0, 0, 0, 1, 1, 0, -1, -1, 0, -1, -1, 0, 0, -1, 1, -1, 1, 0, -1, 1, 1, -1, -1, 1, 1, -1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, -1, -1, 0, 1, 1, 0, 0, -1, 0, -1, 0, 1, 1, 1, 0, 1, 0, 0, -1, 0, -1, 0, 0, 0, -1, 1, 1, 0, -1, -1, -1, 0, -1, 0, 0, -1, -1, 0, 1, 1, 1, 1, 0, 0, -1, 0, -1, -1, 1, 0, 0, 0, -1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, -1, 0, 0, -1, -1, 0, 1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 1, 1, -1, 0, 1, 0, -1, 1, 1, 1, -1, -1, 0, 1, 0, 0, 1, 0, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, -1, 0, -1, -1, -1, 1, 1, -1, -1, -1, 0, -1, -1, -1, 0, -1, -1, 1, -1, -1, -1, 0, -1, -1, 0, 1, 1, 1, 0, -1, -1, 0, 0, 0, 0, 0, 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 0, 0, 0, 0, -1, 1, 1, -1, 1, 0, 0, -1, -1, -1, 1, -1, 0, 0, -1, 1, -1, -1, 1, 0, -1, -1, 0, 0, 0, 0, 0, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, -1, -1, 1, 1, 0, 1, 0, 0, 1, -1, 1, -1, -1, 0, -1, -1, 1, 1, 1, 1, 0, 1, -1, -1, -1, 0, -1, -1, -1, -1, 1, -1, -1, 1, 1, 0, 1, -1, -1, -1, 1, 0, 0, -1, 0, -1, 1, 1, 1, 0, -1, -1, -1, 1, -1, 0, 0, 1, -1, -1, 1, 0, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 0, 0, 1, 1, 0, 0, 0, -1, 1, -1, -1, -1, 0, 0, 0, -1, -1, 1, -1, 1, 1, -1, 1, 1, -1, 1, -1, 0, 1, -1, -1, 0, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, 1, 0, -1, 0, 1, 1, 1, 0, 0, 0, 1, 1, -1, -1, 1, 0, 0, 0, -1, -1, -1, 0, 0, 0, 0, 1, 0, 1, 0, -1, 1, 1, -1, -1, -1, -1, 0, -1, 0, -1, 0, 1, 0, 0, 0, 0, 1, 0, 1, -1, 0, 1, -1, 1, 0, 1, -1, 1, -1, 1, 0, 1, 0, 1, 1, -1, 0, -1, 0, 1, 0, 1, -1, 1, -1, 1, 1, 0, 0, -1, 1, 1, 1, -1, 0, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 0, 0, 0, 1, 1, 1, 0, 1, 1, -1, 0, 0, -1, 0, 1, 0, -1, 0, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 0, -1, -1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 0, 0, 0, 1, 0, 0, -1, -1, -1, -1, 0, -1, 1, -1, 1, 0, 0, 0, 0, 0, -1, 0, -1, 0, 0, -1, -1, 1, 0, -1, 0, -1, 1, -1, -1, 0, -1, -1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, -1, 0, -1, -1, 1, 1, 0, 1, -1, 1, 1, 0, 0, 0, 0, -1, 1, -1, -1, -1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 1, 0, 0, 0, 1, -1, 0, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, 0, 0, 1, -1, -1, 0, -1, 0, 0, 1, 1, 1, -1, 0, 0, -1, 1, 0, -1, -1, 1, 0, -1, 1, -1, -1, 0, -1, -1, 0, 0, -1, 0, 0, 1, -1, 0, 1, 1, -1, 1, 0, 0, 0, -1, 0, -1, -1, -1, 0, 0, -1, -1, -1, 0, 1, 0, 1, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, -1, 1, -1, 1, -1, -1, 0, -1, -1, -1, 1, -1, 1, 1, 0, 1, 1, 1, 0, 0, 0, -1, 0, 1, 1, 1, -1, -1, 1, 0, -1, 1, 0, 0, 1, 0, -1, 1, 0, 1, 0, -1, 0, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, -1, 1, 0, 1, -1, 1, -1, 1, 0, -1, 0, 1, 1, -1, 0, 1, -1, 0, 0, 1, -1, -1, -1, 0, -1, -1, 0, -1, 1, 1, 0, 1, 1, 0, -1, 1, 0, 0, -1, -1, -1, 1, 1, 0, 0, -1, 1, 1, 0, 1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 0, 0, -1, -1, 1, 1, 0, -1, 1, 1, 1, 0, -1, -1, 0, -1, 0, 0, -1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 0, 1, 0, 1, -1, 1, -1, -1, 0, -1, 1, 1, 0, 1, 1, 0, 1, 1, 0, -1, 1, -1, 0, 0, -1, 0, 1, -1, 1, 1, -1, 0, 1, -1, 0, -1, 0, 1, -1, -1, 0, 0, -1, 1, -1, -1, 1, -1, -1, 0, 1, 0, 1, 1, -1, -1, 1, -1, 1, 0, -1, 1, -1, 0, -1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, -1, -1, 1, -1, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 0, -1, 0, 1, -1, -1, 1, 0, 0, 1, 1, 1, 1, -1, 0, 0, 1, 1, -1, -1, 0, -1, -1, 1, 1, 0, 1, 0, 0, 0, 1, -1, 0, 1, 0, 0, -1, 0, 1, 1, 1, -1, -1, 0, -1, 0, 1, 1, -1, 1, 0, 1, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, -1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, 1, 0, -1, 1, -1, 1, 1, 1, -1, 1, 1, 0, -1, 1, 1, 0, -1, 0, -1, 1, 1, -1, 1, 0, 0, 1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, 0, 0, 1, -1, -1, 0, -1, 0, 1, 0, -1, -1, 0, 0, 0, -1, 1, 0, -1, -1, -1, 1, -1, 1, 0, 1, -1, -1, -1, 0, -1, -1, 1, 0, 0, 0, 1, 0, 0, 1, 1, -1, -1, 0, 0, 1, -1, 0, 1, -1, 0, 1, 0, -1, 1, 0, -1, 1, -1, -1, -1, 1, 1, 0, 0, -1, 0, -1, 0, -1, 1, 1, -1, -1, 0, -1, 0, 0, -1, 0, 1, -1, 0, -1, 0, 1, 1, -1, -1, 1, -1, -1, 1, 1, 0, -1, 1, -1, 0, 0, 1, 0, -1, 1, 1, 1, 1, 1, -1, 0, 1, 0, -1, 0, -1, 0, 1, -1, 0, -1, 1, -1, 1, 1, 0, -1, 0, -1, -1, 1, 0, -1, 1, 1, 1, 0, 0, 1, -1, -1, 1, 1, 0, 1, 1, 0, 0, 1, -1, 1, 0, 1, -1, 1, -1, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 1, 1, 0, 1, -1, 0, 0, 0, 0, 0, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, -1, -1, 0, 0, 0, 0, 1, 1, -1, -1, 1, -1, 0, -1, 1, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, -1, 0, 0, -1, 0, 0, 0, -1, -1, 0, 0, -1, -1, 0, 1, -1, -1, -1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 1, -1, 0, 1, 0, -1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, -1, 1, 1, -1, 1, 0, -1, 1, -1, -1, 0, -1, 0, 0, 0, 0, 1, 1, 1, -1, 0, 0, 0, -1, 1, 0, 0, -1, 1, -1, 0, 0, -1, 0, 1, 0, 1, 0, 0, 1, -1, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, 0, 1, -1, 1, 0, -1, -1, 1, 1, 1, 1, 0, -1, -1, 1, 0, 0, -1, -1, 0, 0, 1, 1, 0, 1, 1, -1, 0, 1, 0, 0, -1, 1, -1, -1, 0, -1, 0, -1, 1, -1, 1, -1, 0, 0, 1, 1, 1, -1, 1, 1, 1, 1, 0, -1, 1, -1, -1, 0, 1, -1, -1, 0, 0, -1, -1, 1, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 0, 0, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 0, -1, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0, 0, 0, -1, 0, -1, 0, 0, 1, 0, -1, -1, 0, -1, 0, 1, -1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, -1, 0, 1, 1, 1, 1, 1, 1, 1, -1, 0, -1, 0, 1, 1, -1, 0, 0, -1, -1, 1, 1, -1, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, 1, 0, 1, 0, -1, 1, 0, 1, -1, 0, 0, 0, 1, -1, 0, 0, 0, 1, -1, 1, 0, -1, 0, 0, 0, 1, 1, 0, -1, -1, 1, -1, 1, 1, 0, 1, 0, 0, 1, -1, 1, 1, 1, 0, 0, -1, -1, 1, 0, 0, 1, -1, -1, 1, 1, -1, 1, 0, -1, 1, -1, 1, 0, 0, 1, 0, 0, 1, 1, -1, -1, 0, 1, 1, 1, -1, 0, 0, 1, -1, -1, 0, 0, 1, 1, 1, -1, 0, 0, 1, -1, -1, 0, 0, 1, 1, 0, -1, 1, -1, 0, 0, 0, -1, 1, -1, 1, 1, 0, -1, -1, 0, -1, 1, -1, -1, -1, 0, 1, -1, -1, 1, -1, 0, 1, -1, 0, 0, 1, 0, -1, -1, 0, 1, 1, 1, -1, 0, 0, -1, 1, 1, -1, 0, 1, -1, 0, 1, 1, 0, 1, -1, -1, 0, 0, -1, -1, -1, 1, -1, -1, 0, -1, 0, 0, 1, -1, 0, 1, 0, 1, 0, 1, 0, -1, 0, 1, 0, -1, 0, -1, -1, -1, 0, -1, 0, -1, -1, -1, -1, 1, -1, 1, 0, 1, -1, -1, -1, -1, 1, -1, -1, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0, 1, -1, 1, -1, 1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 0, 0, -1, 0, 0, 0, 0, -1, 1, 1, 0, 1, 1, 0, -1, 1, 0, 1, -1, -1, 1, 0, 0, -1]

  ```

## 수행단계

- 주어진 리스트에서 합이 가장 큰 연속된 구간을 찾는 함수를 basic_approach/find_energetic_neuron_sequence.py 파일에 구현한다.

  - 이 함수는 숫자로 구성된 리스트에서 합이 가장 큰 연속된 구간을 분할 정복 방식으로 찾는다.
  - 이 구간의 시작 인덱스와 끝 인덱스로 구성된 리스트와 이 구간의 전압의 합을 반환한다.
  - 예를 들어서 주어진 리스트가 [5, -1, 2, 3, -1, 3, -4, 3, -6]인 경우, 이 리스트에서 값의 합이 11이 되는 [5, -1, 2, 3, -1, 3] 구간이 합이 가장 큰 구간이므로, 11을 반환한다.
  - 주어진 리스트가 [2, -5, 2, -1, 1]인 경우, 첫 번째 인덱스의 [2]와 세 번째 인덱스의 [2], 그리고 [2, -1, 1]이 구간의 합이 2로 가장 큰 구간이다. 그러므로 이 함수는 2를 반환한다.

- 첨부한 리스트를 사용해 실행한 결과를 출력한다.

## 결과 예시

```
testcase 1
    최대 부분 합 : 11
testcase 2
    최대 부분 합 : 2
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 사실 연구원 N에게 도움이 되는 결과는 전압의 합이 가장 큰 구간의 전압의 합이 아니라, 이 구간이 어디인지에 대한 정보이다. 전압의 합과 함께 어떤 구간에서 전압의 합이 가장 큰지도 반환하도록 함수를 구현하고, 문제에서 제공한 테스트케이스에서 그 구간의 시작과 끝 인덱스의 튜플의 목록을 출력해보자.
  - 문제에서 제시한 예제 리스트의 경우, 첫 번째 리스트는 [(0, 5)]를 출력해야 하며, 두 번째 리스트는 모든 위치의 목록, 즉 [(0, 0), (2, 2), (2, 4)]를 출력해야 한다. 리스트를 출력하는 순서는 시작 인덱스와 끝 인덱스 순서로 정렬해서 출력한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/find_energetic_neuron_sequence.py 파일에 구현이 되어 있는지 확인한다.
  - 분할 정복 방식으로 문제를 나누어가며 해결하엿는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    testcase 1
        최대 부분 합 : 11
    testcase 2
        최대 부분 합 : 2
    testcase 3
        최대 부분 합 : 5
    testcase 4
        최대 부분 합 : -1
    testcase 5
        최대 부분 합 : 0
    testcase 6
        최대 부분 합 : 55
    testcase 7
        최대 부분 합 : 100
    testcase 8
        최대 부분 합 : -100
    testcase 9
        최대 부분 합 : 11
    testcase 10
        최대 부분 합 : 300
    testcase 11
        최대 부분 합 : 372
    testcase 12
        최대 부분 합 : 586
    testcase 13
        최대 부분 합 : 552
    testcase 14
        최대 부분 합 : 20222
    testcase 15
        최대 부분 합 : 22
    ```

### [보너스 과제의 확인]

- 지시한 대로 구현하였는가?

  - 최대 합이 되는 구간의 시작 인덱스와 끝 인덱스를 시작 인덱스 우선으로 정렬해 출력하고 있는지 확인한다.

- 결과는 정확한가?

  - 결과는 다음과 같다.

    ```
    testcase 1
        최대 부분 합 : 11
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 5)]
    testcase 2
        최대 부분 합 : 2
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 0), (2, 2), (2, 4)]
    testcase 3
        최대 부분 합 : 5
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 4)]
    testcase 4
        최대 부분 합 : -1
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]
    testcase 5
        최대 부분 합 : 0
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2)]
    testcase 6
        최대 부분 합 : 55
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(1, 10)]
    testcase 7
        최대 부분 합 : 100
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 0)]
    testcase 8
        최대 부분 합 : -100
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 0)]
    testcase 9
        최대 부분 합 : 11
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 5), (9, 14)]
    testcase 10
        최대 부분 합 : 300
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(67, 99)]
    testcase 11
        최대 부분 합 : 372
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(33, 51), (35, 51)]
    testcase 12
        최대 부분 합 : 586
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(34, 38)]
    testcase 13
        최대 부분 합 : 552
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(289, 975)]
    testcase 14
        최대 부분 합 : 20222
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 999)]
    testcase 15
        최대 부분 합 : 22
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(1687, 1835), (1687, 1839), (1687, 1845), (1687, 1846), (1687, 1848), (1687, 1857), (1687, 1858), (1688, 1835), (1688, 1839), (1688, 1845), (1688, 1846), (1688, 1848), (1688, 1857), (1688, 1858), (1690, 1835), (1690, 1839), (1690, 1845), (1690, 1846), (1690, 1848), (1690, 1857), (1690, 1858), (1691, 1835), (1691, 1839), (1691, 1845), (1691, 1846), (1691, 1848), (1691, 1857), (1691, 1858)]
    ```

### [문제에 대한 이해]

- 분할 정복 방식으로 문제를 해결하기 위해서 문제를 어떻게 나누었는지 설명하라.
- 문제를 작은 문제로 분할했을 때 중첩되지 않는 회색지대에 해당하는 부분이 남아 있었다면 어떤 부분인지, 그리고 이 부분의 문제를 어떻게 해결하였는지 설명하라.

### [코드 예시]

```python
  def find_maxsum_subarray(arr, start = None, end = None):
    if start == None:
        start = 0
    if end == None:
        end = len(arr) - 1
    if start == end:
        return arr[start], [(start, end)]
    mid = (start + end) // 2
    leading_max, leading_max_parts = find_maxsum_subarray(arr, start, mid)
    trailing_max, trailing_max_parts = find_maxsum_subarray(arr, mid + 1, end)
    forwaring_sum = 0
    backwarding_sum = 0

    forwarding_max = float("-inf")
    backwarding_max = float("-inf")
    forwarding_max_indices = []
    backwarding_max_indices = []
    for i in range(mid, start - 1, -1):
        forwaring_sum += arr[i]
        if forwaring_sum > forwarding_max:
            forwarding_max = forwaring_sum
            forwarding_max_indices = [i]
        elif forwaring_sum == forwarding_max:
            forwarding_max_indices.append(i)

    for i in range(mid + 1, end + 1):
        backwarding_sum += arr[i]
        if backwarding_sum > backwarding_max:
            backwarding_max = backwarding_sum
            backwarding_max_indices = [i]
        elif backwarding_sum == backwarding_max:
            backwarding_max_indices.append(i)
    crossing_max = forwarding_max + backwarding_max
    crossing_max_parts = []
    for i in forwarding_max_indices:
        for j in backwarding_max_indices:
            crossing_max_parts.append((i, j))
    sum_dict = {}
    sum_dict[crossing_max] = crossing_max_parts
    if leading_max in sum_dict:
        sum_dict[leading_max] += leading_max_parts
    else:
        sum_dict[leading_max] = leading_max_parts
    if trailing_max in sum_dict:
        sum_dict[trailing_max] += trailing_max_parts
    else:
        sum_dict[trailing_max] = trailing_max_parts
    max_sum = max(crossing_max, leading_max, trailing_max)
    return max_sum, sum_dict[max_sum]



def main():
    tc1 = [5, -1, 2, 3, -1, 3, -4, 3, -6]
    tc2 = [2, -5, 2, -1, 1]
    tc3 = [1, 1, 1, 1, 1]
    tc4 = [-1, -1, -1, -1, -1]
    tc5 = [0, 0, 0]
    tc6 = [-100, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -100, 54]
    tc7 = [100]
    tc8 = [-100]
    tc9 = [5, -1, 2, 3, -1, 3, -4, 3, -100, 5, -1, 2, 3, -1, 3, -4, 3, -6]
    tc10 = [5, -29, -74, 96, 70, 20, 81, -24, 5, -70, 56, -65, -53, 83, -81, -25, -6, -20, 61, 18, 3, -2, 75, 32, -46, -49, 92, -70, -85, 13, 40, 37, 80, -52, -25, 11, 90, -56, 4, 57, -18, -9, -88, -24, 28, -5, -41, -92, 8, 47, -13, -85, -86, 1, 52, -32, 24, -33, -56, -86, -22, -9, 17, 82, -66, 4, -91, 84, -27, 52, -82, 82, 84, -29, -38, 36, -76, 72, -41, 35, 57, -21, -7, -47, 50, -12, 25, -61, -43, -9, 13, -65, -17, 48, 81, 39, 75, -45, -6, 93]
    tc11 = [58, -9, 13, -14, -59, 57, -97, 25, 62, 44, 13, -66, -51, 61, 3, 91, -60, -38, 42, -74, -43, -26, -18, -12, -47, 63, 92, -23, -36, -96, 60, -71, -43, 46, -46, 10, 99, -83, 5, 89, 28, -7, 67, -7, 99, -70, -28, 43, -81, 70, 48, 90, -68, -65, -100, -54, 24, -42, -54, -50, -26, -24, -55, -43, -26, 18, 56, -32, -67, 12, -12, 10, 17, -36, 23, -21, 8, -53, -4, -89, 8, 29, -19, 84, -37, 72, 15, -78, 11, -44, 8, 87, -65, -88, 92, -37, -74, -30, -74, 4]
    tc12 = [166, -363, -551, -715, -628, -789, -588, -401, -100, -79, 56, -693, -29, -558, -529, -671, -772, 134, -565, -214, 148, -308, -304, -543, 75, -779, -264, -487, -365, -593, -253, -744, -435, -550, 75, 103, 67, 158, 183, -71, -378, -554, -351, -644, -610, 141, -181, 68, -299, -6, -97, -535, 124, -15, -778, -91, -227, -445, -477, -423, -1, -216, -79, -722, -660, -711, -686, -3, -790, 111, -488, -773, 35, -656, -771, 117, -44, -153, -11, -461, -165, -778, -135, -748, -404, -356, -64, -601, -137, -25, -602, -448, -699, -334, 24, -559, -68, -500, -122, -79]
    tc13 = [30, 22, -12, -5, 1, -21, 13, 1, -18, -16, -9, -16, 13, 29, -18, -6, -24, 13, 3, -23, -11, 0, 13, 19, -18, 7, 11, 14, -25, 24, -24, -20, -29, 2, -27, 18, -2, 27, 7, 21, 15, -20, -25, -25, -23, -23, 12, 6, -16, 13, 8, 18, -19, 11, -20, 9, 24, 13, 15, -15, -5, -9, 22, 30, -15, -11, 13, -8, -24, 18, 1, 27, -10, -28, -1, 30, 0, -6, 19, -18, -18, 3, 27, 2, 28, -22, -11, 22, 12, -23, -12, 21, -24, -20, -11, -27, 10, 10, 24, -16, 6, -5, -19, 1, 7, 15, 11, -21, 3, 17, -28, 12, 0, 7, 20, 7, 29, 23, -9, -30, -11, 0, 14, -24, -2, 11, 1, -4, -24, -13, 26, -3, -19, 11, -4, 28, 17, 8, -30, 8, -27, -30, 18, -12, 8, -24, 21, 11, 2, 28, -17, 26, 10, 27, -21, -24, -20, -2, -9, -13, 24, -26, -29, 3, 19, -27, -5, 8, 15, 27, 23, 21, 8, -14, 20, 8, -6, -24, 0, 10, -15, -20, -11, -19, 2, -10, -4, 20, -3, 16, 5, 6, 23, -25, -12, 30, -19, 25, -26, 22, -24, 20, 2, -19, -3, 10, 26, -3, -5, 2, 9, -30, 5, -21, -7, -18, 12, 11, 29, -7, -29, 5, 1, 4, 21, -21, -6, 7, 11, -14, 3, 13, 26, 4, 2, 4, -14, 19, 18, -27, 17, -30, 2, 18, 11, -23, 5, -13, 29, 25, 17, -4, 23, -8, 21, -2, -13, -27, 14, -25, -20, -1, 19, 9, 6, -21, -24, -15, -29, 0, -4, 28, -13, -5, 28, -22, -9, -18, -17, -19, 7, 10, -9, -11, -24, 3, 14, -22, -25, 7, 15, 15, 23, -2, -26, 24, 29, -28, 2, -9, -23, 1, 5, -19, 28, 5, -20, 27, -3, 0, 15, 14, -2, -7, 6, -1, 9, 22, -29, -29, 8, 5, -13, -23, 16, 15, -14, -26, -7, 22, 1, 9, 6, 23, 0, 14, -1, -11, 26, -22, -7, 24, -8, 24, -9, 21, -30, 6, -29, -19, -5, -10, -14, 1, 24, 26, -28, 22, -18, 27, -12, 16, 9, -22, -15, -17, 10, 29, -9, -20, 26, 24, 27, -22, 18, 24, -12, 27, 19, -27, 20, 16, -30, -29, 1, -12, -13, 8, 9, 9, 26, -7, -22, 19, 4, -11, -26, -1, -10, 7, 17, 19, 21, 2, 27, 21, 24, 19, 0, 28, 23, -24, -20, -8, 2, 19, 29, 8, -12, -24, -8, -12, 29, 1, -4, 19, -26, 15, 5, -26, -22, -25, 29, -7, -24, -1, -26, -1, -1, -4, -30, 10, 22, 0, 7, 18, -29, 30, 30, 28, 18, -28, 6, -18, 6, 19, -29, -8, -9, -28, -17, -29, -21, 21, -21, -30, 0, 26, 26, -16, -25, -12, 25, -14, -5, -6, -20, -8, 14, 2, -13, -19, -15, 30, 19, -12, -26, 12, 13, 13, -22, -26, 9, -2, 7, 3, 27, 30, -27, -30, -8, -16, -3, 27, -19, -1, 6, 6, 28, 16, -14, 19, -3, -20, 22, -25, 4, -21, 27, 1, 14, -27, 28, 20, -19, 12, -21, 21, 14, -22, -26, -5, -23, 15, 12, 14, 7, -7, 10, 22, -2, -9, 27, 3, 13, -16, -6, -15, -17, 9, 14, -30, 27, 23, 4, -26, -5, 30, 0, 8, 13, 21, -27, -7, -13, -7, 12, -4, -2, 25, 15, 3, 2, -5, -11, 30, 28, -4, 9, -27, -23, 1, -17, -18, 26, 13, -18, 30, -3, 15, 14, 0, -20, 5, 28, -11, 9, -25, 2, -19, 25, -22, -27, -13, -19, 4, 20, 25, 22, -15, 13, -26, 11, 22, -17, -11, 2, -26, -4, 0, 3, 27, 16, -8, 11, 9, -24, -10, 28, 4, 11, -14, -29, -12, -17, -3, 26, 28, 21, -18, 7, 19, 23, -11, -13, -21, 4, 21, -22, -15, -5, 0, -13, 15, 23, -18, 9, 26, 8, -15, -10, 9, 29, -25, -16, -13, 25, -8, 20, -18, -30, -23, 13, -27, 30, 16, 30, 9, 13, -15, -30, 0, 23, -16, -26, -1, -26, 1, 20, -24, 23, -3, 26, 6, -4, -4, 8, -4, -15, 10, 16, 21, 21, 30, -21, 11, -28, -23, 0, -19, 15, -11, -24, -1, -25, 20, -15, 21, -1, 30, 2, 20, 16, 4, -27, -27, 8, -7, -15, 28, -24, -29, -13, -9, 26, 28, 23, 24, -15, -5, -27, 17, 14, 10, 17, 17, 11, -4, -21, 20, 14, -6, 16, 29, 9, 28, 0, -6, 8, 24, -9, -10, -27, -2, -13, 10, -4, -12, -2, 10, -18, -8, -13, -14, 5, -20, -2, -13, -28, 3, -20, -9, -29, -17, -26, 11, -15, -3, -5, 16, -5, -23, 19, 24, 20, -15, 10, 3, -27, -22, 9, -29, -15, -25, 12, -7, 12, 12, 28, 12, -21, -23, -24, 1, -20, -21, 8, 27, 10, 20, 7, 1, -23, -19, 17, 4, 13, -18, 11, -21, 8, -9, 16, 16, 13, -18, -17, 28, -5, 29, 25, -24, -12, 18, 19, 1, -15, 3, 24, 9, -18, 7, -27, -1, 17, -16, 9, 22, -30, 21, 13, 25, 18, 13, -30, -1, 3, 28, -8, 2, 9, 24, 21, -12, 7, 5, -16, 19, 27, -28, -26, -19, -30, 9, 8, 11, -21, -4, -23, 4, -21, -29, 1, 29, -5, 7, 6, -9, 1, -6, -4, 16, -17, -30, -30, 2, 25, 26, 7, 6, 6, 10, 5, 27, -29, -13, 3, 26, -3, -2, 9, 4, -23, 21, 16, 6, 26, 24, 17, 13, 6, 11, 18, 19, 30, -26, 5, 11, 7, -28, -14, 8, 5, 7, -7, 3, -30, 29, -14, 22, 20, 24, 17, 28, 25, 14, 13, -4, 30, -1, -16, 29, 7, -22, 22, -18, -23, -2, 14, -28, 26, -14, 16, 25, 0, 7, -13, -4, 6, -4, 10, -15, -4, -12, -19, 18, -25, -8, -26, 14, -8, -30, -20, 2, -21, 7, -28, 14, -3, 12]
    tc14 = [45, 20, 29, 41, 6, -9, 38, 4, -9, 33, 40, -7, 14, -10, 46, -7, 41, 29, 6, 38, -5, -1, 22, 17, 49, 4, 29, 4, 20, 20, 50, 12, 0, 14, 33, 15, 43, 39, 35, -6, -5, 0, 6, 29, 5, 28, 50, 47, -7, 32, 0, 12, 16, 1, 24, -5, -9, 6, 6, 9, 19, 25, 48, 31, 21, 24, 32, 24, -2, 40, -5, 34, 26, 31, 28, 28, 26, 12, 19, 43, 3, 40, 12, 3, -3, -4, 8, 31, 15, 44, 23, 35, -1, -1, 31, 0, 50, 20, 39, 24, -9, -9, -8, -2, 6, 33, 19, 35, 44, 33, 1, 16, 8, 22, -5, 46, -5, 17, 6, -10, 5, 35, 13, -4, 9, 8, 6, -7, 24, 13, 4, 23, 27, 21, -1, -10, -2, 13, 2, 48, 22, 39, 20, 26, 6, 43, 44, -8, 3, 9, 15, 8, 9, 12, 33, 37, 23, 39, 40, 5, 25, 48, 28, 10, 38, 20, 1, -4, 41, -7, 11, -4, 2, 7, 29, 38, 32, 43, 14, 45, 18, 45, 35, 48, -7, 25, 49, 24, 39, 19, 18, 24, -7, 17, 32, -1, 38, 25, 45, 15, 14, 45, 45, -6, 23, 24, 33, 38, 0, 39, 50, 42, 33, 12, 31, 41, 33, 12, -3, -2, 28, 7, 37, 32, 13, 5, 13, 39, 16, 0, 9, 18, 12, 2, -8, 44, 16, 46, 7, 22, 47, 24, 43, 43, 4, 48, 41, 13, 40, -7, 14, 1, -10, 4, 29, 33, 37, -10, 25, -9, 49, 10, 49, 48, 3, 27, 36, -1, 10, 19, -1, 3, 38, 3, 38, 45, 22, 33, 31, 13, 15, 1, 46, 37, 0, 18, 24, 36, 20, 17, 38, -4, 2, 19, 37, 31, 9, 44, 30, 24, 26, 17, -8, 36, 32, 30, 40, 39, 4, -1, 7, 7, 24, 41, 43, 18, 19, 31, 47, -7, 17, 24, 38, 43, 43, 34, 44, 49, 37, 3, 10, 39, 23, 14, 49, 38, 43, 16, -1, 8, 44, -3, 38, 47, 30, -3, -6, 17, -9, -9, 42, 5, -2, -2, 28, 49, 32, 7, 37, 28, -10, 6, 46, 26, 6, 18, 44, 32, 45, -5, 16, 39, 44, 24, 20, 25, 47, 4, 19, -6, 27, 22, -3, 9, 1, 3, 33, 30, 1, 34, 32, 35, 16, 28, 17, 43, 39, 42, 36, 21, -3, 17, 12, 37, 20, 34, 1, 24, 39, 19, 21, 21, 47, 38, 41, -6, 48, 18, 29, 42, 50, 2, 0, 41, 25, 31, 11, 32, 31, 31, -4, 8, 20, 33, 26, 13, 10, 25, 0, 20, 33, 41, -4, 2, 22, 3, 16, 1, 36, 36, -6, 12, -2, 17, 43, 45, 16, 37, 26, 44, 15, 27, 33, 35, -4, 49, 38, 17, 3, 22, -7, 33, -4, 36, 13, 15, 30, 19, 16, 9, 34, 4, 14, 39, -6, -3, -8, 6, 50, 13, 34, 21, 34, 19, -4, 25, 25, 0, 0, 39, 0, 49, 38, 39, 45, 44, 14, 9, 43, 21, 11, 6, 36, 44, 31, -5, 34, 16, 20, 25, 20, 11, 13, 39, -8, 48, 39, 9, 44, 9, 35, 31, 29, 13, 37, 10, 15, 17, 34, 41, 26, 27, -1, 18, 16, 31, 3, 33, 14, -7, -10, 37, 19, 32, 50, 48, 3, 1, 4, 3, -7, 26, 47, 4, 29, -2, -8, 18, -4, 13, 9, 31, 12, 11, 1, 29, 4, -2, -8, 36, 24, 24, 40, 14, 33, 48, -4, 35, -5, 9, -3, -4, 46, 31, 18, 23, 23, -9, 38, 45, 2, 31, 16, 38, 9, 1, 50, 37, 40, 24, 19, 39, 30, 18, 6, 44, 4, 20, 42, 50, 0, 3, 4, -8, 17, 49, 17, 6, 41, 48, 6, 40, 36, 1, -7, 7, 11, 25, 9, 36, -5, 13, 17, -3, 49, 24, 31, -6, 0, -7, -10, 6, 47, -2, 46, 26, 26, 3, 4, -6, 45, 20, -2, 44, 11, 15, 39, 9, 13, 23, 17, 33, 7, 6, 37, -8, 34, 27, 43, -2, 9, 42, -1, 14, 12, 6, -9, 47, 7, 44, 36, 31, 45, 32, 2, 25, 49, 5, 27, 3, 43, 14, 21, -6, 45, -5, 32, 49, 22, 23, 44, 14, 49, 22, 32, 7, 17, 40, 32, 36, 7, 20, 9, -4, 17, 39, 29, 40, -10, 5, 37, 20, 3, 13, 30, 31, 41, 38, 5, 12, 35, 32, 20, 7, -7, 49, 27, 2, 13, 42, 27, -8, 4, -10, 28, 8, -5, 39, 40, 0, 47, 30, 45, 29, 2, 45, 46, -6, 40, 10, 43, 17, -10, -2, 8, 22, 36, 46, 17, -9, 33, 24, -5, 5, 36, 7, 48, 13, -7, 28, 16, -7, 22, -3, 12, 35, -3, 11, -6, 25, 35, 41, 13, 50, 36, -4, 8, -8, -1, 38, 0, 7, 40, 47, 13, 25, 46, 35, 21, 7, 31, 9, 18, 17, 4, 14, 10, 8, 40, 20, 21, 21, 44, 10, 14, -2, 12, 20, -4, 6, 45, 10, 33, -6, 22, 44, 14, 11, 4, 9, 31, 38, 11, 42, 33, 25, 1, 10, 44, 49, 18, -4, -9, 48, -6, 17, -1, 43, 5, 42, 37, 43, 37, 31, 23, 31, 27, 8, -9, 27, 45, 20, 26, -6, 27, 39, 8, 45, 22, -5, 29, 41, 15, 2, 6, 3, 13, 16, 46, 10, 36, 24, 22, 9, 18, 41, 21, -1, 44, 24, 12, 31, 40, 31, 30, 26, 47, 31, 6, -8, -7, 8, 41, 5, 13, -6, -3, 1, -4, 0, 17, 25, 15, 25, 4, 8, 24, 13, -6, 7, 20, 6, 21, 43, 9, 18, 10, 28, 33, 25, 46, -1, 20, 40, 23, 33, 11, 50, 16, -5, 44, 28, 41, 40, 23, -5, 24, 8, 6, 8, 33, 43, 45, 43, 25, 26, 0, 30, -7, 7, 23, 1, 4, 27, 46, 5, 29, 20, -6, 40, 40, 16, -7, 39, -5, 28, 6, 45, 5, 43]
    tc15 = [-1, 0, 0, -1, 0, 1, 1, 0, 0, 1, -1, 0, -1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 0, -1, 1, 1, -1, -1, -1, -1, 1, 0, 0, 0, 1, 0, -1, 1, -1, 1, 0, 0, 0, 1, 0, 0, -1, 1, -1, 1, 1, -1, 1, 1, 0, 1, -1, 1, 1, 0, -1, 1, -1, 1, 1, 1, -1, 0, 0, 0, -1, -1, 1, -1, 0, 1, 1, -1, -1, 0, 0, -1, 1, 1, 0, -1, -1, -1, 1, -1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, -1, 0, 0, 0, -1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, -1, -1, -1, -1, 0, -1, 0, 0, 0, 1, 0, 0, 1, 1, 1, -1, 0, -1, 1, 0, -1, -1, -1, 0, 0, -1, -1, 0, 1, 1, -1, 1, 1, -1, 0, 1, -1, 1, 1, -1, 0, 1, 1, 1, 1, 0, -1, -1, 0, 0, 1, 0, 1, -1, -1, 1, 0, 0, 1, 0, 0, 1, 1, -1, -1, -1, 1, 1, 0, 0, -1, 1, -1, 1, -1, 1, 0, 1, 1, 0, 1, 0, 0, -1, 0, -1, -1, -1, -1, 1, 0, 0, 1, -1, 0, -1, 1, 1, -1, 1, 0, 0, 0, -1, -1, -1, -1, 0, -1, 0, 0, 0, 0, 0, 1, 1, 0, -1, -1, 0, -1, -1, 0, 0, -1, 1, -1, 1, 0, -1, 1, 1, -1, -1, 1, 1, -1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, -1, -1, 0, 1, 1, 0, 0, -1, 0, -1, 0, 1, 1, 1, 0, 1, 0, 0, -1, 0, -1, 0, 0, 0, -1, 1, 1, 0, -1, -1, -1, 0, -1, 0, 0, -1, -1, 0, 1, 1, 1, 1, 0, 0, -1, 0, -1, -1, 1, 0, 0, 0, -1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, -1, 0, 0, -1, -1, 0, 1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 1, 1, -1, 0, 1, 0, -1, 1, 1, 1, -1, -1, 0, 1, 0, 0, 1, 0, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, -1, 0, -1, -1, -1, 1, 1, -1, -1, -1, 0, -1, -1, -1, 0, -1, -1, 1, -1, -1, -1, 0, -1, -1, 0, 1, 1, 1, 0, -1, -1, 0, 0, 0, 0, 0, 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 0, 0, 0, 0, -1, 1, 1, -1, 1, 0, 0, -1, -1, -1, 1, -1, 0, 0, -1, 1, -1, -1, 1, 0, -1, -1, 0, 0, 0, 0, 0, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, -1, -1, 1, 1, 0, 1, 0, 0, 1, -1, 1, -1, -1, 0, -1, -1, 1, 1, 1, 1, 0, 1, -1, -1, -1, 0, -1, -1, -1, -1, 1, -1, -1, 1, 1, 0, 1, -1, -1, -1, 1, 0, 0, -1, 0, -1, 1, 1, 1, 0, -1, -1, -1, 1, -1, 0, 0, 1, -1, -1, 1, 0, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 0, 0, 1, 1, 0, 0, 0, -1, 1, -1, -1, -1, 0, 0, 0, -1, -1, 1, -1, 1, 1, -1, 1, 1, -1, 1, -1, 0, 1, -1, -1, 0, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, 1, 0, -1, 0, 1, 1, 1, 0, 0, 0, 1, 1, -1, -1, 1, 0, 0, 0, -1, -1, -1, 0, 0, 0, 0, 1, 0, 1, 0, -1, 1, 1, -1, -1, -1, -1, 0, -1, 0, -1, 0, 1, 0, 0, 0, 0, 1, 0, 1, -1, 0, 1, -1, 1, 0, 1, -1, 1, -1, 1, 0, 1, 0, 1, 1, -1, 0, -1, 0, 1, 0, 1, -1, 1, -1, 1, 1, 0, 0, -1, 1, 1, 1, -1, 0, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 0, 0, 0, 1, 1, 1, 0, 1, 1, -1, 0, 0, -1, 0, 1, 0, -1, 0, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 0, -1, -1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 0, 0, 0, 1, 0, 0, -1, -1, -1, -1, 0, -1, 1, -1, 1, 0, 0, 0, 0, 0, -1, 0, -1, 0, 0, -1, -1, 1, 0, -1, 0, -1, 1, -1, -1, 0, -1, -1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, -1, 0, -1, -1, 1, 1, 0, 1, -1, 1, 1, 0, 0, 0, 0, -1, 1, -1, -1, -1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 1, 0, 0, 0, 1, -1, 0, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, 0, 0, 1, -1, -1, 0, -1, 0, 0, 1, 1, 1, -1, 0, 0, -1, 1, 0, -1, -1, 1, 0, -1, 1, -1, -1, 0, -1, -1, 0, 0, -1, 0, 0, 1, -1, 0, 1, 1, -1, 1, 0, 0, 0, -1, 0, -1, -1, -1, 0, 0, -1, -1, -1, 0, 1, 0, 1, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, -1, 1, -1, 1, -1, -1, 0, -1, -1, -1, 1, -1, 1, 1, 0, 1, 1, 1, 0, 0, 0, -1, 0, 1, 1, 1, -1, -1, 1, 0, -1, 1, 0, 0, 1, 0, -1, 1, 0, 1, 0, -1, 0, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, -1, 1, 0, 1, -1, 1, -1, 1, 0, -1, 0, 1, 1, -1, 0, 1, -1, 0, 0, 1, -1, -1, -1, 0, -1, -1, 0, -1, 1, 1, 0, 1, 1, 0, -1, 1, 0, 0, -1, -1, -1, 1, 1, 0, 0, -1, 1, 1, 0, 1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 0, 0, -1, -1, 1, 1, 0, -1, 1, 1, 1, 0, -1, -1, 0, -1, 0, 0, -1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 0, 1, 0, 1, -1, 1, -1, -1, 0, -1, 1, 1, 0, 1, 1, 0, 1, 1, 0, -1, 1, -1, 0, 0, -1, 0, 1, -1, 1, 1, -1, 0, 1, -1, 0, -1, 0, 1, -1, -1, 0, 0, -1, 1, -1, -1, 1, -1, -1, 0, 1, 0, 1, 1, -1, -1, 1, -1, 1, 0, -1, 1, -1, 0, -1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, -1, -1, 1, -1, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 0, -1, 0, 1, -1, -1, 1, 0, 0, 1, 1, 1, 1, -1, 0, 0, 1, 1, -1, -1, 0, -1, -1, 1, 1, 0, 1, 0, 0, 0, 1, -1, 0, 1, 0, 0, -1, 0, 1, 1, 1, -1, -1, 0, -1, 0, 1, 1, -1, 1, 0, 1, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, -1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, 1, 0, -1, 1, -1, 1, 1, 1, -1, 1, 1, 0, -1, 1, 1, 0, -1, 0, -1, 1, 1, -1, 1, 0, 0, 1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, 0, 0, 1, -1, -1, 0, -1, 0, 1, 0, -1, -1, 0, 0, 0, -1, 1, 0, -1, -1, -1, 1, -1, 1, 0, 1, -1, -1, -1, 0, -1, -1, 1, 0, 0, 0, 1, 0, 0, 1, 1, -1, -1, 0, 0, 1, -1, 0, 1, -1, 0, 1, 0, -1, 1, 0, -1, 1, -1, -1, -1, 1, 1, 0, 0, -1, 0, -1, 0, -1, 1, 1, -1, -1, 0, -1, 0, 0, -1, 0, 1, -1, 0, -1, 0, 1, 1, -1, -1, 1, -1, -1, 1, 1, 0, -1, 1, -1, 0, 0, 1, 0, -1, 1, 1, 1, 1, 1, -1, 0, 1, 0, -1, 0, -1, 0, 1, -1, 0, -1, 1, -1, 1, 1, 0, -1, 0, -1, -1, 1, 0, -1, 1, 1, 1, 0, 0, 1, -1, -1, 1, 1, 0, 1, 1, 0, 0, 1, -1, 1, 0, 1, -1, 1, -1, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 1, 1, 0, 1, -1, 0, 0, 0, 0, 0, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, -1, -1, 0, 0, 0, 0, 1, 1, -1, -1, 1, -1, 0, -1, 1, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, -1, 0, 0, -1, 0, 0, 0, -1, -1, 0, 0, -1, -1, 0, 1, -1, -1, -1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 1, -1, 0, 1, 0, -1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, -1, 1, 1, -1, 1, 0, -1, 1, -1, -1, 0, -1, 0, 0, 0, 0, 1, 1, 1, -1, 0, 0, 0, -1, 1, 0, 0, -1, 1, -1, 0, 0, -1, 0, 1, 0, 1, 0, 0, 1, -1, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, 0, 1, -1, 1, 0, -1, -1, 1, 1, 1, 1, 0, -1, -1, 1, 0, 0, -1, -1, 0, 0, 1, 1, 0, 1, 1, -1, 0, 1, 0, 0, -1, 1, -1, -1, 0, -1, 0, -1, 1, -1, 1, -1, 0, 0, 1, 1, 1, -1, 1, 1, 1, 1, 0, -1, 1, -1, -1, 0, 1, -1, -1, 0, 0, -1, -1, 1, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 0, 0, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 0, -1, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0, 0, 0, -1, 0, -1, 0, 0, 1, 0, -1, -1, 0, -1, 0, 1, -1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, -1, 0, 1, 1, 1, 1, 1, 1, 1, -1, 0, -1, 0, 1, 1, -1, 0, 0, -1, -1, 1, 1, -1, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, 1, 0, 1, 0, -1, 1, 0, 1, -1, 0, 0, 0, 1, -1, 0, 0, 0, 1, -1, 1, 0, -1, 0, 0, 0, 1, 1, 0, -1, -1, 1, -1, 1, 1, 0, 1, 0, 0, 1, -1, 1, 1, 1, 0, 0, -1, -1, 1, 0, 0, 1, -1, -1, 1, 1, -1, 1, 0, -1, 1, -1, 1, 0, 0, 1, 0, 0, 1, 1, -1, -1, 0, 1, 1, 1, -1, 0, 0, 1, -1, -1, 0, 0, 1, 1, 1, -1, 0, 0, 1, -1, -1, 0, 0, 1, 1, 0, -1, 1, -1, 0, 0, 0, -1, 1, -1, 1, 1, 0, -1, -1, 0, -1, 1, -1, -1, -1, 0, 1, -1, -1, 1, -1, 0, 1, -1, 0, 0, 1, 0, -1, -1, 0, 1, 1, 1, -1, 0, 0, -1, 1, 1, -1, 0, 1, -1, 0, 1, 1, 0, 1, -1, -1, 0, 0, -1, -1, -1, 1, -1, -1, 0, -1, 0, 0, 1, -1, 0, 1, 0, 1, 0, 1, 0, -1, 0, 1, 0, -1, 0, -1, -1, -1, 0, -1, 0, -1, -1, -1, -1, 1, -1, 1, 0, 1, -1, -1, -1, -1, 1, -1, -1, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0, 1, -1, 1, -1, 1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 0, 0, -1, 0, 0, 0, 0, -1, 1, 1, 0, 1, 1, 0, -1, 1, 0, 1, -1, -1, 1, 0, 0, -1]
    testcases = [tc1, tc2, tc3, tc4, tc5, tc6, tc7, tc8, tc9, tc10, tc11, tc12, tc13, tc14, tc15]
    for i, tc in enumerate(testcases):
        print(f"testcase {i + 1}")
        max_sum, max_sum_indices = find_maxsum_subarray(tc)
        print(f"    최대 부분 합 : {max_sum}")
        max_sum_indices.sort()
        print(f"    최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : {max_sum_indices}")

if __name__ == "__main__":
    main()
```

---

# 문제 5. 그룹장의 업무

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

동물 지능 연구그룹의 X 그룹장은 작년에 좋은 평가를 받지 못했다. 탁월한 연구성과로 그룹장의 보직을 맡았지만, 연구원으로서의 자질과 조직장으로서의 자질은 항상 일치하지 않는 법이다.

곰곰히 생각해보니, 우선 그룹에 속한 팀들의 연구 진행 사항을 꼼꼼하게 파악하는 것이 필요하겠다는 생각이 들었다. 그룹장은 소속 팀들의 회의 일정을 확인하고, 되도록 많은 회의에 직접 참석하기로 결정했다. 이 소식을 전해들은 각 연구팀은 오히려 그룹장의 회의 참석이 달갑지 않았다. 조금이라도 더 많은 연구비를 확보하기 위해 팀간, 그룹간 경쟁이 벌어지고 있는 마당에 그룹장이 어떤 자잘한 문제라도 발견하면 곤란해질 수 있겠다는 생각이 들어서였다. 결국 각 팀은 다른 팀의 회의 일정을 확인하고 회의 일정을 일부로 겹쳐 잡는 방식으로 회의 시간을 조정해 그룹장이 최대한 자주 회의에 들어오지 못하도록 하고자 했다.

각 팀의 회의 일정을 받아든 X 그룹장은 중첩된 일정을 확인하고 생각에 잠겼다.

'뭐, 일정이 이렇게 된건 대충 짐작은 간단 말이야. 나도 재작년까지는 저랬을꺼야. 뭐, 이 일정 기준으로라도 최대한 많은 회의에 들어가봐야겠군...'

## 수행목표

- 1번의 회의는 시작 시간과 끝 시간으로 정의되며, 한 번 회의에 참석하면 회의가 끝날때까지 자리를 지키는 것을 원칙으로 한다. 회의가 종료된 후, 다음 회의에 참석하는데 필요한 이동 시간은 10분이라고 가정했을 때 최대로 참석 가능한 회의의 수를 반환하는 함수를 구현한다.

  - 각 시간을 표현하는 숫자는 정수부가 시간, 소숫점 이하는 10분 단위의 분이다. 예를 들어 11은 11시, 14.4는 14시 40분을 의미한다.

  - 11시에 회의가 종료되면 11시에 시작하는 다음 회의는 참석할 수 없고, 빨라도 11시 10분(11.1)에 시작하는 회의에 참석할 수 있다.

- 다음은 시작 시간과 종료 시간의 튜플로 구성된 리스트로 이루어진 매 요일의 회의 스케쥴이다. 요일 별로 참석 가능한 회의의 개수를 출력하라.

  ```python
  tc_mon = [(9, 10), (9, 9.5), (10, 10.3), (10.3, 11), (10.4, 11.3)]
  tc_tue = [(9, 10.5), (10, 11.5), (11, 12.5), (12, 13.5)]
  tc_wed = [(9, 10), (10, 11), (11, 12), (12, 13), (13, 14), (14, 15), (15, 16), (16, 17), (17, 18)]
  tc_thr = [(11.4, 18.5), (11.2, 12.2), (15.1, 15.3), (9.3, 13.5), (9.2, 16.1), (12.2, 18.5), (17.2, 17.5), (11.3, 15.1), (9.2, 12.2), (13.1, 14.4), (14.2, 15.5), (15.1, 18.4), (9.1, 18.3), (15.2, 18.2), (16.4, 18.4), (15.0, 15.2), (9.5, 18.2), (13.3, 18.1), (17.3, 18.3), (10.5, 16.3), (11.1, 13.2), (12.3, 16.5), (9.2, 10.4), (16.3, 18.3), (16.3, 16.5), (16.2, 17.4), (14.2, 16.1), (14.3, 15.3), (15.1, 16.1), (12.0, 17.1)]
  tc_fri = [(16.0, 18), (17.1, 17.4), (12.5, 15.4), (14.3, 17.5), (17.3, 17.4), (11.2, 14.0), (9.4, 17.3), (17.5, 18), (10.5, 14.2), (13.0, 14.0), (13.5, 15.2), (15.0, 17.1), (16.3, 17.0), (11.3, 17.0), (14.0, 15.3), (9.3, 11.0), (13.0, 17.1), (13.2, 14.5), (12.3, 14.4), (14.1, 15.1), (14.3, 15.4), (13.0, 13.5), (9.2, 10.5), (14.0, 15.2), (17.5, 18), (10.3, 14.4), (13.3, 13.5), (10.5, 14.2), (11.3, 15.3), (14.2, 15.2), (16.4, 18.0), (12.4, 14.0), (11.0, 15.4), (11.0, 16.2), (11.4, 14.2), (17.0, 18.0), (9.0, 17.2), (11.1, 16.1), (13.1, 16.1), (12.2, 12.5), (14.3, 18), (16.4, 17.1), (9.4, 12.2), (9.0, 12.1), (13.0, 15.3), (11.3, 12.0), (15.1, 16.3), (9.0, 14.1), (15.5, 16.2), (12.3, 17.2), (13.5, 14.0), (15.5, 17.4), (9.1, 15.1), (9.1, 14.0), (13.1, 17.4), (17.1, 17.4), (17.1, 18), (17.5, 18), (14.3, 14.5), (17.2, 18), (11.4, 12.5), (17.1, 18), (11.4, 12.1), (14.0, 18), (10.0, 17.4), (10.1, 15.1), (11.3, 13.0), (10.5, 17.3), (14.5, 15.3), (11.3, 16.4), (16.4, 18), (13.5, 16.0), (11.1, 12.0), (15.5, 17.4), (17.4, 18), (14.4, 15.3), (17.1, 18), (17.0, 18), (12.0, 14.1), (14.3, 16.0), (9.2, 12.1), (11.1, 11.4), (12.2, 18.0), (17.3, 18), (16.4, 17.2), (16.1, 17.2), (14.3, 16.2), (12.0, 13.2), (14.0, 15.0), (12.4, 13.2), (9.2, 16.1), (15.1, 17.5), (10.2, 17.0), (11.0, 15.0), (13.2, 18.0), (17.4, 18), (14.3, 18.0), (13.2, 18.0), (14.2, 17.2), (12.5, 16.5)]
  ```

## 수행단계

- 그리디 알고리즘(Greedy algorithm)에 대해서 조사한다.
- 회의의 목록은 시작 시간과 종료 시간의 튜플의 리스트로 주어진다. 이 리스트를 기준으로 최대한 많은 회의에 참석하는 스케쥴을 그리디 알고리즘을 사용해 작성하는 함수를 basic_approach/greedy_meeting.py 파일에 구현한다.

  - 반환하는 값은 리스트로 주어진 스케쥴에서 최대로 참석 가능한 회의의 수이다.
  - 예를 들어서 주어진 회의 일정이 [(9, 10), (9, 9.5), (10, 10.3), (10.3, 11), (10.4, 11.3)]인 경우, 9시에 시작해서 9시 50분에 끝나는 회의, 10시에 시작해서 10시 30분에 끝나는 회의, 10시 40분에 시작해서 11시 30분에 끝나는 회의에 참석할 수 있으며, 이때는 3을 반환한다.
  - 회의 일정이 [(9, 10.5), (10, 11.5), (11, 12.5), (12, 13.5)]로 주어진 경우, 9시와 11시에 시작하는 회의 또는 10시와 12시에 시작하는 회의에 참석할 수 있으며, 이 때는 2를 반환한다.

- 주어진 회의 스케쥴을 사용해 요일 별 결과를 출력한다.

## 결과예시

```
월요일 회의 스케쥴
    참석 가능한 최대 회의 횟수 : 3

화요일 회의 스케쥴
    참석 가능한 최대 회의 횟수 : 2
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/greedy_meeting.py 파일에 구현이 되어 있는지 확인한다.
  - 그리디 알고리즘을 사용해 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    월요일 회의 스케쥴
        참석 가능한 최대 회의 횟수 : 3

    화요일 회의 스케쥴
        참석 가능한 최대 회의 횟수 : 2

    수요일 회의 스케쥴
        참석 가능한 최대 회의 횟수 : 5

    목요일 회의 스케쥴
        참석 가능한 최대 회의 횟수 : 6

    금요일 회의 스케쥴
        참석 가능한 최대 회의 횟수 : 9
    ```

### [문제에 대한 이해]

- 그리디 알고리즘에 대해서 설명하라.
- 그리디 알고리즘을 이 문제의 해결에 사용한 방법을 설명하라.
- 그리디 알고리즘을 사용했을 때, 이 문제에 대한 정답이 제공되는 이유를 설명하라.

### [코드 예시]

```python
def meeting_count(meeting_list):
    meeting_list_sorted = sorted(meeting_list, key=lambda x: x[1])

    attended_meeting = [meeting_list_sorted[0]]
    current_meeting_finish_time = meeting_list_sorted[0][1]

    for meeting in meeting_list_sorted[1:]:
        if meeting[0] > current_meeting_finish_time:
            attended_meeting.append(meeting)
            current_meeting_finish_time = meeting[1]

    return len(attended_meeting)

def main():
    tc_mon = [(9, 10), (9, 9.5), (10, 10.3), (10.3, 11), (10.4, 11.3)]
    tc_tue = [(9, 10.5), (10, 11.5), (11, 12.5), (12, 13.5)]
    tc_wed = [(9, 10), (10, 11), (11, 12), (12, 13), (13, 14), (14, 15), (15, 16), (16, 17), (17, 18)]
    tc_thr = [(11.4, 18.5), (11.2, 12.2), (15.1, 15.3), (9.3, 13.5), (9.2, 16.1), (12.2, 18.5), (17.2, 17.5), (11.3, 15.1), (9.2, 12.2), (13.1, 14.4), (14.2, 15.5), (15.1, 18.4), (9.1, 18.3), (15.2, 18.2), (16.4, 18.4), (15.0, 15.2), (9.5, 18.2), (13.3, 18.1), (17.3, 18.3), (10.5, 16.3), (11.1, 13.2), (12.3, 16.5), (9.2, 10.4), (16.3, 18.3), (16.3, 16.5), (16.2, 17.4), (14.2, 16.1), (14.3, 15.3), (15.1, 16.1), (12.0, 17.1)]
    tc_fri = [(16.0, 18), (17.1, 17.4), (12.5, 15.4), (14.3, 17.5), (17.3, 17.4), (11.2, 14.0), (9.4, 17.3), (17.5, 18), (10.5, 14.2), (13.0, 14.0), (13.5, 15.2), (15.0, 17.1), (16.3, 17.0), (11.3, 17.0), (14.0, 15.3), (9.3, 11.0), (13.0, 17.1), (13.2, 14.5), (12.3, 14.4), (14.1, 15.1), (14.3, 15.4), (13.0, 13.5), (9.2, 10.5), (14.0, 15.2), (17.5, 18), (10.3, 14.4), (13.3, 13.5), (10.5, 14.2), (11.3, 15.3), (14.2, 15.2), (16.4, 18.0), (12.4, 14.0), (11.0, 15.4), (11.0, 16.2), (11.4, 14.2), (17.0, 18.0), (9.0, 17.2), (11.1, 16.1), (13.1, 16.1), (12.2, 12.5), (14.3, 18), (16.4, 17.1), (9.4, 12.2), (9.0, 12.1), (13.0, 15.3), (11.3, 12.0), (15.1, 16.3), (9.0, 14.1), (15.5, 16.2), (12.3, 17.2), (13.5, 14.0), (15.5, 17.4), (9.1, 15.1), (9.1, 14.0), (13.1, 17.4), (17.1, 17.4), (17.1, 18), (17.5, 18), (14.3, 14.5), (17.2, 18), (11.4, 12.5), (17.1, 18), (11.4, 12.1), (14.0, 18), (10.0, 17.4), (10.1, 15.1), (11.3, 13.0), (10.5, 17.3), (14.5, 15.3), (11.3, 16.4), (16.4, 18), (13.5, 16.0), (11.1, 12.0), (15.5, 17.4), (17.4, 18), (14.4, 15.3), (17.1, 18), (17.0, 18), (12.0, 14.1), (14.3, 16.0), (9.2, 12.1), (11.1, 11.4), (12.2, 18.0), (17.3, 18), (16.4, 17.2), (16.1, 17.2), (14.3, 16.2), (12.0, 13.2), (14.0, 15.0), (12.4, 13.2), (9.2, 16.1), (15.1, 17.5), (10.2, 17.0), (11.0, 15.0), (13.2, 18.0), (17.4, 18), (14.3, 18.0), (13.2, 18.0), (14.2, 17.2), (12.5, 16.5)]
    testcases = [tc_mon, tc_tue, tc_wed, tc_thr, tc_fri]
    wday_list = ["월", "화", "수", "목", "금"]
    for i, tc in enumerate(testcases):
        print(f"{wday_list[i]}요일 회의 스케쥴")
        count = meeting_count(tc)
        print(f"    참석 가능한 최대 회의 횟수 : {count}")
        print()

if __name__ == "__main__":
    main()

```

---

# 문제 6. 미국에서 동전으로 버스타기

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

학회 참석을 위해서 미국 여행중인 S 연구원은 난감한 상황에 빠졌다. 대한민국은 어디서나 교통카드로 대중교통을 이용할 수 있었는데, 미국 지방 소도시에서 버스를 타려고 하니 카드로 버스를 탈 수 없었던 것이다. 그래서 주섬주섬 호주머니에서 동전을 꺼내고 있는데, 요금통 앞에 다음과 같은 안내문이 적혀 있었다.

> Use the mimnimum number of coins to pay the fare if possible.

## 수행목표

- 미국은 여섯 종류의 동전을 발행한다. 미국에서 사용 가능한 동전은 100센트, 50센트, 25센트, 10센트, 5센트, 1센트 여섯 종류의 동전을 발행하고 있다.
- 버스 요금 n센트를 지불하는데 필요한 최소한의 동전의 개수와 이 때 각 동전 별 사용 개수를 반환하는 함수를 구현한다.
- 버스 요금이 99센트, 398센트, 399센트인 구간의 요금을 지불하는테 필요한 최소한의 동전의 개수와 이 때 동전 별로 사용해야 하는 개수를 출력한다.

## 수행단계

- 100센트, 50센트, 25센트, 10센트, 5센트, 그리고 1센트 동전을 제한없이 사용할 수 있을 때, 특정 금액의 요금을 지불하는데 필요한 최소한의 동전의 개수를 구하는 그리디 알고리즘 접근 방법을 찾는다.
  - 그리디 알고리즘으로 정답을 찾을 수 있는 경우의 조건을 확인한다.
- 그리디 알고리즘을 사용해 최소한의 동전 개수와 이 때 사용할 동전 별 개수를 반환하는 함수를 basic_approach/bus_fare.py 파일에 구현한다.

- 버스 요금이 99센트, 398센트, 399센트인 구간의 결과를 출력한다.

## 결과예시

```
99센트를 거슬러 줄 때 필요한 동전의 최소 개수: 8
이 때의 각 동전의 개수:  {50: 1, 25: 1, 10: 2, 1: 4}
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 동전을 무한히 가지고 있다면 어떤 금액이라도 지불할 수 있겠지만, 동전을 많이 들고 있는 경우는 드물다. 각 동전 별로 사용 가능한 개수가 정해져 있을 때, 이러한 제한 상황에서 최소의 개수의 동전으로 요금을 지불할 때 필요한 동전의 개수와 동전 별 사용 개수를 반환하는 함수를 구현한다.

  - 그리디 알고리즘을 사용해서 구현한다.
  - 만약 제한으로 인해서 요즘을 지불할 수 없다면, 모자란 최소의 금액을 출력한다.

- 100센트, 50센트, 5센트 동전은 제한이 없고 25센트는 0개, 10센트는 1개, 1센트는 3개를 가지고 있을 때, 99센트, 398센트, 399센트를 지불해야 하는 상황의 동전의 최소 개수와 각 동전 별 사용 개수, 그리고 지불할 수 없는 최소의 금액을 출력해보자.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/bus_fare.py 파일에 구현이 되어 있는지 확인한다.
  - 그리디 알고리즘을 사용해 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    99센트를 거슬러 줄 때 필요한 동전의 최소 개수: 8
    이 때의 각 동전의 개수:  {50: 1, 25: 1, 10: 2, 1: 4}
    398센트를 거슬러 줄 때 필요한 동전의 최소 개수: 10
    이 때의 각 동전의 개수:  {100: 3, 50: 1, 25: 1, 10: 2, 1: 3}
    399센트를 거슬러 줄 때 필요한 동전의 최소 개수: 11
    이 때의 각 동전의 개수:  {100: 3, 50: 1, 25: 1, 10: 2, 1: 4}
    ```

### [보너스 과제 확인]

- 지시한 대로 보너스 과제를 해결하였는가?

  - 그리디 알고리즘을 사용해 구현하였는가?

- 결과가 정확한가?

  ```
  99센트를 거슬러 줄 때 필요한 동전의 최소 개수: 12
  이 때의 각 동전의 개수:  {50: 1, 25: 0, 10: 1, 5: 7, 1: 3}
  남은 금액:  1
  398센트를 거슬러 줄 때 필요한 동전의 최소 개수: 15
  이 때의 각 동전의 개수:  {100: 3, 50: 1, 25: 0, 10: 1, 5: 7, 1: 3}
  남은 금액:  0
  399센트를 거슬러 줄 때 필요한 동전의 최소 개수: 15
  이 때의 각 동전의 개수:  {100: 3, 50: 1, 25: 0, 10: 1, 5: 7, 1: 3}
  남은 금액:  1
  ```

### [문제에 대한 이해]

- 이 문제를 해결하기 위해서 택한 탐욕적 선택에 대해서 설명하라.
- 어떤 나라의 동전이 1원, 25원, 30원으로 구성되어 있다고 할 때, 그리디 알고리즘으로 이 문제를 해결할 수 있는가? 이유와 함께 설명하라.

### [코드 예시]

```python

TBD
```

---

# 문제 7. 깊숙히, 더 깊숙히

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

동물의 지능을 연구하는 연구원 T는 다양한 크기, 다양한 형태의 미로에서 쥐가 미로를 탈출하는 방식을 연구하고 있다. 어느날 한 친구가 말했다.

"쥐를 왜 저런 곳에 가둬두고 고생을 시켜?"

물론 농담으로 한 말이긴 한데, 그날 밤 꿈 자신이 그 미로에 갖혀서 헤메는 꿈을 꾸었다. 미로를 위에서 내려다 볼 때는 별 감흥이 없었는데 정작 제한된 시야로 미로를 헤메는 것은 지독한 악몽이었다. 그 끝나지 않을 것 같은 꿈에서 깨어난 연구원 T는 혹시라도 자신이 죽은 후에, 자신이 행한 실험때문에 미로 형태의 지옥에 갖히게 되면 어떻게 해야 할 지와 같은 망상에 사로잡히게 되었다.

## 수행목표

- 그래프 형태의 미로가 주어지고, 미로의 두 꼭짓점 중 두 곳이 입구 꼭짓점과 출구 꼭짓점으로 지정된다. 입구 꼭짓점의 이름은 'start'로 고정되며, 출구 꼭짓점의 이름은 'end'로 고정된다. 미로 그래프의 클래스를 만들고 주어진 미로에서 출구로 가는 방법을 출력하는 메소드를 구현한다.
- 미로를 표현하는 그래프는 다음의 특성을 가지고 있다.

  - 방향성이 없는 그래프이며, 연결된 두 점을 어느 방향으로도 진행할 수 있지만, 최종적으로 반환하는 결과에는 한 번 방문한 꼭짓점은 다시 방문하지 않는 형태로 구성되어야 한다.
  - 그래프는 순환 구조를 가지고 있지 않다. 즉 어떤 꼭짓점에서 자기 자신으로 연결되는 변은 존재하지 않는다.

- 다음 데이터는 7개의 미로를 그래프로 표현한 데이터이다. 이 다섯개의 데이터에서 입구에서 출구까지 진행 가능한 여러 방법 중 하나를 찾아 출력한다.
  - 만약 입구에서 시작해 출구에 도착할 수 없는 경우, 미로를 찾을 수 없다고 출력해야 한다.
  - 각각의 데이터는 한 줄에 하나씩의 변을 표현한다. 꼭짓점의 이름은 임의의 고유한 소문자 조합으로 제시되며, start와 end라는 이름의 꼭짓점이 반드시 포함된다.
  - 첨부한 데이터의 첫 번째 미로는 다음 그림의 미로를 나타낸다.

![image-20240114231923053](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240114231923053.png)

```python
tc1 = [('start', 'bbb'), ('bbb', 'ccc'), ('bbb', 'ddd'), ('ccc', 'aaa'), ('ccc', 'end'), ('end', 'ddd')]
tc2 = [('start', 'hhh'), ('hhh', 'aaa'), ('aaa', 'ccc'), ('ccc', 'iii'), ('iii', 'kkk'), ('kkk', 'ddd'), ('ddd', 'end'), ('end', 'bbb'), ('bbb', 'fff'), ('fff', 'jjj'), ('jjj', 'ggg'), ('jjj', 'aaa'), ('bbb', 'aaa'), ('ccc', 'bbb'), ('end', 'ccc'), ('end', 'iii'), ('end', 'fff'), ('fff', 'ggg'), ('ggg', 'ddd'), ('ggg', 'start'), ('start', 'jjj'), ('hhh', 'jjj'), ('hhh', 'lll'), ('aaa', 'lll'), ('aaa', 'mmm'), ('mmm', 'eee'), ('eee', 'iii'), ('iii', 'mmm'), ('ccc', 'mmm'), ('mmm', 'lll')]
tc3 = [('start', 'hhh'), ('hhh', 'jjj'), ('jjj', 'ggg'), ('jjj', 'start'), ('ggg', 'start'), ('ccc', 'mmm'), ('mmm', 'lll'), ('ggg', 'hhh'), ('aaa', 'lll'), ('aaa', 'ccc'), ('eee', 'mmm'), ('iii', 'ccc'), ('iii', 'eee'), ('eee', 'ccc'), ('eee', 'aaa'), ('iii', 'lll'), ('mmm', 'aaa'), ('lll', 'eee'), ('lll', 'ccc'), ('mmm', 'iii'), ('iii', 'aaa'), ('end', 'kkk'), ('kkk', 'ddd'), ('ddd', 'fff'), ('fff', 'bbb'), ('bbb', 'end'), ('end', 'ddd'), ('fff', 'kkk'), ('kkk', 'bbb'), ('ddd', 'bbb'), ('end', 'fff')]
tc4 = [('bbb', 'end'), ('bbb', 'ccc'), ('ccc', 'iii'), ('iii', 'lll'), ('lll', 'kkk'), ('kkk', 'ddd'), ('ddd', 'fff'), ('fff', 'jjj'), ('jjj', 'ggg'), ('ggg', 'aaa'), ('aaa', 'eee'), ('eee', 'mmm'), ('mmm', 'hhh'), ('hhh', 'start')]
tc5 = [('lll', 'eee'), ('lll', 'bbb'), ('lll', 'ccc'), ('lll', 'kkk'), ('lll', 'ddd'), ('lll', 'fff'), ('lll', 'ggg'), ('lll', 'jjj'), ('lll', 'aaa'), ('lll', 'start'), ('lll', 'hhh'), ('lll', 'mmm'), ('lll', 'end')]
tc6 = [('ccc', 'mmm'), ('bbb', 'iii'), ('iii', 'end'), ('iii', 'kkk'), ('jjj', 'kkk'), ('jjj', 'aaa'), ('start', 'hhh'), ('start', 'ggg'), ('start', 'aaa'), ('aaa', 'lll'), ('lll', 'eee'), ('jjj', 'ddd'), ('ddd', 'end'), ('jjj', 'fff')]
tc7 = [('start', 'aaa'), ('aaa', 'bbb'), ('bbb', 'ccc'), ('ccc', 'ddd'), ('ddd', 'fff'), ('ccc', 'eee'), ('bbb', 'ggg'), ('ggg', 'ccc'), ('ccc', 'ijk'), ('shd', 'eee'), ('eee', 'hjb'), ('hsh', 'kec'), ('seb', 'cra'), ('cra', 'end'), ('ino', 'kec'), ('ino', 'eee'), ('vat', 'hsh'), ('vat', 'ddd'), ('ion', 'ino'), ('seb', 'vat'), ('cat', 'dog'), ('dog', 'pig'), ('pig', 'rat'), ('rat', 'gom'), ('gom', 'pig'), ('pig', 'cat'), ('bbb', 'hjf'), ('aaa', 'bed'), ('ggg', 'poi'), ('ino', 'bhj'), ('vat', 'okj'), ('cra', 'pas'), ('vat', 'dak'), ('seb', 'bes'), ('ddd', 'rnr'), ('dra', 'gon'), ('gon', 'shd'), ('fac', 'eof'), ('eof', 'fla'), ('fla', 'ten'), ('ten', 'fac')]
```

## 수행단계

- DFS 탐색 방법에 대해서 조사한다.

- 기초 자료구조 챕터에서 그래프를 인접 리스트로 표현해 구현하는 방법에 대해서 학습했다. 당시에 문제에서 제시한 방향성 그래프와 달리, 이 문제는 비방향성 그래프를 구성해야 한다. 인접 리스트로 비방향성 그래프를 다루는 방법에 대해서 조사한다.

- start 꼭짓점에서 end 꼭짓점으로 이동하는 경로 중 하나를 찾아 출력하기 위한 클래스와 메소드를 basic_approach/find_route.py 파일에 구현한다.

  - DFS 탐색 방법을 적용해서 경로를 찾아야 한다.
  - 찾아낸 경로는 같은 꼭짓점을 다시 방문하지 않는다.
  - 반환하는 경로는 꼭짓점의 이름의 목록으로 반환한다. 위의 그래프에서는 ['start', 'bbb', 'ccc', 'end'] 또는 ['start', 'bbb', 'ddd', 'end'] 둘 중 하나를 반환한다.
  - 만약 start에서 end로 갈 수 있는 방법이 없는 경우, 빈 리스트를 반환한다.

- 미로 그래프를 만들기 위한 데이터는 일곱 개의 리스트로 주어지는데, 리스트의 각 항목은 연결된 두 꼭짓점의 이름의 튜플로 주어진다.

  - 예시 그림의 그래프는 tc1의 리스트로 표현하고 있다.

  * 그래프의 표현에서 꼭짓점의 순서는 그래프의 구조와 무관하다. 예를 들어 end,ddd와 ddd,end는 동일하다.
  * 7개의 미로 그래프의 객체를 생성하고, 구현한 메소드를 사용해 얻은 결과를 출력한다.

## 결과예시

```
testcase 1
    탈출 경로 : start -> bbb -> ccc -> end
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/find_route.py 파일에 구현이 되어 있는지 확인한다.
  - 깊이 우선 탐색 방법으로 경로를 찾고 있는지 확인한다.
  - 탈출 경로를 확인할 수 없을 때 이를 출력할 수 있도록 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다. 어떤 숫자를 골라내었느냐에 따라 결과는 다르지만 제거한 숫자와 동일한 숫자를 찾을 수 있어야 한다.

  ```
  testcase 1
      탈출 경로 : start -> bbb -> ccc -> end

  testcase 2
      탈출 경로 : start -> hhh -> aaa -> ccc -> iii -> kkk -> ddd -> end

  testcase 3
      탈출할 수 없음

  testcase 4
      탈출 경로 : start -> hhh -> mmm -> eee -> aaa -> ggg -> jjj -> fff -> ddd -> kkk -> lll -> iii -> ccc -> bbb -> end

  testcase 5
      탈출 경로 : start -> lll -> end

  testcase 6
      탈출 경로 : start -> aaa -> jjj -> kkk -> iii -> end

  testcase 7
      탈출 경로 : start -> aaa -> bbb -> ccc -> ddd -> vat -> seb -> cra -> end

  ```

### [문제에 대한 이해]

- DFS란 무엇인가?
- 그래프 자료구조에서 DFS 방식으로 탐색을 할 때, 한 번 방문한 꼭짓점을 다시 방문하지 않도록 하기 위해서 어떤 방법을 사용하였는가?

### [코드 예시]

```python
class MazeGraph:
    def __init__(self):
        self.vertices = {}

    def add_edge(self, vertex1, vertex2):
        if vertex1 not in self.vertices:
            self.vertices[vertex1] = []
        if vertex2 not in self.vertices[vertex1]:
            self.vertices[vertex1].append(vertex2)
        if vertex2 not in self.vertices:
            self.vertices[vertex2] = []
        if vertex1 not in self.vertices[vertex2]:
            self.vertices[vertex2].append(vertex1)

    def find_route(self, start, end, visited = None):
        if visited == None:
            visited = []
        if start == end:
            return [end]
        visited.append(start)
        for neighbor in self.vertices[start]:
            if neighbor not in visited:
                route_after = self.find_route(neighbor, end, visited)
                if route_after != None:
                    return [start] + route_after
        return None

def main():
    tc1 = [('start', 'bbb'), ('bbb', 'ccc'), ('bbb', 'ddd'), ('ccc', 'aaa'), ('ccc', 'end'), ('end', 'ddd')]
    tc2 = [('start', 'hhh'), ('hhh', 'aaa'), ('aaa', 'ccc'), ('ccc', 'iii'), ('iii', 'kkk'), ('kkk', 'ddd'), ('ddd', 'end'), ('end', 'bbb'), ('bbb', 'fff'), ('fff', 'jjj'), ('jjj', 'ggg'), ('jjj', 'aaa'), ('bbb', 'aaa'), ('ccc', 'bbb'), ('end', 'ccc'), ('end', 'iii'), ('end', 'fff'), ('fff', 'ggg'), ('ggg', 'ddd'), ('ggg', 'start'), ('start', 'jjj'), ('hhh', 'jjj'), ('hhh', 'lll'), ('aaa', 'lll'), ('aaa', 'mmm'), ('mmm', 'eee'), ('eee', 'iii'), ('iii', 'mmm'), ('ccc', 'mmm'), ('mmm', 'lll')]
    tc3 = [('start', 'hhh'), ('hhh', 'jjj'), ('jjj', 'ggg'), ('jjj', 'start'), ('ggg', 'start'), ('ccc', 'mmm'), ('mmm', 'lll'), ('ggg', 'hhh'), ('aaa', 'lll'), ('aaa', 'ccc'), ('eee', 'mmm'), ('iii', 'ccc'), ('iii', 'eee'), ('eee', 'ccc'), ('eee', 'aaa'), ('iii', 'lll'), ('mmm', 'aaa'), ('lll', 'eee'), ('lll', 'ccc'), ('mmm', 'iii'), ('iii', 'aaa'), ('end', 'kkk'), ('kkk', 'ddd'), ('ddd', 'fff'), ('fff', 'bbb'), ('bbb', 'end'), ('end', 'ddd'), ('fff', 'kkk'), ('kkk', 'bbb'), ('ddd', 'bbb'), ('end', 'fff')]
    tc4 = [('bbb', 'end'), ('bbb', 'ccc'), ('ccc', 'iii'), ('iii', 'lll'), ('lll', 'kkk'), ('kkk', 'ddd'), ('ddd', 'fff'), ('fff', 'jjj'), ('jjj', 'ggg'), ('ggg', 'aaa'), ('aaa', 'eee'), ('eee', 'mmm'), ('mmm', 'hhh'), ('hhh', 'start')]
    tc5 = [('lll', 'eee'), ('lll', 'bbb'), ('lll', 'ccc'), ('lll', 'kkk'), ('lll', 'ddd'), ('lll', 'fff'), ('lll', 'ggg'), ('lll', 'jjj'), ('lll', 'aaa'), ('lll', 'start'), ('lll', 'hhh'), ('lll', 'mmm'), ('lll', 'end')]
    tc6 = [('ccc', 'mmm'), ('bbb', 'iii'), ('iii', 'end'), ('iii', 'kkk'), ('jjj', 'kkk'), ('jjj', 'aaa'), ('start', 'hhh'), ('start', 'ggg'), ('start', 'aaa'), ('aaa', 'lll'), ('lll', 'eee'), ('jjj', 'ddd'), ('ddd', 'end'), ('jjj', 'fff')]
    tc7 = [('start', 'aaa'), ('aaa', 'bbb'), ('bbb', 'ccc'), ('ccc', 'ddd'), ('ddd', 'fff'), ('ccc', 'eee'), ('bbb', 'ggg'), ('ggg', 'ccc'), ('ccc', 'ijk'), ('shd', 'eee'), ('eee', 'hjb'), ('hsh', 'kec'), ('seb', 'cra'), ('cra', 'end'), ('ino', 'kec'), ('ino', 'eee'), ('vat', 'hsh'), ('vat', 'ddd'), ('ion', 'ino'), ('seb', 'vat'), ('cat', 'dog'), ('dog', 'pig'), ('pig', 'rat'), ('rat', 'gom'), ('gom', 'pig'), ('pig', 'cat'), ('bbb', 'hjf'), ('aaa', 'bed'), ('ggg', 'poi'), ('ino', 'bhj'), ('vat', 'okj'), ('cra', 'pas'), ('vat', 'dak'), ('seb', 'bes'), ('ddd', 'rnr'), ('dra', 'gon'), ('gon', 'shd'), ('fac', 'eof'), ('eof', 'fla'), ('fla', 'ten'), ('ten', 'fac')]
    testcases = [tc1, tc2, tc3, tc4, tc5, tc6, tc7]
    for i, tc in enumerate(testcases):
        maze = MazeGraph()
        for vertex1, vertex2 in tc:
            maze.add_edge(vertex1, vertex2)
        print(f"testcase {i + 1}")
        route = maze.find_route('start', 'end')
        if route == None:
            print("    탈출할 수 없음")
        else:
            route_in_str = ' -> '.join(route)
            print(f"    탈출 경로 : {route_in_str}")
        print()


if __name__ == '__main__':
    main()
```

---

# 문제 8. 계통도를 공유하려는데... (1)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

공동 연구를 수행중인 외부 연구팀으로부터 계통도 데이터의 공유 요청을 받은 닥터 E의 고민은 계통도의 전달 방법이었다. 몇몇 계통도는 너무 방대해서 출력 문서로 전달은 커녕, 이미지 파일로 만든다 할 지라도 어마어마하게 커다란 그림파일을 만들어야 할 판이었다. 게다가 문서나 이미지로 전달해 봤자, 다시 일일이 손으로 입력을 해야 하는 데이터를 상대방이 좋아할리가 만무했다.

그래서 계통도를 적당한 문자열로 표현해서 전달하는 방법을 찾기 위해서 프로그래밍 지원 게시판에 도움을 청하게 되었다.

## 수행목표

- 이진 트리가 주어졌을 때, 이 이진 트리를 다음의 조건을 만족하는 문자열로 표현하고자 한다.

  > - 어떤 계통도를 이 방법을 사용해서 표현하면 항상 동일한 결과가 나온다.
  > - 서로 다른 계통도는 항상 다른 문자열로 표현된다.
  > - 이 문자열을 사용해서 원래의 계통도를 복원할 수 있다.

- 이러한 문자열 표현 방법은 여러가지가 있다. 이 중 하나는 다음과 같은 방법이다.

  - 이진 트리의 최상위 노드를 기록한다.
  - 이진 트리의 그 다음 레벨의 노드를 왼쪽부터 차례로 기록한다. 만약 비어 있는 노드가 있다면, 이 위치를 알 수 있도록 한다.
  - 이 과정을 반복해 이진 트리의 최하위 레벨의 노드를 왼쪽부터 차례로 기록한다.
  - 다음은 두 개의 트리와, 이 두 트리를 이 방법으로 문자열로 바꾼 예이다.

    - 트리 1 : `G0,G1_1,G1_2,G2_1,G2_2,G2_3,G2_4`

      ![image-20240116200733387](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240116200733387.png)

    - 트리 2 : `G0,G1_1,G1_2,,G2_2,G2_3,,,,,,G3_5`

      ![image-20240116201127404](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240116201127404.png)

  - 이진 트리를 이와 같은 방식으로 표현하는 함수를 구현한다.

- 다음 첨부파일에는 8개의 트리가 포함되어 있다. 이 트리를 문자열로 바꾸고 출력한다.

## 수행단계

- BFS에 대해서 조사한다.

  - 트리 자료구조에서 BFS 방식으로 트리를 탐사하는 방법을 조사한다.

- 이진 트리를 생성한 후, 이 이진 트리를 BFS 방식으로 고유한 문자열로 바꾸는 함수를 basic_approach/convert_tree_to_str_b.py 파일에 구현한다.

  - 이진 트리를 문자열로 바꾸기 위해서 트리 전체를 탐사하는 방식은 너비 우선 탐석(BFS) 방식을 사용한다.
  - 이 함수는 트리를 최상위 레벨부터 최하위 레벨까지 차례로 쉼표로 구분해 나열한다.
  - 만약 특정 위치에 노드가 없다면 쉼표와 쉼표 사이에 아무 값도 추가하지 않는 방식으로 이를 표현한다.
  - 최하위 레벨의 존재하는 마지막 노드 이후의 빈 자리는 표시하지 않는다.

- 이 함수를 사용해 첨부한 파일에 포함된 8개의 트리를 문자열 형식으로 변경한 후, 이 문자열을 다음 함수를 사용해 만든 간이 해시값을 출력한다.
  - 파일은 자료 구조 과정에서 이진 트리의 문제에 사용한 것과 동일한 구조의 파일이다.
  - 각 줄이 하나의 노드이며, 노드의 위치와 이름으로 구성되어 있다.
  - 위치에서 O는 최상위 노드를 의미하며, l은 왼쪽 자식 노드, r은 오른쪽 자식 노드를 의미한다.
  - 각 노드의 순서는 무작위로 셔플되어 있으나, 데이터에 포함된 모든 노드를 사용해 트리를 생성해야 한다.

## 결과예시

```
Testcase 1
    BFS 문자열 표현의 간이 해시값 : 669e

Testcase 2
    BFS 문자열 표현의 간이 해시값 : 3d7c

Testcase 3
    BFS 문자열 표현의 간이 해시값 : 669e

Testcase 4
    BFS 문자열 표현의 간이 해시값 : 433b

(이하 생략)
```

## 참고사항

- 테스트케이스 1, 2, 3, 4 트리의 문자열 표현은 다음과 같다.
  - a0,b0,b1,c0,c1,c2,c3
  - b0,a0
  - a0,b0,b1,c0,c1,c2,c3
  - a0,b0,,c0,,,,d0,,,,,,,,e0
- 이 문제를 해결하기 위해서 이전에 구현한 datastructure/evolution_binarytree.py 파일을 import해서 사용하거나, 이 파일에서 필요한 코드를 복사해 사용해도 좋다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 친절한 닥터 E는 공동 연구를 진행하는 외부 연구팀을 위해서 이렇게 만들어진 문자열 형식의 트리를 원래의 트리로 변경하는 방법도 제공해주기로 하였다. 이를 위해서 위의 형식으로 주어진 문자열을 트리로 복원하는 함수를 구현하라.
  - 문제에서 제공한 8개의 트리를 문자열로 바꾼 결과를 다시 트리로 복원하고, 이를 다시 문자열로 바꾸어 출력한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/convert_tree_to_str_b.py 파일에 구현이 되어 있는지 확인한다.
  - 너비 우선 탐색(BFS) 방식으로 트리를 탐색하면서 트리의 문자열을 생성하는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

  ```
  Testcase 1
      BFS 문자열 표현의 간이 해시값 : 669e

  Testcase 2
      BFS 문자열 표현의 간이 해시값 : 3d7c

  Testcase 3
      BFS 문자열 표현의 간이 해시값 : 669e

  Testcase 4
      BFS 문자열 표현의 간이 해시값 : 433b

  Testcase 5
      BFS 문자열 표현의 간이 해시값 : 4254

  Testcase 6
      BFS 문자열 표현의 간이 해시값 : 5698

  Testcase 7
      BFS 문자열 표현의 간이 해시값 : 7917

  Testcase 8
      BFS 문자열 표현의 간이 해시값 : 399b
  ```

### [보너스 과제 확인]

- 결과가 정확한가?
  - 원래의 트리를 그대로 복원하여, 복원한 트리의 문자열 표현이 원래의 문자열 표현과 동일한지 확인한다.

```
Testcase 1
    BFS 문자열 표현의 간이 해시값 : 669e
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 669e
    원래의 트리와 일치합니다.

Testcase 2
    BFS 문자열 표현의 간이 해시값 : 3d7c
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 3d7c
    원래의 트리와 일치합니다.

Testcase 3
    BFS 문자열 표현의 간이 해시값 : 669e
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 669e
    원래의 트리와 일치합니다.

Testcase 4
    BFS 문자열 표현의 간이 해시값 : 433b
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 433b
    원래의 트리와 일치합니다.

Testcase 5
    BFS 문자열 표현의 간이 해시값 : 4254
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 4254
    원래의 트리와 일치합니다.

Testcase 6
    BFS 문자열 표현의 간이 해시값 : 5698
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 5698
    원래의 트리와 일치합니다.

Testcase 7
    BFS 문자열 표현의 간이 해시값 : 7917
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 7917
    원래의 트리와 일치합니다.

Testcase 8
    BFS 문자열 표현의 간이 해시값 : 399b
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 399b
    원래의 트리와 일치합니다.
```

### [문제에 대한 이해]

- 너비 우선 탐색 (BFS)란 무엇인가?
- 트리에서 BFS 방식으로 탐색하는 순서를 임의의 트리를 사용해 설명하라.
- 파이썬 프로그램에서 트리의 BFS 탐색을 위해서 어떠한 방법을 사용하였는가?

### [코드 예시]

```python

class Species:
    def __init__(self, name):
        self.name = name
        self.left = None
        self.right = None

def add_child(species_name: str, parent: Species, is_left: bool) -> Species:
    new_species = Species(species_name)
    if parent != None:
        if is_left:
            if parent.left != None:
                return None
            else:
                parent.left = new_species
        else:
            if parent.right != None:
                return None
            else:
                parent.right = new_species
    return new_species

def convert_tree_bfs(root: Species):
    if root == None:
        return ''
    result = root.name + ','
    node_for_explore = [root.left, root.right]
    while True:
        next_node_count = 0
        node_for_explore_next = []
        for node in node_for_explore:
            if node == None:
                result += ','
                node_for_explore_next += [None, None]
            else:
                result += node.name + ','
                if node.left != None:
                    node_for_explore_next.append(node.left)
                    next_node_count += 1
                else:
                    node_for_explore_next.append(None)
                if node.right != None:
                    node_for_explore_next.append(node.right)
                    next_node_count += 1
                else:
                    node_for_explore_next.append(None)
        if next_node_count == 0:
            break
        node_for_explore = node_for_explore_next
    while result[-1] == ',':
        result = result[:-1]
    return result

def recover_tree(tree_str: str):
    nodes = tree_str.split(',')
    if len(nodes) == 0:
        return None
    root = Species(nodes[0])
    parent_nodes = [root]
    next_parent_nodes = []
    idx = 1
    while idx < len(nodes):
        if len(parent_nodes) == 0:
            parent_nodes = next_parent_nodes
            next_parent_nodes = []

        parent_node = parent_nodes.pop(0)
        if parent_node == None:
            next_parent_nodes += [None, None]
        else:
            next_child = nodes[idx]
            if next_child != '':
                parent_node.left = Species(next_child)
                next_parent_nodes.append(parent_node.left)
            else:
                next_parent_nodes.append(None)
            if idx + 1 >= len(nodes):
                break
            next_child = nodes[idx + 1]
            if next_child != '':
                parent_node.right = Species(next_child)
                next_parent_nodes.append(parent_node.right)
            else:
                next_parent_nodes.append(None)
        idx += 2
    return root

def make_tree(nodes: list[(str, str)]):
    check_node_location = nodes[0][0]
    nodes.sort(key=lambda x: len(x[0]))

    root = add_child(nodes[0][1], None, True)
    check_node = None
    if check_node_location == 'O':
        check_node = root
    for i in range(1, len(nodes)):
        location = nodes[i][0]
        name = nodes[i][1]
        parent = root
        discovery_str = ''
        for j in range(1, len(location) - 1):
            if location[j] == 'l':
                parent = parent.left
                discovery_str += 'l'
            else:
                parent = parent.right
                discovery_str += 'r'

        if location[-1] == 'l':
            added_node = add_child(name, parent, True)

        else:
            added_node = add_child(name, parent, False)
        if location == check_node_location:
            check_node = added_node
    return root, check_node


import hashlib

def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]


def main():
    with open("tree_example.txt", "r") as f:
        lines = f.readlines()

    testcases = []
    testcase = []
    for line in lines:
        if line[:8] == 'Testcase':
            if testcase != []:
                testcases.append(testcase)
                testcase = []
        else:
            testcase.append(line.strip().split(','))
    testcases.append(testcase)

    for i, tc in enumerate(testcases):
        print(f"Testcase {i+1}")
        root, _ = make_tree(tc)
        tree_description = convert_tree_bfs(root)
        print(f"    BFS 문자열 표현의 간이 해시값 : {hash4(tree_description)}")
        recovered_tree = recover_tree(tree_description)
        recovered_tree_description = convert_tree_bfs(recovered_tree)
        if tree_description == recovered_tree_description:
            print(f"    복원한 트리의 BFS 문자열 표현의 간이 해시값 : {hash4(recovered_tree_description)}")
            print(f"    원래의 트리와 일치합니다.")
        else:
            print(f"    복원한 트리의 BFS 문자열 표현의 간이 해시값 : {hash4(recovered_tree_description)}")
            print(f"    원래의 트리와 일치하지 않습니다.")
        print()

if __name__ == "__main__":
    main()
```

---

# 문제 9. 계통도를 공유하려는데... (2)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

계통도를 공유하기 위해서 프로그래밍 게시판에서 조언한 방법에 따라 계통도를 문자열로 만들어놓고 보니 그 결과가 닥터 E의 마음을 불편하게 했다. 쓸데없이 문자열이 길어졌고, 또 주어진 문자열 만으로 트리의 형태를 유추하는게 쉽지 않았기 때문이다.

곰곰히 생각해 보니 더 좋은 방법이 있는 것 같았다. 머리 속의 생각을 정리하고 이를 실제로 만들어보니 결과가 꽤나 흡족했다.

## 수행목표

- 이진 트리를 다음과 같은 문자열로 표현한다.

  - 같은 부모를 공유하는 두 자식 노드는 괄호로 묶는다.
  - 형제가 없는 노드는 빈 문자열로 표현한다.
  - 자식 노드는 부모 노드 뒤에 붙여서 표현한다.
  - 자식 노드가 없는 노드는 더 이상 확장해 표현하지 않는다.

    - 다음은 두 개의 트리와, 이 두 트리를 이 방법으로 문자열로 바꾼 예이다.

    * 트리 1 : `G0(G1_1(G2_1,G2_2),G1_2(G2_3,G2_4))`

      ![image-20240116200733387](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240116200733387.png)

    * 트리 2 : `G0(G1_1(,G2_2),G1_2(G2_3(G3_5,),),)`

      ![image-20240116201127404](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240116201127404.png)

  * 이진 트리를 이와 같은 방식으로 표현하는 함수를 구현한다.

* 다음 첨부파일에는 8개의 트리가 포함되어 있다. 이 트리를 문자열로 바꾸고 출력한다.

## 수행단계

- 트리 자료구조에서 DFS 방식으로 탐사하는 방법에 대해서 조사한다.

- 이진 트리를 생성한 후, 이 이진 트리를 DFS 방식으로 고유한 문자열로 바꾸는 함수를 basic_approach/convert_tree_to_str_d.py 파일에 구현한다.

  - 이진 트리를 문자열로 바꾸기 위해서 트리 전체를 탐사하는 방식은 깊이 우선 탐석(DFS) 방식을 사용한다.
  - 이 함수는 레벨과 무관하게 자식 노드들을 먼저 확인해 괄호와 쉼표를 사용해 나열한다.
  - 형제 노드 중 하나가 없는 경우, 빈 자리는 빈 문자열로 표현해 왼쪽, 오른쪽 중 비어 있는 쪽이 어디인지 알 수 있도록 한다.

- 이 함수를 사용해 첨부한 파일에 포함된 8개의 트리를 문자열 형식으로 변경한 후, 이 문자열을 다음 함수를 사용해 만든 간이 해시값을 출력한다.
  - 파일은 자료 구조 과정에서 이진 트리의 문제에 사용한 것과 동일한 구조의 파일이다.
  - 각 줄이 하나의 노드이며, 노드의 위치와 이름으로 구성되어 있다.
  - 위치에서 O는 최상위 노드를 의미하며, l은 왼쪽 자식 노드, r은 오른쪽 자식 노드를 의미한다.
  - 각 노드의 순서는 무작위로 셔플되어 있으나, 데이터에 포함된 모든 노드를 사용해 트리를 생성해야 한다.

## 결과예시

```
Testcase 1
    BFS 문자열 표현의 간이 해시값 : 6822

Testcase 2
    BFS 문자열 표현의 간이 해시값 : a86b

Testcase 3
    BFS 문자열 표현의 간이 해시값 : 6822

Testcase 4
    BFS 문자열 표현의 간이 해시값 : e919
(이하 생략)
```

## 참고사항

- 테스트케이스 1, 2, 3, 4 트리의 문자열 표현은 다음과 같다.
  - a0(b0(c0,c1),b1(c2,c3))
  - b0(a0,)
  - a0(b0(c0,c1),b1(c2,c3))
  - a0(b0(c0(d0(e0,),),),)
- 이 문제를 해결하기 위해서 이전에 구현한 datastructure/evolution_binarytree.py 파일을 import해서 사용하거나, 이 파일에서 필요한 코드를 복사해 사용해도 좋다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 친절한 닥터 E는 공동 연구를 진행하는 외부 연구팀을 위해서 수정한 방식으로 만든 문자열 형식의 트리 데이터를 원래의 트리로 변경하는 방법도 제공해주기로 하였다. 이를 위해서 위의 형식으로 주어진 문자열을 트리로 복원하는 함수를 구현하라.
  - 문제에서 제공한 8개의 트리를 문자열로 바꾼 결과를 다시 트리로 복원하고, 이를 다시 문자열로 바꾸어 출력한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/convert_tree_to_str_d.py 파일에 구현이 되어 있는지 확인한다.
  - 깊이 우선 탐색(DFS) 방식으로 트리를 탐색하면서 트리의 문자열을 생성하는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

  ```
  Testcase 1
      BFS 문자열 표현의 간이 해시값 : 6822

  Testcase 2
      BFS 문자열 표현의 간이 해시값 : a86b

  Testcase 3
      BFS 문자열 표현의 간이 해시값 : 6822

  Testcase 4
      BFS 문자열 표현의 간이 해시값 : e919

  Testcase 5
      BFS 문자열 표현의 간이 해시값 : 336f

  Testcase 6
      BFS 문자열 표현의 간이 해시값 : cca6

  Testcase 7
      BFS 문자열 표현의 간이 해시값 : f4b4

  Testcase 8
      BFS 문자열 표현의 간이 해시값 : 5f48

  ```

### [보너스 과제 확인]

- 결과가 정확한가?
  - 원래의 트리를 그대로 복원하여, 복원한 트리의 문자열 표현이 원래의 문자열 표현과 동일한지 확인한다.

```
Testcase 1
    BFS 문자열 표현의 간이 해시값 : 669e
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 669e
    원래의 트리와 일치합니다.

Testcase 2
    BFS 문자열 표현의 간이 해시값 : 3d7c
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 3d7c
    원래의 트리와 일치합니다.

Testcase 3
    BFS 문자열 표현의 간이 해시값 : 669e
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 669e
    원래의 트리와 일치합니다.

Testcase 4
    BFS 문자열 표현의 간이 해시값 : 433b
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 433b
    원래의 트리와 일치합니다.

Testcase 5
    BFS 문자열 표현의 간이 해시값 : 4254
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 4254
    원래의 트리와 일치합니다.

Testcase 6
    BFS 문자열 표현의 간이 해시값 : 5698
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 5698
    원래의 트리와 일치합니다.

Testcase 7
    BFS 문자열 표현의 간이 해시값 : 7917
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 7917
    원래의 트리와 일치합니다.

Testcase 8
    BFS 문자열 표현의 간이 해시값 : 399b
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 399b
    원래의 트리와 일치합니다.
```

### [문제에 대한 이해]

- 트리에서 DFS 방식으로 탐색하는 순서를 임의의 트리를 사용해 설명하라.
- 파이썬 프로그램에서 트리의 DFS 탐색을 위해서 어떠한 방법을 사용하였는가?
- 만약 재귀 호출을 사용하지 않고 DFS와 BFS를 구현해야 할 때, 스택 또는 큐 둘 중 하나를 사용할 수 있다고 가정하자. DFS와 BFS 각각은 어떤 자료구조를 사용해서 구현하는 것이 바람직한지 의견을 근거와 함께 제시하라.

### [코드 예시]

```python
class Species:
    def __init__(self, name):
        self.name = name
        self.left = None
        self.right = None

def add_child(species_name: str, parent: Species, is_left: bool) -> Species:
    new_species = Species(species_name)
    if parent != None:
        if is_left:
            if parent.left != None:
                return None
            else:
                parent.left = new_species
        else:
            if parent.right != None:
                return None
            else:
                parent.right = new_species
    return new_species

def convert_tree_dfs(root: Species):
    if root == None:
        return ''
    result = root.name
    if root.left == None and root.right == None:
        return result
    if root.left != None:
        result += '(' + convert_tree_dfs(root.left) + ','
    else:
        result += '(,'
    if root.right != None:
        result += convert_tree_dfs(root.right) + ')'
    else:
        result += ')'
    return result

def recover_tree(tree_str: str):
    if tree_str == '':
        return None
    if '(' not in tree_str:
        return Species(tree_str)
    depth = 0
    p_start = -1
    comma_at = -1
    p_end = -1
    idx = 0
    while True:
        if tree_str[idx] == '(':
            if depth == 0:
                p_start = idx
            depth += 1
        elif tree_str[idx] == ',':
            if depth == 1:
                comma_at = idx
        elif tree_str[idx] == ')':
            depth -= 1
            if depth == 0:
                p_end = idx
                break
        idx += 1
    left = tree_str[p_start + 1:comma_at]
    right = tree_str[comma_at + 1:p_end]
    node = Species(tree_str[:p_start])
    if left != '':
        node.left = recover_tree(left)
    if right != '':
        node.right = recover_tree(right)
    return node

def make_tree(nodes: list[(str, str)]):
    check_node_location = nodes[0][0]
    nodes.sort(key=lambda x: len(x[0]))

    root = add_child(nodes[0][1], None, True)
    check_node = None
    if check_node_location == 'O':
        check_node = root
    for i in range(1, len(nodes)):
        location = nodes[i][0]
        name = nodes[i][1]
        parent = root
        discovery_str = ''
        for j in range(1, len(location) - 1):
            if location[j] == 'l':
                parent = parent.left
                discovery_str += 'l'
            else:
                parent = parent.right
                discovery_str += 'r'

        if location[-1] == 'l':
            added_node = add_child(name, parent, True)

        else:
            added_node = add_child(name, parent, False)
        if location == check_node_location:
            check_node = added_node
    return root, check_node


import hashlib

def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]


def main():
    with open("tree_example.txt", "r") as f:
        lines = f.readlines()

    testcases = []
    testcase = []
    for line in lines:
        if line[:8] == 'Testcase':
            if testcase != []:
                testcases.append(testcase)
                testcase = []
        else:
            testcase.append(line.strip().split(','))
    testcases.append(testcase)

    for i, tc in enumerate(testcases):
        print(f"Testcase {i+1}")
        root, _ = make_tree(tc)
        tree_description = convert_tree_dfs(root)
        print(f"    BFS 문자열 표현의 간이 해시값 : {hash4(tree_description)}")
        recovered_tree = recover_tree(tree_description)
        recovered_tree_description = convert_tree_dfs(recovered_tree)
        if tree_description == recovered_tree_description:
           print(f"    복원한 트리의 BFS 문자열 표현의 간이 해시값 : {hash4(recovered_tree_description)}")
           print(f"    원래의 트리와 일치합니다.")
        else:
           print(f"    복원한 트리의 BFS 문자열 표현의 간이 해시값 : {hash4(recovered_tree_description)}")
           print(f"    원래의 트리와 일치하지 않습니다.")
        print()

if __name__ == "__main__":
    main()
```

---

# 문제 10. 진화 계통도 상의 생물들을 의미있게 나열하라

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 E는 트리로 구성된 계통도를 이리저리 뜯어보다가 계통도에 포함된 생물들을 나열하는 몇 가지 절차를 발견했다.
'이 순서로 나열하면, 조상 생물이 항상 후손 생물 보다 앞에 위치하는 목록이 만들어지는군.'
'어, 이렇게 하면 후손 생물이 항상 조상 생물보다 앞에 위치하는 목록도 만들어지는데?'
'음, 이건 어떤 특징이 있지?'
닥터 E는 트리에서 본인이 발견한 목록 생성 절차에 대한 메모를 작성한 다음, 그 메모를 프로그래밍 지원 게시판에 게시하고 이러한 절차로 목록을 만드는 방법을 문의했다.

## 수행목표

- 생물의 이름을 노드의 값으로 가지는 이진트리를 사용해 진화계통도 트리를 생성한다.
- 진화계통도 트리에 포함된 모든 생물의 이름을 단 한번 씩 만 포함하는 목록을 만드는 함수 1을 구현한다. 이 목록은 다음 원칙을 준수한다.
  > - 부모-자식 관계의 노드에 대해서, 항상 부모 노드의 이름이 자식 노드의 이름보다 목록의 앞부분에 위치한다.
  > - 같은 부모를 가진 형제 노드는 왼쪽 노드의 이름이 오른쪽 노드의 이름보다 목록의 앞부분에 위치한다.
- 진화계통도 트리에 포함된 모든 생물의 이름을 단 한번 씩 만 포함하는 목록을 만드는 함수 2를 구현한다. 이 목록은 다음 원칙을 준수한다.
  > - 부모-자식 관계의 노드에 대해서, 항상 자식 노드의 이름이 부모 노드의 이름보다 목록의 앞부분에 위치한다.
  > - 같은 부모를 가진 형제 노드는 왼쪽 노드의 이름이 오른쪽 노드의 이름보다 목록의 앞부분에 위치한다.
- 진화계통도 트리에 포함된 모든 생물의 이름을 단 한번 씩 만 포함하는 목록을 만드는 함수 3을 구현한다. 이 목록은 다음 원칙을 준수한다.
  > - 어떤 노드의 왼쪽 자식 노드와 그 노드의 자손 노드의 이름은 항상 그 노드의 이름보다 앞에 위치한다.
  > - 어떤 노드의 오른쪽 자식 노드와 그 노드의 자손 노드의 이름은 항상 그 노드의 이름보다 뒤에 위치한다.
- 다음 그림의 이진트리를 대상으로 세 함수가 반환하는 결과의 목록은 다음과 같다.

  - 함수 1 : R, G, A, L, O, I, M, T, H
  - 함수 2 : L, A, O, G, H, T, M, I, R
  - 함수 3 : A, L, G, O, R, I, T, H, M

  ![](ch4_10_1.png)

- 첨부한 파일(tree_example2.txt)에는 11개의 트리가 포함되어 있고, 각각의 트리는 다음과 같이 저장되어 있다.
  - 각 트리는 testcase 번호 줄로 시작한다.
  - 각 줄이 하나의 노드이며, 노드의 위치와 이름으로 구성되어 있다. 위치에서 O은 최상위 노드를 의미하며, l은 왼쪽 자식 노드, r은 오른쪽 자식 노드를 의미한다. 예시는 다음과 같다.
    - O : 루트 노드
    - Ol : 루트의 왼쪽 자식 노드
    - Orlr : 루트의 오른쪽 자식 노드의 왼쪽 자식 노드의 오른쪽 자식 노드
  - 트리에 포함된 각 노드의 순서는 무작위로 섞여서 제공된다. 생성된 트리에는 주어진 노드가 모두 포함되어야 한다.
- 첨부한 파일의 데이터로 생성한 11개의 트리에 대해서 세 방식의 이름 리스트를 생성한 후, 이 리스트를 모두 이어 붙인 문자열의 간이 해시값을 출력한다.

## 수행단계

- 진화 계통도를 이진트리로 구성하는 파이썬 클래스 및 함수를 구현한다. 이 부분은 과거 문제에서 구현한 코드를 가지고 와서 사용해도 좋다.
- 수행 목표에서 제시한 3개의 함수를 basic_approach/traversal.py 파일에 구현한다.
  - 세 함수는 모두 재귀 호출을 사용해서 동작한다.
  - 세 함수는 같은 코드를 공유하고, 코드의 순서만 다르게 구성해 서로 다른 문자열의 리스트를 반환하도록 구현한다. (물론, 재귀호출하는 함수의 이름은 달라야 한다.)
- 첨부한 파일에 포함된 트리의 표현은 예전 문제에서 사용한 이진트리의 테스트용 데이터와 같은 형식이다. 예전에 구현한 파일 파싱 코드를 가지고 와서 사용해도 좋다. 첨부한 파일에 포함된 각각의 트리를 생성한다.
- 만든 트리를 세 가지 방식으로 구현된 함수를 사용해 세 개의 리스트를 만든다. 이 세개의 리스트를 순서대로 다음 함수의 파라미터로 사용해서 얻은 결과를 출력한다.

```python
import hashlib

def hash4_from_lists(arr1, arr2, arr3):
    arr = arr1 + arr2 + arr3
    return hashlib.md5(str(arr).encode()).hexdigest()[:4]

```

## 결과예시

```
Testcase 1 : ebf1

Testcase 2 : 806f

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/traversal.py 파일에 구현이 되어 있는지 확인한다.
  - 전위 순회, 중위 순회, 후위 순회 세 방식을 재귀 호출로 재귀 호출의 순서만 바꾸는 차이를 가지도록 구현하였는지 확인하낟.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

  ```
  Testcase 1 : ebf1

  Testcase 2 : 806f

  Testcase 3 : 4aea

  Testcase 4 : 806f

  Testcase 5 : cdf0

  Testcase 6 : b76e

  Testcase 7 : 8714

  Testcase 8 : 3a89

  Testcase 9 : ffd1

  Testcase 10 : 518f

  Testcase 11 : 0a3c
  ```

### [문제에 대한 이해]

- 이 문제에서 사용한 이진 트리의 세 가지 탐색 방법은 각각 전위 순회 탐사, 후위 순회 탐사, 중위 순회 탐사라고 한다. 세 탐사 방법을 재귀 호출을 사용해 구현하는 방법을 설명하라.

### [코드 예시]

```python
class Species:
    def __init__(self, name):
        self.name = name
        self.left = None
        self.right = None

def add_child(species_name: str, parent: Species, is_left: bool) -> Species:
    new_species = Species(species_name)
    if parent != None:
        if is_left:
            if parent.left != None:
                return None
            else:
                parent.left = new_species
        else:
            if parent.right != None:
                return None
            else:
                parent.right = new_species
    return new_species

def in_order(root: Species):
    if root == None:
        return []
    result = []
    result += in_order(root.left)
    result.append(root.name)
    result += in_order(root.right)
    return result

def pre_order(root: Species):
    if root == None:
        return []
    result = []
    result.append(root.name)
    result += pre_order(root.left)
    result += pre_order(root.right)
    return result

def post_order(root: Species):
    if root == None:
        return []
    result = []
    result += post_order(root.left)
    result += post_order(root.right)
    result.append(root.name)
    return result


def make_tree(nodes: list[(str, str)]):
    check_node_location = nodes[0][0]
    nodes.sort(key=lambda x: len(x[0]))

    root = add_child(nodes[0][1], None, True)
    check_node = None
    if check_node_location == 'O':
        check_node = root
    for i in range(1, len(nodes)):
        location = nodes[i][0]
        name = nodes[i][1]
        parent = root
        discovery_str = ''
        for j in range(1, len(location) - 1):
            if location[j] == 'l':
                parent = parent.left
                discovery_str += 'l'
            else:
                parent = parent.right
                discovery_str += 'r'

        if location[-1] == 'l':
            added_node = add_child(name, parent, True)

        else:
            added_node = add_child(name, parent, False)
        if location == check_node_location:
            check_node = added_node
    return root, check_node

import hashlib

def hash4_from_lists(arr1, arr2, arr3):
    arr = arr1 + arr2 + arr3
    return hashlib.md5(str(arr).encode()).hexdigest()[:4]


def main():
    with open("tree_example2.txt", "r") as f:
        lines = f.readlines()

    testcases = []
    testcase = []
    for line in lines:
        if line[:8] == 'Testcase':
            if testcase != []:
                testcases.append(testcase)
                testcase = []
        else:
            testcase.append(line.strip().split(','))
    testcases.append(testcase)

    for i, tc in enumerate(testcases):
        root, _ = make_tree(tc)
        in_order_list = in_order(root)
        pre_order_list = pre_order(root)
        post_order_list = post_order(root)
        result = hash4_from_lists(pre_order_list, post_order_list, in_order_list)
        print(f"Testcase {i + 1} : {result}")
        print()

if __name__ == "__main__":
    main()

```
# 단계 5. 다이나믹 프로그래밍

## 스토리

유전자 정보를 연구하는 G 연구원과 T 연구원은 학창 시절부터의 절친이었다. 어쩌다보니 같은 직장에서 근무하게 된 두 사람은 종종 식사나 술자리를 함께 하면서 여전히 좋은 관계를 유지하고 있었다. 어느 가을 저녁, 두 사람은 연구소 근처 맛집에서 저녁을 먹고 있었다. T 연구원은 연구소 밖에서 업무 이야기하는 것을 좋아하지는 않았지만, 요즘 잘 안풀리는 문제가 있다며 G 연구원에게 의견을 물어봤다.

“우리 연구 그룹에서 개발한 스마트 마우스 기억나지?”

“응. 기억 능력에 연산 능력이 있을지도 모른다고 발표했던 그 쥐 말하는거지?”

“응. 그런데 문제가 있어.”

“뭔데?”

“쥐의 지능을 검증하려고 하는데, 우리가 멍청한게 문제지.”

이렇게 시작한 사연은 다음과 같았다.

스마트 동물 연구 그룹에서 개발한 “영리한 쥐”가 연산 능력과 학습 능력이 있는지를 확인하기 위해 다음과 같은 실험을 설계했다.

방이 N개가 있는 미로를 설치한다. 각 방은 1번 방에서 N번 방까지 이름이 붙어 있고, 시작 지점은 방은 아니지만 편의상 0번 방이라고 부르고 있다. 0번 방은 N개의 통로가 있고, 1번 방에서 N번 방까지 연결되어 있다. 1번 방은 N-1개의 통로가 있고 2번 방에서 N번 방까지 연결되어 있다. 이런 식으로 K번 방은 K+1번 방부터 N번 방까지 연결된 통로를 가지고 있다. 각 통로는 길이가 정해져 있으며, 쥐들의 속도는 모두 일정하다. 그리고 N번 방에 도착하면 보상을 주는데, 빨리 도착할 수록 보상이 좋아진다.

“그래서 보상이 뭐야?”

“응. 8년 숙성된 냄새가 엄청난 치즈. 쥐가 그 냄새를 맡으면 미칠 듯이 좋아하더라구. 문제는, 이 치즈가 싸구려라서 시간이 지나면 지날 수록 냄새가 점점 사라진다는건데…”

“그래서?”

“이 치즈 냄새가 통로에 퍼지니까, 기를 쓰고 쥐들이 달리더라구.”

“그리고?”

“영리한 쥐가 매번 1등을 했지.”

“그러면 입증된거 아니야?”

“그런데, 영리한 쥐가 점점 학습을 해서 더 영리해지고 있는지를 확인해야 하니까. 그런데 문제는 영리한 쥐가 최선의 선택을 했는지 확인해보고 싶은데… 그게 계산이 잘 안되더라구.”

“음. 혹시, 실험할 때 방은 몇 개 설치한거야?”

“적당히 설치했어. 한 1000개 정도?”

G 연구원은 순간 할 말을 잃었다. 방이 1000개인 미로라면 방과 방 사이의 통로의 개수만 499500개이다. 적당히라는게 뭔지 모르는 녀석. 아니, 우리 연구소 실험 예산 괜찮은거야?

---

# 문제 1. 갈 수 있는 모든 길

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

K 바이오 연구소는 넓은 부지에 건설된 여러 실험동을 운영하고 있다. 가격이 비싸고 크기가 큰 몇몇 실험 장비의 경우는 연구소 전체가 공유해서 쓰는 경우가 있는데, 이런 장비를 사용하는 실험을 진행하는 경우 실험동과 실험동 사이를 오가며 연구와 실험을 해야만 한다. V 연구원은 이런 문제 때문에 하루에도 몇 번씩 연구소 부지를 끝에서 끝까지 왕복하는 일이 잦았다.

조금이라도 짧은 지름길을 찾고 싶다는 생각에 V 연구원은 연구원 약도를 뚫어져라 응시하고 있었다. 물론 이렇게 간절히 바라면서 지켜본다고 해서 해결책이 튀어 나올리는 만무하다.

우선 왕복해야 하는 두 실험동 사이의 모든 경로를 구해보기로 했다. 일단 모든 경로를 구할 수 있다면 각 경로의 거리를 계산해 그 중 가장 짧은 거리의 경로가 어떤 경로인지 알 수 있을 터였다.

## 수행목표

- 연구소를 구성하는 두 지점 사이의 거리가 포함된 데이터를 사용해 두 지점 사이의 모든 경로와 각 경로의 거리를 반환하는 함수를 구현한다.
- 첨부 파일에 포함된 10개의 지점 및 거리 데이터를 대상으로 'start' 지점에서 'end' 지점 사이의 모든 경로를 구한 다음, 이중 가장 짧은 거리, 가장 긴 거리, 평균 거리를 찾아 이를 출력한다.

## 수행단계

- `dp/shortest_path1.py` 파일에 다음을 구현한다.
  - 연결된 두 지점의 목록으로 비방향성 그래프를 생성한다.
  - 생성된 그래프에서 지정된 두 지점 사이의 가능한 모든 경로를 생성하고, 각 경로의 전체 거리와 함께 튜플의 리스트 형태로 반환하는 함수를 구현한다.
- 첨부 파일에는 총 10개의 그래프 데이터가 포함되어 있다. 각각의 데이터는 `Testcase 번호` 줄로 구분된다.

  - 각각의 그래프 데이터에는 `start`, `end`라는 이름의 꼭짓점이 하나씩 포함되어 있으며, 나머지 꼭짓점은 고유한 소문자 한 글자의 이름을 갖는다.
  - 두 꼭짓점과 꼭짓점 사이의 거리를 공백 문자로 구분해 하나의 줄을 구성한다. 비방향성 그래프이므로 두 꼭짓점의 순서는 그래프의 구성에 영향을 미치지 않는다.
  - 아래 그림의 그래프는 첫 번째 테스트 데이터의 그래프이다. 이 데이터를 사용해 만든 그래프에서 함수가 반환하는 값은 다음과 같다. - `[(['start','end'], 1000), (['start', 'a', 'b', 'end'], 850), (['start', 'a', 'c', 'b', 'end'], 800)]`  
    ![Alt text](ch5_1.png)

- 첨부 파일에 포함된 10개의 그래프 각각에 대해서 다음을 출력한다.

  - `start`에서 `end`로 연결되는 경로의 수, 이 경로 중 최단 거리, 최장 거리 및 평균 거리의 값
  - 만약 경로가 존재하지 않으면 경로가 존재하지 않는다고 출력한다.

## 결과 예시

```
Testcase 1의 모든 경로의 수는 3이며 최단 거리는 800, 최장 거리는 1000, 평균 거리는 883 입니다.

Testcase 2의 모든 경로의 수는 2이며 최단 거리는 200, 최장 거리는 200, 평균 거리는 200 입니다.
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 문제에서 사용한 방법으로 구할 수 있는 최단 경로와 최장 경로를 출력한다. 만약 같은 거리의 최단 경로 또는 최장 경로가 둘 이상 존재하는 경우 모두 출력한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/shortest_path1.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    Testcase 1의 모든 경로의 수는 3이며 최단 거리는 800, 최장 거리는 1000, 평균 거리는 883 입니다.

    Testcase 2의 모든 경로의 수는 2이며 최단 거리는 200, 최장 거리는 200, 평균 거리는 200 입니다.

    Testcase 3의 모든 경로의 수는 1이며 최단 거리는 150, 최장 거리는 150, 평균 거리는 150 입니다.

    Testcase 4에서 start에서 시작해 end에 도착할 수 있는 경로가 존재하지 않습니다.

    Testcase 5의 모든 경로의 수는 1이며 최단 거리는 400, 최장 거리는 400, 평균 거리는 400 입니다.

    Testcase 6의 모든 경로의 수는 65이며 최단 거리는 100, 최장 거리는 500, 평균 거리는 401 입니다.

    Testcase 7의 모든 경로의 수는 4422이며 최단 거리는 240, 최장 거리는 1205, 평균 거리는 948 입니다.

    Testcase 8의 모든 경로의 수는 3이며 최단 거리는 242, 최장 거리는 373, 평균 거리는 285 입니다.

    Testcase 9의 모든 경로의 수는 130이며 최단 거리는 319, 최장 거리는 1697, 평균 거리는 1007 입니다.

    Testcase 10의 모든 경로의 수는 12499052이며 최단 거리는 247, 최장 거리는 2637, 평균 거리는 1952 입니다.
    ```

### [보너스 과제 확인]

- 보너스 과제를 지시한 대로 해결하였으며 그 결과는 정확한가?
  - 각각의 경로를 출력하되 같은 거리의 경로가 둘 이상 있는 경우 이를 모두 출력하고 있는지 확인한다.
  - 결과 예시는 다음과 같다.
- 각각의 문자를 최대 n번까지 사용해서 만들 수 있는 모든 단어를 반환하는 함수를 구현하고, 입력에 대해서 정확한 결과를 출력하였는가?

  - 결과 예시는 다음과 같다. 전체 목록의 출력은 일부만 포함하고 있다.

    ```
    Testcase 1의 모든 경로의 수는 3이며 최단 거리는 800, 최장 거리는 1000, 평균 거리는 883 입니다.
        최단 거리 경로
            start -> a -> c -> b -> end
        최장 거리 경로
            start -> end

    Testcase 2의 모든 경로의 수는 2이며 최단 거리는 200, 최장 거리는 200, 평균 거리는 200 입니다.
        최단 거리 경로
            start -> a -> end
            start -> b -> end
        최장 거리 경로
            start -> a -> end
            start -> b -> end

    Testcase 3의 모든 경로의 수는 1이며 최단 거리는 150, 최장 거리는 150, 평균 거리는 150 입니다.
        최단 거리 경로
            start -> end
        최장 거리 경로
            start -> end

    Testcase 4에서 start에서 시작해 end에 도착할 수 있는 경로가 존재하지 않습니다.

    Testcase 5의 모든 경로의 수는 1이며 최단 거리는 400, 최장 거리는 400, 평균 거리는 400 입니다.
        최단 거리 경로
            start -> a -> b -> c -> end
        최장 거리 경로
            start -> a -> b -> c -> end

    Testcase 6의 모든 경로의 수는 65이며 최단 거리는 100, 최장 거리는 500, 평균 거리는 401 입니다.
        최단 거리 경로
            start -> end
        최장 거리 경로
            start -> a -> b -> c -> d -> end
            start -> a -> b -> d -> c -> end
            start -> a -> c -> b -> d -> end
            start -> a -> c -> d -> b -> end
            start -> a -> d -> b -> c -> end
            start -> a -> d -> c -> b -> end
            start -> b -> a -> c -> d -> end
            start -> b -> a -> d -> c -> end
            start -> b -> c -> a -> d -> end
            start -> b -> c -> d -> a -> end
            start -> b -> d -> a -> c -> end
            start -> b -> d -> c -> a -> end
            start -> c -> a -> b -> d -> end
            start -> c -> a -> d -> b -> end
            start -> c -> b -> a -> d -> end
            start -> c -> b -> d -> a -> end
            start -> c -> d -> a -> b -> end
            start -> c -> d -> b -> a -> end
            start -> d -> a -> b -> c -> end
            start -> d -> a -> c -> b -> end
            start -> d -> b -> a -> c -> end
            start -> d -> b -> c -> a -> end
            start -> d -> c -> a -> b -> end
            start -> d -> c -> b -> a -> end

    Testcase 7의 모든 경로의 수는 4422이며 최단 거리는 240, 최장 거리는 1205, 평균 거리는 948 입니다.
        최단 거리 경로
            start -> c -> end
        최장 거리 경로
            start -> g -> c -> h -> f -> d -> a -> e -> b -> end

    Testcase 8의 모든 경로의 수는 3이며 최단 거리는 242, 최장 거리는 373, 평균 거리는 285 입니다.
        최단 거리 경로
            start -> a -> end
            start -> b -> a -> end
        최장 거리 경로
            start -> c -> a -> end

    Testcase 9의 모든 경로의 수는 130이며 최단 거리는 319, 최장 거리는 1697, 평균 거리는 1007 입니다.
        최단 거리 경로
            start -> f -> n -> end
        최장 거리 경로
            start -> c -> e -> i -> d -> f -> o -> b -> r -> a -> g -> l -> j -> n -> end

    Testcase 10의 모든 경로의 수는 12499052이며 최단 거리는 247, 최장 거리는 2637, 평균 거리는 1952 입니다.
        최단 거리 경로
            start -> b -> end
        최장 거리 경로
            start -> p -> i -> k -> b -> r -> n -> l -> q -> g -> f -> a -> j -> c -> e -> h -> o -> d -> m -> end
    ```

### [문제에 대한 이해]

- 그래프에서 모든 경로를 구하는데 사용한 방법을 설명하라.
- 완전 탐색법으로 모든 경로를 구한 후 최단 거리 경로를 구하는 이 문제의 접근 방법은 어떤 문제가 있을 것으로 추정되는가?
- 구현한 방법으로 특정 두 지점 사이의 최단 거리 경로를 구하고자 할 때의 시간 복잡도를 제시하라.

### [코드 예시]

```python
class Graph:
    def __init__(self):
        self.vertices = {}
        self.distance_table = {}

    def add_edge(self, vertex1, vertex2, distance):
        if vertex1 not in self.vertices:
            self.vertices[vertex1] = []
        if vertex2 not in self.vertices[vertex1]:
            self.vertices[vertex1].append(vertex2)
        if vertex2 not in self.vertices:
            self.vertices[vertex2] = []
        if vertex1 not in self.vertices[vertex2]:
            self.vertices[vertex2].append(vertex1)
        distance_key = (vertex1, vertex2)
        if vertex1 > vertex2:
            distance_key = (vertex2, vertex1)
        self.distance_table[distance_key] = distance

    def find_all_path(self, start, end, visited = None, paths = None):
        result = []
        is_first_call = False
        if visited == None:
            visited = []
            is_first_call = True
        if paths == None:
            paths = []

        visited.append(start)
        if start == end:
            paths.append(visited)
        else:
            for neighbor in self.vertices[start]:
                if neighbor not in visited:
                    self.find_all_path(neighbor, end, visited[:], paths)

        if is_first_call:

            for path in paths:
                distance = 0
                for i in range(len(path) - 1):
                    distance_key = (path[i], path[i + 1])
                    if path[i] > path[i + 1]:
                        distance_key = (path[i + 1], path[i])
                    distance += self.distance_table[distance_key]
                result.append((path, distance))

        return result


def main():
    with open("dp_tc1.txt", "r") as f:
        lines = f.readlines()

    case_start_lines = []
    for i, line in enumerate(lines):
        if line.startswith("Testcase"):
            case_start_lines.append(i)
    case_start_lines.append(len(lines))

    for i in range(len(case_start_lines) - 1):
        lab_map = Graph()
        for j in range(case_start_lines[i] + 1, case_start_lines[i + 1]):
            line = lines[j].strip()
            if line == '':
                continue
            vertex1, vertex2, distance = line.split(' ')
            distance = int(distance)
            lab_map.add_edge(vertex1, vertex2, distance)

        all_paths = lab_map.find_all_path('start', 'end')
        if all_paths == []:
            print(f"Testcase {i + 1}에서 start에서 시작해 end에 도착할 수 있는 경로가 존재하지 않습니다.")
        else:
            path_count = len(all_paths)
            total_distance = 0
            min_distance = float('inf')
            max_distance = 0
            min_path = []
            max_path = []
            for path, distance in all_paths:
                total_distance += distance
                if distance < min_distance:
                    min_distance = distance
                    min_path = [path]
                elif distance == min_distance:
                    min_path.append(path)
                if distance > max_distance:
                    max_distance = distance
                    max_path = [path]
                elif distance == max_distance:
                    max_path.append(path)
            print(f"Testcase {i + 1}의 모든 경로의 수는 {path_count}이며 최단 거리는 {min_distance}, 최장 거리는 {max_distance}, 평균 거리는 {total_distance // path_count} 입니다.")
            print(f"    최단 거리 경로")
            for path in min_path:
                print(f"        {' -> '.join(path)}")
            print(f"    최장 거리 경로")
            for path in max_path:
                print(f"        {' -> '.join(path)}")
        print()

if __name__ == "__main__":
    main()

```

---

# 문제 2. 꼭 가야 하는 길만 찾는 구조

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

V 연구원은 약도에서 실험동 사이를 연결하는 모든 경로를 사용해 그래프를 구성한 후, 이 그래프에서 모든 경로를 찾고 거리를 비교하려 했다. 하지만 복잡한 K 바이오 연구소의 구조에서 모든 경로를 찾는 작업이 매우 비효율적인 방법이라는 사실을 알고리즘을 구현한 후에야 알게 되었다.

효율적인 방법을 찾고자 고민을 하던 V 연구원은 최단 거리를 찾는 문제에서 어떤 특정한 구조가 있다는 사실을 깨달았다.

## 수행목표

- 두 지점 사이의 최단 거리를 구할 때 다음 원칙을 사용할 수 있다.
  - 두 지점 사이의 최단 경로에 포함된 특정 구간은 최단 경로이다.
  - 두 지점 사이의 여러 경로 중 최단 경로가 아닌 경로는 어떠한 다른 최단 경로에도 포함되지 않는다.
- 이 구조를 사용해 최단 경로를 구하는 함수를 구현한다.
- 다음 첨부 파일에는 10개의 그래프를 구성하는 데이터가 포함되어 있다. 이 중 첫 9개의 그래프에 대한 결과를 출력한다.

## 수행단계

- 수행 목표에서 제시한 두 가지 원칙의 타당성을 분석한다.
- 이 원칙은 문제의 구조와 관련된 원칙이다. 문제의 구조를 분석해보자.
  - 아래 그림에서 end로 연결되는 지점이 c 뿐이며 a와 b가 end와 연결되지 않는다고 가정하자. 이 경우 D(a, b)가 두 지점 사이의 최단 거리를 나타낸다면, D(start, end) = 124 + D(start, c)가 된다.
  - 아래 그림의 연결이 모두 유효하다고 가정할 때, D(start, end)를 D(start, b), D(start, c), D(start, a)를 포함하는 수식으로 표현해보자.
    ![Alt text](ch5_2.png)
- 이 원칙이 제시하는 문제의 구조를 점화식으로 사용하는 재귀 호출 방식으로 두 지점 사이의 최단 경로의 거리를 구하는 함수를 dp/shortest_path2.py 파일에 구현한다.
- 첨부 파일은 이전 문제와 동일한 구조를 가진 파일로 총 10개의 그래프 데이터가 포함되어 있다. 이 중 첫 아홉 개의 그래프에 대해서 `start`에서 `end`로의 최단 거리를 출력한다.
- 열 번째 그래프의 경우는 실행했을 때 어떤 문제가 있는지 확인한다.

## 결과예시

```
Testcase 1의 최단 거리는 196입니다.

Testcase 2의 최단 거리는 200입니다.
(이하 생략)
```

## 참고사항

- 이전 문제의 테스트 데이터와 비교하면 첫 번째, 다섯 번째 테스트케이스의 데이터만 다르고 나머지는 같다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 문제의 구조를 사용하는 재귀 호출로 최단 거리를 구하는 방식을 그대로 사용하면서 동시에 이 최단 거리에 해당하는 경로도 반환하도록 함수를 수정한다.
  - 만약 같은 거리의 최단 경로가 둘 이상 있는 경우 모두를 반환한다.
  - 이 함수는 테스크테이스의 처음 두 그래프에 대해서 다음 튜플을 반환하도록 구현한다.
    - (196, [['start', 'c', 'b', 'end']])
    - (200, [['start', 'a', 'end'], ['start', 'b', 'end']])
  - 이 함수의 반환 결과를 그대로 출력한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/shortest_path2.py 파일에 구현이 되어 있는지 확인한다.
  - 문제의 구조를 사용하는 재귀 호출 방식으로 구현되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. Testcase 10의 결과는 출력되어 있지 않아도 무방하다.

    ```
    Testcase 1의 최단 거리는 196입니다.

    Testcase 2의 최단 거리는 200입니다.

    Testcase 3의 최단 거리는 150입니다.

    Testcase 4에서 start에서 시작해 end에 도착할 수 있는 경로가 존재하지 않습니다.

    Testcase 5의 최단 거리는 310입니다.

    Testcase 6의 최단 거리는 100입니다.

    Testcase 7의 최단 거리는 240입니다.

    Testcase 8의 최단 거리는 242입니다.

    Testcase 9의 최단 거리는 319입니다.

    Testcase 10의 최단 거리는 247입니다.
    ```

### [보너스 과제의 확인]

- 보너스 과제를 지시대로 해결하였는가?
  - 문제의 구조를 사용하는 재귀 호출 방식으로 구현하고 있는지 확인한다.
- 결과가 정확한가?

  - 최단 경로가 둘 이상인 경우(2번, 5번, 8번 테스트케이스) 모든 경로를 반환값에 포함하고 있는지 확인한다.
  - 결과 예시는 다음과 같다.

    ```
    Testcase 1의 최단 거리는 196입니다.
        최단 경로를 구하는 함수의 반환값 : (196, [['start', 'c', 'b', 'end']])

    Testcase 2의 최단 거리는 200입니다.
        최단 경로를 구하는 함수의 반환값 : (200, [['start', 'a', 'end'], ['start', 'b', 'end']])

    Testcase 3의 최단 거리는 150입니다.
        최단 경로를 구하는 함수의 반환값 : (150, [['start', 'end']])

    Testcase 4에서 start에서 시작해 end에 도착할 수 있는 경로가 존재하지 않습니다.

    Testcase 5의 최단 거리는 310입니다.
        최단 경로를 구하는 함수의 반환값 : (310, [['start', 'a', 'c', 'd', 'end'], ['start', 'b', 'c', 'd', 'end'], ['start', 'a', 'c', 'e', 'end'], ['start', 'b', 'c', 'e', 'end']])

    Testcase 6의 최단 거리는 100입니다.
        최단 경로를 구하는 함수의 반환값 : (100, [['start', 'end']])

    Testcase 7의 최단 거리는 240입니다.
        최단 경로를 구하는 함수의 반환값 : (240, [['start', 'c', 'end']])

    Testcase 8의 최단 거리는 242입니다.
        최단 경로를 구하는 함수의 반환값 : (242, [['start', 'b', 'a', 'end'], ['start', 'a', 'end']])

    Testcase 9의 최단 거리는 319입니다.
        최단 경로를 구하는 함수의 반환값 : (319, [['start', 'f', 'n', 'end']])

    Testcase 10의 최단 거리는 247입니다.
        최단 경로를 구하는 함수의 반환값 : (247, [['start', 'b', 'end']])

    ```

### [문제에 대한 이해]

- 문제에서 제시한 두 가지 원칙의 타당성에 대해서 설명하라.
- D(start, end)를 D(start, b), D(start, c), D(start, a)를 포함하는 수식으로 표현하라.
- 이 방식은 '작은 문제의 결과를 활용해 큰 문제를 해결'하는 형태로 문제의 구조를 활용한다. 이때 큰 문제를 상위 구조의 문제, 작은 문제를 하위 구조의 문제라고 정의한다면, 가장 큰 구조의 문제와 가장 작은 구조의 문제는 무엇인가?
- 열 번째 테스트 그래프에서 발생하는 문제는 무엇인가? 이 문제의 원인은 무엇인지 알고리즘의 구조를 기반으로 설명해보자.
- 같은 방법을 사용해 두 지점 사이의 최장 거리를 구할 수 있는가? 근거와 함께 답을 제시하라.

### [코드 예시]

```python
class Graph:
    def __init__(self):
        self.vertices = {}
        self.distance_table = {}

    def add_edge(self, vertex1, vertex2, distance):
        if vertex1 not in self.vertices:
            self.vertices[vertex1] = []
        if vertex2 not in self.vertices[vertex1]:
            self.vertices[vertex1].append(vertex2)
        if vertex2 not in self.vertices:
            self.vertices[vertex2] = []
        if vertex1 not in self.vertices[vertex2]:
            self.vertices[vertex2].append(vertex1)
        distance_key = (vertex1, vertex2)
        if vertex1 > vertex2:
            distance_key = (vertex2, vertex1)
        self.distance_table[distance_key] = distance

    def get_distance(self, vertex1, vertex2):
        if (vertex1, vertex2) in self.distance_table:
            return self.distance_table[(vertex1, vertex2)]
        elif (vertex2, vertex1) in self.distance_table:
            return self.distance_table[(vertex2, vertex1)]
        else:
            return None

    def find_shortest_distance(self, start, end, visited = None):
        if visited == None:
            visited = [end]
        if start == end:
            return 0
        distance = float('inf')
        min_distance = float('inf')
        for neighbor in self.vertices[end]:
            if neighbor not in visited:
                distance = self.find_shortest_distance(start, neighbor, visited + [neighbor]) + self.get_distance(neighbor, end)
                if distance < min_distance:
                    min_distance = distance
        return min_distance

    def find_shortest_path(self, start, end, visited = None):
        if visited == None:
            visited = [end]
        if start == end:
            return 0, [visited]

        distance = float('inf')
        min_distance = float('inf')
        min_path = []
        for neighbor in self.vertices[end]:
            if neighbor not in visited:
                distance, paths = self.find_shortest_path(start, neighbor, [neighbor] + visited)

                if distance + self.get_distance(neighbor, end) < min_distance:
                    min_distance = distance + self.get_distance(neighbor, end)
                    min_path = []
                    for path in paths:
                        min_path.append(path)
                elif distance + self.get_distance(neighbor, end) == min_distance:
                    for path in paths:
                        min_path.append(path)
        return (min_distance, min_path)


def main():
    with open("dp_tc2.txt", "r") as f:
        lines = f.readlines()

    case_start_lines = []
    for i, line in enumerate(lines):
        if line.startswith("Testcase"):
            case_start_lines.append(i)
    case_start_lines.append(len(lines))

    for i in range(len(case_start_lines) - 1):
        lab_map = Graph()
        for j in range(case_start_lines[i] + 1, case_start_lines[i + 1]):
            line = lines[j].strip()
            if line == '':
                continue
            vertex1, vertex2, distance = line.split(' ')
            distance = int(distance)
            lab_map.add_edge(vertex1, vertex2, distance)
        result = lab_map.find_shortest_path('start', 'end')
        distance = result[0]
        if distance == float('inf'):
            print(f"Testcase {i + 1}에서 start에서 시작해 end에 도착할 수 있는 경로가 존재하지 않습니다.")
        else:
            print(f"Testcase {i + 1}의 최단 거리는 {distance}입니다.")
            print(f"    최단 경로를 구하는 함수의 반환값 : {result}")
        print()

if __name__ == "__main__":
    main()

```

---

# 문제 3. 관점을 바꾸면 길이 보인다.

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

'어, 이게 아닌데?'

V 연구원은 크게 실망했다. 구조를 사용해서 해결하면 효과적으로 문제를 해결할 수 있을 것이라는 생각이 들었는데, 사실 그렇지 않았기 때문이다. 하지만, 관점을 바꿔 다시 도전해보기로 마음을 먹었다.

'상향식으로 접근해보면 어떨까?'

## 수행목표

- 알고 있는 두 지점간의 최단 거리를 사용해 다른 두 지점의 최단 거리를 갱신하는 과정을 반복한다. 이 과정을 더 이상 갱신되는 두 지점 사이의 최단 거리가 없을 때 까지 반복하는 방식으로 두 지점간의 최단 거리를 계산하고 최종적으로 파라미터로 전달한 두 지점 사이의 거리를 반환한다.
- 다음 첨부 파일에는 12개의 그래프를 구성하는 데이터가 포함되어 있다. 12개의 그래프에 대한 결과를 출력한다.

## 수행단계

- 하향식 접근 방법 대신 다음과 같이 상향식 접근 방식으로 거리를 계산하고, 계산된 결과 중 지정한 두 지점 사이의 거리를 반환하는 함수를 dp/shortest_path3.py 파일에 구현한다.
  - 처음에 우리가 알 수 있는 두 지점 사이의 잠정 최단 거리는 그래프에서 직접 연결된 두 꼭짓점 사이의 거리이다.
  - 그 다음 단계에서 우리가 알 수 있는 잠정 최단 거리는 현재 잠정 최단 거리를 알고 있는 두 지점을 연결한 결과이다.
  - 그 다음 단계도 마찬가지로 그 시점에서 알 수 있는 잠정 최단 거리를 연결해 나간다.
  - 이 과정을 반복하다보면 두 지점 사이의 잠정 최단 거리에 대한 두 가지 상황이 발생한다.
    - 잠정 최단 거리를 알 수 없었는데 새롭게 알 수 있는 새로운 두 지점이 추가된다.
    - 잠정 최단 거리를 알고 있었는데 이 잠정 최단 거리보다 더 짧은 새로운 잠정 최단 거리로 갱신된다.
  - 예를 들어 다음 그림의 그래프에서 처음에는 start와 end 사이의 잠정 최단 거리를 알 수 없지만, 초기에 주어진 start와 c, c와 end 사이의 잠정 최단 거리를 더하면, start와 end 사이의 잠정 최단 거리를 알 수 있다.
  - 또한 c와 end 사이의 잠정 최단 거리가 124인 상황에서, c와 b, b와 end 사이의 잠정 최단 거리를 더하면 c와 end 사이의 잠정 최단 거리가 124보다 작은 80으로 갱신된다.
    ![Alt text](ch5_2.png)
  - 이 과정을 더 이상 최단 거리가 갱신되지 않는다고 판단될 때 까지 반복한다.
  - 이전 문제와 마찬가지로 최단 경로를 구하는 문제의 구조를 활용하지만, 큰 문제에서 점점 작은 문제로 나누어 접근하는 대신, 작은 문제를 모아서 큰 문제를 해결하는 반대 방향의 접근 방식이다. 이전 문제처럼 큰 문제에서 시작하는 접근 방법을 하향식 접근 방법, 반대로 작은 문제를 모아서 큰 문제를 해결하는 접근 방식을 상향식 접근 방식이라고 부른다.
- 상향식 접근 방식으로 구현한 함수를 사용해 첨부 파일에 포함된 12개의 그래프에서 `start` 지점에서 `end` 지점 사이의 최단 거리를 찾아 출력한다.

## 결과예시

```
Testcase 1 : 최단 거리는 196입니다.

Testcase 2 : 최단 거리는 200입니다.
(이하 생략)
```

## 참고사항

- 이 문제의 테스트케이스 중 처음 10개는 이전 문제의 테스트케이스와 동일하며, 뒤의 2개가 추가되었다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 같은 상향식 방법으로 접근하되, 모든 두 지점간의 최단 거리를 구하는 대신 파라미터로 시작 지점에서 다른 모든 지점까지의 최단 거리를 구하는 방법으로 조금 더 빠르게 두 지점 사이의 최단 거리를 구하는 함수를 구현하고, 이 함수를 사용해 `start`와 `end` 두 지점 사이의 최단 거리를 테스트케이스 12개의 그래프에 대해서 출력해보자.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/shortest_path3.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍으로 구현하였는지 확인한다.
  - 이 문제는 그리디 알고리즘 방식을 적용한 다른 최단 경로 알고리즘을 요구하는 문제가 아니다. 만약 그러한 알고리즘을 사용한 경우, 해당 알고리즘이 왜 문제에서 제시한 방법으로 해석되는지를 명확히 설명할 수 있는 경우에만 해답으로 인정한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 테스트케이스 8의 경우, 구현 방식에 따라 95, 96, 97 셋 중 어느 값도 나올 수 있다.

    ```
    Testcase 1 : 최단 거리는 196입니다.

    Testcase 2 : 최단 거리는 200입니다.

    Testcase 3 : 최단 거리는 150입니다.

    Testcase 4 : start에서 시작해 end에 도착할 수 있는 경로가 존재하지 않습니다.

    Testcase 5 : 최단 거리는 310입니다.

    Testcase 6 : 최단 거리는 100입니다.

    Testcase 7 : 최단 거리는 240입니다.

    Testcase 8 : 최단 거리는 242입니다.

    Testcase 9 : 최단 거리는 319입니다.

    Testcase 10 : 최단 거리는 247입니다.

    Testcase 11 : 최단 거리는 211입니다.

    Testcase 12 : 최단 거리는 214입니다.
    ```

### [보너스 과제 확인]

- 지시한대로 보너스 과제를 해결하였는가?
  - 상향식으로 시작 지점에서 각 지점으로의 잠정 최단 거리만 계산하는 방식으로 반복 갱신한 후 더 이상 갱신되지 않을 때 까지 이를 반복하는 방식으로 구현하였는지 확인한다.
- 결과가 정확한가?
  - 결과는 수정 전과 동일해야 하며, 수행 시간은 마지막 테스트케이스에서도 거의 지연없이 결과를 확인할 수 있어야 한다.

### [문제에 대한 이해]

- 일상의 특정 문제를 해결하기 위한 상향식 접근 방법과 하향식 접근 방법의 예를 들어보라. 같은 문제를 서로 다른 방법으로 접근하는 예시를 제시하라.
- 구현한 함수를 기준으로 상향식으로 최단 거리를 계산하는 과정을 설명하라.
- 하향식 접근 방법과 비교해 이 문제의 상향식 접근 방법의 성능이 좋은 이유를 설명하라.

### [코드 예시]

```python

class Graph:
    def __init__(self):
        self.vertices = {}
        self.distance_table = {}

    def add_edge(self, vertex1, vertex2, distance):
        if vertex1 not in self.vertices:
            self.vertices[vertex1] = []
        if vertex2 not in self.vertices[vertex1]:
            self.vertices[vertex1].append(vertex2)
        if vertex2 not in self.vertices:
            self.vertices[vertex2] = []
        if vertex1 not in self.vertices[vertex2]:
            self.vertices[vertex2].append(vertex1)
        distance_key = (vertex1, vertex2)
        if vertex1 > vertex2:
            distance_key = (vertex2, vertex1)
        self.distance_table[distance_key] = distance

    def get_distance(self, vertex1, vertex2):
        if (vertex1, vertex2) in self.distance_table:
            return self.distance_table[(vertex1, vertex2)]
        elif (vertex2, vertex1) in self.distance_table:
            return self.distance_table[(vertex2, vertex1)]
        else:
            return None

    # bonus problem solution
    def find_shortest_distance2(self, start, end):
        vertices = list(self.vertices.keys())
        distances_from_start = {}
        for (v1, v2), v in self.distance_table.items():
            if v1 == start or v2 == start:
                if v1 == start:
                    distances_from_start[v2] = v
                else:
                    distances_from_start[v1] = v
        while True:
            updated_distances_from_start = {}
            for mid in distances_from_start.keys():
                if mid not in updated_distances_from_start:
                    updated_distances_from_start[mid] = distances_from_start[mid]
                else:
                    updated_distances_from_start[mid] = min(updated_distances_from_start[mid], distances_from_start[mid])
                for dst in vertices:
                    distance_mid_dst = self.get_distance(mid, dst)
                    if distance_mid_dst == None:
                        continue
                    distance_start_mid_dst = distances_from_start[mid] + distance_mid_dst
                    current_distance_start_dst = float('inf')
                    if dst in updated_distances_from_start:
                        current_distance_start_dst = updated_distances_from_start[dst]
                    direct_to_dst = float('inf')
                    if dst in distances_from_start:
                        direct_to_dst = distances_from_start[dst]
                    updated_distances_from_start[dst] = min(distance_start_mid_dst, current_distance_start_dst, direct_to_dst)
            is_updated = False
            if len(distances_from_start) != len(updated_distances_from_start):
                is_updated = True
            else:
                for k, v in distances_from_start.items():
                    if v != updated_distances_from_start[k]:
                        is_updated = True
                        break
            if is_updated == False:
                break
            distances_from_start = updated_distances_from_start
        if end in distances_from_start:
            return distances_from_start[end]
        else:
            return None

    def find_shortest_distance(self, start, end):
        vertices = list(self.vertices.keys())
        distances = {}
        for (v1, v2), v in self.distance_table.items():
            key = tuple(sorted([v1, v2]))
            distances[key] = v
        while True:
            updated_distances = {}
            for i in range(len(vertices)):
                for j in range(i + 1, len(vertices)):
                    v1 = vertices[i]
                    v2 = vertices[j]
                    key = tuple(sorted([v1, v2]))
                    current_distance = float('inf')
                    if key in distances:
                        current_distance = distances[key]
                    for inter_vertex in vertices:
                        if inter_vertex == v1 or inter_vertex == v2:
                            continue
                        first_half_key = tuple(sorted([v1, inter_vertex]))
                        second_half_key = tuple(sorted([inter_vertex, v2]))
                        if first_half_key in distances and second_half_key in distances:
                            current_distance = min(current_distance, distances[first_half_key] + distances[second_half_key])
                    if current_distance != float('inf'):
                        updated_distances[(key)] = current_distance
            is_updated = False
            if len(distances) != len(updated_distances):
                is_updated = True
            else:
                for k, v in distances.items():
                    if v != updated_distances[k]:
                        is_updated = True
                        break
            if is_updated == False:
                break
            distances = updated_distances
        key = tuple(sorted([start, end]))

        if key in distances:
            return distances[key]
        else:
            return None

def main():
    with open("dp_tc3.txt", "r") as f:
        lines = f.readlines()

    case_start_lines = []
    for i, line in enumerate(lines):
        if line.startswith("Testcase"):
            case_start_lines.append(i)
    case_start_lines.append(len(lines))

    for i in range(len(case_start_lines) - 1):
        lab_map = Graph()
        for j in range(case_start_lines[i] + 1, case_start_lines[i + 1]):
            line = lines[j].strip()
            if line == '':
                continue
            vertex1, vertex2, distance = line.split(' ')
            distance = int(distance)
            lab_map.add_edge(vertex1, vertex2, distance)
        distance = lab_map.find_shortest_distance('start', 'end')
        print(f"Testcase {i + 1} : ", end = '')
        if distance == None:
            print("start에서 시작해 end에 도착할 수 있는 경로가 존재하지 않습니다.")
        else:
            print(f"최단 거리는 {distance}입니다.")
        print()

if __name__ == "__main__":
    main()
```

---

# 문제 4. 관점을 바꿔서 찾은 길

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

관점을 바꿔 해결의 실마리를 찾은 연구원 V. 하지만 연구원 V에게 고비가 하나 더 남아 있었다. 필요한 것은 최단 거리 뿐 아니라 최단 거리로 갈 수 있는 경로였기 때문이다.

## 수행목표

- 이전 문제에서 상향식 접근 방법으로 최단 거리를 빠르게 찾는 방법을 만들었다면, 이번 문제에서는 그 최단 거리의 경로가 어떤 경로인지 찾는다.
- 상향식 접근 방법으로 최단 거리를 계산하면서 최단 경로도 계산한 후, 지정한 두 지점 사이의 최단 경로를 함께 반환하는 함수를 구현한다.
- 다음 첨부 파일에는 12개의 그래프를 구성하는 데이터가 포함되어 있다. 12개의 그래프에 대한 결과를 출력한다.

## 수행단계

- 두 지점 사이의 잠정 최단 거리를 계산하면서 잠정 최단 경로도 함께 계산하는 방법을 정리한다.
- 이 방법을 사용해 상향식 접근 방법으로 두 지점 사이의 최단 거리 뿐 아니라 최단 경로도 반환하는 함수를 dp/shortest_path4.py 파일에 구현한다.
  - 이 함수가 반환하는 최단 경로는 최단 경로들의 목록의 형태이다. 같은 거리의 최단 경로가 둘 이상 존재할 수 있기 때문이다.
- 상향식 접근 방식으로 구현한 함수를 사용해 첨부 파일에 포함된 12개의 그래프에서 `start` 지점에서 `end` 지점 사이의 최단 거리와 이 때의 경로를 찾아 출력한다.
  - 같은 거리의 최단 경로가 둘 이상인 경우 모든 경로를 출력한다.

## 결과 예시

```
Testcase 1 : 최단 거리는 196입니다.
    최단 경로를 구하는 함수의 반환값 : [['start', 'c', 'b', 'end']]

Testcase 2 : 최단 거리는 200입니다.
    최단 경로를 구하는 함수의 반환값 : [['start', 'a', 'end'], ['start', 'b', 'end']]

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/shortest_path4.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 접근 방법으로 최단 거리와 최단 경로를 구하는 함수를 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    Testcase 1 : 최단 거리는 196입니다.
        최단 경로를 구하는 함수의 반환값 : [['start', 'c', 'b', 'end']]

    Testcase 2 : 최단 거리는 200입니다.
        최단 경로를 구하는 함수의 반환값 : [['start', 'a', 'end'], ['start', 'b', 'end']]

    Testcase 3 : 최단 거리는 150입니다.
        최단 경로를 구하는 함수의 반환값 : [['start', 'end']]

    Testcase 4 : start에서 시작해 end에 도착할 수 있는 경로가 존재하지 않습니다.

    Testcase 5 : 최단 거리는 310입니다.
        최단 경로를 구하는 함수의 반환값 : [['start', 'a', 'c', 'd', 'end'], ['start', 'b', 'c', 'd', 'end'], ['start', 'a', 'c', 'e', 'end'], ['start', 'b', 'c', 'e', 'end']]

    Testcase 6 : 최단 거리는 100입니다.
        최단 경로를 구하는 함수의 반환값 : [['start', 'end']]

    Testcase 7 : 최단 거리는 240입니다.
        최단 경로를 구하는 함수의 반환값 : [['start', 'c', 'end']]

    Testcase 8 : 최단 거리는 242입니다.
        최단 경로를 구하는 함수의 반환값 : [['start', 'a', 'end'], ['start', 'b', 'a', 'end']]

    Testcase 9 : 최단 거리는 319입니다.
        최단 경로를 구하는 함수의 반환값 : [['start', 'f', 'n', 'end']]

    Testcase 10 : 최단 거리는 247입니다.
        최단 경로를 구하는 함수의 반환값 : [['start', 'b', 'end']]

    Testcase 11 : 최단 거리는 211입니다.
        최단 경로를 구하는 함수의 반환값 : [['start', 'ac', 'end']]

    Testcase 12 : 최단 거리는 214입니다.
        최단 경로를 구하는 함수의 반환값 : [['start', 'ehkxe', 'end']]
    ```

### [문제에 대한 이해]

- 최단 경로를 구하기 위해서 어떤 방법을 사용하였는지 설명하라.

### [코드 예시]

```python
class Graph:
    def __init__(self):
        self.vertices = {}
        self.distance_table = {}

    def add_edge(self, vertex1, vertex2, distance):
        if vertex1 not in self.vertices:
            self.vertices[vertex1] = []
        if vertex2 not in self.vertices[vertex1]:
            self.vertices[vertex1].append(vertex2)
        if vertex2 not in self.vertices:
            self.vertices[vertex2] = []
        if vertex1 not in self.vertices[vertex2]:
            self.vertices[vertex2].append(vertex1)
        distance_key = (vertex1, vertex2)
        if vertex1 > vertex2:
            distance_key = (vertex2, vertex1)
        self.distance_table[distance_key] = distance

    def get_distance(self, vertex1, vertex2):
        if (vertex1, vertex2) in self.distance_table:
            return self.distance_table[(vertex1, vertex2)]
        elif (vertex2, vertex1) in self.distance_table:
            return self.distance_table[(vertex2, vertex1)]
        else:
            return None

    def find_shortest_path(self, start, end):
        vertices = list(self.vertices.keys())
        vertices.sort()
        distances = {}
        shortest_paths = {}
        for (v1, v2), v in self.distance_table.items():
            key = tuple(sorted([v1, v2]))
            distances[key] = v
            shortest_paths[key] = [[v1, v2]]
        while True:
            updated_distances = {}
            for i in range(len(vertices)):
                for j in range(i + 1, len(vertices)):
                    v1 = vertices[i]
                    v2 = vertices[j]
                    key = (v1, v2)
                    current_distance = float('inf')
                    current_path = []
                    if key in distances:
                        current_distance = distances[key]
                        current_path = shortest_paths[key]
                    for inter_vertex in vertices:
                        if inter_vertex == v1 or inter_vertex == v2:
                            continue
                        first_half_key = tuple(sorted([v1, inter_vertex]))
                        second_half_key = tuple(sorted([inter_vertex, v2]))
                        if first_half_key in distances and second_half_key in distances:
                            distance_through_inter_vertex = distances[first_half_key] + distances[second_half_key]
                            path_through_inter_vertex = []
                            for path_prev in shortest_paths[first_half_key]:
                                for path_after in shortest_paths[second_half_key]:
                                    composed_path = path_prev[:-1]
                                    if path_prev[0] != v1:
                                        composed_path = path_prev[::-1][:-1]
                                    if path_after[-1] == v2:
                                        composed_path += path_after
                                    else:
                                        composed_path += path_after[::-1]
                                    path_through_inter_vertex.append(composed_path)
                            if distance_through_inter_vertex < current_distance:
                                current_distance = distance_through_inter_vertex
                                current_path = path_through_inter_vertex
                            elif distance_through_inter_vertex == current_distance:
                                for path in path_through_inter_vertex:
                                    if path not in current_path:
                                        current_path.append(path)
                    if current_distance != float('inf'):
                        updated_distances[(key)] = current_distance
                        shortest_paths[key] = current_path
            is_updated = False
            if len(distances) != len(updated_distances):
                is_updated = True
            else:
                for k, v in distances.items():
                    if v != updated_distances[k]:
                        is_updated = True
                        break
            if is_updated == False:
                break
            distances = updated_distances
        key = tuple(sorted([start, end]))
        if key not in distances:
            return None, None
        if shortest_paths[key][0][0] == start:
            result_path = shortest_paths[key]
        else:
            result_path = []
            for path in shortest_paths[key]:
                result_path.append(path[::-1])

        return distances[key], result_path


def main():
    with open("dp_tc3.txt", "r") as f:
        lines = f.readlines()

    case_start_lines = []
    for i, line in enumerate(lines):
        if line.startswith("Testcase"):
            case_start_lines.append(i)
    case_start_lines.append(len(lines))

    for i in range(len(case_start_lines) - 1):
        lab_map = Graph()
        for j in range(case_start_lines[i] + 1, case_start_lines[i + 1]):
            line = lines[j].strip()
            if line == '':
                continue
            vertex1, vertex2, distance = line.split(' ')
            distance = int(distance)
            lab_map.add_edge(vertex1, vertex2, distance)
        distance, path = lab_map.find_shortest_path('start', 'end')
        print(f"Testcase {i + 1} : ", end = '')
        if distance == None:
            print("start에서 시작해 end에 도착할 수 있는 경로가 존재하지 않습니다.")
        else:
            print(f"최단 거리는 {distance}입니다.")
            print(f"    최단 경로를 구하는 함수의 반환값 : {path}")

        print()

if __name__ == "__main__":
    main()
```

---

# 문제 5. 영리한 쥐의 경로찾기 (1)

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

'영리한 쥐'가 최선의 선택을 했는지 검증을 하기 위해서 최적의 경로가 무엇인지 알아내야 하는 연구원 T. 쥐가 점점 영리해져서 최선의 선택을 했는데, 정작 인간이 그 경로를 알지 못한다면 이건 인간의 존엄과 직결된 치명적인 문제이다. (이 문제의 심각성이 잘 이해가 되지 않는 사람들은 과정의 스토리를 다시 한 번 읽고 오자.)

이 사실을 자각한 연구원 T는 떨리는 손으로 프로그래밍 게시판에 도움을 청했다.

## 수행목표

- 영리한 쥐의 경로찾기 문제는 다음과 같이 정리할 수 있다.
  - 지점이 N개가 있는 미로를 설치한다. 각 지점은 1번 지점에서 N번 지점까지 이름이 붙어 있고, 시작 지점은 편의상 0번 지점이라고 부르고 있다.
  - 0번 지점은 N개의 통로가 있고, 1번 지점에서 N번 지점까지 연결되어 있다.
  - 1번 지점은 N-1개의 통로가 있고 2번 지점에서 N번 지점까지 연결되어 있다.
  - 이런 식으로 K번 지점은 K+1번 지점부터 N번 지점까지 연결된 통로를 가지고 있다.
  - 각 통로는 길이가 정해져 있으며, 쥐들의 속도는 모두 1cm/s로 일정하다. 그리고 쥐는 뒤로 돌아갈 수 없다. 앞으로만 나아갈 뿐이다.
  - 그리고 N지점 방에 도착하면 보상을 주는데, 빨리 도착할 수록 보상이 좋아진다.
  - 해결해야 하는 문제 : 모든 경우 경로의 경우 중에 N번 지점에 가장 빨리 도착할 수 있는 경로를 선택한 쥐는 출발 후 몇 초 후에 N번 지점에 도착할까?
- 다음 그림의 미로에서 0번 지점에서 출발한 쥐가 4번 지점에 가장 빨리 도착할 수 있는 경로를 선택했을 때, 출발 시간을 기준으로 몇 초 후에 도착할지를 출력한다.
  ![Alt text](ch5_3.png)

## 수행단계

- 문제의 구조를 분석한다. 다음은 구조 분석에 도움이 되는 몇 가지 조언들이다.
  - 위의 그림을 그대로 표로 옮겨보자. 표의 첫 열은 이전 지점을, 표의 첫 행은 이후 지점을, 그리고 값은 두 지점 사이의 통로를 이동하는데 필요한 시간이다. (1cm/s의 속도로 이동하므로, 사실 시간과 거리는 같은 값이다.)
  - 두 지점 사이를 이동할 때 직접 연결된 통로로 이동하는 것이 빠른 경우도 있지만, 다른 지점을 들러서 이동하는 것이 더 빠른 경우도 있다. 즉 두 지점 사이를 연결하는 통로의 길이를 t(i, j), 두 지점 사이의 최소 이동 시간을 mt(i, j)라고 했을 때 t(i, j) >= mt(i, j)의 관계가 성립한다.
  - 문제의 구조를 분석하는 목표는 다음과 같다.
    - 상위 문제를 해결하는데 사용 가능한 하위 문제를 찾는다. 이 과정은 일반항의 점화식을 찾는 것과 동일한 작업이다. 이 문제에서는 0 <= i <= k <= j <= N인 모든 i, j, k에 대해서 mt(i, j)와 mt(i, k), mt(k, j), 그리고 t(i, j) 사이의 관계를 찾아서 이를 점화식으로 사용한다.
    - 가장 간단한 문제를 찾는다. 가장 간단한 문제는 하향식으로 접근하는 재귀 호출의 경우 종료 조건을, 상향식으로 접근하는 경우에는 시작 지점을 의미한다. 일반적으로 가장 간단한 문제는 값이 주어지거나 쉽게 구할 수 있는 직관적인 문제이다.
- 찾아낸 문제의 구조를 사용하는 하향식 접근 방법으로 mt(i, j)의 값을 구해서 반환하는 함수를 dp/smart_mouse1.py 파일에 구현한다.
  - 이 함수는 i, j 이외에 미로의 구조를 파라미터로 받는다. 그림의 미로는 다음과 같은 파라미터로 주어진다.
    ```python
    t = [[0, 4, 8, 14, 19], [-1, 0, 5, 11, 16], [-1, -1, 0, 5, 8], [-1, -1, -1, 0, 4], [-1, -1, -1, -1, 0]]
    ```
  - 위의 그림의 미로에서 영리한 쥐가 0번 지점에서 4번 지점으로 이동하는데 필요한 시간의 최소값을 구해서 출력한다.
  - 다음 데이터는 0번 지점부터 15번 지점까지로 구성된 미로의 데이터이다. 이 데이터에서 0번 지점에서 15번 지점으로 이동하는데 필요한 시간의 최소값을 구해서 출력한다.
    - 꽤 오랜 시간이 걸릴 수도 있지만, 기다려서 결과를 출력한다. 그리고 실행에 긴 시간이 필요한 이유를 찾아보자.
    ```python
    tc2 = [[0, 4, 8, 7, 15, 15, 19, 21, 21, 32, 30, 31, 38, 39, 43, 47, 46, 58, 53, 54, 62], [-1, 0, 2, 5, 8, 14, 13, 18, 19, 25, 28, 29, 30, 38, 43, 41, 46, 50, 49, 59, 53], [-1, -1, 0, 4, 6, 7, 9, 14, 19, 23, 27, 29, 31, 32, 37, 43, 48, 44, 50, 49, 61], [-1, -1, -1, 0, 3, 6, 10, 11, 14, 20, 25, 22, 30, 24, 33, 36, 36, 41, 44, 53, 50], [-1, -1, -1, -1, 0, 3, 6, 9, 12, 14, 22, 26, 27, 27, 29, 30, 41, 40, 44, 46, 48], [-1, -1, -1, -1, -1, 0, 2, 4, 9, 12, 15, 17, 22, 25, 34, 25, 37, 40, 39, 44, 48], [-1, -1, -1, -1, -1, -1, 0, 2, 5, 10, 12, 15, 17, 22, 24, 28, 29, 34, 37, 43, 46], [-1, -1, -1, -1, -1, -1, -1, 0, 2, 7, 11, 10, 15, 17, 20, 21, 26, 34, 35, 34, 42], [-1, -1, -1, -1, -1, -1, -1, -1, 0, 2, 7, 8, 12, 15, 19, 17, 25, 28, 29, 35, 35], [-1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 2, 5, 7, 12, 15, 19, 19, 25, 25, 29, 33], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 7, 8, 12, 14, 17, 22, 26, 28, 27], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 4, 11, 11, 17, 19, 21, 25, 29], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 6, 11, 12, 15, 22, 22, 22], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 2, 4, 9, 10, 16, 19, 22], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 6, 10, 12, 15, 16], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 8, 8, 13, 15], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 6, 8, 12], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 4, 9], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 6], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 2], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0]]
    ```

## 결과예시

```
TC 1 - 최소 이동 시간 : 16
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/smart_mouse1.py 파일에 구현이 되어 있는지 확인한다.
  - 재귀 호출을 사용한 하향식 접근 방법으로 구현되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    TC 1 - 최소 이동 시간 : 16
    TC 2 - 최소 이동 시간 : 46
    ```

### [문제에 대한 이해]

- 미로를 문제에서 언급한 방식의 표로 옮겨보라.
- 이 문제의 구조를 설명하라.
- 구현한 알고리즘의 시간 복잡도를 분석하라.
- 이 방법은 완전탐색법이라고 할 수 있을까?

### [코드 예시]

```python
def find_min_time(i, j, t):
    try:
        if i == j:
            return 0
        elif i + 1 == j:
            return t[i][j]
        min_time = t[i][j]
        for k in range(i + 1, j):
            min_time = min(min_time, find_min_time(i, k, t) + find_min_time(k, j, t))
        return min_time
    except IndexError:
        return None

def main():
    tc1 = [[0, 4, 8, 14, 19], [-1, 0, 5, 11, 16], [-1, -1, 0, 5, 8], [-1, -1, -1, 0, 4], [-1, -1, -1, -1, 0]]
    print(f"TC 1 - 최소 이동 시간 : {find_min_time(0, 4, tc1)}")
    tc2 = [[0, 4, 8, 7, 15, 15, 19, 21, 21, 32, 30, 31, 38, 39, 43, 47, 46, 58, 53, 54, 62], [-1, 0, 2, 5, 8, 14, 13, 18, 19, 25, 28, 29, 30, 38, 43, 41, 46, 50, 49, 59, 53], [-1, -1, 0, 4, 6, 7, 9, 14, 19, 23, 27, 29, 31, 32, 37, 43, 48, 44, 50, 49, 61], [-1, -1, -1, 0, 3, 6, 10, 11, 14, 20, 25, 22, 30, 24, 33, 36, 36, 41, 44, 53, 50], [-1, -1, -1, -1, 0, 3, 6, 9, 12, 14, 22, 26, 27, 27, 29, 30, 41, 40, 44, 46, 48], [-1, -1, -1, -1, -1, 0, 2, 4, 9, 12, 15, 17, 22, 25, 34, 25, 37, 40, 39, 44, 48], [-1, -1, -1, -1, -1, -1, 0, 2, 5, 10, 12, 15, 17, 22, 24, 28, 29, 34, 37, 43, 46], [-1, -1, -1, -1, -1, -1, -1, 0, 2, 7, 11, 10, 15, 17, 20, 21, 26, 34, 35, 34, 42], [-1, -1, -1, -1, -1, -1, -1, -1, 0, 2, 7, 8, 12, 15, 19, 17, 25, 28, 29, 35, 35], [-1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 2, 5, 7, 12, 15, 19, 19, 25, 25, 29, 33], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 7, 8, 12, 14, 17, 22, 26, 28, 27], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 4, 11, 11, 17, 19, 21, 25, 29], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 6, 11, 12, 15, 22, 22, 22], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 2, 4, 9, 10, 16, 19, 22], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 6, 10, 12, 15, 16], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 8, 8, 13, 15], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 6, 8, 12], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 4, 9], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 6], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 2], [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0]]
    print(f"TC 2 - 최소 이동 시간 : {find_min_time(0, 20, tc2)}")

if __name__ == '__main__':
    main()
```

---

# 문제 6. 영리한 쥐의 경로찾기 (2)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

프로그래밍 지원 게시판에는 문제의 구조를 찾고 구조를 활용해 해결한다는 취지의 설명이 달렸고, 이 설명을 이해한 T 연구원은 문제를 해결할 수 있었다.

아니, 해결한 것이 아니다. T 연구원은 무려 수백개 이상의 지점을 가진 대규모 실험을 생각하고 있었기 때문이다. 당장 20개의 지점을 가진 가상의 데이터에서 계산하는데 수십초 씩 걸린다는 것을 확인한 마당에 이 방법을 해결책이라 할 수는 없었다.

그런 T 연구원을 지켜보던, G 연구원은 T 연구원에게 사정을 듣고 고민을 나누기로 한다. 그리고 문제의 구조에 이용 가능한 무엇인가가 더 있다는 사실을 알게 되었다.

## 수행목표

- 좀 더 큰 미로에서 영리한 쥐가 목표 지점에 도달하는 최소 시간을 구할 수 있는 하향식 접근 함수를 구현한다.
- 다음 코드를 사용해 임의의 크기(room_count)의 가상 미로 데이터를 생성할 수 있다. 이 미로를 사용해 room_count가 20, 30, 40, 50일 때의 결과를 수행 시간과 함께 출력해보자.

  ```python
  import random

  def make_distance(i, j):
      distance = 0
      for x in range(j - i):
          distance += random.randint(-1, 1) + 3
      return distance

  def make_maze(room_count):
      maze = []
      for i in range(room_count + 1):
          ith_line = []
          for j in range(room_count + 1):
              if i > j:
                  ith_line.append(-1)
              elif i == j:
                  ith_line.append(0)
              else:
                  ith_line.append(make_distance(i, j))
          maze.append(ith_line)
      return maze
  ```

## 수행단계

- 다이나믹 프로그래밍에서 메모 전략(메모이제이션)의 개념을 조사한다.
- 문제의 구조를 기반으로 하향식 접근 방식으로 문제를 해결하되, 메모이제이션을 사용해 빠르게 답을 얻을 수 있는 수정된 함수를 dp/smart_mouse2.py 파일에 구현한다.
- 수행목표에서 제공된 코드로 지점의 개수가 20, 30, 40, 50개인 미로를 각각 만들고, 각 미로해서 0번 지점에서 가장 큰 번호의 지점으로 이동하는데 필요한 시간을 구해서 출력한다.
  - 이 때, 각 미로에서 이 시간을 구하는데 필요한 함수의 실행 시간을 함께 출력한다.

## 결과예시

```
n = 20인 경우
    수행 시간: 0.0 초
    최소 이동 시간 : 47
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/smart_mouse2.py 파일에 구현이 되어 있는지 확인한다.
  - 하향식 접근방법을 메모이제이션과 함께 사용하여 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과의 예시이다. 결과는 항상 다르게 나오지만, 수행 시간은 거의 지연없이 결과를 확인할 수 있어야 한다.

    ```
    n = 20인 경우
        수행 시간: 0.0 초
        최소 이동 시간 : 47

    n = 30인 경우
        수행 시간: 0.00251007080078125 초
        최소 이동 시간 : 72

    n = 40인 경우
        수행 시간: 0.004511117935180664 초
        최소 이동 시간 : 92

    n = 50인 경우
        수행 시간: 0.008000373840332031 초
        최소 이동 시간 : 114
    ```

### [문제에 대한 이해]

- 메모이제이션은 무엇인가?
- 재귀 호출과정에서 전역변수를 사용하지 않고 메모이제이션 방식을 적용하는 방법을 설명하라.
- 이 문제를 메모이제이션을 사용해서 해결한 경우의 시간복잡도는 얼마인가?

### [코드 예시]

```python
import time
import random

def make_distance(i, j):
    distance = 0
    for x in range(j - i):
        distance += random.randint(-1, 1) + 3
    return distance

def make_maze(n):
    maze = []
    for i in range(n + 1):
        ith_line = []
        for j in range(n + 1):
            if i > j:
                ith_line.append(-1)
            elif i == j:
                ith_line.append(0)
            else:
                ith_line.append(make_distance(i, j))
        maze.append(ith_line)
    return maze

def execute_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"    수행 시간: {end - start} 초")
        return result
    return wrapper

@execute_time
def find_min_time_wrapper(i, j, t):
    return find_min_time(i, j, t)

def find_min_time(i, j, t, memo=None):
    if memo == None:
        memo = {}
    if (i, j) in memo:
        return memo[(i, j)]
    try:
        if i == j:
            return 0
        elif i + 1 == j:
            return t[i][j]
        min_time = t[i][j]
        for k in range(i + 1, j):
            min_time = min(min_time, find_min_time(i, k, t, memo) + find_min_time(k, j, t, memo))
        memo[(i, j)] = min_time
        return min_time
    except IndexError:
        return None

def main():
    for i in range(4):
        n = i * 10 + 20
        print(f"n = {n}인 경우")
        t = make_maze(n)
        print(f"    최소 이동 시간 : {find_min_time_wrapper(0, n, t)}")
        print()

if __name__ == '__main__':
    main()
```

---

# 문제 7. 영리한 쥐의 경로찾기 (3)

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

T 연구원이 알아야 하는 것은 가장 짧은 경로의 거리 뿐 아니라 이 경로가 어떤 경로인지도 알아야 했다. 시간 기준으로 확인을 하면 쥐가 점점 영리해지고 있는지를 확인할 수 있지만, 경로를 알면 쥐가 어떤 방향으로 지능이 발전하고 있는지를 유추할 수 있기 때문이다.

## 수행목표

- 하향식 접근 방법과 메모이제이션을 사용해 빠르게 쥐의 최소 이동 시간을 구할 수 있게 되었다. 이 방법을 유지하며서, 어떤 지점들을 들러서 진행할 때 가장 빠르게 이동할 수 있는지도 함께 반환하는 함수를 구현한다.
- 첨부한 파일에는 5개의 리스트가 정의되어 있다. 각각이 별도의 쥐의 미로 실험 환경을 나타낸다. 이 5개의 리스트에 대해서 영리한 쥐의 최소 이동 시간과 이 때 쥐가 어떤 지점들을 거쳐서 목적 지점에 도착하는지를 출력한다.

## 수행단계

- 재귀 호출 과정에서 경로를 추적하는 방법을 다음과 같은 과정을 통해 찾아보자.
  - 경로도 메모이제이션과 같은 방법으로 저장할 수 있다. 딕셔너리를 하나 생성한다. (문제 설명을 위해서 이 딕셔너리의 이름은 split이라고 하자.)
    - 딕셔너리는 지점 i, 지점 j에 대해서 `(i, j)` 튜플을 키로 가진다. `split[(i, j)] = k`인 경우 i 지점에서 j 지점으로 갈 때의 최적 경로는 k를 지나서 간다는 의미이다. 만약 `split[(i, j)] = j`인 경우, i에서 j 지점으로 이동할 때 아무 곳도 들르지 않는 직접 연결된 통로로 이동하는 것이 가장 빠르다는 의미이다.
    - 최적 경로를 계산하는 과정에서 적절한 시점에 split 딕셔너리에 위와 같은 값을 저장하도록 메모이제이션을 사용하는 하향식 접근 방법의 구현 함수를 dp/smart_mouse3.py 파일에 구현한다.
    - split 딕셔너리를 사용하면 최적 경로를 재구성할 수 있다. split 딕셔너리로부터 지정된 두 구간의 최적 경로를 재구성하는 함수를 구현한다.
    - 이 함수는 split 딕셔너리를 반환하거나, split 딕셔너리를 사용해 재구성된 최적 경로를 반환한다. split 딕셔너리를 반환하는 경우에도, 출력하는 결과는 split 딕셔너리가 아니라 재구성된 최적 경로이다.
- 제공한 테스트 미로 데이터는 이전 문제와 동일한 구조의 리스트이다. 이 데이터 각각에 대해서 최소 이동 시간과 이 때 지나가는 각 지점의 번호를 출력해보자.
  - 만약 같은 최소 이동 시간의 경로가 둘 이상 있는 경우 그 중 유효한 경로 하나 이상을 출력한다.

## 결과예시

```
TC 1 - 최소 이동 시간 : 2
    최소 이동 경로 : 0 -> 2

TC 2 - 최소 이동 시간 : 16
    최소 이동 경로 : 0 -> 2 -> 4
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/smart_mouse3.py 파일에 구현이 되어 있는지 확인한다.
  - 메모이제이션과 하향식 접근 방법으로 구현하는 함수가 최소 이동 시간과 이 때의 경로 또는 이 경로를 재구성할 수 있는 딕셔너리를 생성해 반환하는지를 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```
    TC 1 - 최소 이동 시간 : 2
        최소 이동 경로 : 0 -> 2

    TC 2 - 최소 이동 시간 : 16
        최소 이동 경로 : 0 -> 2 -> 4

    TC 3 - 최소 이동 시간 : 60
        최소 이동 경로 : 0 -> 2 -> 3 -> 9 -> 10 -> 20

    TC 4 - 최소 이동 시간 : 90
        최소 이동 경로 : 0 -> 2 -> 5 -> 7 -> 8 -> 9 -> 10 -> 11 -> 12 -> 13 -> 14 -> 15 -> 16 -> 17 -> 19 -> 26 -> 29 -> 31 -> 32 -> 36 -> 37 -> 39 -> 40

    TC 5 - 최소 이동 시간 : 117
        최소 이동 경로 : 0 -> 1 -> 2 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 12 -> 15 -> 20 -> 22 -> 26 -> 27 -> 29 -> 36 -> 41 -> 46 -> 48 -> 49 -> 50
    ```

### [문제에 대한 이해]

- 경로를 저장하는 딕셔너리에 값을 추가하는 시점과, 어떤 값을 저장하는지 설명하라.
  - 두 지점 사이의 최소 이동 시간에 해당하는 중간 지점을 찾았을 때 이 중간 지점의 값을 저장한다.
- 지점 i에서 지점 j까지 가장 빠르게 이동하는 방법이 들르지 않고 이동하는 경우 split(i, j)값이 j가 되도록 하는 메커니즘을 설명하라.
  - split(i, j)의 초기값을 j로 설정한다.

### [코드 예시]

```python
from smart_mouse3_data import testcase_1, testcase_2, testcase_3, testcase_4, testcase_5

def find_mintime_path(i, j, t, memo = None, split = None):
    is_first_call = False
    if memo == None:
        is_first_call = True
        memo = {}
    if split == None:
        split = {}
    if i == j:
        return 0, split
    elif i + 1 == j:
        return t[i][j], split
    if (i, j) in memo:
        return memo[(i, j)], split
    min_time = t[i][j]
    split[(i, j)] = j
    for k in range(i + 1, j):
        min_time_before, _ = find_mintime_path(i, k, t, memo, split)
        min_time_after, _ = find_mintime_path(k, j, t, memo, split)
        if min_time > min_time_before + min_time_after:
            min_time = min_time_before + min_time_after
            split[(i, j)] = k
    memo[(i, j)] = min_time
    if is_first_call:
        return min_time, get_path(i, j, split)
    else:
        return min_time, split

def get_path(start, end, split):
    if start == end:
        return []
    if start + 1 == end:
        return [start, end]
    mid = split[(start, end)]
    if mid == end:
        return [start, end]

    return get_path(start, mid, split)[:-1] + get_path(mid, end, split)

def main():
    testcases = [testcase_1, testcase_2, testcase_3, testcase_4, testcase_5]
    for i, tc in enumerate(testcases):
        min_time, path = find_mintime_path(0, len(tc) - 1, tc)
        print(f"TC {i + 1} - 최소 이동 시간 : {min_time}")
        path_str = map(str, path)
        print(f"    최소 이동 경로 : {' -> '.join(path_str)}")
        print()

if __name__ == '__main__':
    main()
```

---

# 문제 8. 영리한 쥐의 경로찾기 (4)

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

이제 영리한 쥐보다 사람의 지능이 모자람이 없다는 사실을 실증한 T 연구원은, 최종적으로 목표로 하는 규모의 실험 결과를 미리 예측해 보기로 했다. 900개의 지점을 가진 미로를 구성하고 쥐의 최소 이동 시간을 계산해보려 했는데......

문제에 직면한 T 연구원은 곰곰히 생각하다가 관점을 바꾸어 보기로 했다. 누군가 그렇게 어려운 문제를 풀었는데, 그 누군가와 그 문제에 대해서 T 연구원은 알지 못했지만 여튼 관점을 바꾸어 보기로 했다.

## 수행목표

- 미로의 크기를 매우 확장했을 때 어떤 결과가 나오는지를 확인한다.
- 이 문제를 해결하는 상향식 접근 방법을 찾고, 이를 사용해 쥐의 최소 이동 시간을 계산해 반환하는 함수를 구현한다.
- 첨부한 파일에 포함된 5개의 리스트에 대한 결과를 출력한다.
- 다음 미로 생성 코드를 사용해 room_count가 900인 미로를 만들고 900개의 지점을 가진 미로에서 함수의 결과와 실행 시간을 출력한다.

  ```python
  import random

  def make_distance(i, j):
      distance = 0
      for x in range(j - i):
          distance += random.randint(-1, 1) + 3
      return distance

  def make_maze(room_count):
      maze = []
      for i in range(room_count + 1):
          ith_line = []
          for j in range(room_count + 1):
              if i > j:
                  ith_line.append(-1)
              elif i == j:
                  ith_line.append(0)
              else:
                  ith_line.append(make_distance(i, j))
          maze.append(ith_line)
      return maze
  ```

## 수행단계

- 상향식 접근 방법을 찾아보자. 아래 그림은 영리한 쥐 첫 번째 문제에서 사용했던 그림과 동일하다.
  - 지점 0에 있는 쥐가 지점 0까지 이동하는 최소 이동 시간은 얼마인지 확인해보자.
  - 지점 0에 있는 쥐가 지점 1까지 이동할 때 가능한 모든 경우를 나열해보자.
    - 지점 1까지의 최소 이동 시간이 얼마인지 확인해보자.
  - 지점 0에 있는 쥐가 지점 2까지 이동할 때 가능한 모든 경우를 나열해보자.
    - 지점 2까지의 최소 이동 시간이 얼마인지 확인해보자.
  - mt[k]를 지점 0에서 지점 k까지의 최소 이동 시간, t[i][j]는 지점 i에서 지점 j로 직접 연결된 통로의 이동 시간이라고 할 때, mt[2]를 mt와 t를 사용해 표현해보자.
  - mk[k]를 mt와 t를 사용해 상향식으로 계산하는 방법을 찾아본다.
- 상향식 접근 방법으로 미로의 지점 0에 들어간 쥐가 지점 N으로 이동하는데 걸리는 최소 시간을 계산해 반환하는 함수를 dp/smart_mouse4.py 파일에 구현한다.
  - min_time 배열을 지점의 수 + 1 만큼 크기로 미리 생성하고, 이 배열에 0번 지점부터 i번 지점으로 이동하는데 필요한 최소 시간을 저장한다. 이 배열은 작은 값부터 차례로 상향식으로 채워 나가고, 최종적으로 N번 지점의 값을 계산함으로써 상향식 계산이 마무리되어야 한다.
- 제공한 테스트 미로 데이터는 이전 문제와 동일한 구조의 리스트이다. 이 데이터 각각에 대해서 최소 이동 시간을 상향식 다이나믹 프로그래밍으로 계산해 출력한다.
- 무작위로 지점 900의 미로를 만든 후, 메모이제이션을 사용한 하향식 접근방법의 구현 결과(dp/smart_mouse2.py)와 이번 문제에서 구현한 상향식 구현 결과의 실행 시간 차이를 비교한다. 성능 차이가 나는 이유도 분석해보자.
  - 실행 시간을 확인할 때 미로를 만드는 시간을 포함시키지 않도록 주의하자.

## 결과예시

```
TC 1 - 최소 이동 시간 : 2
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/smart_mouse4.py 파일에 구현이 되어 있는지 확인한다.
  - 수행 과정에서 제시한 상향식 접근 방법을 사용해 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다. 900개의 지점을 가진 미로의 결과는 무작위 미로의 결과이므로 결과값은 실행할 때마다 달라진다. 실행 시간은 거의 실시간으로 결과를 확인할 수 있어야 정상이다.

    ```
    TC 1 - 최소 이동 시간 : 2

    TC 2 - 최소 이동 시간 : 16

    TC 3 - 최소 이동 시간 : 60

    TC 4 - 최소 이동 시간 : 90

    TC 5 - 최소 이동 시간 : 117

    900개의 지점을 가진 미로에서의 실행
        수행 시간: 0.06237387657165527 초
        최소 이동 시간 : 2043
    ```

### [문제에 대한 이해]

- 지점 0에 있는 쥐가 지점 0까지 이동하는 최소 이동 시간은 얼마인지 확인해보자.
  - 0번 지점은 시작 지점이므로, 최소 이동 시간은 0이다.
- 지점 0에 있는 쥐가 지점 1까지 이동할 때 가능한 모든 경우를 나열해보자.
  - 가능한 모든 경우 : 0번 지점에서 1번 지점으로 이동하는 한 가지이다.
- 지점 1까지의 최소 이동 시간은 얼마인가?
  - 최소 이동 시간 : 4초
- 지점 0에 있는 쥐가 지점 2까지 이동할 때 가능한 모든 경우를 나열해보자.
  - 가능한 모든 경우 : 바로 가는 경우(8초)와 1번 지점을 들러서 가는 경우(4초 + 5초 = 9초)
- 지점 2까지의 최소 이동 시간은 얼마인가?
  - 최소 이동 시간 : 8초
- min_time[k] 배열은 지점 0에 있는 쥐가 지점 k까지의 최소 이동 시간을 나타내고, t[i][j]는 지점 i에서 지점 j로 연결된 경로의 이동 시간이다. 지점 2까지의 모든 경우를 min_time 배열과 t 배열을 사용해 표현해보자.
  - 바로 가는 경우의 이동 시간 : min_time[0] + t[0][2]
  - 1번 지점을 들렀다 가는 경우의 이동 시간 : min_time[1] + t[1][2]
- 지점 2까지의 최소 이동 시간을 min_time 배열과 t 배열을 사용해 표현해보자.
  - min_time[2] = MIN(min_time[0] + t[0][2], min_time[1] + t[1][2])
- 지점 3까지의 최소 이동 시간인 min_time[3]을 동일한 방법으로 표현해보자.
  - 3번 지점까지의 최소 시간은 다음 값들의 최소값이다.
    - min_time[0] + t[0][3]
    - min_time[1] + t[1][3]
    - min_time[2] + t[2][3]
  - 그러므로 최소 이동 시간은 다음과 같이 표현할 수 있다. min_time[3] = MIN(min_time[0] + t[0][3], min_time[1] + t[1][3], min_time[2] + t[2][3])
- 지점 4까지의 최소 이동 시간인 min_time[4]를 동일한 방법으로 표현해보자.
  - min_time[4] = MIN(min_time[0] + t[0][4], min_time[1] + t[1][4], min_time[2] + t[2][4], min_time[3] + t[3][4])
- 상향식으로 영리한 쥐의 경로찾기 문제를 해결하는 방법을 설명해보자.
  - min_time 배열을 n + 1 크기로 생성하고 min_time[0]을 0, 나머지 값을 float[‘inf’] 또는 충분히 큰 값으로 초기화한다.
  - 1에서 n 까지의 루프를 만들고, 각 루프마다 min_time[i]을 계산한다.
    - 0에서 i - 1까지의 루프를 만들고, min_time[j] + t[j][i]의 값 중 가장 작은 값을 min_time[i]의 값으로 한다.
- 메모이제이션을 사용한 하향식 접근방법과 상향식 접근 방법을 매우 큰 규모의 미로(지점이 900개 규모인 경우)에 대해서 실행했을 때의 차이를 설명하라.
  - 상향식 접근 방법이 매우 빠르게 답을 제시하는 반면, 하향식 접근 방법은 메모이제이션을 사용한 경우에도 매우 오랜 시간이 필요하다.
- 이 문제에서 상향식 접근 방법의 성능이 하향식 접근 방법의 성능보다 좋은 이유를 제시하라.
  - 하향식 접근 방법은 n에 비래해서 재귀 호출을 하며, (메모를 사용하지 않는 경우 중복 계산으로 인해서 지수 시간 복잡도가 됨), 각 재귀 호출은 O(n^2)이므로 결국 O(n^3)의 시간 복잡도를 가지게 된다.
  - 상향식 접근 방법은 n의 크기에 따라 반복이 증가하는 이중으로 중첩된 루프를 사용하므로 O(n^2)의 시간 복잡도를 가지게 된다.
  - 결국 시간 복잡도의 차이로 실행 시간의 치이가 발생한다.

### [코드 예시]

```python
import time
import random
from smart_mouse4_data import testcase_1, testcase_2, testcase_3, testcase_4, testcase_5

def make_distance(i, j):
    distance = 0
    for x in range(j - i):
        distance += random.randint(-1, 1) + 3
    return distance

def make_maze(room_count):
    maze = []
    for i in range(room_count + 1):
        ith_line = []
        for j in range(room_count + 1):
            if i > j:
                ith_line.append(-1)
            elif i == j:
                ith_line.append(0)
            else:
                ith_line.append(make_distance(i, j))
        maze.append(ith_line)
    return maze

def find_min_time(n, t):
    min_time = [float('inf')] * (n + 1)
    min_time[0] = 0
    for i in range(1, n + 1):
        for j in range(i):
            min_time[i] = min(min_time[i], min_time[j] + t[j][i])
    return min_time[n]

def main():
    testcases = [testcase_1, testcase_2, testcase_3, testcase_4, testcase_5]
    for i, tc in enumerate(testcases):
        min_time = find_min_time(len(tc) - 1, tc)
        print(f"TC {i + 1} - 최소 이동 시간 : {min_time}")
        print()

    tc = make_maze(900)
    start = time.time()
    min_time = find_min_time(len(tc) - 1, tc)
    end = time.time()
    print("900개의 지점을 가진 미로에서의 실행")
    print(f"    수행 시간: {end - start} 초")
    print(f"    최소 이동 시간 : {min_time}")

if __name__ == '__main__':
    main()
```

---

# 문제 9. 영리한 쥐의 경로찾기 (5)

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

드디어 엄청나게 큰 규모의 실험의 결과도 미리 예측해서 실험의 달성 목표를 미리 제시할 수 있게 되었다.

'아!'

엄청나게 큰 규모의 실험에서도 어떤 지점을 통과해야 최소 시간인지를 알아야 한다는 사실을 T 연구원은 뒤늦게 깨달았다.

## 수행목표

- 상향식 다이나믹 프로그래밍으로 최소 이동 시간으로 미로를 통과하는 영리한 쥐가 어떤 지점을 들렀는지 결과를 반환하는 함수를 구현한다.
- 구현한 함수를 첨부한 데이터에서 실행한 결과를 출력한다.

## 수행단계

- 영리한 쥐의 경로를 찾는 과정은 이 문제가 마지막이다. 마지막으로 상향식 접근 방법으로 쥐의 경로를 찾는 일이다. 이 결과를 반환하는 함수를 dp/smart_mouse5.py 파일에 구현한다. 이 과정에서 다음 힌트를 사용할 수 있다.
  - previous 배열을 다음과 같이 정의한다.
  - previous[i] = j의 의미는, i번 지점까지의 최소 시간 경로는 i번 지점을 지나기 바로 이전에 j번 지점을 지난다는 의미이다.
  - previous 배열을 생성하고, 의미있는 값으로 초기화하며, 최소시간을 계산하는 과정에서 previous 배열의 값을 업데이트 하도록 코드를 수정해보자.
  - 최소 시간을 계산한 다음, previous 배열의 값을 사용해, 최소 시간으로 목적지에 도달한 쥐가 중간에 들른 지점을 추적하도록 코드를 수정해보자.
- 수행 목표에서 제시한 테스트 케이스를 사용해 결과를 출력한다.
  - 같은 시간의 최소 경로가 둘 이상 있더라도 하나 이상만 출력하면 된다.
  - 이전 테스트케이스에서 크기가 매우 큰 두 개의 데이터가 추가되어 있다.

## 결과예시

```
TC 1 - 최소 이동 시간 : 2
    최소 이동 경로 : 0 -> 2

TC 2 - 최소 이동 시간 : 16
    최소 이동 경로 : 0 -> 2 -> 4
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/smart_mouse5.py 파일에 구현이 되어 있는지 확인한다.
  - 수행 과정에서 제시한 상향식 접근 방법을 사용해 구현하였는지 확인한다. 경로를 찾는 힌트는 문제에서 제시한 방법을 사용하지 않아도 무방하지만, 상향식 다이나믹 프로그래밍 방법으로 구현이 되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```
    TC 1 - 최소 이동 시간 : 2
        최소 이동 경로 : 0 -> 2

    TC 2 - 최소 이동 시간 : 16
        최소 이동 경로 : 0 -> 2 -> 4

    TC 3 - 최소 이동 시간 : 60
        최소 이동 경로 : 0 -> 2 -> 7 -> 20

    TC 4 - 최소 이동 시간 : 90
        최소 이동 경로 : 0 -> 3 -> 4 -> 8 -> 9 -> 10 -> 11 -> 13 -> 16 -> 19 -> 26 -> 29 -> 31 -> 32 -> 36 -> 37 -> 39 -> 40

    TC 5 - 최소 이동 시간 : 117
        최소 이동 경로 : 0 -> 1 -> 2 -> 5 -> 6 -> 7 -> 8 -> 9 -> 12 -> 15 -> 20 -> 22 -> 26 -> 27 -> 29 -> 36 -> 41 -> 46 -> 48 -> 49 -> 50

    TC 6 - 최소 이동 시간 : 230
        최소 이동 경로 : 0 -> 1 -> 2 -> 3 -> 11 -> 12 -> 13 -> 17 -> 21 -> 22 -> 26 -> 31 -> 32 -> 34 -> 37 -> 55 -> 59 -> 68 -> 74 -> 87 -> 92 -> 93 -> 94 -> 95 -> 96 -> 99 -> 100

    TC 7 - 최소 이동 시간 : 461
        최소 이동 경로 : 0 -> 1 -> 2 -> 7 -> 8 -> 10 -> 15 -> 19 -> 29 -> 30 -> 36 -> 40 -> 46 -> 51 -> 58 -> 59 -> 62 -> 63 -> 64 -> 67 -> 71 -> 74 -> 80 -> 84 -> 95 -> 98 -> 100 -> 103 -> 108 -> 109 -> 112 -> 113 -> 114 -> 115 -> 116 -> 117 -> 122 -> 123 -> 124 -> 131 -> 138 -> 140 -> 144 -> 147 -> 148 -> 155 -> 157 -> 159 -> 160 -> 161 -> 163 -> 170 -> 173 -> 175 -> 180 -> 183 -> 184 -> 186 -> 192 -> 199 -> 200
    ```

### [문제에 대한 이해]

- previous 배열의 생성 및 초기화 방법에 대해서 설명하라. 특히 이렇게 초기값을 사용하는 의도도 설명해보자.
  - 이 배열은 n + 1의 크기, 값은 0으로 초기화한다. 초기값이 0이라는 의미는 i 지점 까지의 계산 전에는 최소 시간 경로를 한 번도 들르지 않고 곧장 i로 삼겠다는 의미이다.
  - 이후 계산 과정에서 다른 점을 들러서 i로 가는 이동 시간과 직접 i로 가는 이동 시간을 비교하게 되며, 더 작은 값을 찾을 수 없어서 이 값이 업데이트 되지 않으면 초기의 값이 끝까지 유지된다.
- previous 배열은 언제 업데이트 되는가?
  - `min_time[i]`가 업데이트 될 때 업데이트한다.
- 최소 이동 시간의 계산이 끝난 후 경로를 추적하는 과정을 설명하라.
  - `previous[n] = j`은 n번 지점까지의 최소시간 경로에서 n 앞에 들르는 지점을 의미한다.
  - `previous[j]`는 n번 지점까지의 최소 시간 경로에서 n, j 앞에 들르는 지점을 의미한다.
  - 이와 같은 역추적을 previous[] = 0이 될 때 까지 반복한다.
  - 이 결과의 역순이 경로가 된다.

### [코드 예시]

```python
from smart_mouse5_data import testcase_1, testcase_2, testcase_3, testcase_4, testcase_5, testcase_6, testcase_7

def find_min_path(n, t):
    min_time = [float('inf')] * (n + 1)
    previous = [0] * (n + 1)

    min_time[0] = 0

    for i in range(1, n + 1):
        for j in range(i):
            if min_time[i] > min_time[j] + t[j][i]:
                min_time[i] = min_time[j] + t[j][i]
                previous[i] = j
    path = []
    current = n
    while current != 0:
        path.append(current)
        current = previous[current]
    path.reverse()
    return min_time[n], path

def find_min_time(n, t):
    min_time = [float('inf')] * (n + 1)
    min_time[0] = 0
    for i in range(1, n + 1):
        for j in range(i):
            min_time[i] = min(min_time[i], min_time[j] + t[j][i])
    return min_time[n]

def main():
    testcases = [testcase_1, testcase_2, testcase_3, testcase_4, testcase_5, testcase_6, testcase_7]
    for i, tc in enumerate(testcases):
        min_time, path = find_min_path(len(tc) - 1, tc)
        print(f"TC {i + 1} - 최소 이동 시간 : {min_time}")
        path_str = map(str, [0] + path)
        print(f"    최소 이동 경로 : {' -> '.join(path_str)}")
        print()

if __name__ == '__main__':
    main()
```

---

# 문제 10. 파스칼의 삼각형

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

드디어 완벽한 답을 찾아낸 T 연구원은, 본인의 본업과 무관한 다음과 같은 궁금증이 생겨났다.

'상향식 접근 방법이 항상 좋은거야?'

## 수행목표

- 조합은 다음과 같은 점화식을 사용해서 계산할 수 있다.

  - $_n\mathcal C_m=_{n-1}\mathcal C_m+_{n-1}\mathcal C_{m-1}$

- 이 점화식을 사용해서 조합의 값을 구하는 함수 두개를 구현한다.
  - 하나는 하향식 접근, 다른 하나는 상향식 접근 방법으로 구현한다.
- 주어진 두 가지 경우의 실행 시간을 측정한다.
- 실행 시간을 비교하고, 이를 분석한다. 이 때 분석에 파스칼의 삼각형을 사용한다.

## 수행단계

- 문제에서 제시한 구조를 사용해 조합(Combination)을 계산하고 그 결과를 출력하는 함수를 dp/bottomup_vs_topdown.py 파일에 구현한다.
  - 두 함수는 모두 실행할 때 계산에 필요한 시간을 출력하도록 구현한다.
- 구현한 두 함수를 사용해 다음 두 개의 조합의 결과를 계산해 출력한다. 이 때 각 함수의 실행 시간도 함께 출력한다.
  - $_{900}\mathcal C_{450}$
  - $_{900}\mathcal C_{5}$
- 파스칼의 삼각형에 대해서 조사한다.
  - 파스칼의 삼각형과 조합의 관계에 대해서도 조사한다.
- $_4\mathcal C_3$의 값이 포함된 파스칼의 삼각형을 그려보자. $_4\mathcal C_3$의 값에 O로 체크를 한다.
  - 이 파스칼의 삼각형에서, 하향식 접근 방식의 계산 과정에서 구하는 결과값에 X를 쳐 보자.
  - 이 파스칼의 삼각형에서, 상향식 접근 방식의 계산 과정에서 구하는 결과값에 X를 쳐 보자.
- 파스칼의 삼각형에서 얻을 수 있는 통찰을 사용해 이 문제에서 함수의 수행 시간이 출력한 것과 같이 나온 이유를 확인한다.

## 결과예시

```
combination(900, 450)의 경우
수행 시간: 0.17208099365234375 초
하향식 접근 방식 : 224747188206601595731889139037713458435141013503593341894408388853402888711781430442741976993612639685074658454424962304517685394291753692909893226941007848625775254760391669040333020957131591685203823894886989214819079915185020650292157414056821827745387955846023022800

수행 시간: 0.18119001388549805 초
상향식 접근 방식 : 224747188206601595731889139037713458435141013503593341894408388853402888711781430442741976993612639685074658454424962304517685394291753692909893226941007848625775254760391669040333020957131591685203823894886989214819079915185020650292157414056821827745387955846023022800
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/bottomup_vs_topdown.py 파일에 구현이 되어 있는지 확인한다.
  - 점화식을 기반으로 문제의 구조를 사용해서 상향식, 하향식 접근 방법 각각의 함수를 구현하고 사용하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 실행 시간은 C(900, 5)에서 의미있는 차이로 하향식 접근 방식이 더 빠르다.

    ```
    combination(900, 450)의 경우
    수행 시간: 0.17208099365234375 초
    하향식 접근 방식 : 224747188206601595731889139037713458435141013503593341894408388853402888711781430442741976993612639685074658454424962304517685394291753692909893226941007848625775254760391669040333020957131591685203823894886989214819079915185020650292157414056821827745387955846023022800

    수행 시간: 0.18119001388549805 초
    상향식 접근 방식 : 224747188206601595731889139037713458435141013503593341894408388853402888711781430442741976993612639685074658454424962304517685394291753692909893226941007848625775254760391669040333020957131591685203823894886989214819079915185020650292157414056821827745387955846023022800

    combination(900, 5)의 경우
    수행 시간: 0.0019998550415039062 초
    하향식 접근 방식 : 4866287287680

    수행 시간: 0.1553964614868164 초
    상향식 접근 방식 : 4866287287680
    ```

### [문제에 대한 이해]

- 파스칼의 삼각형은 무엇인가?
  - 파스칼의 삼각형은 $(a+b)^n$의 각 항의 계수를 n이 0일때부터 차례로 중앙 정렬 형태로 나타낸 것이다.
- 파스칼의 삼각형과 조합의 관계는 어떻게 되나?
  - 파스칼의 삼각형에서 n + 1번째 줄의 r + 1번째 값이 $_n\mathcal C_r$의 값이 된다.
- $_4\mathcal C_3$의 값이 포함된 파스칼의 삼각형을 그리고 $_4\mathcal C_3$의 값에 동그라미를 쳐 보자.
  - ![Alt text](ch5_4.png)
- $_4\mathcal C_3$의 값이 포함된 파스칼의 삼각형을 그리고 상향식 접근방법에서 계산하는 값들에 X를 쳐 보자.
  - ![Alt text](ch5_5.png)
- $_4\mathcal C_3$의 값이 포함된 파스칼의 삼각형을 그리고 하향식 접근방법에서 계산하는 값들에 X를 쳐 보자.

  - ![Alt text](ch5_6.png)

- 이 문제에서 수행 시간이 결과와 같이 나온 이유를 설명해보자.
  - 하향식 접근 방법의 성능이 오히려 좋게 나왔다.
  - 상향식 접근법을 위해서 가장 작은 값에서 계산해 올라가는 경우, 이와 같이 하향식 접근에서는 계산하지 않아도 되는 모든 경우를 다 계산하게 되므로 오히려 하향식 접근법이 더 빠르게 동작한다. 이는 r의 값이 n이나 0에 가까울 수록 더 심해진다. 그래서 $_{900}\mathcal C_{5}$에서 차이가 오히려 두드려지게 나왔다.
- 상향식 접근 방법보다 하향식 접근 방법이 좋은 경우를 일반화 시켜 이야기할 수 있는가?
  - 상향식 접근법이 모든 문제를 해결하기 위해 불필요한 계산을 하게 되는 반면, 하향식 접근법이 재귀 호출에 필요한 부분의 문제만 해결하도록 동작하는 문제의 경우는 상향식 접근법의 성능이 하향식 접근법의 성능보다 나쁠 수 있다.

### [코드 예시]

```python
import time
def execute_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"수행 시간: {end - start} 초")
        return result
    return wrapper


@execute_time
def combination_td_wrapper(n, m):
    return combination_td(n, m)
def combination_td(n, m, memo = None):
    if memo == None:
        memo = {}
    if n < 0 or m < 0:
        return None
    if n < m:
        return None
    if (m == 0) or (n == m):
        return 1
    elif (n, m) in memo:
        return memo[(n, m)]
    else:
        memo[(n, m)] = combination_td(n - 1, m, memo) + combination_td(n - 1, m - 1, memo)
        return memo[(n, m)]

@execute_time
def combination_bu(n, m, comb = {}):
    if n < 0 or m < 0:
        return None
    if n < m:
        return None
    for i in range(0, n + 1):
        for j in range(0, i + 1):
            if j == 0:
                comb[(i, j)] = 1
            elif i == j:
                comb[(i, j)] = 1
            else:
                comb[(i, j)] = comb[(i - 1, j)] + comb[(i - 1, j - 1)]
            if (i == n) and (j == m):
                return comb[(i, j)]

def main():
    print("combination(900, 450)의 경우")
    print(f"하향식 접근 방식 : {combination_td_wrapper(900, 450)}")
    print()
    print(f"상향식 접근 방식 : {combination_bu(900, 450)}")
    print()
    print("combination(900, 5)의 경우")
    print(f"하향식 접근 방식 : {combination_td_wrapper(900, 5)}")
    print()
    print(f"상향식 접근 방식 : {combination_bu(900, 5)}")

if __name__ == '__main__':
    main()
```

---

# 문제 11. 가장 전기가 잘 통하는 구간은 어디일까? (2)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

N 연구원은 신경 연결의 전기적 특성을 확인하기 위한 실험을 하고 있다. (이전 과정의 4번 문제를 참고하라.)

당시 분할 정복 방법으로 문제를 해결한 N 연구원은 조금이라도 더 빠른 해결 방법을 찾는 중이다. 실험과 관련된 연산을 모두 장비에서 수행하기 위해서 초소형 에지 디바이스에 필요한 기능들을 옮겼기 때문이다. 무엇보다 메모리가 작은 장비라 재귀 호출을 사용하지 않고 해결할 수 있는 방법이 필요한 상황이었다.

이와 관련된 고민을 프로그래밍 지원 게시판에 적어두자, 익명으로 '상향식 다이나믹 프로그래밍으로 접근하면 O(1)의 공간 복잡도로 구현이 가능하다'
는 답변이 달렸다.

## 수행목표

- 숫자로 구성된 리스트가 주어지면, 이 리스트에서 합이 가장 큰 연속된 구간을 찾아서, 시작과 끝 인덱스와 이 때의 합의 값을 반환하는 함수를 구현한다.
  - 이번에는 다이나믹 프로그래밍을 사용해서 문제를 해결한다.
- 다음 첨부한 파일에는 17개의 리스트로 구성된 테스트케이스가 포함되어 있다. 이 데이터를 사용해서 함수를 실행한 결과를 출력한다.
  - 17번째 테스트케이스는 길이 100000의 무작위 리스트를 생성한다. 그러므로 실행할 때마다 결과가 다르게 나오지만, 어찌되었건 이 정도 길이의 리스트에서도 빠르게 답을 구할 수 있는 알고리즘으로 구현해야 한다.

## 수행단계

- 상향식 다이나믹 프로그래밍으로 주어진 배열에서 연속된 항목의 합이 최대가 되는 부분 배열의 합을 반환하는 함수를 dp/find_energetic_neuron_sequence.py 파일에 구현한다.
  - 이 함수는 분할 정복 방식이 아닌 상향식 다이나믹 프로그래밍 접근 방법을 사용해서 해결한다.
  - 이 문제를 상향식으로 접근하기 위해서 다음 배열을 사용한다.
    - dp[i] : 주어진 리스트에서 i번째 인덱스를 마지막 항목으로 하는 최대 연속된 부분 배열의 합. 예를 들어서 [1, -2, -3] 리스트에서 dp[1]은 [3, -2]와 [-2] 중 앞의 배열의 합인 1이 값이 되며, dp[2]는 [1, -2, -3], [-2, -3], [-3] 세 개의 배열 중 합이 가장 큰 [-3]의 -3을 값으로 한다.
    - dp[i]와 dp[i - 1] 사이의 관계를 찾는다.
    - 이 배열의 값을 dp[0]부터 상향식으로 구해 나간다.
      - 단 주어진 배열의 크기 n에 대에서 dp[0]에서 dp[n - 1]까지의 값을 다 구해야 하지만, dp[n - 1]이 최종적인 답은 아니라는 점에 유의한다.
- 주어진 리스트의 데이터를 사용해서 결과를 구하고, 이를 출력한다.
- 상향식 다이나믹 프로그래밍으로 구현한 경우의 시간 복잡도를 예전 구현한 분할 정복 방법의 시간 복잡도와 비교한다.

## 결과예시

```
testcase 1
    최대 부분 합 : 11

testcase 2
    최대 부분 합 : 2
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 분할 정복 방식과 달리 상향식 다이나믹 프로그래밍으로 이 문제를 해결할 때, 이 합을 구할 수 있는 '모든' 부분 배열을 찾는 것은 어렵지는 않지만 매우 귀찮은 일이다. 하지만 이 부분 배열 중 가장 길이가 짧은 부분 배열은 간단히 찾을 수 있다. 이 문제에서 최대가 되는 연속된 부분 배열의 합의 값과, 이 부분 배열 중 길이가 가장 짧은 부분 배열의 시작과 끝 인덱스를 출력해보자.
  - 만약 합이 같고 길이가 같은 배열이 둘 이상 존재한다면 둘 모두 출력한다.
  - 부분 배열을 출력하는 대신, 부분 배열의 시작 인덱스와 끝 인덱스를 출력한다.
  - 다음은 tc5 ([0, 0, 0])의 실행 결과의 예시이다.
    - `[(0, 0), (1, 1), (2, 2)]`
    - 참고로 길이가 가장 짧은 배열이 아닌 모든 부분 배열을 찾는 경우의 답은 `[(0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2)]`가 된다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/find_energetic_neuron_sequence.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍을 사용해 구현하였는지를 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    - 마지막 테스트케이스의 경우, 무작위로 생성한 배열의 결과이므로 값은 실행할 때마다 달라진다. 하지만 이 크기의 배열에서도 지연없이 답을 출력할 수 있어야 한다.

    ```
    testcase 1
        최대 부분 합 : 11

    testcase 2
        최대 부분 합 : 2

    testcase 3
        최대 부분 합 : 5

    testcase 4
        최대 부분 합 : -1

    testcase 5
        최대 부분 합 : 0

    testcase 6
        최대 부분 합 : 55

    testcase 7
        최대 부분 합 : 100

    testcase 8
        최대 부분 합 : -100

    testcase 9
        최대 부분 합 : 11

    testcase 10
        최대 부분 합 : 300

    testcase 11
        최대 부분 합 : 372

    testcase 12
        최대 부분 합 : 586

    testcase 13
        최대 부분 합 : 552

    testcase 14
        최대 부분 합 : 20222

    testcase 15
        최대 부분 합 : 22

    testcase 16
        최대 부분 합 : 75204

    testcase 17
        최대 부분 합 : 1832
    ```

### [보너스 과제 확인]

- 결과가 정확한가?

  - 가장 작은 크기의 합이 가장 큰 연속된 부분 배열의 시작 인덱스와 끝 인덱스를 출력하고 있는지 확인한다.
  - 마지막 테스트케이스는 무작위 배열에서 생성된 결과로 실행할 때마다 다른 결과가 나온다.

    ```
    testcase 1
        최대 부분 합 : 11
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(0, 5)]

    testcase 2
        최대 부분 합 : 2
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(0, 0), (2, 2)]

    testcase 3
        최대 부분 합 : 5
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(0, 4)]

    testcase 4
        최대 부분 합 : -1
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]

    testcase 5
        최대 부분 합 : 0
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(0, 0), (1, 1), (2, 2)]

    testcase 6
        최대 부분 합 : 55
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(1, 10)]

    testcase 7
        최대 부분 합 : 100
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(0, 0)]

    testcase 8
        최대 부분 합 : -100
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(0, 0)]

    testcase 9
        최대 부분 합 : 11
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(0, 5), (9, 14)]

    testcase 10
        최대 부분 합 : 300
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(67, 99)]

    testcase 11
        최대 부분 합 : 372
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(35, 51)]

    testcase 12
        최대 부분 합 : 586
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(34, 38)]

    testcase 13
        최대 부분 합 : 552
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(289, 975)]

    testcase 14
        최대 부분 합 : 20222
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(0, 999)]

    testcase 15
        최대 부분 합 : 22
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(1691, 1835)]

    testcase 16
        최대 부분 합 : 75204
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(1, 9997)]

    testcase 17
        최대 부분 합 : 1658
        최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : [(76587, 90530)]
    ```

### [문제에 대한 이해]

- dp[i]와 dp[i - 1] 사이의 관계에 대해서 설명하라.
- 상향식으로 이 문제를 해결하는 과정을 설명하라. 초기화, 상향 과정, 종료를 모두 포함해 설명해야 한다.
- 분할 정복 알고리즘으로 해결하는 방법과 상향식 다이나믹 프로그래밍으로 해결하는 방법을 비교해 효율성을 설명하라.
- (보너스 과제를 해결한 경우)왜 모든 부분 배열합을 다이나믹 프로그래밍으로 계산하는 것이 복잡하며, 다만 가장 길이가 짧은 부분 배열은 쉽게 구할 수 있는 이유를 설명하라.

### [코드 예시]

```python
from find_energetic_neuron_sequence_data import testcases

def find_maxsum_subarray(arr):
    n = len(arr)
    dp = [0] * n
    start_idx = [0] * n
    dp[0] = arr[0]
    max_sum = dp[0]
    max_sum_subarray = [(0, 0)]

    for i in range(1, n):
        if dp[i - 1] <= 0:
            dp[i] = arr[i]
            start_idx[i] = i
        else:
            dp[i] = dp[i - 1] + arr[i]
            start_idx[i] = start_idx[i - 1]
        if dp[i] > max_sum:
            max_sum = dp[i]
            max_sum_subarray = [(start_idx[i], i)]
        elif dp[i] == max_sum:
            max_sum_subarray.append((start_idx[i], i))

    return max_sum, max_sum_subarray

def main():
    for i, tc in enumerate(testcases):
        print(f"testcase {i + 1}")
        max_sum, max_sum_indices = find_maxsum_subarray(tc)
        print(f"    최대 부분 합 : {max_sum}")
        min_size = float("inf")
        min_size_subarray = []
        for start, end in max_sum_indices:
            if end - start < min_size:
                min_size = end - start
                min_size_subarray = [(start, end)]
            elif end - start == min_size:
                min_size_subarray.append((start, end))
        print(f"    최대 부분 합을 갖는 부분 배열 중 길이가 가장 짧은 배열의 시작과 끝 인덱스의 리스트 : {min_size_subarray}")
        print()


if __name__ == "__main__":
    main()

```

---

# 문제 12. 가장 전기가 잘 통하는 구간은 어디일까? (3)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

N 연구원은 가슴 깊숙한 곳 부터 짜증이 올라오고 있었다.

'내가 개발자도 아닌데!'

그것은 익명으로 누군가 도움을 주면서 덧붙인 'O(1)의 공간 복잡도로 구현이 가능하다'는 한 마디 때문이었다. 에지 디바이스에서 동작 가능한 프로그램을 만들고 있기 때문이 아니라, N 연구원의 성격 탓이었다. 도전정신이 자극받았기 때문이었다.

## 수행목표

- 숫자로 구성된 리스트가 주어지면, 이 리스트에서 합이 가장 큰 연속된 구간을 찾아서, 시작과 끝 인덱스와 이 때의 합의 값을 반환하는 함수를 구현한다.
  - 단, 이 문제를 해결하기 위해서 입력 리스트를 제외한 나머지 부분에서 추가로 사용하는 메모리의 공간복잡도는 상수 공간 복잡도(O(1))로 구현한다.
- 첨부한 파일에 포함된 10개의 배열에서 합이 최대인 연속 부분 배열의 합과 합이 최대가 되는 연속 부분 배열 중 하나를 출력한다.

## 수행단계

- 상향식 다이나믹 프로그래밍 방식으로 접근하기 위해서 이전 문제에서 dp[i]를 정의하고, 이 dp[i]를 상향식으로 계산하는 방식으로 문제를 해결했다. 이 방법을 개선해서 메모리를 덜 사용하는 함수를 dp/constant_memory_dp.py 파일에 구현한다.
  - 이 함수가 추가로 사용하는 메모리의 공간 복잡도는 O(1)로 한다.
  - 최대 연속 부분 배열 합 뿐 아니라 이 합이 되는 배열 중 임의의 하나를 반환한다.
- 첨부한 파일에 포함된 15개의 배열에 대해서 실행하고 그 결과를 출력한다.

## 결과예시

```
testcase 1
    최대 부분 합 : 0
    최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (0, 0)

testcase 2
    최대 부분 합 : 55
    최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (1, 10)

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/constant_memory_dp.py 파일에 구현이 되어 있는지 확인한다.
  - 문제를 해결하는데 사용하는 메모리는 정적으로 고정된 크기의 메모리만 사용하는지 확인한다. 물론, 상향식 다이나믹 프로그래밍으로 해결해야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    testcase 1
        최대 부분 합 : 0
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (0, 0)

    testcase 2
        최대 부분 합 : 55
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (1, 10)

    testcase 3
        최대 부분 합 : 11
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (0, 5)

    testcase 4
        최대 부분 합 : 300
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (67, 99)

    testcase 5
        최대 부분 합 : 372
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (35, 51)

    testcase 6
        최대 부분 합 : 586
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (34, 38)

    testcase 7
        최대 부분 합 : 552
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (289, 975)

    testcase 8
        최대 부분 합 : 20222
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (0, 999)

    testcase 9
        최대 부분 합 : 22
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (1691, 1835)

    testcase 10
        최대 부분 합 : 75204
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (1, 9997)

    testcase 11
        최대 부분 합 : 101
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (2, 202)

    testcase 12
        최대 부분 합 : 9
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (171, 181)

    testcase 13
        최대 부분 합 : 21134
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (185, 193)

    testcase 14
        최대 부분 합 : 1282
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (35, 1233)

    testcase 15
        최대 부분 합 : 13553
        최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : (0, 1233)
    ```

### [문제에 대한 이해]

- 상향식 다이나믹 프로그래밍으로 문제를 해결할 때 공간복잡도가 O(1)이라는 말은 어떤 의미를 가지는지 설명하라.
  - 상향식 다이나믹 프로그래밍의 하위 문제의 계산값을 저장하는 배열을 별도로 사용하지 않는다는 의미이다.
- 공간 복잡도를 O(1)로 하면서 상향식 다이나믹 프로그래밍의 시간 복잡도를 유지하는 방법을 설명하라.
  - dp(i)의 역할을 하는 변수 대신 이 역할을 하는 변수를 정의한다.
  - 최대 배열 부분합을 저장하는 변수를 정의한다.
  - 상향식으로 올라가면서 계산값들을 모두 저장하는 대신, 현재 항목을 마지막으로 하는 부분 배열의 최대 합을 계산하고, 이 값이 지금까지의 최대 배열 부분합 보다 큰 경우, 최대 배열 부분합을 갱신한다.

### [코드 예시]

```python
from constant_memory_dp_data import testcases


def max_subarray_sum_with_constant_memory(array):
    n = len(array)
    # dp[i]의 역할을 하는 변수
    max_now_start_idx = 0
    max_start_idx = 0
    max_end_idx = 0
    max_now = array[0]
    # 지금까지의 최대값을 저장하는 변수
    max_sofar = array[0]
    # 배열을 순회하며 max_now를 갱신
    for i in range(1, n):
        # 현재 항목을 마지막으로 하는 부분 배열의 최대 합을 계산
        if max_now <= 0:
            max_now = array[i]
            max_now_start_idx = i
        else:
            max_now += array[i]
        # 최대값 갱신
        if max_now > max_sofar:
            max_sofar = max_now
            max_start_idx = max_now_start_idx
            max_end_idx = i
    # dp[]의 최대값에 해당하는 max_sofar를 반환
    return max_sofar, max_start_idx, max_end_idx


def main():
    for i, tc in enumerate(testcases):
        print(f"testcase {i + 1}")
        max_sum, max_sum_start_idx, max_sum_end_idx = max_subarray_sum_with_constant_memory(tc)

        print(f"    최대 부분 합 : {max_sum}")
        print(f"    최대 부분 합을 갖는 부분 배열 중 하나의 시작과 끝 인덱스 : {max_sum_start_idx, max_sum_end_idx}")

        print()


if __name__ == "__main__":
    main()


```

---

# 문제 13. DNA의 공통 패턴 (1)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

“바이러스 감염이 돌연변이의 원인이 되는지 확인하는 연구가 있어요.”
바이러스를 연구하는 V 연구원과 진화를 연구하는 E 연구원이 커피를 마시면서 최근 연구 동향에 대해서 이야기를 나누고 있었다. 두 사람 중 V 연구원이 지금 잘 풀리지 않는 문제에 대해서 물어보던 중이었다.

“몸에서 DNA가 복제될 때, 바이러스의 영향으로 바이러스의 DNA 패턴 일부가 DNA에 섞여 들어가거든요. 그래서 특정 돌연변이로 의심되는 두 개체 각각의 DNA 염기 서열에서 가장 긴 공통 부분 문자열을 찾은 후, 이 패턴과 일치하는 바이러스를 찾아보는 방법으로 진행 중이에요. 그런데 가장 긴 공통 부분 문자열을 찾는게 영......"

그러자 E 연구원이 제안했다.

"프로그래밍 지원 게시판의 도움을 받아보시죠?"

## 수행목표

- 두 개의 문자열이 주어진다. 두 문자열에 모두 포함되어 있는 부분 문자열 중 가장 긴 부분 문자열의 길이를 출력하는 프로그램을 작성한다.
  - 여기서 포함된 부분 문자열이란 포함된 연속된 부분 문자열을 의미하지 않는다. 'CTA', 'CTC', 'CAC' 셋 모두 'CTAC'에 포함되어 있는 부분 문자열에 해당된다.
  - 'CTAC', 'CACG' 두 문자열이 주어졌을 때, 두 문자열에 공통으로 포함된 가장 긴 부분 문자열은 'CAC'이며 이 문자열의 길이 3을 반환한다.
- 다음 테스트케이스에는 6개의 문자열 쌍이 제공된다. 각 쌍에서 공통으로 포함된 가장 긴 부분 문자열의 길이를 출력하라.

  ```python
  testcases = [('CTAC', 'CACG'), ('CCCAGCGTCGAAACCGCTGC', 'ACACGGATGCCTGTTATGAT'), ('CAACCACAAC', 'C'), ('AATGATGCTC', ''), ('TCTCTCATCAACAACGGGGTTGACCAAACGGGCAGTGTGGTGTTCAAAGCCGACTTATAGCCTACATGACTTAGCTTGCTATTACGTTGCATTTCCACGGAAACCCGAAAGCAGGGTCAGAGCCTCGCTGATCCACCCACTAACTATATCGCCCTTCCTCAGTCATGCTCCCGCGCAAAGAGGGGCTCTCAAGGTGTTCGTAGGTTGGCCGCCCTTGTGCTCTGAGGCCTAGTAAGAGGGTATCACGTTGCGCAGCAAGGCAAAGGGGCTACCGTGAACGCAGCTATGGGATGTGCAAAACGTGATGACTAGCGTCGCGTTAGTGCTTCCAGCATAAGTCCGAGCCAGGCCGCCTAGACATGGTTACTGTTGACTTGGTCCCCTTTTGTTAAGGTGCACAATCGACAACGGGTGGTCGGCCATCTCTTGCATAGGTCGGAGTTAAAGGACCGCGAACTGGCCCTCTACGTTTTTGTCACGCGGAGTGGCGCATTAAGATA', 'CCTACTTCTTAAGGCCGGTAGTGAAGTTCACAATATGTGTTTCTACCTATTACCCAAGGTGCGAGGGTTTTGATCGGGTGTGTTTTAGGCCTATTTAACTCCATCCGGCGAGTCACGTGGTCCGCTCATGTAGTGCTTACGGGGATCGGGTGGGGTAATAGTAGCGACGATTGTGCTTAGCCCGAGCGTGAAACTGCCAATATCGATGAACGATCTGAAATACACGTTGAATTGAAGCCGCTAGTGGTTCCATCGAATAGTCCTAGGGATGAATAGATATGGGGTTACAAAGAACCCACGGCTCAGGCTGGACATTAACAGCGAGTCGCTTCTACAGAGGGCGTTCATCAACGCGGGTTTAAGATATCCCATTGGGGTCGTGACGTGTCCTCGCCCAATGCGCGACTCGATCCATACGTAGACTATTACAACGGCGTGGAATCTTAAAATTCGAAGTATCGGGACCGGCGGACGCATGCGTAATTTGTCGCCTCGAGAGG'), ('GGTTCACTGGACACCTATCAAGGGAACTTGTTTCGGTGCTACATGATGTGCACTACTCCTATTACATTCGTTCTTCTTAAGAAACAACAGTGTTGCATGGCTATGACGGCCGTATAACTCCCCAGGTAGCTGAGGCATACAGGCTCGGAGGAGGGTCATGCATCATGTGTTGTCAAACCTGTCGTGTAGACAAGCTCCGGAGAGCGATGAGGTGGGGAAAGGCTAATGAAGGTTCTATTGTTTCTATATGGTGCGCCATAGATCTATGTTTTAGGGTCCGCACTACTCGCATATGCCCACTGGCAGAAATAGCAGGGCTTGCGGGCTAAATTCCCTGCACCGAAAACAGCCATCCCCCAGATCAGTGTCGATCGCACCTGCCAATTATTGACTTTCAGTGGCTAGATCAATCTTCGAAACCAAACATTTGCTACGACGGATCGGAGCTTGTTACTGCACGACAGACGGGGCACACTATGTCGGTTCCTTGCACCTCCGGAGTCAAGGCCTGGAAAATCGCAATTCGGACCGAGATAATATTCGATCGCCTACATAGAATTGAATCGTGATGACATCGTGGACCTTGACGCTACTACTTTA', 'TGGACGTGTGTAGCTTTATCGCCTTTCGACAAAAAAAACTCATTGGTCATGTACGTTCGACTCCTGGGTCACGCTTCATCTTGAGGTTCAAAATTAGTGTAGACCCTCTAGCAACTTCGCACATCTCTCCAGATCGGTTCCTATAAAATATGTGGCTTGGGATGAGGTGAAGCCGGGTGCCGGGTGCATGTGAATACGCTGATAATCCGGAGGGGCTATACCGGCGCAGCTACTCGCCAACGCACTCCTAGTCCCCTTGGGAGTTGAGGGCACCTGACGTGTGGTGACACAGTCGAGGTT')]
  ```

## 수행단계

- 다음 과정을 통해서 문제의 구조를 확인한다.

  - 두 문자열의 길이가 각각 n, m인 경우 (n + 1) x (m + 1) 크기의 행렬 `dp[][]`을 만든다.

    - `dp[i][j]`는 첫 번째 문자열의 앞 i 글자 문자열과 두 번째 문자열의 앞 j 글자 문자열의 최장 공통 부분 순열의 길이이다.
    - i는 0에서 n 까지의 값을, j는 0에서 m 까지의 값을 가진다.
    - 두 문자열이 각각 ‘CTAC’, ‘CACG’이고, 아래 표의 셀의 값이 `dp[i][j]`라고 할 때, 아래 표를 완성시켜보자.

      |               | 0 (빈 문자열) | 1 (C) | 2 (CT) | 3 (CTA) | 4 (CTAC) |
      | ------------- | ------------- | ----- | ------ | ------- | -------- |
      | 0 (빈 문자열) |               |       |        |         |          |
      | 1 (C)         |               |       |        |         |          |
      | 2 (CA)        |               |       |        |         |          |
      | 3 (CAC)       |               |       |        |         |          |
      | 4 (CACG)      |               |       |        |         |          |

  - 글자를 한 글자씩 추가해가는 과정을 복기해보자.
    - 이 과정에서 LCS가 1에서 2로 바뀌는 경우는 어떤 경우인가?
    - 이 과정에서 LCS가 2에서 3으로 바뀌는 경우는 어떤 경우인가?
    - 바뀌지 않는 경우는 어떤 경우이며, 이때의 값을 위 또는 왼쪽 셀의 값과 비교해보자.

- 확인한 구조를 사용해 상향식 다이나믹 프로그래밍으로 문제를 해결하는 함수를 dp/common_pattern1.py 파일에 구현한다.
  - 반드시 위에서 제시한 구조를 사용한 상향식 다이나믹 프로그래밍으로 구현한다.
- 제공한 테스트케이스 6쌍에 대해서, 각 쌍 별로 가장 긴 공통 부분 문자열의 길이를 출력한다.

## 결과예시

```
Testcase 1의 가장 긴 공통 부분 문자열의 길이 : 3

Testcase 2의 가장 긴 공통 부분 문자열의 길이 : 11
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/common_pattern1.py 파일에 구현이 되어 있는지 확인한다.
  - 수행단계에서 제시한 방식의 상향식 다이나믹 프로그래밍을 사용해 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    Testcase 1의 가장 긴 공통 부분 문자열의 길이 : 3

    Testcase 2의 가장 긴 공통 부분 문자열의 길이 : 11

    Testcase 3의 가장 긴 공통 부분 문자열의 길이 : 1

    Testcase 4의 가장 긴 공통 부분 문자열의 길이 : 0

    Testcase 5의 가장 긴 공통 부분 문자열의 길이 : 316

    Testcase 6의 가장 긴 공통 부분 문자열의 길이 : 257
    ```

### [문제에 대한 이해]

- `dp[i][j]`는 첫 번째 문자열의 앞 i 글자 문자열과 두 번째 문자열의 앞 j 글자 문자열의 최장 공통 부분 순열의 길이이다. 이 행렬의 값에 해당하는 각 항목의 값을 사용하여 아래 표를 완성시켜보라.

|               | 0 (빈 문자열) | 1 (C) | 2 (CT) | 3 (CTA) | 4 (CTAC) |
| ------------- | ------------- | ----- | ------ | ------- | -------- |
| 0 (빈 문자열) |               |       |        |         |          |
| 1 (C)         |               |       |        |         |          |
| 2 (CA)        |               |       |        |         |          |
| 3 (CAC)       |               |       |        |         |          |
| 4 (CACG)      |               |       |        |         |          |

- 완성된 표는 다음과 같다.
  | | 0 (빈 문자열) | 1 (C) | 2 (CT) | 3 (CTA) | 4 (CTAC) |
  | ------------- | ------------- | ----- | ------ | ------- | -------- |
  | 0 (빈 문자열) | 0 |0 | 0 | 0 | 0 |
  | 1 (C) | 0 | 1 | 1 | 1 | 1 |
  | 2 (CA) | 0 | 1 | 1 | 2 | 2 |
  | 3 (CAC) | 0 | 1 | 1 | 2 | 3 |
  | 4 (CACG) | 0 | 1 | 1 | 2 | 3 |

- 위의 표에서 오른쪽 방향으로 값이 1 증가하는 경우는 어떤 경우인가?
  - 첫 번째 문자열에 글자가 추가되어 최대 길이의 공통 부분 문자열의 크기가 증가하는 경우
- 위의 표에서 아래쪽 방향으로 값이 1 증가하는 경우는 어떤 경우인가?
  - 두 번째 문자열에 글자가 추가되어 최대 길이의 공통 부분 문자열의 크기가 증가하는 경우
- 위의 표에서 오른쪽 또는 아래쪽 방향의 값이 동일한 경우는 어떤 경우인가?
  - 글자 추가가 최대 길이의 공통 부분 문자열에 영향을 미치지 않는 경우
- 구현한 상향식 알고리즘의 시간 복잡도를 제시하라.
  - 두 시퀀스의 크기만큼의 이중 루프를 반복하면서 계산한다.
  - 그러므로 두 글자의 길이가 n, m일 때 시간 복잡도는 O(nm)이다.

### [코드 예시]

```python
def dna_longgest_shared_pattern_length(word1, word2):
    word1_length = len(word1)
    word2_length = len(word2)
    dp = [[0] * (word2_length + 1) for _ in range(word1_length + 1)]
    for i in range(word1_length):
        for j in range(word2_length):
            if word1[i] == word2[j]:    # 추가 후 마지막 글자가 같을 때
                dp[i + 1][j + 1] = dp[i][j] + 1
            else:                       # 추가 후 마지막 글자가 다를 때
                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])

    return dp[word1_length][word2_length]

def main():
    testcases = [('CTAC', 'CACG'), ('CCCAGCGTCGAAACCGCTGC', 'ACACGGATGCCTGTTATGAT'), ('CAACCACAAC', 'C'), ('AATGATGCTC', ''), ('TCTCTCATCAACAACGGGGTTGACCAAACGGGCAGTGTGGTGTTCAAAGCCGACTTATAGCCTACATGACTTAGCTTGCTATTACGTTGCATTTCCACGGAAACCCGAAAGCAGGGTCAGAGCCTCGCTGATCCACCCACTAACTATATCGCCCTTCCTCAGTCATGCTCCCGCGCAAAGAGGGGCTCTCAAGGTGTTCGTAGGTTGGCCGCCCTTGTGCTCTGAGGCCTAGTAAGAGGGTATCACGTTGCGCAGCAAGGCAAAGGGGCTACCGTGAACGCAGCTATGGGATGTGCAAAACGTGATGACTAGCGTCGCGTTAGTGCTTCCAGCATAAGTCCGAGCCAGGCCGCCTAGACATGGTTACTGTTGACTTGGTCCCCTTTTGTTAAGGTGCACAATCGACAACGGGTGGTCGGCCATCTCTTGCATAGGTCGGAGTTAAAGGACCGCGAACTGGCCCTCTACGTTTTTGTCACGCGGAGTGGCGCATTAAGATA', 'CCTACTTCTTAAGGCCGGTAGTGAAGTTCACAATATGTGTTTCTACCTATTACCCAAGGTGCGAGGGTTTTGATCGGGTGTGTTTTAGGCCTATTTAACTCCATCCGGCGAGTCACGTGGTCCGCTCATGTAGTGCTTACGGGGATCGGGTGGGGTAATAGTAGCGACGATTGTGCTTAGCCCGAGCGTGAAACTGCCAATATCGATGAACGATCTGAAATACACGTTGAATTGAAGCCGCTAGTGGTTCCATCGAATAGTCCTAGGGATGAATAGATATGGGGTTACAAAGAACCCACGGCTCAGGCTGGACATTAACAGCGAGTCGCTTCTACAGAGGGCGTTCATCAACGCGGGTTTAAGATATCCCATTGGGGTCGTGACGTGTCCTCGCCCAATGCGCGACTCGATCCATACGTAGACTATTACAACGGCGTGGAATCTTAAAATTCGAAGTATCGGGACCGGCGGACGCATGCGTAATTTGTCGCCTCGAGAGG'), ('GGTTCACTGGACACCTATCAAGGGAACTTGTTTCGGTGCTACATGATGTGCACTACTCCTATTACATTCGTTCTTCTTAAGAAACAACAGTGTTGCATGGCTATGACGGCCGTATAACTCCCCAGGTAGCTGAGGCATACAGGCTCGGAGGAGGGTCATGCATCATGTGTTGTCAAACCTGTCGTGTAGACAAGCTCCGGAGAGCGATGAGGTGGGGAAAGGCTAATGAAGGTTCTATTGTTTCTATATGGTGCGCCATAGATCTATGTTTTAGGGTCCGCACTACTCGCATATGCCCACTGGCAGAAATAGCAGGGCTTGCGGGCTAAATTCCCTGCACCGAAAACAGCCATCCCCCAGATCAGTGTCGATCGCACCTGCCAATTATTGACTTTCAGTGGCTAGATCAATCTTCGAAACCAAACATTTGCTACGACGGATCGGAGCTTGTTACTGCACGACAGACGGGGCACACTATGTCGGTTCCTTGCACCTCCGGAGTCAAGGCCTGGAAAATCGCAATTCGGACCGAGATAATATTCGATCGCCTACATAGAATTGAATCGTGATGACATCGTGGACCTTGACGCTACTACTTTA', 'TGGACGTGTGTAGCTTTATCGCCTTTCGACAAAAAAAACTCATTGGTCATGTACGTTCGACTCCTGGGTCACGCTTCATCTTGAGGTTCAAAATTAGTGTAGACCCTCTAGCAACTTCGCACATCTCTCCAGATCGGTTCCTATAAAATATGTGGCTTGGGATGAGGTGAAGCCGGGTGCCGGGTGCATGTGAATACGCTGATAATCCGGAGGGGCTATACCGGCGCAGCTACTCGCCAACGCACTCCTAGTCCCCTTGGGAGTTGAGGGCACCTGACGTGTGGTGACACAGTCGAGGTT')]
    for i, tc in enumerate(testcases):
        word1, word2 = tc
        print(f"Testcase {i + 1}의 가장 긴 공통 부분 문자열의 길이 : {dna_longgest_shared_pattern_length(word1, word2)}")
        print()

if __name__ == '__main__':
    main()
```

---

# 문제 14. DNA의 공통 패턴 (2)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

"질문을 잘못 하신 것 같은데요?"

E 연구원이 표정을 찡그리며 이야기했다.

"패턴을 찾는 법을 여쭈셔야 했었는데, 가장 긴 패턴의 길이를 물어보셨네요."

그러자 V 연구원이 허탈한 표정으로 말했다.

"아니, 이렇게 물으면 패턴 찾는 방법도 가르쳐줄거라 생각했죠."

그런데 갑자기 V 연구원이 정색하며 말을 이었다.

"그런데, 이 정도 답변이면, 남은 문제는 해결할 수 있을 것 같아요!"

## 수행목표

- 두 개의 문자열이 주어진다. 두 문자열에 모두 포함되어 있는 부분 문자열 중 가장 긴 부분 문자열을 출력하는 프로그램을 작성한다.
  - 여기서 포함된 부분 문자열이란 포함된 연속된 부분 문자열을 의미하지 않는다. 'CTA', 'CTC', 'CAC' 셋 모두 'CTAC'에 포함되어 있는 부분 문자열에 해당된다.
  - 'CTAC', 'CACG' 두 문자열이 주어졌을 때, 두 문자열에 공통으로 포함된 가장 긴 부분 문자열은 'CAC'이며 이 문자열을 출력한다.
- 다음 테스트케이스에는 6개의 문자열 쌍이 제공된다. 각 쌍에서 공통으로 포함된 가장 긴 부분 문자열의 길이를 출력하라.
  ```python
  testcases = [('CTAC', 'CACG'), ('CCCAGCGTCGAAACCGCTGC', 'ACACGGATGCCTGTTATGAT'), ('CAACCACAAC', 'C'), ('AATGATGCTC', ''), ('TCTCTCATCAACAACGGGGTTGACCAAACGGGCAGTGTGGTGTTCAAAGCCGACTTATAGCCTACATGACTTAGCTTGCTATTACGTTGCATTTCCACGGAAACCCGAAAGCAGGGTCAGAGCCTCGCTGATCCACCCACTAACTATATCGCCCTTCCTCAGTCATGCTCCCGCGCAAAGAGGGGCTCTCAAGGTGTTCGTAGGTTGGCCGCCCTTGTGCTCTGAGGCCTAGTAAGAGGGTATCACGTTGCGCAGCAAGGCAAAGGGGCTACCGTGAACGCAGCTATGGGATGTGCAAAACGTGATGACTAGCGTCGCGTTAGTGCTTCCAGCATAAGTCCGAGCCAGGCCGCCTAGACATGGTTACTGTTGACTTGGTCCCCTTTTGTTAAGGTGCACAATCGACAACGGGTGGTCGGCCATCTCTTGCATAGGTCGGAGTTAAAGGACCGCGAACTGGCCCTCTACGTTTTTGTCACGCGGAGTGGCGCATTAAGATA', 'CCTACTTCTTAAGGCCGGTAGTGAAGTTCACAATATGTGTTTCTACCTATTACCCAAGGTGCGAGGGTTTTGATCGGGTGTGTTTTAGGCCTATTTAACTCCATCCGGCGAGTCACGTGGTCCGCTCATGTAGTGCTTACGGGGATCGGGTGGGGTAATAGTAGCGACGATTGTGCTTAGCCCGAGCGTGAAACTGCCAATATCGATGAACGATCTGAAATACACGTTGAATTGAAGCCGCTAGTGGTTCCATCGAATAGTCCTAGGGATGAATAGATATGGGGTTACAAAGAACCCACGGCTCAGGCTGGACATTAACAGCGAGTCGCTTCTACAGAGGGCGTTCATCAACGCGGGTTTAAGATATCCCATTGGGGTCGTGACGTGTCCTCGCCCAATGCGCGACTCGATCCATACGTAGACTATTACAACGGCGTGGAATCTTAAAATTCGAAGTATCGGGACCGGCGGACGCATGCGTAATTTGTCGCCTCGAGAGG'), ('GGTTCACTGGACACCTATCAAGGGAACTTGTTTCGGTGCTACATGATGTGCACTACTCCTATTACATTCGTTCTTCTTAAGAAACAACAGTGTTGCATGGCTATGACGGCCGTATAACTCCCCAGGTAGCTGAGGCATACAGGCTCGGAGGAGGGTCATGCATCATGTGTTGTCAAACCTGTCGTGTAGACAAGCTCCGGAGAGCGATGAGGTGGGGAAAGGCTAATGAAGGTTCTATTGTTTCTATATGGTGCGCCATAGATCTATGTTTTAGGGTCCGCACTACTCGCATATGCCCACTGGCAGAAATAGCAGGGCTTGCGGGCTAAATTCCCTGCACCGAAAACAGCCATCCCCCAGATCAGTGTCGATCGCACCTGCCAATTATTGACTTTCAGTGGCTAGATCAATCTTCGAAACCAAACATTTGCTACGACGGATCGGAGCTTGTTACTGCACGACAGACGGGGCACACTATGTCGGTTCCTTGCACCTCCGGAGTCAAGGCCTGGAAAATCGCAATTCGGACCGAGATAATATTCGATCGCCTACATAGAATTGAATCGTGATGACATCGTGGACCTTGACGCTACTACTTTA', 'TGGACGTGTGTAGCTTTATCGCCTTTCGACAAAAAAAACTCATTGGTCATGTACGTTCGACTCCTGGGTCACGCTTCATCTTGAGGTTCAAAATTAGTGTAGACCCTCTAGCAACTTCGCACATCTCTCCAGATCGGTTCCTATAAAATATGTGGCTTGGGATGAGGTGAAGCCGGGTGCCGGGTGCATGTGAATACGCTGATAATCCGGAGGGGCTATACCGGCGCAGCTACTCGCCAACGCACTCCTAGTCCCCTTGGGAGTTGAGGGCACCTGACGTGTGGTGACACAGTCGAGGTT')]
  ```

## 수행단계

- 이전 문제에서 작성했던 dp[][]를 다시 살펴보자. 다음은 두 염기 서열 시퀀스가 CTAC, CACG인 경우의 dp[][] 행렬을 테이블로 나타낸 것이다.

  |               | 0 (빈 문자열) | 1 (C) | 2 (CT) | 3 (CTA) | 4 (CTAC) |
  | ------------- | ------------- | ----- | ------ | ------- | -------- |
  | 0 (빈 문자열) | 0             | 0     | 0      | 0       | 0        |
  | 1 (C)         | 0             | 1     | 1      | 1       | 1        |
  | 2 (CA)        | 0             | 1     | 1      | 2       | 2        |
  | 3 (CAC)       | 0             | 1     | 1      | 2       | 3        |
  | 4 (CACG)      | 0             | 1     | 1      | 2       | 3        |

  - 이 과정에서 LCS가 1에서 2로 바뀌는 경우는 어떤 경우인가?
  - 이 과정에서 LCS가 2에서 3으로 바뀌는 경우는 어떤 경우인가?
  - 바뀌지 않는 경우는 어떤 경우이며, 이때의 값을 위 또는 왼쪽 셀의 값과 비교해보자.

- 위 테이블의 값의 변화 상황을 사용해서 가장 긴 공통 부분 문자열을 찾는 방법을 정리한다.
- 위에서 정리한 방법을 사용해 가장 긴 공통 부분 문자열을 찾아 반환하는 함수를 dp/common_pattern2.py 파일에 구현한다.
- 첨부한 파일에 포함된 15개의 배열에 대해서 실행하고 그 결과를 출력한다.

## 결과예시

```
Testcase 1의 가장 긴 공통 부분 문자열 : CAC

Testcase 2의 가장 긴 공통 부분 문자열 : CACGGACCGTG

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/common_pattern2.py 파일에 구현이 되어 있는지 확인한다.
  - dp 행렬을 추적하여 가장 긴 공통 문자열을 찾는 형식으로 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    Testcase 1의 가장 긴 공통 부분 문자열 : CAC

    Testcase 2의 가장 긴 공통 부분 문자열 : CACGGACCGTG

    Testcase 3의 가장 긴 공통 부분 문자열 : C

    Testcase 4의 가장 긴 공통 부분 문자열 :

    Testcase 5의 가장 긴 공통 부분 문자열 : CTCTCTAACCGGGGTTACAAATGTGTTTCACCATTACCCATGCAGTTGATCGTTGTTTAGGAAACCCACGGCGAGCCGTGTCCCCATTATGCTTCGATCGGGGGGGTAATGTCGAGTTGGCGCCCGGCTCTGCCTAGTAAGAGTACACGTTGAGAAGGCAGGGTCCTGAAAGCTAGGGATGAAAATATGACAGCCGCTAGTGCTTCAGCATGTCCGAGCCACCGCTAGACATGGTTACTGTTGATGGCCTGTTAGTGACATACAACGGGTGGATCTTAATCGAGTAGGACCGCGACGCTCTATTTGTCGCTCGAGA

    Testcase 6의 가장 긴 공통 부분 문자열 : TGGACGTGTGTGCTTTATCCCTTTCACAAAAAAAATCATGGCATGACGCGACTCCTGGGCACGCTTCATCTTGGTTCAAATTGTGTAGACCTCAGCAACTTGAATCTCTCCAGATCGGTTCCTATAAAAATGGGCTTGGGATGAGAAGCCTCCGGTGCATGTGAATACGCTGATAATCCGAGCTAACGGCGAGCTACTGCCAACGCACCTAGTCCCTTGGGAGTTGAGGGACCTGACGTGTGGTGAACAGTCGAGTT

    ```

### [문제에 대한 이해]

- 상향식 다이나믹 프로그래밍의 하위 문제를 해결하기 위해서 사용한 dp 리스트를 사용해서 가장 긴 공통 부분 문자열을 찾는 방식을 설명하라.

  - 두 염기가 추가된 상황에서 두 염기가 같으면 최장 공통 순열의 길이가 증가한다.
  - 즉 대각선 방향으로 값이 증가될 때, 이 때 추가된 염기가 최장 공통 순열에 포함되는 염기가 된다.
  - lcs_table을 역방향으로 추적하면서 공통 시퀀스의 각각의 염기를 찾는다.
  - 복원한 시퀀스를 뒤집는다. (역방향 추적 시에 순서대로 추가한 경우)

### [코드 예시]

```python
def dna_longgest_shared_pattern(word1, word2):
    word1_length = len(word1)
    word2_length = len(word2)

    dp = [[0] * (word2_length + 1) for _ in range(word1_length + 1)]
    # 두 문자열의 첫 번째 글자부터 한 글자씩 추가하면서 dp를 계산한다.
    for i in range(word1_length):
        for j in range(word2_length):
            if word1[i] == word2[j]:    # 추가 후 마지막 글자가 같을 때
                dp[i + 1][j + 1] = dp[i][j] + 1
            else:                       # 추가 후 마지막 글자가 다를 때
                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])

    # dp 배열을 역순으로 추적한다.
    longest_shared_pattern = ''
    i = len(word1)
    j = len(word2)
    while True:
        # 둘 중 하나의 문자열이 비거나 dp[i][j] = 0이면 종료
        if i == 0 or j == 0 or dp[i][j] == 0:
            break
        # 두 문자열의 마지막 글자를 빼도 값이 같다면 양쪽 글자 모두 최장 공통부분문자열에 포함되지 않는다.
        if dp[i][j] == dp[i - 1][j - 1]:
            i -= 1
            j -= 1
        # 두 문자열의 마지막 글자 중 하나가 최장 공통부분문자열이 되는 상황이므로, 같은 문자열이 될 때까지 이동한다.
        elif dp[i][j] == dp[i - 1][j]:
            i -= 1
        elif dp[i][j] == dp[i][j - 1]:
            j -= 1
        # 두 문자열의 마지막 글자가 같은 상황 - 최장 공통부분문자열의 앞 부분에 해당 글자를 추가한다.
        else:
            longest_shared_pattern = word1[i - 1] + longest_shared_pattern
            i -= 1
            j -= 1
    return longest_shared_pattern

def main():
    testcases = [('CTAC', 'CACG'), ('CCCAGCGTCGAAACCGCTGC', 'ACACGGATGCCTGTTATGAT'), ('CAACCACAAC', 'C'), ('AATGATGCTC', ''), ('TCTCTCATCAACAACGGGGTTGACCAAACGGGCAGTGTGGTGTTCAAAGCCGACTTATAGCCTACATGACTTAGCTTGCTATTACGTTGCATTTCCACGGAAACCCGAAAGCAGGGTCAGAGCCTCGCTGATCCACCCACTAACTATATCGCCCTTCCTCAGTCATGCTCCCGCGCAAAGAGGGGCTCTCAAGGTGTTCGTAGGTTGGCCGCCCTTGTGCTCTGAGGCCTAGTAAGAGGGTATCACGTTGCGCAGCAAGGCAAAGGGGCTACCGTGAACGCAGCTATGGGATGTGCAAAACGTGATGACTAGCGTCGCGTTAGTGCTTCCAGCATAAGTCCGAGCCAGGCCGCCTAGACATGGTTACTGTTGACTTGGTCCCCTTTTGTTAAGGTGCACAATCGACAACGGGTGGTCGGCCATCTCTTGCATAGGTCGGAGTTAAAGGACCGCGAACTGGCCCTCTACGTTTTTGTCACGCGGAGTGGCGCATTAAGATA', 'CCTACTTCTTAAGGCCGGTAGTGAAGTTCACAATATGTGTTTCTACCTATTACCCAAGGTGCGAGGGTTTTGATCGGGTGTGTTTTAGGCCTATTTAACTCCATCCGGCGAGTCACGTGGTCCGCTCATGTAGTGCTTACGGGGATCGGGTGGGGTAATAGTAGCGACGATTGTGCTTAGCCCGAGCGTGAAACTGCCAATATCGATGAACGATCTGAAATACACGTTGAATTGAAGCCGCTAGTGGTTCCATCGAATAGTCCTAGGGATGAATAGATATGGGGTTACAAAGAACCCACGGCTCAGGCTGGACATTAACAGCGAGTCGCTTCTACAGAGGGCGTTCATCAACGCGGGTTTAAGATATCCCATTGGGGTCGTGACGTGTCCTCGCCCAATGCGCGACTCGATCCATACGTAGACTATTACAACGGCGTGGAATCTTAAAATTCGAAGTATCGGGACCGGCGGACGCATGCGTAATTTGTCGCCTCGAGAGG'), ('GGTTCACTGGACACCTATCAAGGGAACTTGTTTCGGTGCTACATGATGTGCACTACTCCTATTACATTCGTTCTTCTTAAGAAACAACAGTGTTGCATGGCTATGACGGCCGTATAACTCCCCAGGTAGCTGAGGCATACAGGCTCGGAGGAGGGTCATGCATCATGTGTTGTCAAACCTGTCGTGTAGACAAGCTCCGGAGAGCGATGAGGTGGGGAAAGGCTAATGAAGGTTCTATTGTTTCTATATGGTGCGCCATAGATCTATGTTTTAGGGTCCGCACTACTCGCATATGCCCACTGGCAGAAATAGCAGGGCTTGCGGGCTAAATTCCCTGCACCGAAAACAGCCATCCCCCAGATCAGTGTCGATCGCACCTGCCAATTATTGACTTTCAGTGGCTAGATCAATCTTCGAAACCAAACATTTGCTACGACGGATCGGAGCTTGTTACTGCACGACAGACGGGGCACACTATGTCGGTTCCTTGCACCTCCGGAGTCAAGGCCTGGAAAATCGCAATTCGGACCGAGATAATATTCGATCGCCTACATAGAATTGAATCGTGATGACATCGTGGACCTTGACGCTACTACTTTA', 'TGGACGTGTGTAGCTTTATCGCCTTTCGACAAAAAAAACTCATTGGTCATGTACGTTCGACTCCTGGGTCACGCTTCATCTTGAGGTTCAAAATTAGTGTAGACCCTCTAGCAACTTCGCACATCTCTCCAGATCGGTTCCTATAAAATATGTGGCTTGGGATGAGGTGAAGCCGGGTGCCGGGTGCATGTGAATACGCTGATAATCCGGAGGGGCTATACCGGCGCAGCTACTCGCCAACGCACTCCTAGTCCCCTTGGGAGTTGAGGGCACCTGACGTGTGGTGACACAGTCGAGGTT')]
    for i, tc in enumerate(testcases):
        word1, word2 = tc
        print(f"Testcase {i + 1}의 가장 긴 공통 부분 문자열 : {dna_longgest_shared_pattern(word1, word2)}")
        print()

if __name__ == '__main__':
    main()

```
# 단계 6. 다이나믹 프로그래밍 연습

## 스토리

유전자 정보를 연구하는 G 연구원과 T 연구원은 학창 시절부터의 절친이었다. 어쩌다보니 같은 직장에서 근무하게 된 두 사람은 종종 식사나 술자리를 함께 하면서 여전히 좋은 관계를 유지하고 있었다. 어느 가을 저녁, 두 사람은 연구소 근처 맛집에서 저녁을 먹고 있었다. T 연구원은 연구소 밖에서 업무 이야기하는 것을 좋아하지는 않았지만, 요즘 잘 안풀리는 문제가 있다며 G 연구원에게 의견을 물어봤다.

“우리 연구 그룹에서 개발한 스마트 마우스 기억나지?”

“응. 기억 능력에 연산 능력이 있을지도 모른다고 발표했던 그 쥐 말하는거지?”

“응. 그런데 문제가 있어.”

“뭔데?”

“쥐의 지능을 검증하려고 하는데, 우리가 멍청한게 문제지.”

이렇게 시작한 사연은 다음과 같았다.

스마트 동물 연구 그룹에서 개발한 “영리한 쥐”가 연산 능력과 학습 능력이 있는지를 확인하기 위해 다음과 같은 실험을 설계했다.

방이 N개가 있는 미로를 설치한다. 각 방은 1번 방에서 N번 방까지 이름이 붙어 있고, 시작 지점은 방은 아니지만 편의상 0번 방이라고 부르고 있다. 0번 방은 N개의 통로가 있고, 1번 방에서 N번 방까지 연결되어 있다. 1번 방은 N-1개의 통로가 있고 2번 방에서 N번 방까지 연결되어 있다. 이런 식으로 K번 방은 K+1번 방부터 N번 방까지 연결된 통로를 가지고 있다. 각 통로는 길이가 정해져 있으며, 쥐들의 속도는 모두 일정하다. 그리고 N번 방에 도착하면 보상을 주는데, 빨리 도착할 수록 보상이 좋아진다.

“그래서 보상이 뭐야?”

“응. 8년 숙성된 냄새가 엄청난 치즈. 쥐가 그 냄새를 맡으면 미칠 듯이 좋아하더라구. 문제는, 이 치즈가 싸구려라서 시간이 지나면 지날 수록 냄새가 점점 사라진다는건데…”

“그래서?”

“이 치즈 냄새가 통로에 퍼지니까, 기를 쓰고 쥐들이 달리더라구.”

“그리고?”

“영리한 쥐가 매번 1등을 했지.”

“그러면 입증된거 아니야?”

“그런데, 영리한 쥐가 점점 학습을 해서 더 영리해지고 있는지를 확인해야 하니까. 그런데 문제는 영리한 쥐가 최선의 선택을 했는지 확인해보고 싶은데… 그게 계산이 잘 안되더라구.”

“음. 혹시, 실험할 때 방은 몇 개 설치한거야?”

“적당히 설치했어. 한 1000개 정도?”

G 연구원은 순간 할 말을 잃었다. 방이 1000개인 미로라면 방과 방 사이의 통로의 개수만 499500개이다. 적당히라는게 뭔지 모르는 녀석. 아니, 우리 연구소 실험 예산 괜찮은거야?

---

# 문제 1. 이상한 나라에서 동전으로 버스 타기

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

S 연구원은 논문 성과가 탁월한 연구원이다. 그러다 보니 논문 발표를 위해서 해외 출장도 잦은 편이다. 그런 그도 이런 신기한 동전을 발행하는 나라는 처음이었다.

'1 다음이 7, 그리고 그 다음이 15?'

알고보니 그 국가의 오래전 역사 시대에 초대 국왕 1명이 7명의 기사들과 15개의 주변 왕국을 정복한 역사를 기념하기 위한 주화 시스템이었던 것이다. 그리고 33원 동전이 있었는데, 이 동전이 왜 발행되고 있는지는 도무지 알 수가 없었다.

여하튼 S 연구원은 이 나라에서도 동전을 사용해 이곳저곳을 방문해야 한다.

## 수행목표

- 편의상 어떤 국가의 화폐 단위를 원이라고 부르기로 하자. S 연구원이 방문한 국가의 동전은 1원 동전, 7원 동전, 15원 동전, 33원 동전으로 구성되어 있다.
- 이 나라의 일반 버스 요금은 1117원, 고급 버스 요금은 2521원, 지하철 요금은 1923원이다. 네 종류의 동전을 제한없이 사용할 수 있을 때, 최소 개수의 동전으로 일반 버스, 고급 버스, 지하철을 탑승할 때 사용해야 할 동전 별 개수를 출력해보자.
- S 연구원이 귀국하기 전에 인플레이션으로 인한 영향으로 1원 동전이 사용금지되고, 대신 53원 동전이 새로 발행되었다. 세로운 네 종류의 동전이 있을 때 최소 개수의 동전으로 세 종류의 대중교통을 탑승할 때 사용해야 할 동전의 개수와 손해보는 금액이 얼마인지를 출력해보자.

## 수행단계

- `dp_exer/bus_fare_dynamic.py` 파일에 다음을 구현한다.
  - 어떤 구성의 동전으로도 정해진 요금을 최소 개수의 동전으로 이용하는데 필요한 각 동전 별 개수와 정확히 지정한 요금을 만들 수 없을 때 손해를 보아야 하는 금액이 얼마인지를 반환하는 함수를 구현한다.
  - 각 동전의 사용 개수에는 제한이 없다.
  - 사용 가능한 동전 조합으로 정해진 금액을 지불할 수 없는 경우 이 금액을 초과하는 최소 요금을 지불하며, 이 차액이 손해를 보아야 하는 금액이 된다.
  - 다이나믹 프로그래밍을 사용해서 구현한다.
- 사용 가능한 동전이 1원, 7원, 15원, 33원 네 종류일 때 1117원, 2521원, 1923원을 최소 개수의 동전으로 각각 지불할 때 필요한 각 동전의 개수를 출력한다.
- 사용 가능한 동전이 7원, 15원, 33원, 53원 네 종류일 때 1117원, 2521원, 1923원을 최소 개수의 동전으로 각각 지불할 때 필요한 각 동전의 개수와 손해를 보게 되는 경우 손해 금액을 출력한다.

## 결과 예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 호주머니에 사용 가능한 동전의 수가 제한되어 있는 상황에서 다이나믹 프로그래밍 방식으로 최소한의 동전으로 요금을 지불하는 방법을 알려주는 함수를 구현한다.
  - 만약 모든 동전을 사용해도 요금을 지불할 수 없는 경우는 모자란 금액을, 동전이 남은 상태에서 정확히 지정한 요금을 지불할 수 없는 경우는 최소한의 손해를 보고 요금을 지불할 때, 이 최소한의 손해가 얼마인지도 반환한다.
- 7원, 15원, 33원, 53원 동전이 각각 20개씩 있을 때, 1117원, 2521원, 1923원을 최소 개수의 동전으로 지불해야 하는 경우의 필요한 각 동전의 개수, 모자란 금액 또는 손해를 보는 금액이 얼마인지를 출력한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/bus_fare_dynamic.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방식을 적용해 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```

    ```

### [보너스 과제 확인]

- 보너스 과제를 지시한 대로 해결하였으며 그 결과는 정확한가?
  - 동전이 제한되어 있을 때 요금을 지불하는 방법과 모자란 요금 또는 손해보는 요금의 금액을 반환하는 함수를 다이나믹 프로그래밍 방식을 사용해 구현하였는지 확인한다.
  - 결과 예시는 다음과 같다.

```

```

### [문제에 대한 이해]

- 그리디 알고리즘으로 최소의 동전 개수를 사용하는 거스름돈을 계산 방법을 제공해주지 못하는 이유는 무엇인가? 이전 문제의 예제와 위에서 제시한 경우를 비교해서 답해보라.
  - 탐욕적인 선택이 최적해를 보장하지 못하는 경우이다.
  - 상위 동전이 하위 동전의 정수배로만 구성되어 있는 경우, 상위 동전이 하위 동전의 선택을 완전히 커버할 수 있는 반면, 그렇지 않은 경우 상위 동전을 선택했을 때 하위 동전의 선택보다 못한 경우가 발생하기 때문이다.
- 그리디 알고리즘에서 탐욕적 선택을 한 후의 상황은 마치 다이나믹 프로그래밍에서 어떤 문제의 일부를 해결한 상황과 유사하다. 이 시점에서 그리디 알고리즘과 다이나믹 프로그램의 차이는 무엇인가?
  - 다이나믹 프로그래밍의 경우 하위 문제가 상위 문제에 속해 있고, 가장 작은 문제가 최적의 문제라는 조건이 있다.
  - 그리디 알고리즘은 하위 문제가 상위 문제에 속하지 못하는 경우가 발생한다.
- 최소 동전을 사용해 거스름돈 거슬러 주는 다이나믹 프로그래밍 접근 전략을 제시하라.
  - 금액 별로 최소 개수를 저장하고, 가장 작은 경우 (0센트) 부터 시작해 목표 금액 까지 거슬러 주는 방법을 상향식으로 계산해 올라가면서, 작은 금액에 대해서 계산한 결과를 사용한다.
  - 점화식은 다음과 같다. 거슬러 주는 동전의 개수를 coin_count(n)이라고 하면 coin_count(n) = min(coin_coint(n), 1 + [n - coin]) for all coin이 된다.
- 사용 가능한 동전 종류의 배열이 정렬되어 있다고 가정하자. 동전의 개수가 m, 거슬러주는 목표 금액이 n인 경우, 그리디 알고리즘으로 구현한 경우의 시간 복잡도를 제시하라.
  - 금액과 무관하게 가장 큰 동전부터 나눗셈을 한 번씩 하면 된다. 시간 복잡도는 O(m)이다.
- 동전의 개수가 m, 거슬러주는 목표 금액이 n인 경우, 다이나믹 프로그래밍으로 접근한 경우의 시간 복잡도를 제시하라.
  - 금액 별(n)로 반복하면서 매 반복 시에 동전의 개수(m) 만큼 반복하므로, 시간 복잡도는 O(mn)이다.

### [코드 예시]

```python

```

---

# 문제 2. 판매 전략을 수립하라

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

연구소의 예산은 주로 국가에서 지원해주지만, 그것만으로 모든 연구 예산을 확보할 수가 없었다. 그래서 연구소에는 몇 가지 수익 사업을 병행하고 있었다. 그 중 하나가 다른 기관의 의뢰를 받아서 DNA 염기 서열을 해독해 주는 일이었다.
이 사업의 사업 책임자 P 책임 행정원은 지선생의 입사동기로 오래된 벗이었다. 그 친구가 어느날 지선생을 찾아와 물었다.
“이걸 어떻게 굴려야 돈일 더 벌 수 있을까?”

## 수행목표

- 지선생은 이 문제를 다음과 같이 정의했다.
  > - 연구소는 한 번에 주문에서 처리하는 DNA의 최소 개수를 1단위로 정해놓고 있으며, 이 최소 단위의 정수배에 해당하는 요청만 받고 있다. 그리고 염기서열 해독 시스템은 매월 연구 진행상황에 따라 사업에 사용할 수 있는 요청 건수, 그리고 요청의 개수에 따른 가격이 바뀐다.
  > - 이에 따라 특정 월의 사업에서 다음의 값이 고정되어 있다.
  >   - 사업을 통해 받아서 처리해 줄 수 전체 요청 건수(기준 : 단위)
  >   - 주문당 요청의 단위 별 가격 배열 (억원)
  > - 구하고자 하는 해답은 다음과 같다.
  >   - 가능한 최대 매출액과 최고의 매출을 기록할 수 있도록 판매하는 방법을 반환한다. 단 같은 최대 매출을 기록하는 판매 방법이 있는 경우, 처리하는 주문의 횟수가 최소인 방법을 출력하며, 처리하는 주문의 횟수가 동일한 경우, 아무거나 출력해도 무방하다.
- 다음 테스트케이스의 결과를 출력한다.
  - 각 테스트케이스는 (n, price)의 튜플로 구성되며, n은 처리 가능한 전체 요청 건수이며, price는 단위 별 가격의 배열이며, 이 때의 단위는 각 배열의 항목에 대응되는 인덱스 값에 1을 더한 값이다.
  - 예를 들어 price 배열이 [1, 5, 8, 9]인 경우, 1단위 주문의 가격은 1억원, 4단위 주문의 가격은 9억원이라는 의미가 된다.

```python
TC1 = (4, [1, 5, 8, 9])
TC2 = (8, [2, 5, 8, 9, 10, 17, 17, 20])
TC3 = (10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
TC4 = (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
TC5 = (100, [2, 5, 7, 8, 10, 14, 16, 17, 20, 24, 27, 29, 32, 33, 37, 38, 41, 43, 47, 49, 51, 54, 56, 60, 64, 68, 71, 75, 78, 80, 82, 84, 87, 91, 93, 94, 95, 99, 100, 104, 106, 107, 109, 111, 115, 118, 120, 124, 126, 130, 133, 136, 138, 140, 142, 145, 149, 153, 155, 158, 162, 163, 165, 166, 168, 172, 174, 175, 179, 182, 183, 186, 188, 189, 193, 196, 200, 203, 204, 207, 211, 214, 218, 220, 223, 227, 228, 230, 231, 232, 233, 236, 239, 240, 242, 244, 246, 248, 251, 253])
```

## 수행단계

- 문제의 구조를 분석한다. 다음 흐름을 따라가 보면 분석에 도움이 될 수도 있다.
  - 이 문제를 처리 가능한 단위수 n, 주문의 요청 단위가 n일 때의 가격을 price[n - 1], max_sales(n)은 처리 가능 단위수가 n일 때의 최대의 매출로 정의하고 다음 사항을 확인해보자.
  - n단위의 처리가 가능한 상태에서 1단위의 요청을 처리했을 때, 기대 가능한 최대 매출은 얼마인가? price 배열과 max_sales 함수로 표현해보자.
  - 2단위의 요청을 처리했을 때 기대 가능한 최대 매출은 얼마인가?
  - i단위의 요청을 처리했을 때 기대 가능한 최대 매출은 얼마인가?
  - 이렇게 구한 매출들을 어떤 방식으로 취합해야 n 단위가 있을 때의 최대 매출이 될까?
- 이 문제를 다이나믹 프로그래밍 방식을 사용해 해결하는 함수를 dp_exer/max_sales.py 파일에 구현한다.
  - 만약 하향식 다이나믹 프로그래밍으로 구현하는 경우 메모이제이션을 적용한다.
  - 최대 기대 매출 뿐 아니라 어떻게 주문을 받아야 하는지도 계산해 함께 반환한다.
- 테스트 케이스를 구현한 함수를 사용해 결과를 구하고 출력하는 테스트 코드를 main 함수에 구현한다.

## 결과예시

```
TC 1:
최대 매출 : 10억원
판매 방법 :
    2단위 주문 : 2회
(이하 생략)
```

## 참고사항

- 이전 문제의 테스트 데이터와 비교하면 첫 번째, 다섯 번째 테스트케이스의 데이터만 다르고 나머지는 같다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 지선생의 도움을 받아서 사업이 번창하자, 이번에는 실제 염기 서열 해독 작업을 진행하는 연구원들의 불만이 쇄도했다. 그들의 요구는 번잡한 1단위 주문은 더 이상 받지 말자는 것이었고, 어짜피 일손은 부족하고 사업은 번창하고 있는 상황이라 이를 수용하기로 했다. 이 경우 다음과 같은 고려 사항이 추가된다.
  - 가격 배열에 1단위 처리의 가격이 적혀 있더라도 이 값은 더 이상 사용하지 않는 값이 된다.
  - 1단위 이외에도 처리하지 않는 단위가 추가된다. 이 경우 해당 단위의 금액은 0으로 제시된다.
  - 최소 요청 건수에 제한이 발생하면서, 최대 매출을 기록하면서도 남는 처리 용량이 발생할 수 있다. 남는 처리 용량도 함께 반환한다.
- 다음 테스트 케이스에 대해서, 최대 기대 매출, 판매 방법, 잔여 처리 용량을 출력한다.

```
TC1 = (4, prices = [0, 5, 0, 9])
TC2 = (8, prices = [0, 0, 8, 0, 0, 0, 14, 0])
TC3 = (10, prices = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1])
TC4 = (10, prices = [0, 2, 3, 4, 5, 6, 7, 8, 9, 0])
TC5 = (100, prices = [0, 0, 7, 8, 10, 14, 16, 17, 20, 24, 27, 29, 32, 33, 37, 38, 41, 43, 47, 49, 51, 54, 56, 60, 64, 68, 71, 75, 78, 80, 0, 0, 0, 0, 0, 94, 95, 99, 100, 104, 106, 107, 109, 111, 115, 118, 120, 124, 126, 130, 133, 136, 138, 140, 142, 145, 149, 153, 155, 158, 162, 163, 165, 166, 168, 172, 174, 175, 179, 182, 183, 186, 188, 189, 193, 196, 200, 203, 204, 207, 211, 214, 218, 220, 223, 227, 228, 230, 231, 232, 233, 236, 239, 240, 242, 244, 246, 248, 251, 253])
```

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/max_sales.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방식으로 구현하였는지 확인한다. 만약 하향식 다이나믹 프로그래밍 방법으로 구현한 경우 메모이제이션이 적용되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다.

    ```
    TC 1:
    최대 매출 : 10억원
    판매 방법 :
        2단위 주문 : 2회

    TC 2:
    최대 매출 : 22억원
    판매 방법 :
        6단위 주문 : 1회
        2단위 주문 : 1회

    TC 3:
    최대 매출 : 10억원
    판매 방법 :
        1단위 주문 : 10회

    TC 4:
    최대 매출 : 10억원
    판매 방법 :
        10단위 주문 : 1회

    TC 5:
    최대 매출 : 267억원
    판매 방법 :
        35단위 주문 : 1회
        34단위 주문 : 1회
        29단위 주문 : 1회
        2단위 주문 : 1회
    ```

### [보너스 과제의 확인]

- 보너스 과제를 지시대로 해결하였는가?
  - 문제의 구조를 사용하는 재귀 호출 방식으로 구현하고 있는지 확인한다.
- 결과가 정확한가?

  - 결과 예시는 다음과 같다.

    ```
    TC 1:
        최대 매출 : 10억원
        판매 방법 :
            2단위 주문 : 2회
        잔여 처리 용량 : 0단위

    TC 2:
        최대 매출 : 16억원
        판매 방법 :
            3단위 주문 : 2회
        잔여 처리 용량 : 2단위

    TC 3:
        최대 매출 : 5억원
        판매 방법 :
            2단위 주문 : 5회
        잔여 처리 용량 : 0단위

    TC 4:
        최대 매출 : 10억원
        판매 방법 :
            8단위 주문 : 1회
            2단위 주문 : 1회
        잔여 처리 용량 : 0단위

    TC 5:
        최대 매출 : 266억원
        판매 방법 :
            29단위 주문 : 3회
            13단위 주문 : 1회
        잔여 처리 용량 : 0단위
    ```

### [문제에 대한 이해]

- n = 4, prices = [1, 5, 8, 9]일 때 최대 매출은 얼마이며, 이 때의 판매 방법은 어떻게 될까?
  - 최고의 매출을 기록하기 위해서는 2단위씩 2번 주문을 받으면 된다. 이 때의 매출은 10억원이다.
- i단위의 요청을 처리했을 때 기대 가능한 최대 매출은 얼마인가? 처리 가능한 용량이 n일 때의 기대 가능한 최대 매출을 max_sales(n)이라 표현하고, i 단위의 가격을 price(i)라고 할 때, 최대 매출을 max_sales와 price를 사용해서 표현하라.
  - i단위의 요청을 처리했을 때의 기대 가능한 최대 매출 : price[i] + max_sales(n - i)
- 문제의 구조를 제시하라.
- 구현한 방식의 시간 복잡도는 얼마인가?

### [코드 예시]

```python

```

---

# 문제 3. 화석 보호 무역 시대

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

목에 건 직원증에 ‘E’이라는 이름이 적혀 있는 연구원이 어이없는 표정으로 멍하니 앉아 있었다. 그가 뒷목을 잡게 된 사연은 다음과 같다.

> - 넓은 사막을 가진 Z국은 전 세계에서 가장 많은 화석을 발견할 수 있는 나라이다. 그런데, 최근 Z국이 어느 나라의 연구자가 발굴하건 간에, 화석의 가치를 종류별로 정하고 각 국가별로 반출할 수 있는 화석의 전체 가치의 크기를 정했다. 만약 정확히 그 가치를 맞추지 못하고 그 값을 넘거나, 모자라는 경우 화석을 반출 할 수 없었다. 다행인 것은 종류별로 개수의 제한은 없다는 점이었다. 즉 가치가 작은 화석은 많은 수를 반출할 수 있으며, 수는 작더라도 가치가 높은 화석을 위주로 반출하는 선택도 가능한 상황이었다.
> - 주로 화석을 연구하는 진화생물학 연구 그룹에서는 반입 가능한 모든 ‘경우의 수’를 살펴보기로 했다. 그래서 E 연구원에게 내려진 특명은 반입 가능한 모든 ‘경우의 수’를 구해오라는 것이었다. 하지만, 일일이 목록의 수를 세어보는것은, 너무나 힘든 일이었다.

진화계통도와 관련된 프로그램을 몇 개 작성한 것이 사람들의 기대감을 지나치게 높여버렸다. E 연구원은 문제를 분석하다가 다시 프로그래밍 지원 게시판의 문을 두드렸다.

## 수행목표

- 반입이 허용된 화석 가치의 총 합과 화석 별 가치가 포함된 배열이 주어진다. 이 상황에서 정확하게 반입 허용 화석 가치를 구성할 수 있는 모든 반입 목록을 작성할 때, 이 반입 목록의 개수를 반환하는 함수를 구현한다.
- 다음 6개의 테스트케이스에 포함된 각각의 테스트케이스는 반입 목표 가치와 화석별 가치의 배열로 구성된 튜플이다.
  - 첫 번째 테스트케이스는 각 화석의 가치가 34, 47, 55일 때, 이 화석들을 조합해 가치 501을 만들 수 있는 목록의 개수를 반환해야 하며, 501을 만들 수 없으므로 반환하는 값은 0이 된다.
  - 두 번째 테스트케이스는 각 화석의 가치가 2, 2일 때 이 화석들을 조합해 가치 8을 만들 수 있는 목록의 개수를 반환해야 한다. 주의할 점은, 두 화석의 가치가 같더라도, 서로 다른 화석이라는 점을 고려해 목록을 만들어야 한다는 것이다. 이 경우, (첫 번째 화석의 개수, 두 번째 화석의 개수) 기준으로 (4, 0), (3, 1), (2, 2), (1, 3), (0, 4) 5개의 목록을 만들 수 있고, 5를 반환한다.
- 다음 테스트케이스의 각각에 대한 결과를 출력한다.

```python
TC1 = (501, [34, 47, 55])
TC2 = (8, [2, 2])
TC3 = (99, [3, 4, 5, 6])
TC4 = (590, [2, 6, 9, 3, 10])
TC5 = (500, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
TC6 = (1000, [1, 2, 3, 4, 5])
```

## 수행단계

- 문제의 구조를 분석하고, 이 문제를 상향식 접근법과 하향식 접근법 각각을 사용해서 해결하는 경우의 해결 방법을 정리한다.
- 반입이 허용된 화석 가치의 총 합과 화석 별 가치가 포함된 배열이 주어진다. 이 상황에서 정확하게 반입 허용 화석 가치를 구성할 수 있는 모든 반입 목록을 작성할 때, 이 반입 목록의 개수를 반환하는 함수를 dp_exer/fossil1.py 파일에 구현한다.
  - 상향식 접근법과 하향식 접근법 각각을 사용하는 두 개의 별도의 함수를 모두 구현한다.
  - 하향식 접근법으로 구현하는 경우 메모이제이션을 적용한다.
- 주어진 테스트케이스에 대해서 결과를 구한 후, 이를 출력한다.
  - 상향식, 하향식 각 접근법으로 답을 구하는데 걸린 시간을 각각 측정해 출력한다.
- 상향식, 하향식 두 접근법의 차이를 구현 방식과 함수의 성능 양 측면에서 비교해보자.

## 결과예시

```
하향식 다이나믹 프로그래밍
    수행 시간: 0.00033283233642578125 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 1.0967254638671875e-05 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
    수행 시간: 0.0011639595031738281 초
(중간 생략)
상향식 다이나믹 프로그래밍
    수행 시간: 9.226799011230469e-05 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 2.1457672119140625e-06 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
(이하 생략)
```

## 참고사항

- 이 문제의 테스트케이스 중 처음 10개는 이전 문제의 테스트케이스와 동일하며, 뒤의 2개가 추가되었다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/fossil1.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍, 메모이제이션을 적용한 하향식 다이나믹 프로그래밍 방법을 사용한 각각의 함수가 구현되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 상향식, 하향식 두 접근 방법의 결과는 동일해야 한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 실행 시간은 다를 수 있다.

```
하향식 다이나믹 프로그래밍
    수행 시간: 0.00033283233642578125 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 1.0967254638671875e-05 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
    수행 시간: 0.0011639595031738281 초
    TC 3에서 생성할 수 있는 반입 목록의 경우의 수 : 585
    수행 시간: 0.041081905364990234 초
    TC 4에서 생성할 수 있는 반입 목록의 경우의 수 : 1722389
    수행 시간: 0.0815131664276123 초
    TC 5에서 생성할 수 있는 반입 목록의 경우의 수 : 2391508958235
    수행 시간: 0.1903541088104248 초
    TC 6에서 생성할 수 있는 반입 목록의 경우의 수 : 357746987
상향식 다이나믹 프로그래밍
    수행 시간: 9.226799011230469e-05 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 2.1457672119140625e-06 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
    수행 시간: 2.7894973754882812e-05 초
    TC 3에서 생성할 수 있는 반입 목록의 경우의 수 : 585
    수행 시간: 0.000186920166015625 초
    TC 4에서 생성할 수 있는 반입 목록의 경우의 수 : 1722389
    수행 시간: 0.00030112266540527344 초
    TC 5에서 생성할 수 있는 반입 목록의 경우의 수 : 2391508958235
    수행 시간: 0.0003070831298828125 초
    TC 6에서 생성할 수 있는 반입 목록의 경우의 수 : 357746987
```

### [문제에 대한 이해]

- 문제의 구조를 설명하라.
- 상향식 접근법, 하향식 접근법 각각의 해결 전략을 제시하라.
- 두 접근법의 차이를 분석하라. 만약 두 함수의 실행 시간 기준의 성능 차이가 존재한다면, 분석을 통해 이 차이를 설명할 수 있어야 한다.

### [코드 예시]

```python

```

---

# 문제 4. 경우의 수는 수가 아니다.

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

“그 경우의 수가 그 경우의 수가 아니다!”

진화생물학 연구그룹의 그룹장이 E 연구원에게 핀잔을 줬다. 우리는 ‘경우의 수'라는 말을 쓸 때, ‘경우의 개수'로 쓰기도 하지만 ‘모든 경우의 목록'에도 경우의 수라는 표현을 쓰곤 한다. 물론 E 연구원도 ‘경우의 수’가 그 ‘경우의 수’일지도 모른다는 생각은 했지만, 계산 결과 나온 어마어마한 크기의 ‘경우의 수’를 보고, 전체 가능한 목록을 가지고 오라는 이야기는 아니겠지 생각했던 것이다. 그래서, E 연구원은 그룹장에게 되물었다.

“2조개가 넘는 목록을 다 보시겠다구요?”

그룹장의 말.

“내가 알아서 할 테니까…”

## 수행목표

- 이전 문제에서 해결한 방법 중 상향식 접근법을 사용해서 문제를 해결하면서 동시에 목록의 개수 뿐 아니라 모든 목록을 출력하는 프로그램을 작성한다.
- 다음 데이터를 사용해 각 테스트케이스의 목록의 개수 및 모든 목록을 구하고, 이를 출력한다.

```python
TC1 = (501, [34, 47, 55])
TC2 = (5, [1, 2, 3])
TC3 = (25, [3, 4, 5, 6])
```

## 수행단계

- 이전 문제에서 구현한 두 가지 방식 중 상향식 다이나믹 프로그래밍 접근 방법을 사용할 때, 목록의 개수 뿐 아니라 모든 목록을 작성하도록 수정하는 방법을 정리한다.
- 상향식 접근 방법을 사용해서 주어진 데이터로 생성 가능한 전체 목록의 수와 모든 목록을 반환하는 함수를 dp_exer/fossil2.py 파일에 구현한다.
- 주어진 3개의 테스트케이스에 대해서 각각의 결과를 출력한다.

## 결과 예시

```
TC2에서 생성할 수 있는 반입 목록의 수 : 5
TC2에서 생성할 수 있는 반입 목록 : [[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], [1, 1, 3], [2, 3]]
(TC1, TC3 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/shortest_path4.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 접근 방법으로 최단 거리와 최단 경로를 구하는 함수를 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

```
    TC1에서 생성할 수 있는 반입 목록의 수 : 0
    TC1에서 생성할 수 있는 반입 목록 : []

    TC2에서 생성할 수 있는 반입 목록의 수 : 5
    TC2에서 생성할 수 있는 반입 목록 : [[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], [1, 1, 3], [2, 3]]

    TC3에서 생성할 수 있는 반입 목록의 수 : 17
    TC3에서 생성할 수 있는 반입 목록 : [[3, 3, 3, 3, 3, 3, 3, 4], [3, 3, 3, 4, 4, 4, 4], [3, 3, 3, 3, 4, 4, 5], [4, 4, 4, 4, 4, 5], [3, 3, 3, 3, 3, 5, 5], [3, 4, 4, 4, 5, 5], [3, 3, 4, 5, 5, 5], [5, 5, 5, 5, 5], [3, 3, 3, 3, 3, 4, 6], [3, 4, 4, 4, 4, 6], [3, 3, 4, 4, 5, 6], [3, 3, 3, 5, 5, 6], [4, 5, 5, 5, 6], [3, 3, 3, 4, 6, 6], [4, 4, 5, 6, 6], [3, 5, 5, 6, 6], [3, 4, 6, 6, 6]]
```

### [문제에 대한 이해]

- 모든 목록을 반환하기 위해서 이 목록들을 저장하는 변수의 자료형은 무엇이며 어떻게 정의하고 초기화 하였는가?
  - 리스트를 사용한다.
  - 생성하는 크기는 (target_value + 1)의 크기로 생성한다.
  - 초기화 값은 cases[0]은 아무것도 반입하지 않는 경우의 빈 리스트가 존재하므로 `[[]]`로 초기화한다.
  - 나머지 경우는 계산 전이므로 `[]`로 초기화한다.
- 모든 목록을 반환하기 위해 구현한 알고리즘의 동작 방식을 설명하라.
  - 경우의 수를 구할 때는 num_case에 하위 문제의 경우의 수를 더했던 부분에서
  - 대신 현재 선택 가능한 모든 경우에 대해서,
  - 현재 화석의 가치를 추가한 새로운 경우를 생성하고,
  - 이를 목록 배열에 추가해 모두 취합한다.

### [코드 예시]

```python

```

---

# 문제 5. 미생물의 단순한 DNA (1)

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

E 연구원은 그룹장의 명령만 수행하는 수동적인 연구원은 아니고, 본인의 고유한 연구 주제를 가지고 있었다. 그는 진화생물학을 전공했지만, 오늘날 여러 이론의 발전으로 각 분야의 연구가 서로에게 도움이 되다 보니, 진화생물학에 DNA 구조 분석을 접목하는 접근 방법을 찾고 있었다.

E 연구원은 본인이 발견한, 아니 발견했다고 주장하는 이론이 있다. 그런데, 그 이론을 검증하려면 복잡한 계산이 필요한데, 다이나믹 프로그래밍의 개념을 접하자, 그 문제도 다이나믹 프로그래밍으로 풀 수 있다는 사실을 알게 되었다. 그의 이론은 다음과 같다.

> - 특별한 종의 미생물들은 유전자 염기서열은 몇 개의 패턴으로만 중첩 없이 구성되며, 이 특징으로 특정 진화의 갈래를 확인할 수 있다는 것이었다. 예를 들어서 CTAGC와 TAGGCT 두 개의 염기서열 패턴만으로 구성되는 예제는 다음과 같다.
>   - CTAGC, TAGGCT (패턴 그 자체)
>   - CTAGCT-TAGGCT, TAGGCT-CTAGC, CTAGC-CTAGC-TAGGCT-CTAGC (패턴들의 조합)
> - 다음은 여기에 해당되지 않는 예제이다.
>   - C-TAGGCT-AGCA-TAGGCT (해당 패턴이 포함되어는 있지만, 해당 패턴 만으로 구성되지 않음)
>   - TAGG-CT-AGC (TAGGCT, CTAGC가 포함되어 있지만, 중첩되어 있다.)

이 이론을 검증하기 위해서 실제 어떤 유전자가 특정 패턴으로만 구성되어 있는지 확인해야 하는데, 이 문제가 어려운 이유는 간단한 미생물 정도만 해도 몇 백만에서 천만 정도의 길이에 달할 정도로 유전자 염기서열이 길다는 것이었다. 이 중 1% 정도만 샘플링해서 조사한다 해도 1만 정도의 길이가 된다. 연구원 L은 유전자 염기 서열에서 1만 이하의 길이를 가지는 부분을 샘플링해서 테스트 작업을 시작하고 있는 중이었다.

## 수행목표

- E 연구원이 풀어야 하는 문제는 다음과 같다.
  - 패턴은 C, T, A, G 네 글자가 조합된 문자열로 주어진다.
  - 주어진 문자열이 지정된 패턴 만으로 중첩없이 구성되어 있는지를 검사하고, 결과에 따라 True 또는 False를 반환한다.
- E 연구원이 풀어야 하는 문제를 해결해주는 함수를 구현한다.
- 다음은 검사할 패턴(patterns 리스트)과 테스트 대상 DNA 염기 서열(문자열)들이 기재되어 있다. 11개의 DNA 염기 서열에 대해서 해당 염기 서열이 검사할 패턴 만으로 중첩 없이 구성되어 있는지 검사한 결과를 출력한다.
  ```python
  patterns = ['CTAG', 'GCC', 'CTA']
  test1 = "CTAG"
  test2 = "GCCCTACTAG"
  test3 = "CCCCCCCCCC"
  test4 = "GTTTCAGGGA"
  test5 = "CTAGCTAGCC"
  test6 = "CTACTAGCTAGCC"
  test7 = "ACCAGAGTCTCTCCTCTTAC"
  test8 = "GCCCTACTAGCCCTAGCTAGCCCTAGGCCCTAGCCCTAGCCGCCGCCCTACTAGCCCTACTA"
  test9 = "GCCCTAGCTAGCTAGCCGCCGCCCTACTACTAGCCGCCGCCTAGCCGCCCTACTACTAGGCCCTAG"
  test10 = "CTAGCTACTACTAGCTAGCTAGCTAGCTAGCTACTAGCTACTAGCTAGCCCTAGCTACTAGCTAGCTAGCTAGCTAGGCCGCCCTAGCTAGGCCGCCCTAGCTAGCTAGGCCGCCCTAGCTAGGCCGCCCTAGCTAGCTAGCTACTAGCTACTAGCTAGCCGCCCTAGCCCTACTAG"
  test11 = "GCCCTAGCTACTAGCTAGCTAGCCGCCCTACTAGGCCGCCCTACTACTAGGCCGCCGCCCTAGCTAGGCCGCCCTACTAGCTACTAGCTAGCTACTAGCTACTAGCTACTAGGCCGCCCTACTAGGCCCTACTAGGCCCTAGCCGCCCTAGCTAGGCCGCCCTACTAGGCCCTACTACTAGGCCCTAGCTACTAGCTAGGCCCTAGGCCGCCCTAGGCCCTACTACTACTAGCCGCCGCCCTACTAGGCCCTACTACTAGCCCTAGGCCCTAGCTAGCTACTAGCCGCCCTAGCTAGGCCGCCGCCGCCCTAGGCCGCCCTAGCCGCCCTACTACTACTACTAGCTACTACTAGCTAGCTACTAGCTACTAGGCCGCCGCCGCCCTACTAGGCCCTACTAGCTACTAGCCCTACTACTACTACTAGCCGCCGCCCTAGCTAGCCGCCCTAGGCCCTACTACTACTAGCCGCCCTAGGCCCTACTAGCCCTAGGCCCTAGCCCTAGCTAGCCCTAGCTAGCTAGCCGCCCTACTACTAGCTACTAGCTAGCTAGCTAGGCCCTAGCTAGGCCGCCGCCCTAGGCCCTACTAGCTAGCCGCCCTACTAGGCCGCCCTAGCTAGCCCTAGCCCTAGCCGCCCTAGCTAGCTACTAGCCCTACTAGCTAGCTAGCCCTACTAGCTACTAGCTAGCCCTACTACTAGCCCTACTAGCTACTACTAGCCCTAGGCCCTAGGCCCTAGCTACTACTAGGCCGCCGCCCTACTAGCCGCCGCCCTAGGCCCTACTACTAGGCCGCCGCCCTAGCTAGCCCTAGGCCCTAGCTAGGCCCTAGCCCTACTAGGCCCTAGCTAGCTAGCTAGGCCGCCCTAGCTAGCTAGCCGCCGCCGCCCTAGCCCTAGGCCCTAGCTAGCCGCCGCCCTAGCCCTAGCCGCCCTACTAGCTAGCTACTACTAGCTAGCTACTAGCTACTAGCTAGCCCTAGCCCTAGGCCGCCGCCGCCCTAGCCCTACTACTACTAGCCCTAGGCCCTACTAGCTAGGCCGCCCTAGCCCTAGCTAGCTAGCTAGCTACTACTAGGCCCTAGCTAGCCCTAGGCCGCCCTACTAGCTAGCTACTAGCTAGCTAGCTAGCCGCCCTAGGCCGCCCTAGCCCTAGGCCGCCGCCCTACTACTAGCCCTACTACTAGCTACTAGCTAGCTACTAGCTAGCTAGGCCCTACTAGCTACTAGCCCTAGCTAGCTAGCCCTAGCTAGGCCCTAGCCCTACTAGCCGCCCTAGCCGCCCTACTAGGCCGCCCTAGCTACTAGCTAGCTACTACTAGCCCTAGCCGCCGCCGCCCTACTAGCTAGGCCGCCGCCGCCCTAGCTAGCCCTACTAGCTAGCTAGCTAGCTAGCTAGGCCGCCCTAGCTAGCCCTACTAGCTACTAGGCCCTAGCTACTAGCCCTAGGCCCTACTACTAGCTACTAGCTAGCCCTACTAGCTAGCTAGCCCTAGCTACTAGGCCCTACTAGCTAGCTAGCCCTACTAGCTAGCTACTAGCCCTAGCTAGCTACTAGCCCTAGGCCGCCGCCCTAGCCCTAGCTACTAGCTAGCTAGCTACTAGCTAGCTAGCTAGCCCTACTACTACTAGCCGCCCTAGCTACTACTACTAGCCCTAGCTAGCTAGCCCTACTACTACTAGCTAGCCCTACTAGCTAGCCGCCCTAGCTAGCTAGCTACTAGCCCTACTAGCCCTACTACTAGCTACTAGGCCCTAGGCCGCCCTAGCCCTAGGCCCTACTAGCTACTACTAGCTAGCTAGGCCGCCCTACTACTACTACTAGCTACTACTAGCTAGCTAGCCGCCCTAGCTAGGCCGCCGCCCTAGCTAGCTAGCTAGCTAGCTAGCTACTAGCTAGCTACTAGCTACTAGCCCTAGCTAGCTAGCTAGCTACTAGCTACTAGCTACTAGCCCTAGCCCTAGGCCGCCGCCGCCCTAGCTAGGCCCTAGCTAGCCGCCCTACTAGGCCCTAGCTAGCTACTAGGCCGCCGCCCTACTAGCTAGGCCGCCCTACTAGGCCCTAGCCCTACTAGCTACTAGCCGCCCTACTAGGCCCTAGCTAGCTACTAGCTACTACTAGCCGCCCTAGCCCTAGCTACTAGCTAGCCCTACTACTAGCTAGCTACTAGCTACTAGCCCTACTACTAGCCCTAGCTACTAGGCCCTAGCCGCCCTAGCCCTACTAGGCCGCCCTACTACTAGCCGCCCTACTAGGCCCTAGCTAGCTACTAGCTAGCCCTACTACTAGCTACTAGGCCCTAGCTACTAGCCCTAGCTACTAGCTAGCTAGGCCCTAGCTAGCTAGCTAGCTACTAGCTACTAGCTAGCTAGGCCCTACTAGCTACTAGGCCCTAGCTAGCCGCCCTAGCTAGCTAGCCCTAGCTAGGCCGCCGCCGCCCTACTAGCTACTACTAGCTAGCCGCCCTACTAGCCCTAGCTACTACTAGCTAGGCCGCCCTAGGCCCTACTAGCCCTAGCCCTACTAGCTAGGCCGCCCTAGGCCCTACTACTAGGCCGCCGCCCTACTAGCTAGCTAGCTAGCTAGCCCTACTAGGCCCTAGCCCTAGGCCCTACTACTAGCTAGCTACTACTAGGCCCTAGGCCCTACTAGCTAGCTACTAGCTAGGCCCTAGCTAGCTAGGCCCTAGCTACTAGCCGCCCTAGCTAGCTAGCCCTACTAGGCCCTAGGCCGCCCTACTAGCTAGCCGCCGCCCTAGGCCGCCCTAGCTACTAGCTAGCCGCCCTAGCTAGCTAGCCCTACTAGGCCCTAGCTAGCTAGCTAGGCCCTACTACTACTAGCCCTAGCTAGGCCCTACTAGCTACTAGCTACTAGGCCCTAGCCCTAGGCCGCCCTAGCTACTACTACTAGCCCTAGCTAGGCCCTAGCTAGCTAGCTACTACTAGCCGCCCTACTAGCCCGATTAGCTACTAGGCCGCCCTACTAGCTAGCTAGCTACTAGCTAG"
  ```

## 수행단계

- 문제의 구조를 분석하고, 문제를 해결하기 위한 하향식 접근법과 상향식 접근법을 각각 정리한다.
- dp_exer/simple_dna.py 파일에 주어진 문자열이 패턴 만으로 중첩없이 구성되어 있는지를 검사해 그 결과를 반환하는 함수를 구현한다.
  - 하향식 접근법과 상향식 접근법 각각의 함수를 구현한다.
- 주어진 테스트케이스 11개에 대해서 함께 제공된 패턴만으로 중첩없이 구성되어 있는지를 두 함수 각각에 대해서 검사하고, 그 결과를 출력한다.
- 상향식, 하향식 두 접근 전략을 비교 분석한다.
  - 이 문제의 경우 하향식 접근법을 사용할 때 메모이제이션을 사용해도 큰 도움이 되지 않는다. 그 이유가 무엇인지 정리한다.

## 결과예시

```
수행 시간: 1.9073486328125e-06 초
TC 1 하향식 접근법 : True
수행 시간: 5.7220458984375e-06 초
TC 1 상향식 접근법 : True
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/simple_dna.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식, 하향식 각각의 접근 방법을 사용한 두 개의 함수가 구현되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

```
수행 시간: 1.9073486328125e-06 초
TC1 하향식 접근법 : True
수행 시간: 5.7220458984375e-06 초
TC1 상향식 접근법 : True

수행 시간: 2.86102294921875e-06 초
TC2 하향식 접근법 : True
수행 시간: 9.059906005859375e-06 초
TC2 상향식 접근법 : True

수행 시간: 9.5367431640625e-07 초
TC3 하향식 접근법 : False
수행 시간: 5.9604644775390625e-06 초
TC3 상향식 접근법 : False

수행 시간: 9.5367431640625e-07 초
TC4 하향식 접근법 : False
수행 시간: 5.9604644775390625e-06 초
TC4 상향식 접근법 : False

수행 시간: 4.0531158447265625e-06 초
TC5 하향식 접근법 : True
수행 시간: 7.867813110351562e-06 초
TC5 상향식 접근법 : True

수행 시간: 4.0531158447265625e-06 초
TC6 하향식 접근법 : True
수행 시간: 1.0967254638671875e-05 초
TC6 상향식 접근법 : True

수행 시간: 1.1920928955078125e-06 초
TC7 하향식 접근법 : False
수행 시간: 1.3113021850585938e-05 초
TC7 상향식 접근법 : False

수행 시간: 1.9073486328125e-05 초
TC8 하향식 접근법 : True
수행 시간: 0.00020813941955566406 초
TC8 상향식 접근법 : True

수행 시간: 1.5974044799804688e-05 초
TC9 하향식 접근법 : False
수행 시간: 0.00020194053649902344 초
TC9 상향식 접근법 : False

수행 시간: 0.00013375282287597656 초
TC10 하향식 접근법 : True
수행 시간: 0.0015680789947509766 초
TC10 상향식 접근법 : True

수행 시간: 0.001992940902709961 초
TC11 하향식 접근법 : False
수행 시간: 0.3107450008392334 초
TC11 상향식 접근법 : False
```

### [문제에 대한 이해]

- 하향식 다이나믹 프로그래밍 전략을 사용하기 위한 문제의 구조와 해결 전략을 제시하라.
- 상향식 다이나믹 프로그래밍 전략을 사용하기 위한 문제의 구조와 해결 전략을 제시하라.
- 하향식 접근법과 상향식 접근법을 비교 분석해보라. 성능 차이가 발생하였다면, 그 이유도 함께 제시하라.

### [코드 예시]

```python

```

---

# 문제 6. 미생물의 단순한 DNA (2)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

E 연구원은 실험을 통해 이론을 검증한 후, 이 내용을 정리해 해외 유명 진화생물학 저널에 논문을 투고했다. 논문이 실린 저널이 출판된지 한 달쯤 지나서 E 연구원에게 메일이 하나 도착했다. 이 분야에서 연구를 하는 사람이면 누구나 알고 있는 해외 유명 연구자의 메일이었다.

> - 좋은 논문 발표해 주셔서 감사합니다. 정말 좋은 성과라고 생각합니다.
> - 그런데 논문을 꼼꼼히 읽어보던 중에, 재미있는 것을 발견했습니다. 마침 제가 하던 연구와 결합이 가능할 것 같은데, 혹시 시퀀스 몇 개에 대해 패턴으로 쪼갠 결과를 보내주실 수 있으신지요? 그리고 하나의 시퀀스가 주어진 패턴에 대해서 쪼갠 결과가 둘 이상이면, 모두 다 보내주실 수 있으시면 큰 도움이 될 것 같습니다.
> - 제 사견입니다만, 10년 안에 저와 L님이 공동으로 노벨 생리의학상 후보가 될 수 있지 않을까라는 기대도 하게 됩니다. 부디 꼭 부탁드립니다.

## 수행목표

- 패턴과 문자열이 주어졌을 때, 문자열이 패턴 만으로 중첩없이 검사하는 것으로 그치지말고, 패턴을 사용해 문자열을 구성한 방식을 반환하도록 수정된 함수를 구현한다.
  - 예를 들어 패턴이 [‘CT’, ‘TA’, ‘AG’, ‘CTT’, ‘AAG’]로 주어지고, 검사해야 할 문자열이 'CTTAAG'인 경우, 이 문자열은 CTT-AAG로 패턴을 사용해 나눌 수 있다. 그런데 'CTTAAG'는 CT-TA-AG로 패턴을 사용해서 나눌 수 있는 다른 방법이 존재한다. 함수의 반환 결과는 이를 모두 포함한 ['CTT-AAG', 'CT-TA-AG']를 반환해야 한다.
  - 만약 패턴만으로 중첩 없이 입력 문자열을 나눌 수 없는 경우 빈 리스트[]를 반환한다.
- 다음 테스트케이스 3개에 대해서 실행 결과를 출력한다.
  ```python
  patterns = ['CT', 'TA', 'AG', 'CTT', 'AAG']
  test1 = "CTTAAG"
  test2 = "GCCCTACTAGCCCTAGCTAGCCCTAGGCCCTAGCCCTAGCCGCCGCCCTACTAGCCCTACTA"
  test3 = "AGCTCTTAAAGAAGTATAAGCTTCTCTTCTCTTCTTAAGTAAGCTCTTACTCTTAAGCTAGAGAGAGAG"
  ```

## 수행단계

- 하향식 접근법을 사용해 패턴만으로 중첩없이 문자열이 구성되어 있는지를 검사하는 함수를 이전 문제에서 구현한 바 있다. 하향식 접근법으로 구성 가능 여부를 반환하는 대신 패턴으로 구성하는 방법의 목록을 반환하는 함수를 dp_exer/simple_dna2.py 파일에 구현한다.
- 주어진 테스트케이스 각각에 대해서 입력 문자열을 패턴으로 나눈 결과를 출력한다.

## 결과예시

```
TC1을 자른 결과 : ['CT-TA-AG', 'CTT-AAG']

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/simple_dna2.py 파일에 구현이 되어 있는지 확인한다.
  - 하향식 접근방법을 메모이제이션과 함께 사용하여 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과의 예시이다. 결과는 항상 다르게 나오지만, 수행 시간은 거의 지연없이 결과를 확인할 수 있어야 한다.

```
TC1을 자른 결과 : ['CT-TA-AG', 'CTT-AAG']

TC2을 자른 결과 : []

TC3을-자른-결과-:-['AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CT-TA-AG-TA-AG-CT-CT-TA-CT-CT-TA-AG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CT-TA-AG-TA-AG-CT-CT-TA-CT-CTT-AAG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CTT-AAG-TA-AG-CT-CT-TA-CT-CT-TA-AG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CTT-AAG-TA-AG-CT-CT-TA-CT-CTT-AAG-CT-AG-AG-AG-AG-AG']
```

### [문제에 대한 이해]

- 패턴을 자른 결과를 취합하기 위해서 재귀 함수는 어떤 전략을 사용하는가?
  - 파라미터에 뮤터블 객체를 전달해 자른 결과를 취합하는 방식과 반환값을 리스트로 받아서 모든 리스트를확장해 나가는 방식의 구현에 따라 답이 달라진다. 아래 예시 답변은 후자의 경우이다.
  - 문자열의 가장 앞 부분이 주어진 패턴과 매칭 되는 경우, 나머지 부분을 재귀 호출한다.
  - 재귀 호출의 결과가 비어 있지 않은 리스트인 경우 리스트의 모든 결과의 앞에 매칭된 패턴을 추가한다.
  - 재귀 호출의 결과가 리스트인 경우 그대로 빈 리스트를 반환한다.
  - 문자열의 가장 앞 부분이 주어진 패턴과 매칭이 되지 않는 경우 빈 리스트를 반환한다.

### [코드 예시]

```python

```

---

# 문제 7. 비싼 블록 놀이 (1)

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

바이러스 연구를 위해 신규 도입된 특수한 바이러스 배양 장치는 배양하는 조건을 다양하게 설정해 다양한 목적으로 활용할 수 있는 최첨단 장비이다. 생태 환경을 통제해 바이러스의 세대별 주기가 배양 조건에 따라 서로 다른 진화가 가능한지를 확인하기 위해서 T 연구원은 이 장비를 사용하기로 했다.

‘이것이 장비의 매뉴얼이구나?’

장비의 매뉴얼에는 장비의 사용 방법이 다음과 같이 적혀 있었다.

> - 배양기는 n X 2의 크기이다.
> - 이 장비는 바이러스가 유출되지 못하게 가둬 두는 1X2 크기의 바이오 세이프티 필터와 바이러스가 자유롭게 드나들 수 있는 2X1 크기의 바이오 컴패터블 필터를 바닥에 설치해야 한다.
> - 이 설치 방식에 따라 모두 다른 실험 결과를 얻을 수 있다.
> - 바닥에 필터가 설치되어 있지 않은 영역이 조금이라도 있는 경우 바이러스가 배양기 외부로 유출될 위험이 매우 높으므로, 절대 주의해야 한다.

T 연구원은 이 장비를 사용하기에 앞서 총 몇 종류의 설정이 가능한지 알아야 했다. 실험 계획을 세우기 위해서 반드시 필요한 값이기 때문이었다.

## 수행목표

- 배양기는 n X 2의 구조를 가지고 있다. (가로가 양의 정수 n의 크기이다.) 그리고 배양기 바닥은 1 X 2 또는 2 X 1 크기의 필터로 빠짐없이 채워야 장비가 정상적으로 동작하며, 필터의 종류와 무관하게 필터를 배치한 형태만으로 서로 다른 실험 환경이 설정된다고 할 때, 서로 다른 전체 실험 설정의 수를 계산해 반환하는 함수를 구현한다.
- n = 2, 10, 30, 50, 100일 때 서로 다른 전체 실험 설정의 수를 계산하고, 이를 출력한다.

## 수행단계

- 문제의 구조를 분석한다.
- 다이나믹 프로그래밍 접근 방법을 사용해 문제를 해결하는 방법을 정리한다.
- dp_exer/filtering1.py 파일에 서로 다른 전체 실험 설정의 수를 반환하는 함수를 구현한다.
  - 이 함수는 다이나믹 프로그래밍으로 구현한다. 접근 방법은 각자 선택하되, 시간 복잡도는 O(n) 이하가 되도록 구현하여야 한다.
- n = 2, 10, 30, 50, 100일 때의 결과를 각각 출력한다.

## 결과예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/filtering1.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방법을 사용해서 O(n) 시간 복잡도 이내로 동작하는 알고리즘으로 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- 이 문제의 점화식을 설명과 함께 제시하라.
- 구현한 알고리즘의 시간 복잡도를 설명과 함께 제시하라.

### [코드 예시]

```python

```

---

# 문제 8. 비싼 블록 놀이 (2)

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

정작 배양기 사용 하가를 받아서 배양기의 덮개를 열어보니, 배양기는 n x 2 구조가 아니라 n x 3 구조였다. 매뉴얼이 옛날 구버전의 것이었는데, 연구소의 인트라넷에 새 버전으로 업데이트가 되지 않았던 것이다.

T 연구원은 뭔가 더 많은 경우를 테스트 할 수 있을 것이라는 생각에 횡재한 기분이었다. 하지만 들뜬 기분도 잠시. 전체 실험 가능한 설정의 수를 다시 계산해야 한다는 생각에 우울감이 몰려왔다. 게다가 문제의 난이도가 n x 2일 때보다 훨씬 복잡해졌음을 직관적으로 깨달을 수 있었다.

'뭐, 일단 부딪혀보고 안되면 프로그래밍 지원 게시판에 도움을 청하면 어떻게 되지 않겠어?'

## 수행목표

- 이전 문제와 달리 이번에는 n X 3 구조의 배양기에 1 x 2 또는 2 x 1 크기의 필터를 빠짐없이 배치해야 한다. (n은 양의 짝수이다.) 이와 같이 배양기의 구조가 변경된 상황에서 필터의 종류와 무관하게 필터를 배치한 형태만으로 서로 다른 실험 환경이 설정된다고 할 때, 서로 다른 전체 실험 설정의 수를 계산해 반환하는 함수를 구현한다.
- 이 함수를 사용해 배양기의 구조가 2 x 3, 4 x 3, ..., 20 x 3 인 10개의 배양기에서 설정 가능한 실험의 총 수를 각각 계산해 출력한다.

## 수행단계

- 문제의 구조를 단계별로 확인해보자.
  - 2 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - 4 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - 6 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - n이 8 이상일 때 배양기에 필터를 배치하는 방법을 작은 크기의 배양기에 필터를 배치하는 방법을 사용해 경우 별로 분류해서 정리해보자.
    - (n - 2) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하는 경우 (배치 A)
    - (n - 4) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하되, 배치 A에 포함되지 않는 경우 (배치 B)
    - (n - 6) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하되, 배치 A와 배치 B에 포함되지 않는 경우 (배치 C)
    - 배치 A, 배치 B, 배치 C와 무관하며, 작은 크기의 배양기에 필터를 배치하는 방법과도 완전히 무관한 별도의 경우
- 이 문제를 상향식 접근 방법으로 해결하는 함수를 dp_exer/filter2.py 파일에 구현한다.
- n = 2, 4, ..., 20일 때의 결과를 출력한다.

## 결과예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/filter2..py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍 접근 방법으로 해결하고 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- n이 홀수인 경우는 어떤 결과가 나오는가?
- 문제의 구조를 하위 문제를 사용해 설명하라.
- n x 3에서 가능한 모든 실험 설정의 수를 case(n)으로 표기할 때, case(n)의 상위 문제와 하위 문제의 관계를 나타내는 점화식을 제시하라.

### [코드 예시]

```python

```

---

# 문제 9. 모두가 바나나를 좋아해

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

동물 지능 연구그룹을 이끄는 X 그룹장은 어느날 지선생을 찾아갔다. X 그룹장은 지선생이 기가 막힐 정도로 천재라는 사실을 눈치채고 있는 소수의 연구원 중 한 사람이었다. 사실 그것이 아니라도 평소 연구 업무에 크게 도움을 주고 있는 지선생을 연구소의 훌륭한 선배로 받들어 모시는 그런 사람이기도 했다.

"요즘 원숭이들의 규칙 준수 가능성을 확인하기 위해서, 원숭이들 행동을 점수로 평가하고 있어요."

"아니 원숭이랑 생긴 일을 왜 나한테 가지고 와서 그래?"

"그런데, 그 녀석들에게 요즘 가르치고 있는게 있거든요."

"뭔데?"

"정확히 100점을 받으면 바나나를 상으로 주고 있어요."

"뭔 소리야?"

"100점을 초과해버리면 안준단 소리죠."

"너 그러다 원숭이한테 맞겠다."

"여튼, 이거 방법을 좀 알려주셨으면..."

"뭔데?"

"원숭이들이 정확히 100점을 받을 수 있는 가능한 모든 행동 시퀀스를 구하는 방법이 필요해요."

"음. 어렵지는 않은데, 점수표는 좀 조절해야겠네?"

"어떻게요?"

"행동에 점수를 매길 때, 행동 별로 같은 점수가 없도록 만들어주면 좋겠네."

"아, 그래요? 그거야, 뭐 어렵지 않죠. 오히려 실험 결과를 식별하기에는 더 편할 것 같은데요?"

"아... 그런데, 원숭이는 예외없이 바나나를 좋아하는거 맞는거지?"

두 사람은 문제를 검토한 후, 머리를 맞대고 방법을 찾아나가기 시작했다.

## 수행목표

- 점수 배열과 목표 점수가 주어진다. 점수 배열은 각 행동 별 점수를 나타내며, 중복된 값을 포함하지 않는다.
- 목표 점수를 정확히 달성하는데 필요한 행동의 시퀀스를 모두 작성해 반환한다.
  - 목표 점수가 30점이고 행동 점수 배열이 [10, 20]인 경우, 이 함수는 [[0, 0, 0], [0, 1], [1, 0]]을 반환한다. 10점 행동을 3번 연달아하거나, 10점 행동 이후에 20점 행동을 하거나, 20점 행동 이후에 10점 행동을 한 세 가지 경우를 해당 점수의 인덱스를 사용해 만든 리스트의 리스트에 해당한다.
  - 목표 점수가 90점이고 행동 점수 배열이 [40, 20]인 경우, 목표 점수를 달성할 수 있는 가능성이 전무하므로 빈 리스트 []를 반환한다.
- 다음 테스트케이스는 점수 배열과 목표 점수의 튜플로 구성되어 있다. 총 5개의 테스트케이스가 제시되며, 각각의 결과를 출력한다.
  ```python
  testcases = [([15, 20], 10), ([1, 2, 3], 6), ([12, 14, 16, 18, 20], 105), ([13, 17, 19], 56)]
  ```

## 수행단계

- 문제의 구조를 분석한다.
  - 하향식으로 접근하기 위해서 목표 점수를 달성하기 전 단계를 사용해서 상위 문제와 하위 문제의 관계를 정리한다.
  - 상향식으로 접근하기 위해서 가장 작은 문제와 상향식 전개 과정을 정리한다.
- 이 문제를 상향식 접근 방법 및 햐힝식 접근 방법 각각의 방식으로 해결하는 두 개의 함수를 dp_exer/monkey_banana.py 파일에 구현한다.
- 제시된 테스트케이스를 사용해 문제를 해결한 결과를 출력한다.

## 결과예시

```

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/monkey_banana.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식, 하향식 각각의 방법을 사용한 두 가지 모두 구현되어 있어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- 하향식 다이나믹 프로그래밍 해결 전략을 제시해보자. 재귀 호출 함수가 하는 일, 종료 조건, 메모이제이션 변수의 정의, 그리고 목록을 작성하는 방법을 설명해야 한다.
  - 목표 점수에서 취할 수 있는 점수 만큼을 뺀 값을 재귀 호출 한 후, 반환되는 전체 목록에 뺀 점수의 항목을 앞에 각각 붙이고 취합하는 방식으로 구현할 수 있다.
  - 종료 조건은 0점이 되었을 때 (성공), 혹은 점수가 남았으나 취할 수 있는 행동이 없을 때(실패) 이다.
  - 목록을 취합하는 방식은 성공의 경우는 해당 항목을 반환하는 경로에 합치고, 실패의 경우에는 버린다.
  - 메모이제이션은 딕셔너리를 사용하며, ws_memo[i]는 i 점을 받기 위한 행동 시퀀스이다.
- 상향식 다이나믹 프로그래밍으로 문제를 해결할 때, 가장 작은 문제를 정의해보자.
  - 가장 작은 문제는 0점을 달성하는 목록을 구하는 문제이다.
- 상향식 다이나믹 프로그래밍으로 문제를 해결할 때, 이전에 계산한 결과를 저장하는 변수를 정의하고 초기화 하는 방법을 제시해보자.
  - 크기 별 문제의 결과를 저장하기 위해서 target + 1 크기의 배열을 빈 배열로 초기화하면서 생성한다.
- 두 가지 구현 방법의 시간 복잡도를 제시하라.

### [코드 예시]

```python

```

---

# 문제 10. DNA에서 오름차순 패턴을 찾아보자

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

유전 정보의 코딩을 연구하는 D 연구원은 자나깨나 염기 서열의 배치 특징을 생각하는 삶을 살고 있다. 문득 이런 생각이 들었다.

'어떤 배치 구조가 길면 길수록 어떤 특징이 나타나지 않을까? 일단 염기 서열의 오름차순 배치 구조부터 확인해봐야겠다.'

## 수행목표

- 'C', 'T', 'A', 'G' 네 글자로 구성된 문자열이 주어진다. 이 문자열의 부분 순열 중, C, T, A, G 순으로 배치된 부분 문자열의 최장 길이와 이 부분 순열 패턴을 찾아 출력하는 프로그램을 작성한다.
  - 예를 들어 주어진 문자열이 CTAGTACG인 경우, 이 문자열에서 `__A__ACG`의 오름차순 부분 순열이 가장 긴 오름차순 부분 순열이 된다. (같은 값의 경우 오름차순으로 간주한다.) 이 경우 4와 함께 AACG를 출력한다.
  - CTAGGTACG의 경우 `C__GGT___`, `__AGGT___` 등 여러 개의 길이가 4인 오름차순 부분 순열을 찾을 수 있으며, 이 부분순열이 가장 긴 오름차순 부분 순열이다. 이 경우 4와 함께 찾을 수 있는 부분 순열 중 하나를 출력한다.
- 다음 테스트케이스에는 16개의 문자열이 주어진다. 이 문자열에서 가장 긴 오름차순 부분 순열의 길이와 부분 순열 중 하나를 출력한다.
  ```python
  testcases = ['CTAGTACG', 'CTAGGTACG', 'AAA', 'ACGT', 'TGCA', 'ACTTTTTTTCGGGGGGT', 'ACTTTTTCT', 'ACTTTTTCGGGT', 'ACTTTTTCGGGGGGTTTTTT', 'GCCTGCTGGT', 'CCCATCTTCCGTCATTATAG', 'ACCAAGAAACTGTAATCTCCTTCTTCTCGA', 'TCCGTTCGGCATACCCCCCGGCGGGGATATCGAACTGGAG', 'GTCCGAGGGGCAAGCAAGCGGGTTGACGCATCCTGAAGCTCTTTCACAGG', 'ATGGGTGAAAACCCCCATTAACATAACTGGCGCCGGGAGTTACGAATCTCGTGCTTGAAGAAGGGCAAACTGTTTTACGAGAGGTGGGGACAGACTACCT', 'CAATCATCTGGCCTCCAATTAAGACTTTATGCTGCTGCTAGCCAGAAATTTATTGACCACCACGGATGCGACGGCTCGACGCTGATGGTGTGACGTTGCAAAAGCTGGTCTATGGCTTGGTTTAGTGGTGGCCATGGACCCCTCACTCGTAATTTGTAAATGTAATAATAGGCGCCAAATTCAGTGTCTGATGCTGGTTCCCCAGCTGTCTCTTGCAAGTCGGCGCCAATCGTTTTCCACGGAACGACTTGTCTGCGGCCTATGCATCGTTCGCTAGCCAGTTAAATGGCATATGCTAGTTCACCTAACCACTTCAAAGTATCAGCCCAAGGATTTTCACCAGGTAGGGAAATTATTAGGATCGCTAAGCAACCCACTGTCCGATACGACAGCCCGCTGCCAGCGTTTCATTATAGTCTTGGAATACCGTTCCGTTGTTTTCAAACCGTTCCAACCCCCCTGATGCGCCAGCGTCTAGGTTTGTCGGCGCTAGTGGCCACCAGCGCGTGCCATACACGCGGTGTTGGCCTAATCAGTTGCTAAGTACCTAGAACGACAGCTAACCGAAAGAGAAAACATCGAGCTTTTACGTAATTTCTACACTATACGCCCTGGACGACATACTAGTCTGCGTTTGGTCTATATCTATATGTTCACTCCGAAGCTCTCAGATCTGATACAGACACATGAGGGTCTTGTAGCATTCCTAGAGCTTCTATACGCGTGGTTCGCCGGCCAGGATATGGGTCACACGGGTACATTCAACTCCTACTACGAGAGGGGGTGTTTAAACTATCCGTAAAGCCACAGTAATCGAGATTTACCCATAGGCGACCGATCAAATCGTCTATGGACAGAAGTGGCTCCGCCCGCGAAGCTAACATAAGGTCCAATTACATTGTTACCTAAGCTCTTGTACTAAAATCTAGTGATCATAATCCCGGCCCCGTTATCGCCACCATGGCAATATTTGAACGCGCCCTCGTAGAGCTCATAAGGA']
  ```

## 수행단계

- 문제의 구조를 분석한다.
- 문제의 구조를 사용하는 다이나믹 프로그래밍 접근 방식으로 최장 부분 순열 중 하나를 문자열로 만들어 반환하는 함수를 dp_exer/ascending_pattern.py 파일에 구현한다.
  - 다이나믹 프로그래밍 방식으로 구현하며, 구현한 알고리즘의 시간 복잡도를 확인한다. -
- 테스트케이스로 제시된 16개의 문자열에서 가장 긴 오름차순 부분 문자열 중 하나를 만들어 길이와 함께 출력한다.

## 결과예시

```
Testcase 1
    가장 긴 오름차순 부분 순열의 길이 : 4
    가장 긴 오름차순 부분 순열 중 하나 : AACG

Testcase 2
    가장 긴 오름차순 부분 순열의 길이 : 4
    가장 긴 오름차순 부분 순열 중 하나 : CGGT
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/ascending_pattern.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 접근방법을 사용해 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

  ```
  Testcase 1
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : AACG

  Testcase 2
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : CGGT

  Testcase 3
      가장 긴 오름차순 부분 순열의 길이 : 3
      가장 긴 오름차순 부분 순열 중 하나 : AAA

  Testcase 4
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : ACGT

  Testcase 5
      가장 긴 오름차순 부분 순열의 길이 : 1
      가장 긴 오름차순 부분 순열 중 하나 : T

  Testcase 6
      가장 긴 오름차순 부분 순열의 길이 : 10
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTTTT

  Testcase 7
      가장 긴 오름차순 부분 순열의 길이 : 8
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTT

  Testcase 8
      가장 긴 오름차순 부분 순열의 길이 : 8
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTT

  Testcase 9
      가장 긴 오름차순 부분 순열의 길이 : 15
      가장 긴 오름차순 부분 순열 중 하나 : ACCGGGGGGTTTTTT

  Testcase 10
      가장 긴 오름차순 부분 순열의 길이 : 6
      가장 긴 오름차순 부분 순열 중 하나 : CCGGGT

  Testcase 11
      가장 긴 오름차순 부분 순열의 길이 : 11
      가장 긴 오름차순 부분 순열 중 하나 : CCCCCCGTTTT

  Testcase 12
      가장 긴 오름차순 부분 순열의 길이 : 16
      가장 긴 오름차순 부분 순열 중 하나 : AAAAAACTTTTTTTTT

  Testcase 13
      가장 긴 오름차순 부분 순열의 길이 : 20
      가장 긴 오름차순 부분 순열 중 하나 : CCCCCCCCCCGGGGGGGGGG

  Testcase 14
      가장 긴 오름차순 부분 순열의 길이 : 20
      가장 긴 오름차순 부분 순열 중 하나 : CCGGGGGGGGGGTTTTTTTT

  Testcase 15
      가장 긴 오름차순 부분 순열의 길이 : 39
      가장 긴 오름차순 부분 순열 중 하나 : AAAAACCCCCCCGGGGGGGGGGGGGGGGGGGGGGGGGTT

  Testcase 16
      가장 긴 오름차순 부분 순열의 길이 : 274
      가장 긴 오름차순 부분 순열 중 하나 : AAAAAAAAAAAAAAAACCCCCGGGGGGGGGGGGGGGGGGTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
  ```

### [문제에 대한 이해]

- 문제의 구조를 제시하라.
  - 문자열의 i 번째 글자의 값을 마지막 값으로 반드시 포함하는 가장 긴 부분 순열의 길이를 dp[i]라고 표현하면, 임의의 dp[j]의 값은 j 보다 작은 모든 k에 대해서 다음 모든 값들의 최대값이 되는 구조가 성립한다.
    - 만약 k 번째 글자보다 j 번째 글자가 같거나 더 큰 값의 글자인 경우 : dp[k] + 1
    - 그렇지 않은 경우 : 1
- 가장 긴 오름차순 부분 순열을 찾는 방법을 설명하라.
  - 가장 긴 오름차순 부분 순열의 길이를 문자열의 모든 인덱스에 대해서 갱신할 때, j번 인덱스의 글자로 끝나는 오름차순 부분 순열의 이전 글자는 k번째 인덱스의 글자가
    된다. 이를 모든 인덱스 별로 관리한 다음, 부분 문자열의 길이가 최대가 되는 j에 대해서 역순으로 이전 글자를 이어 붙이는 과정으로 가장 긴 오름차순 부분 순열을 찾을 수 있다.
- 구현한 알고리즘의 시간 복잡도를 제시하라.
  - 모든 글자에 대해서 더 작은 글자를 반복하는 구조이므로 n의 이중 루프 구조를 가진다. O(n^2)에 해당된다.
- 만약 문제의 조건이 가장 긴 '연속된 오름차순 부분 문자열'인 경우 문제를 어떻게 해결할 수 있는지 접근 전략을 제시해보자.
  - 슬라이딩 윈도우, 헤드와 테일 포인터 등을 유지하면서 전체 문자열을 스캔하는 방법 등 적당한 전략을 제시할 수 있는지 확인한다.

### [코드 예시]

```python
def find_lap(input_seq):
    if not input_seq:
        return ''

    dp = [1] * len(input_seq)
    prev = [-1] * len(input_seq)

    max_len = 0
    max_index = 0

    for i in range(1, len(input_seq)):
        for j in range(i):
            if input_seq[j] <= input_seq[i] and dp[j] + 1 > dp[i]:
                dp[i] = dp[j] + 1
                prev[i] = j
                if dp[i] > max_len:
                    max_len = dp[i]
                    max_index = i

    longest_ascending_pattern = ''
    while max_index != -1:
        longest_ascending_pattern += input_seq[max_index]
        max_index = prev[max_index]
    return longest_ascending_pattern[::-1]


def main():

    testcases = ['CTAGTACG', 'CTAGGTACG', 'AAA', 'ACGT', 'TGCA', 'ACTTTTTTTCGGGGGGT', 'ACTTTTTCT', 'ACTTTTTCGGGT', 'ACTTTTTCGGGGGGTTTTTT', 'GCCTGCTGGT', 'CCCATCTTCCGTCATTATAG', 'ACCAAGAAACTGTAATCTCCTTCTTCTCGA', 'TCCGTTCGGCATACCCCCCGGCGGGGATATCGAACTGGAG', 'GTCCGAGGGGCAAGCAAGCGGGTTGACGCATCCTGAAGCTCTTTCACAGG', 'ATGGGTGAAAACCCCCATTAACATAACTGGCGCCGGGAGTTACGAATCTCGTGCTTGAAGAAGGGCAAACTGTTTTACGAGAGGTGGGGACAGACTACCT', 'CAATCATCTGGCCTCCAATTAAGACTTTATGCTGCTGCTAGCCAGAAATTTATTGACCACCACGGATGCGACGGCTCGACGCTGATGGTGTGACGTTGCAAAAGCTGGTCTATGGCTTGGTTTAGTGGTGGCCATGGACCCCTCACTCGTAATTTGTAAATGTAATAATAGGCGCCAAATTCAGTGTCTGATGCTGGTTCCCCAGCTGTCTCTTGCAAGTCGGCGCCAATCGTTTTCCACGGAACGACTTGTCTGCGGCCTATGCATCGTTCGCTAGCCAGTTAAATGGCATATGCTAGTTCACCTAACCACTTCAAAGTATCAGCCCAAGGATTTTCACCAGGTAGGGAAATTATTAGGATCGCTAAGCAACCCACTGTCCGATACGACAGCCCGCTGCCAGCGTTTCATTATAGTCTTGGAATACCGTTCCGTTGTTTTCAAACCGTTCCAACCCCCCTGATGCGCCAGCGTCTAGGTTTGTCGGCGCTAGTGGCCACCAGCGCGTGCCATACACGCGGTGTTGGCCTAATCAGTTGCTAAGTACCTAGAACGACAGCTAACCGAAAGAGAAAACATCGAGCTTTTACGTAATTTCTACACTATACGCCCTGGACGACATACTAGTCTGCGTTTGGTCTATATCTATATGTTCACTCCGAAGCTCTCAGATCTGATACAGACACATGAGGGTCTTGTAGCATTCCTAGAGCTTCTATACGCGTGGTTCGCCGGCCAGGATATGGGTCACACGGGTACATTCAACTCCTACTACGAGAGGGGGTGTTTAAACTATCCGTAAAGCCACAGTAATCGAGATTTACCCATAGGCGACCGATCAAATCGTCTATGGACAGAAGTGGCTCCGCCCGCGAAGCTAACATAAGGTCCAATTACATTGTTACCTAAGCTCTTGTACTAAAATCTAGTGATCATAATCCCGGCCCCGTTATCGCCACCATGGCAATATTTGAACGCGCCCTCGTAGAGCTCATAAGGA']

    for i, tc in enumerate(testcases):
        print(f"Testcase {i + 1}")
        longest_ascending_pattern = find_lap(tc)
        length_of_lap = len(longest_ascending_pattern)
        print(f"    가장 긴 오름차순 부분 순열의 길이 : {length_of_lap}")
        print(f"    가장 긴 오름차순 부분 순열 중 하나 : {longest_ascending_pattern}")
        print()

if __name__ == '__main__':
    main()


```

---

# 문제 11. DNA에서 아무 패턴을?

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

D 연구원은 오름차순 패턴의 길이와 관련된 염기 서열과 유전 정보와의 관계를 찾는데 실패했다. 하지만 불굴의 의지로 또 다른 가능성을 찾아보고 있었다. 그런 그가 문득 DNA 염기 서열에서 특수한 패턴을 확인하는 프로그램이 있으면 편하지 않을까란 생각을 했다.

D 연구원이 생각하는 특수 패턴 확인 프로그램은 일반적인 '와일드카드' 매칭과 동일한 방법이다. 즉, `*`와 `?`를 사용해서 검사를 하자는 아이디어였다.

## 수행목표

- 'C', 'T', 'A', 'G' 네 글자로 구성된 문자열 형태의 유전자 염기 서열과 패턴이 주어진다. 문자열에 패턴이 포함되어 있는지를 검사하고 그 결과를 출력하는 프로그램을 작성한다. 패턴은 다음과 같다.
  - 단순 문자열 패턴 : 패턴이 문자열에 포함되어 있는지를 검사한다. 예를 들어 주어진 문자열이 `CTATTAG`이고, 패턴이 `TAT`인 경우는 `_TAT___`로 패턴이 문자열에 포함되어 있으므로 '포함'을 출력한다.
  - `?` 와일드카드 패턴 : `?`는 아무 한 글자와 매칭되며, 이러한 패턴이 문자열에 포함되어 있는지 검사한다. 주어진 문자열이 `CTATTAG`이고, 패턴이 `T?T`인 경우는 `_T?T___`로 패턴이 문자열에 포함되어 있으므로 '포함'을, 패턴이 `A?G`인 경우는 이런 패턴이 포함되어 있지 않으므로 '불포함'을 출력한다.
  - `*` 와일드카드 패턴 : `*`는 아무 여러 글자와 매칭되며, 이러한 패턴이 문자열에 포함되어 있는지 검사한다. 주어진 문자열이 `CTATTAG`이고 패턴이 `TA*AG`인 경우 '포함'을, 패턴이 `TA*AT`인 경우 '불포함'을 출력한다. 또한 `*`는 0글자 이상의 아무 여러 글자이므로 문자열이 `CCCAGTT`일 때 패턴이 `AG`, `A*G`는 포함, `A?G`는 불포함을 의미한다.
  - 패턴은 `*`와 `?`를 0개 이상 여러번 사용해서 구성된다. 문자열이 `CGTATGTAGCCGTGTA`이고 패턴이 `AT*CG?GT`인 경우 '포함'을 출력한다. (`___AT_____CG_GT_`)
- 다음 첨부 파일에는 15개의 테스트케이스가 포함되어 있다. 각 테스트케이스는 문자열과 패턴의 튜플로 구성되어 있으며, 마지막 두 개의 테스트케이스는 공백 문자를 포함한 일반적인 문자열에 해당한다. (공백 문자도 하나의 글자로 처리한다.) 이 15개의 테스트케이스에서 주어진 패턴이 포함되어 있는지 검사한 결과를 출력한다.

## 수행단계

- 문제의 구조를 분석한다.
- 이 문제를 상향식 다이나믹 프로그래밍으로 구현하기 위한 방법을 정리한다.
  - 힌트 - 이 문제를 해결하기 위한 상향식 접근 방법에서는 작은 문제의 결과를 저장하기 위한 자료형으로 이차원 배열을 사용한다.
    - dp[s][p], 0 <= s <= 문자열의 길이, 0 <= p <= 패턴의 길이
- 문제의 구조를 사용하는 다이나믹 프로그래밍 접근 방식으로 패턴이 문자열에 포함되어 있는지를 검사하는 함수를 dp_exer/wildcard_pattern.py 파일에 구현한다.
  - 다이나믹 프로그래밍 방식으로 구현한다.
- 테스트케이스로 제시된 15개의 문자열과 패턴에 대해서 검사 결과를 출력한다.

## 결과예시

```
Testcase 1 : 포함

Testcase 2 : 포함

Testcase 3 : 불포함

Testcase 4 : 포함

Testcase 5 : 불포함
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/wildcard_pattern.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍 접근방법을 사용해 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

  ```
  Testcase 1 : 포함

  Testcase 2 : 포함

  Testcase 3 : 불포함

  Testcase 4 : 포함

  Testcase 5 : 불포함

  Testcase 6 : 포함

  Testcase 7 : 포함

  Testcase 8 : 불포함

  Testcase 9 : 포함

  Testcase 10 : 포함

  Testcase 11 : 불포함

  Testcase 12 : 포함

  Testcase 13 : 불포함

  Testcase 14 : 포함

  Testcase 15 : 불포함
  ```

### [문제에 대한 이해]

- 문제의 구조와 상향식으로 문제를 전개해나가는 방식을 설명하라.
  - 모든 패턴은 시작이 `*`이 아닌 경우 처음에 `*`을 추가하고, 마지막이 `*`이 아닌 경우 마지막에 `*`를 추가한다.
  - dp[i][j]를 i번째 글자 까지의 문자열과 j번째 글자 까지의 패턴에 대해서 검사한 결과라 하자. (참거짓값)
  - 우선 패턴 시작의 `*`의 크기만큼 dp[0][j]를 True로 초기화한다.
  - 패턴을 하나씩 추가하면서 차례대로 검사하고, 이 과정을 문자열의 글자를 추가해가면서 검사하는 방향으로 상향식으로 계산해 나간다.
  - 추가한 패턴이 `*`인 경우 `dp[i][j]`는 `dp[i][j - 1]`가 참이거나(`*` 이전 까지 참이었는가) `dp[i - 1][j]`가 참인 경우(이전 글자까지 참이었는가) 참이 된다.
  - 그렇지 않은 경우 추가한 패턴의 글자와 문자열의 추가한 글자가 일치한 경우에 `dp[i][j]`은 `dp[i - 1][j - 1]`와 동일한 값을 가지며, 일치하지 않는 경우는 거짓이 된다. `?`패턴인 경우는 패턴의 추가한 글자와 문자열의 추가한 글자가 일치하는 것으로 간주하고 처리한다.
- 상향식으로 문제를 해결하기 위한 가장 간단한 문제는 무엇이며, 이 값은 무엇으로 초기화되는가?
  - 빈 문자열을 빈 패턴과 비교하는 경우이며, 이는 참으로 초기화된다.
  - 패턴 앞 부분에 `*`의 길이 만큼 `dp[0][j]`는 참이 된다.

### [코드 예시]

```python
from wildcard_pattern_data import testcases
def isMatch(sequence, pattern):
    seq_size = len(sequence)
    pat_size = len(pattern)
    dp = [[False] * (pat_size + 1) for _ in range(seq_size + 1)]
    dp[0][0] = True
    for j in range(1, pat_size + 1):
        if pattern[j - 1] == '*':
            dp[0][j] = dp[0][j - 1]

    for i in range(1, seq_size + 1):
        for j in range(1, pat_size + 1):
            if pattern[j - 1] == '*':
                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
            elif pattern[j - 1] == '?' or sequence[i - 1] == pattern[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]

    return dp[seq_size][pat_size]


def main():

    for i, tc in enumerate(testcases):
        sequence, pattern = tc
        pattern = '*' + pattern + '*'
        print(f"Testcase {i + 1} : {'포함' if isMatch(sequence, pattern) else '불포함'}")
        print()

if __name__ == '__main__':
    main()
```

---

---

# 문제 12. 유전자 조작의 어려움 (1)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

K 바이오 연구소가 보유한 핵심 기술 중 하나는 유전자를 조작하는 기술이다. 이를 위한 수많은 연구 중에 '유전자 조작의 공식화 작업'이 포함되어 있었는데, 이 작업을 담당했던 K 연구원은 그 다음 단계로 유전자 조작을 자동화 하기 위한 작업을 진행하고 있다.

유전자 조작을 자동화하기 위해서는 유전자에 가해야 하는 각종 유전자 조작 단계를 자동으로 만들어낼 수 있어야 한다. K 연구원은 지금까지 컴퓨터로 해 온 여러 작업들을 복기하면서 몇 단계의 작업이 필요한지를 확인하는 방법은 스스로 만들 수 있었다.

## 수행목표

- 유전자 조작 과정은 다음 세 가지 방식으로 이루어진다.
  - 삽입 : 유전자 염기 서열에 C, T, A, G 네 개의 염기 중 하나를 추가한다. 한 번에 하나의 염기만 원하는 위치에 삽입할 수 있다.
  - 치환 : 유전자 염기 서열의 염기 하나를 C, T, A, G 네 개의 염기 중 원래의 염기와 다른 하나로 바꾼다. 한 번에 하나의 원하는 위치의 염기만 치환할 수 있다.
  - 삭제 : 유전자 염기 서열의 염기 하나를 삭제한다. 한 번에 하나의 원하는 위치의 염기만 삭제할 수 있다.
- 두 개의 유전자 염기 서열이 주어지는데, 이 유전자 염기 서열은 C, T, A, G 네 글자로 구성된 문자열 형태로 제공된다. 첫 번째 유전자 염기 서열을 두 번째 유전자 염기 서열로 바꾸는데 필요한 최소의 과정의 수를 출력하는 프로그램을 작성한다.
  - 만약 주어진 두 개의 유전자 염기 서열이 'CATC'와 'CGGT'인 경우, 최소의 과정 수는 3이며, 편집 방법은 다음과 같다.
    - (A를 G로) 치환 : CATC -> CGTC
    - (G를) 삽입 : CGTC -> CGGTC
    - (C를) 삭제 : CGGTC -> GGTC
  - 다음과 같은 다른 과정도 가능하지만, 최소의 과정 수는 3이다.
    - (A를 G로) 치환 : CATC -> CGTC
    - (T를 G로) 치환 : CGTC -> CGGC
    - (C를 T로) 치환 : CGGC -> CGGT
- 다음 테스트케이스에는 총 6개 쌍의 유전자 염기 서열이 포함되어 있다. 각 쌍 별로 첫 번째 유전자를 두 번째 유전자로 변형하는데 필요한 최소 과정의 수를 출력한다.
  ```python
  testcases = [['CATC', 'CGGT'], ['CAACCACAAC', 'C'], ['AATGATGCTC', ''], ['CCCAGCGTCGAAACCGCTGC', 'ACACGGATGCCTGTTATGAT'], ['TCTCTCATCAACAACGGGGTTGACCAAACGGGCAGTGTGGTGTTCAAAGCCGACTTATAGCCTACATGACTTAGCTTGCTATTACGTTGCATTTCCACGGAAACCCGAAAGCAGGGTCAGAGCCTCGCTGATCCACCCACTAACTATATCGCCCTTCCTCAGTCATGCTCCCGCGCAAAGAGGGGCTCTCAAGGTGTTCGTAGGTTGGCCGCCC', 'CCTACTTCTTAAGGCCGGTAGTGAAGTTCACAATATGTGTTTCTACCTATTACCCAAGGTGCGAGGGTTTTGATCGGGTGTGTTTTAGGCCTATTTAACTCCATCCGGCGAGTCACGTGGTCCGCTCATGTAGTGCTTACGGGGATCGGGTGGGGTAATAGTAGCGACGATTGTGCTTAGCCCGAGCGTGAAACTGCCAATATCGATGAACGATCTGAAATACACGTTGAATTGAAGCCGCTAGTGGTTCCATCGAATAGTCCTAGGGATGAATAGATATGGGGTTACAAAGAACCCACGGCTCAGGCTGGACATTAACAGCGAGTCGCTTCTACAGAGGGCGTTCATCAACGCGGGTTTAAGATATCCCATTGGGGTCGTGACGTGTCCTCGCCCAATGCGCGACTCGATCCATACGTAGACTATTACAACGGCGTGGAATCTTAAAATTCGAAGTATCGGGACCGGCGGACGCATGCGTAATTTGTCGCCTCGAGAGG'], ['GGTTCACTGGACACCTATCAAGGGAACTTGTTTCGGTGCTACATGATGTGCACTACTCCTATTACATTCGTTCTTCTTAAGAAACAACAGTGTTGCATGGCTATGACGGCCGTATAACTCCCCAGGTAGCTGAGGCATACAGGCTCGGAGGAGGGTCATGCATCATGTGTTGTCAAACCTGTCGTGTAGACAAGCTCCGGAGAGCGATGAGGTGGGGAAAGGCTAATGAAGGTTCTATTGTTTCTATATGGTGCGCCATAGATCTATGTTTTAGGGTCCGCACTACTCGCATATGCCCACTGGCAGAAATAGCAGGGCTTGCGGGCTAAATTCCCTGCACCGAAAACAGCCATCCCCCAGATCAGTGTCGATCGCACCTGCCAATTATTGACTTTCAGTGGCTAGATCAATCTTCGAAACCAAACATTTGCTACGACGGATCGGAGCTTGTTACTGCACGACAGACGGGGCACACTATGTCGGTTCCTTGCACCTCCGGAGTCAAGGCCTGGAAAATCGCAATTCGGACCGAGATAATATTCGATCGCCTACATAGAATTGAATCGTGATGACATCGTGGACCTTGACGCTACTACTTTA', 'TGGACGTGTGTAGCTTTATCGCCTTTCGACAAAAAAAACTCATTGGTCATGTACGTTCGACTCCTGGGTCACGCTTCATCTTGAGGTTCAAAATTAGTGTAGACCCTCTAGCAACTTCGCACATCTCTCCAGATCGGTTCCTATAAAATATGTGGCTTGGGATGAGGTGAAGCCGGGTGCCGGGTGCATGTGAATACGCTGATAATCCGGAGGGGCTATACCGGCGCAGCTACTCGCCAACGCACTCCTAGTCCCCTTGGGAGTTGAGGGCACCTGACGTGTGGTGACACAGTCGAGGTT']]
  ```

## 수행단계

- 문제의 구조를 분석한다.
  - 두 시퀀스의 첫 글자가 같을 때와, 첫 글자가 다를 때 각각의 상위 구조의 문제와 하위 구조의 문제 사이의 관계가 힌트가 될 수 있다.
  - 하향식 접근방법으로 해결하기 위한 점화식을 찾는다.
- 하향식 다이나믹 프로그래밍으로 이 문제를 해결하는 함수를 dp_exer/dna_edit1.py 파일에 구현한다.
  - 하향식 다이나믹 프로그래밍을 메모이제이션과 함께 사용해서 적용한다.
- 제시된 테스트케이스 6쌍의 유전자 염기 서열에 대해서, 각 쌍 별로 첫 번째 유전자를 두 번재 유전자로 변형하는데 필요한 최소 과정의 수를 구해서 출력한다.

## 결과예시

```
Testcase 1의 최소 DNA 변형 과정의 수 : 3

Testcase 2의 최소 DNA 변형 과정의 수 : 9

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/dna_edit1.py 파일에 구현이 되어 있는지 확인한다.
  - 하향식 접근법을 메모이제이션과 함께 사용하는 형태로 구현되어 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

  ```
  Testcase 1의 최소 DNA 변형 과정의 수 : 3

  Testcase 2의 최소 DNA 변형 과정의 수 : 9

  Testcase 3의 최소 DNA 변형 과정의 수 : 10

  Testcase 4의 최소 DNA 변형 과정의 수 : 13

  Testcase 5의 최소 DNA 변형 과정의 수 : 309

  Testcase 6의 최소 DNA 변형 과정의 수 : 348
  ```

### [문제에 대한 이해]

- 두 시퀀스의 첫 글자가 같은 경우의 문제의 상위 구조와 하위 구조를 설명하라.
  - 양 쪽의 첫 두 글자가 같은 경우 아무것도 할 필요가 없으므로, 편집 비용은 0이며, 이 두 글자를 제외하고 따지면 된다.
  - 상위 구조와 하위 구조의 결과는 같다.
- 두 시퀀스의 첫 글자가 다른 경우의 문제의 상위 구조와 하위 구조를 설명하라.
  - 치환하는 경우는 첫 번째 시퀀스의 첫 번째 글자를 두 번째 시퀀스의 첫 번째 글자로 바꾸는 작업이므로, 실질적으로는 양 쪽에서 첫 번째 글자를 삭제하는 것과 마찬가지이다.
  - 삽입하는 경우는 두 번째 시퀀스의 첫 번째 글자를 삽입해야 하므로, 실질적으로는 두 번째 시퀀스의 첫 번째 글자를 삭제하는 것과 마찬가지이다.
  - 상위 구조의 결과는, 두 하위 구조의 결과의 최소값에 1을 더한 것이다. 두 하위 구조는 첫 번째 시퀀스의 첫 글자를 삭제한 후의 최소 편집 비용, 두 번째 시퀀스의 첫 글자를 삭제한 후의 최소 편집 비용이다.
- 첫 번째 시퀀스를 두 번째 시퀀스로 변형하는 비용의 점화식을 제시하라.
  - 첫 번째 시퀀스의 i번째 글자부터 마지막 글자 까지의 부분 시퀀스와, 두 번째 시퀀스의 j번째 글자부터 마지막 글자까지의 부분 시퀀스의 변형 비용을 edit_distance(i, j)라고 표현하자.
  - edit_distance(i, j) = 1 + min(edit_distance(i + 1, j), edit_distance(i + 1, j + 1), edit_distance(i, j + 1))
- 종료조건은 어떤 경우이며, 이 때의 값은 얼마인가?
  - 만약 두 시퀀스 중 한 쪽이 비어 있는 경우이며, 남은 글자의 수 만큼 비용을 더한다. (삭제를 그 글자의 수 만큼 반복한다는 의미)

### [코드 예시]

```python
def dna_edit_step(seq1, seq2, i = 0, j = 0, memo=None):
    if memo == None:
        memo = {}

    if (i, j) in memo:
        return memo[(i, j)]

    if i == len(seq1):
        return len(seq2) - j
    if j == len(seq2):
        return len(seq1) - i

    if seq1[i] == seq2[j]:
        memo[(i, j)] = dna_edit_step(seq1, seq2, i + 1, j + 1, memo)
        return memo[(i, j)]

    insert_step = dna_edit_step(seq1, seq2, i, j+1, memo)
    delete_step = dna_edit_step(seq1, seq2, i+1, j, memo)
    replace_step = dna_edit_step(seq1, seq2, i+1, j+1, memo)

    memo[(i, j)] = 1 + min(insert_cost, delete_cost, replace_cost)

    return memo[(i, j)]

def main():
    testcases = [['CATC', 'CGGT'], ['CAACCACAAC', 'C'], ['AATGATGCTC', ''], ['CCCAGCGTCGAAACCGCTGC', 'ACACGGATGCCTGTTATGAT'], ['TCTCTCATCAACAACGGGGTTGACCAAACGGGCAGTGTGGTGTTCAAAGCCGACTTATAGCCTACATGACTTAGCTTGCTATTACGTTGCATTTCCACGGAAACCCGAAAGCAGGGTCAGAGCCTCGCTGATCCACCCACTAACTATATCGCCCTTCCTCAGTCATGCTCCCGCGCAAAGAGGGGCTCTCAAGGTGTTCGTAGGTTGGCCGCCC', 'CCTACTTCTTAAGGCCGGTAGTGAAGTTCACAATATGTGTTTCTACCTATTACCCAAGGTGCGAGGGTTTTGATCGGGTGTGTTTTAGGCCTATTTAACTCCATCCGGCGAGTCACGTGGTCCGCTCATGTAGTGCTTACGGGGATCGGGTGGGGTAATAGTAGCGACGATTGTGCTTAGCCCGAGCGTGAAACTGCCAATATCGATGAACGATCTGAAATACACGTTGAATTGAAGCCGCTAGTGGTTCCATCGAATAGTCCTAGGGATGAATAGATATGGGGTTACAAAGAACCCACGGCTCAGGCTGGACATTAACAGCGAGTCGCTTCTACAGAGGGCGTTCATCAACGCGGGTTTAAGATATCCCATTGGGGTCGTGACGTGTCCTCGCCCAATGCGCGACTCGATCCATACGTAGACTATTACAACGGCGTGGAATCTTAAAATTCGAAGTATCGGGACCGGCGGACGCATGCGTAATTTGTCGCCTCGAGAGG'], ['GGTTCACTGGACACCTATCAAGGGAACTTGTTTCGGTGCTACATGATGTGCACTACTCCTATTACATTCGTTCTTCTTAAGAAACAACAGTGTTGCATGGCTATGACGGCCGTATAACTCCCCAGGTAGCTGAGGCATACAGGCTCGGAGGAGGGTCATGCATCATGTGTTGTCAAACCTGTCGTGTAGACAAGCTCCGGAGAGCGATGAGGTGGGGAAAGGCTAATGAAGGTTCTATTGTTTCTATATGGTGCGCCATAGATCTATGTTTTAGGGTCCGCACTACTCGCATATGCCCACTGGCAGAAATAGCAGGGCTTGCGGGCTAAATTCCCTGCACCGAAAACAGCCATCCCCCAGATCAGTGTCGATCGCACCTGCCAATTATTGACTTTCAGTGGCTAGATCAATCTTCGAAACCAAACATTTGCTACGACGGATCGGAGCTTGTTACTGCACGACAGACGGGGCACACTATGTCGGTTCCTTGCACCTCCGGAGTCAAGGCCTGGAAAATCGCAATTCGGACCGAGATAATATTCGATCGCCTACATAGAATTGAATCGTGATGACATCGTGGACCTTGACGCTACTACTTTA', 'TGGACGTGTGTAGCTTTATCGCCTTTCGACAAAAAAAACTCATTGGTCATGTACGTTCGACTCCTGGGTCACGCTTCATCTTGAGGTTCAAAATTAGTGTAGACCCTCTAGCAACTTCGCACATCTCTCCAGATCGGTTCCTATAAAATATGTGGCTTGGGATGAGGTGAAGCCGGGTGCCGGGTGCATGTGAATACGCTGATAATCCGGAGGGGCTATACCGGCGCAGCTACTCGCCAACGCACTCCTAGTCCCCTTGGGAGTTGAGGGCACCTGACGTGTGGTGACACAGTCGAGGTT']]
    for i, testcase in enumerate(testcases):
        print(f'Testcase {i + 1}의', end = '')
        print(f' 최소 DNA 변형 과정의 수 : {dna_edit_cost_td(testcase[0], testcase[1])}')
        print()
if __name__ == "__main__":
    main()
```

---

# 문제 13. 유전자 조작의 어려움 (2)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

K 연구원은 필요한 최소 단계의 수를 구할 수 있었지만, 이 과정에서 필요한 모든 과정을 자동으로 생성하는 일이 꽤나 복잡해 보였다.

프로그래밍 지원 게시판에 도움을 요청하고, 다음 날 출근하니 답변이 달려 있었다. 그런데 답변이 조금 이상했다. 일단 익명 답변이 아닌 실명 답변이었고, 답변이라기 보다는 V 연구원이라고 본인을 소개한 그가 최근에 겪은 문제와 관련된 이야기를 전달하면서 그 방법과 유사하게 해결할 수 있지 않겠느냐는 내용이었다.

일단 조금 더 자세히 물어보기 위해서 V 연구원에게 구내 전화를 걸었다.

## 수행목표

- 유전자 조작 과정을 출력하는 프로그램을 생성한다.
  - 주어진 두 개의 유전자 염기 서열 중 첫 번째 염기 서열(대상 유전자)을 두 번째 염기 서열(목표 유전자)로 변형하는 과정을 출력한다.
  - 변형 과정은 다음을 기준으로 출력한다.
    - 변형의 위치는 대상 유전자를 계속 변형하는 현재 시점에서 두 유전자의 염기가 상이한 위치를 대상으로 한다.
    - 예를 들어서 대상 유전자가 'CATC, 목표 유전자가 'CGTC'인 경우 처음으로 염기가 다른 두 번째 위치가 첫 변형 과정의 대상이 된다.
      - 첫 번째 변형이 'X'의 삽입이라면 CATC를 CXATC로 변형하게 된다.
      - 첫 번째 변형이 삭제라면 CATC를 CTC로 변형하게 된다.
      - 첫 번째 변형이 'X'로 치환이라면 CATC를 CXTC로 변형하게 된다.
    - 대상 유전자가 'CCCAGCGTCGAAACCGCTGC', 목표 유전자가 'ACACGGATGCCTGTTATGAT'이며 전체 과정의 첫 세 과정이 '삭제', 'A로 치환, '삭제'인 경우 다음을 의미한다.
      - 삭제 : 두 유전자에서 가장 먼저 차이가 나는 위치는 첫 번째 염기이다. (C와 A) 그러므로 대상 유전자의 첫 번째 염기인 C를 삭제하여 대상 유전자는 'CCAGCGTCGAAACCGCTGC'로 변형된다.
      - A로 치환 : 현재 상태에서 두 유전자에서 가장 먼저 차이가 나는 위치는 첫 번째 염기이다. (C와 A) 그러므로 대상 유전자의 첫 번째 염기인 C를 A로 치환하여 대상 유전자는 'ACAGCGTCGAAACCGCTGC'로 변형된다.
      - 삭제 : 현재 상태에서 두 유전자에서 가장 먼저 차이가 나는 위치는 네 번째 염기이다. (G와 C) 그러므로 대상 유전자의 첫 번째 염기인 G를 삭제하여 대상 유전자는 'ACACGTCGAAACCGCTGC'로 변형된다.
  - 이와 같은 방법으로 'X를 삽입', 'X로 치환', '삭제'로 구성된 유전자 변형 과정을 순서에 맞게 출력한다.
- 다음 테스트데이터에는 다섯 개의 유전자 쌍이 포함되어 있다. 첫 번째가 대상 유전자, 두 번째가 목표 유전자일 때 다섯 쌍의 유전자의 유전자 변형 과정을 출력한다.
  ```python
  testcases = [['CATC', 'CGGT'], ['CAACCACAAC', 'C'], ['C', 'CAACCACAAC'], ['AATGATGCTC', ''], ['CCCAGCGTCGAAACCGCTGC', 'ACACGGATGCCTGTTATGAT']]
  ```

## 수행과정

- 이전 과정의 'DNA의 공통 패턴 (2)' 문제에서 생성된 dp 행렬의 변화에 따라서 공통으로 포함된 가장 긴 부분 문자열의 길이를 출력하는 과정을 학습한 적이 있다. 만약 이 과정이 기억나지 않는다면 이를 복습하고 온다.
- 상향식 다이나믹 프로그래밍으로 유전자 변형 과정의 수를 저장하는 `dp[i][j]` 배열을 만드는 방법을 정리한다.
  - `dp[i][j]`는 두 시퀀스 각각의 i번째 시퀀스, j번째 시퀀스 까지를 대상으로 구한 유전자 변형 과정의 수를 나타낸다.
  - 이렇게 만든 `dp[][]` 배열의 값을 사용해 변형 과정의 목록을 생성하는 방법을 정리한다. 단 대상 유전자를 고정으로 추적하며, 변형의 위치는 문제에서 제시한 것 처럼 두 유전자의 시퀀스가 달라지는 위치를 대상으로 한다.
- 위에서 정리한 방법을 사용해 유전자 변형 과정의 목록을 반환하는 함수를 dp_exer/dna_edit2.py 파일에 구현한다.
- 테스트데이터를 사용해서 대상 유전자를 목표 유전자로 변형하는 과정을 과정의 길이와 함께 출력한다.
  - 만약 두 가지 이상의 변형 방법이 있는 경우에는 그 중 하나만 출력한다.

## 결과예시

```
Testcase 1 :
  DNA 편집 비용: 3
  편집 방법: 'G'로 치환->'G'로 치환->'T'로 치환

Testcase 2 :
  DNA 편집 비용: 9
  편집 방법: 삭제->삭제->삭제->삭제->삭제->삭제->삭제->삭제->삭제
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/dna_edit2.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍 방식으로 생성한 dp 배열을 추적하는 방식으로 편집 과정을 생성하는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

  ```
  Testcase 1 :
    DNA 편집 비용: 3
    편집 방법: 'G'로 치환->'G'로 치환->'T'로 치환

  Testcase 2 :
    DNA 편집 비용: 9
    편집 방법: 삭제->삭제->삭제->삭제->삭제->삭제->삭제->삭제->삭제

  Testcase 3 :
    DNA 편집 비용: 9
    편집 방법: 'C'를 삽입->'A'를 삽입->'A'를 삽입->'C'를 삽입->'C'를 삽입->'A'를 삽입->'C'를 삽입->'A'를 삽입->'A'를 삽입

  Testcase 4 :
    DNA 편집 비용: 10
    편집 방법: 삭제->삭제->삭제->삭제->삭제->삭제->삭제->삭제->삭제->삭제

  Testcase 5 :
    DNA 편집 비용: 13
    편집 방법: 삭제->'A'로 치환->삭제->삭제->삭제->'T'로 치환->'G'로 치환->'T'를 삽입->'T'를 삽입->'T'를 삽입->'A'로 치환->'A'를 삽입->'T'로 치환
  ```

### [문제에 대한 이해]

- `dp[i][j]`는 대상 유전자의 i 번째까지의 부분 염기서열과 목표 유전자의 j번째까지의 부분 염기서열의 DNA 변형 과정의 수를 나타낸다. 이 dp 배열을 상향식으로 계산하는 방법을 설명하라. 초기값 및 상향식 계산 과정을 포함한다.
  - 이 변형 비용의 초기 값은 다음과 같이 설정한다.
    - `dp[0][j] = j`
    - `dp[i][0] = i`
  - i 번째 염기와 j 번째 염기가 같은 경우 `dp[i][j]`는 `dp[i - 1][j - 1]`과 같다.
  - i 번째 염기와 j 번째 염기가 다른 경우 `dp[i][j]`는 다음 세 가지 값의 최소값에 1을 더한 것과 같다.
    - `dp[i - 1][j]` : 대상 유전자 시퀀스에서 i번째 염기를 삭제
    - `dp[i - 1][j - 1]` : 대상 유전자 시퀀스의 i번째 염기를 목표 유전자 시퀀스의 j번째 염기로 치환
    - `dp[i][j - 1]` : 대상 유전자 시퀀스의 i번째 염기 다음에 목표 유전자 시퀀스의 j번째 염기를 삽입
  - 이 과정을 양쪽 시퀀스의 마지막 염기까지 반복한다.
- 이전 답변에서 초기 조건을 설명하지 않은 경우, dp 배열의 초기 값을 제시하라.
  - `dp[0][j] = j`
  - `dp[i][0] = i`
- 완성된 dp 배열을 사용해 대상 유전자 시퀀스로부터 목표 유전자 시퀀스로 변형하는 방법의 목록을 찾는 방법을 설명하라.
  - `dp[i][j]`를 시작으로, `dp[0][0]`까지 역순으로 추적한다.
  - 만약 대상 유전자 시퀀스의 i번째 염기와 목표 유전자 시퀀스의 j번째 염기가 같다면 i와 j를 1씩 감소시킨다. (변형할 게 없음)
  - 두 염기가 다를 때, `dp[i][j] - 1 = dp[i - 1][j - 1]`인 경우 목표 유전자 시퀀스의 j번째 염기로 대상 유전자 시퀀스의 i번째 염기를 치환한다.
  - 두 염기가 다를 때, `dp[i][j] - 1 = dp[i - 1][j]`인 경우 대상 유전자 시퀀스의 i번째 염기를 삭제한다.
  - 두 염기가 다를 때, `dp[i][j] - 1 = dp[i][j - 1]`인 경우 목표 유전자 시퀀스의 j번째 염기를 삽입한다.
  - 이 상황에서 i = 0인 경우, 목표 유전자 시퀀스의 남은 앞부분을 삽입한다.
  - 이 상황에서 j = 0인 경우, 대상 유전자 시퀀스의 남은 앞부분을 삭제한다.
  - 역추적한 경우이므로, 이 목록을 뒤집는다.

### [코드 예시]

```python
def dna_edit_process(seq1, seq2):
    len_seq1 = len(seq1)
    len_seq2 = len(seq2)

    dp = [[0] * (len_seq2 + 1) for _ in range(len_seq1 + 1)]

    for i in range(len_seq1 + 1):
        dp[i][0] = i
    for j in range(len_seq2 + 1):
        dp[0][j] = j

    for i in range(1, len_seq1 + 1):
        for j in range(1, len_seq2 + 1):
            if seq1[i - 1] == seq2[j - 1]:
								# 같은 염기에 대해서, 왼쪽 대각선 위의 값 가져오기
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j],  # 삭제
                                   dp[i][j - 1],    # 삽입
                                   dp[i - 1][j - 1]) # 교체

    # 변형 방법을 작성한다.

    i = len_seq1
    j = len_seq2
    path = []
    while i > 0 and j > 0:
        current = dp[i][j]
        if seq1[i - 1] == seq2[j - 1]:   # 마지막 염기가 같아서 변형할 필요가 없는 경우
            i, j = i - 1, j - 1
        elif current == dp[i - 1][j - 1] + 1:    # 치환
            path.append(f"'{seq2[j - 1]}'로 치환")
            i, j = i - 1, j - 1
        elif current == dp[i - 1][j] + 1:        # 삭제
            path.append(f"삭제")
            i -= 1
        elif current == dp[i][j - 1] + 1:        # 삽입
            path.append(f"'{seq2[j - 1]}'를 삽입")
            j -= 1

    while i > 0:
        path.append(f"삭제")      # 앞 부분에 모자라는 만큼 삽입
        i -= 1
    while j > 0:
        path.append(f"'{seq2[j - 1]}'를 삽입")      # 앞 부분에 남는 만큼 삭제
        j -= 1

    return dp[len_seq1][len_seq2], path[::-1] # 뒤집어서 반환


def main():
    testcases = [['CATC', 'CGGT'], ['CAACCACAAC', 'C'], ['C', 'CAACCACAAC'], ['AATGATGCTC', ''], ['CCCAGCGTCGAAACCGCTGC', 'ACACGGATGCCTGTTATGAT']]
    for i, testcase in enumerate(testcases):
        print(f'Testcase {i + 1} :')
        cost, path = dna_edit_process(testcase[0], testcase[1])
        path_str = '->'.join(path)
        print(f'  DNA 편집 비용: {cost}')
        print(f'  편집 방법: {path_str}')
        print()
if __name__ == "__main__":
    main()



```

---

# 문제 14. 지키면서 조합한 유전자

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

K 연구원은 유전자 하나를 염기 단위로 변형하는 것 뿐 아니라, 두 유전자를 섞어서 새로운 유전자를 만드는 기술도 연구하고 있다. 이 과정 자체는 어떻게든 수행할 수 있었는데, 문제는 이렇게 만들어진 유전자가 의도대로 두 유전자를 섞어서 만든 것인지 확인하기가 쉽지 않다는 점이었다. 이미 진행중인 실험이 있어서 빠르게 확인 방법을 찾아야 하는 상황이었다.

K 연구원이 고민을 하고 있는데, X 그룹장이 근처를 지나가고 있었다. X 그룹장은 이전 다른 연구에서 K 연구원이 속한 그룹과 공동 연구를 수행한 경험이 있어서 두 사람 사이에 어느 정도의 친분이 있었기에, K 연구원의 고뇌하는 표정을 보고 되물었다.

"무슨 걱정거리라도 있어?"

그 말에 현재 고민하고 있는 내용을 X 그룹장에게 이야기하자, X 그룹장은 다음과 같은 조언을 했다.

"내가 해결해 줄 수 있으면 얼마나 좋겠냐만, 그건 좀 어려울 것 같고. 대신, 급한 문제면 연구지원팀 지선생님을 찾아가서 여쭤봐. 이런 문제는 지선생님이 정말 잘 해결한단 말야."

그 말에 K 연구원은 주섬주섬 노트와 볼펜을 챙겨서 연구지원팀이 있는 행정동으로 향했다.

## 수행목표

- 두 개의 유전자 시퀀스가 주어지면, 이 유전자 시퀀스를 순서를 지키면서 섞는 과정이 이루어진다.
  - 예를 들어 주어진 유전자 시퀀스가 'CT'와 'AG'인 경우, 'CTAG', 'CAGT', 'CATG', 'AGCT', 'ACGT', 'ACTG' 여섯 개의 유전자를 만들 수 있다. 만들어진 유전자 안에는 원래의 시퀀스인 CT, AG가 순서대로 포함되어 있어야 하며, 생성된 유전자 시퀀스의 길이는 원래 두 유전자 시퀀스의 길이의 합과 같아야 한다.
- 세 개의 유전자가 주어진다. 두 개는 기초 유전자이며, 나머지 하나는 파생 유전자이다. 이때 파생 유전자가 두 개의 기초 유전자를 원칙을 지키면서 만들어진 유전자인지 검증하는 프로그램을 작성한다.
- 다음의 테스트케이스는 7개의 트리플로 구성되어 있고, 각각의 트리플이 하나의 테스트케이스이다. 하나의 트리플은 기초 유전자1, 기초 유전자2, 파생 유전자의 튜플로 구성된다. 이 7개의 테스트케이스에 대해서 파생 유전자가 제대로 생성된 유전자인지를 검사한 결과를 출력한다.
  ```python
  testcases = [('', 'CATG', 'CATG'), ('CATG', '', 'CATG'), ('TGACT', 'GAACACG', 'GTAAGACCTACG'), ('AGTACAAAATT', 'TTTAACT', 'TTATAAGCTTACAAAATT'), ('CGTAACTAAA', 'TTCTCAGGC', 'CGTTAACTTCACAAGGCAA'), ('ACCACGGTGAAGATTACTTCAGCACAGGCGACACCATGTCGGACGGGATGATATGTCTCTTTATTGTCCAGGGAGGCAGG', 'GTCGCCGGGCACGAGTAGCCTTACAGTTGCTCTTCCGCTAGATTCAGTCCCGGGCATCGTCTCATATTTGGTTACCATTG', 'AGCCTCAGCCCGGGCAGCGAGGTTGAAGAGATCCTTTACTACAGTTTCGAGCCATCAGGCGACCTTCCACCGACTTAGGTACTGTGCACGGGATAGGTACCCTATGTGCGTCTTTATTGGTCACTCCAGGGGAGTCTGCATCATAGTTGGGTTACCATTG'), ('ATGGCGCAGGGTAGATGGACACGATCCACGCATGGACTGGTACCTAATGTTGCTCGATCGCAACAGCTTCTGGCGCCAAG', 'GTGCCAAAGCCGTTAGTCCCGACACGCTACTACTATACTTGTCGCTTAAGGACTCGGAGGGGTAAATCAAGTTCGGTTTT', 'AGTTGGCGCCGACAAGGAGCCGGTTATGAATGTGGACCCGACACCACGGATCCACTACTCGCAATCTAGGACTACTGGTTACTGTCCTGAATCGTTAAGGATTGCTCTCCGGACGACGGGGCGTAAACAATCAGCATCAATGTGGTCCGCGCGAAGTTTT')]
  ```

## 수행단계

- 문제의 구조를 분석하고, 이를 활용한 하향식 접근법을 찾는다.
  - 메모이제이션이 가능한지 확인한다.
- 문제의 상향식 접근법을 찾는다.
- 이 문제를 상향식 접근법과 하향식 접근법으로 해결하는 두 개의 함수를 `dp_exer/dna_mix.py` 파일에 구현한다.
  - 각 함수는 함수의 결과를 도출하는데 소요된 시간을 출력하도록 구현한다. 재귀 호출을 통해 문제를 해결하는 함수는 모든 재귀 과정에서 시간을 측정하지 않고 전체 문제를 해결하는데 필요한 단 하나의 구간만 시간을 측정한다.
  - 구현한 두 함수의 성능을 비교 분석한다.
- 테스트케이스 7개에 대한 결과를 출력한다.

## 결과예시

```
Testcase 1
    하향식 접근법 : 수행 시간 - 0.0 초
        정상적으로 생성
    상향식 접근법 : 수행 시간 - 0.0 초
        정상적으로 생성

Testcase 2
    하향식 접근법 : 수행 시간 - 0.0 초
        정상적으로 생성
    상향식 접근법 : 수행 시간 - 0.0 초
        정상적으로 생성

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/dna_mix.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 접근방법과 하향식 접근방법 각각의 함수가 구현되어 있는지 확인한다.
  - 함수의 실행 시간을 적절하게 측정하고 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 실행 시간의 경우는 입력 데이터의 길이가 길어지면 차이가 발생하며, 상향식 접근방법이 더 빠르다.

    ```
    Testcase 1
        하향식 접근법 : 수행 시간 - 0.0 초
            정상적으로 생성
        상향식 접근법 : 수행 시간 - 0.0 초
            정상적으로 생성

    Testcase 2
        하향식 접근법 : 수행 시간 - 0.0 초
            정상적으로 생성
        상향식 접근법 : 수행 시간 - 0.0 초
            정상적으로 생성

    Testcase 3
        하향식 접근법 : 수행 시간 - 0.0 초
            정상적으로 생성
        상향식 접근법 : 수행 시간 - 0.0 초
            정상적으로 생성

    Testcase 4
        하향식 접근법 : 수행 시간 - 0.0 초
            정상적으로 생성
        상향식 접근법 : 수행 시간 - 0.0 초
            정상적으로 생성

    Testcase 5
        하향식 접근법 : 수행 시간 - 0.0 초
            비정상으로 생성
        상향식 접근법 : 수행 시간 - 0.0 초
            비정상으로 생성

    Testcase 6
        하향식 접근법 : 수행 시간 - 2.7910051345825195 초
            정상적으로 생성
        상향식 접근법 : 수행 시간 - 0.0010025501251220703 초
            정상적으로 생성

    Testcase 7
        하향식 접근법 : 수행 시간 - 0.26154589653015137 초
            비정상으로 생성
        상향식 접근법 : 수행 시간 - 0.0020012855529785156 초
            비정상으로 생성
    ```

### [문제에 대한 이해]

- 하향식으로 문제를 해결하는 전략을 제시하라.
  - 기본 유전자 시퀀스의 길이의 합이 조합된 시퀀스의 길이와 같은지 확인한다. 같지 않으면 False를 반환한다.
  - 조합된 시퀀스의 첫 번째 글자가 기본 시퀀스 1의 첫 번째 글자와 같다면, 조합된 시퀀스와 기본 시퀀스 1에서 각각 그 글자를 떼어 낸 작은 문제와 동일한 문제이다. 기본 시퀀스 2의 첫번째 글자와 같은 경우도 마찬가지로 동일한 문제이다.
  - 조합된 시퀀스의 첫 번째 글자와 두 기본 유전자 시퀀스의 첫 글자 모두가 같은 경우는 앞의 경우에 이미 포함되어 있다.
  - 만약 조합된 시퀀스의 첫 번째 글자가 기본 시퀀스의 모두의 첫 글자와 다르다면 False이다.
- 하향식 접근법으로 문제를 해결하기 위한 점화식을 제시해보라.

  - 시퀀스 X, Y, Z의 i번째 글자부터 마지막 까지의 부분 문자열을 X(i:), Y(i:), Z(i:)로 표현하고, 입력 X, Y, 출력 Z인 시퀀스가 제대로 조합된 시퀀스 인지를 확인하는 함수를 inter(X, Y, Z)으로 표현한다.
  - inter(X(i:), Y(j:), Z(k:)) = inter(X(i + 1:), Y(j:), Z(k + 1)) or inter(X(i), Y(j + 1:), Z(k + 1:))
  - 종료 조건은 다음 세 가지이다.
    - 입력 시퀀스의 길이의 합이 출력 시퀀스와 다를 때 : 거짓
    - 출력 시퀀스의 첫 번째 글자가 입력 시퀀스 양쪽 어디의 첫 번째 글자도 아닐 때 : 거짓
    - 입력 시퀀스와 출력 시퀀스 모두 빈 문자인 경우 : 참

- 하향식 접근법으로 문제를 해결할 때 메모이제이션이 유효한가? 근거와 함께 제시하라.
  - 유효하지 않다. 중복되는 하위 문제가 없기 때문이다.
- 하향식 접근법으로 구현한 함수의 시간 복잡도는 얼마인가?
  - 지수 시간 복잡도이다.
- 상향식 접근 방법으로 해결하기 위한 문제의 구조를 제시하라.
  - i = 0 또는 j = 0일 때, 입력 시퀀스가 출력 시퀀스와 겹치는 길이까지는 True이고, 그 뒤부터는 False가 된다.
  - i, j가 0이 아닐 때
    - 결과 시퀀스의 현재 글자가 두 입력 시퀀스의 현재 글자와 모두 다르면 False
    - 결과 시퀀스의 현재 글자가 두 입력 시퀀스 중 하나의 현재 글자와 같은 경우
      - 시퀀스 1과 같다면 : mixseq(i, j) = mixseq(i - 1, j)
      - 시퀀스 2와 같다면 : mixseq(i, j) = mixseq(i, j - 1)
    - 결과 시퀀스의 현재 글자가 두 입력 시퀀스의 현재 글자와 모두 같다면
      - mixseq(i, j) = mixseq(i - 1, j) or mixseq(i, j - 1)
- 상향식 접근 방법의 시간 복잡도를 제시하라.
  - 기초 유전자 시퀀스의 길이가 각각 m, n일 때, 시간 복잡도는 O(mn)이다.

### [코드 예시]

```python
import time
def execute_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"수행 시간 - {end - start} 초")
        return result
    return wrapper

@execute_time
def is_pattern_mixed_td_wrapper(in_seq1, in_seq2, out_seq):
    return is_pattern_mixed_td(in_seq1, in_seq2, out_seq)

def is_pattern_mixed_td(in_seq1, in_seq2, out_seq):
    ins1_len = len(in_seq1)
    ins2_len = len(in_seq2)
    out_len = len(out_seq)

    # 만약 모든 문자열이 빈 문자열인 경우
    if (ins1_len == 0) and (ins2_len == 0) and (out_len == 0):
        return True
    # A와 B 문자열의 길이의 합이 C 문자열의 길이와 다를 때
    if (ins1_len + ins2_len) != out_len:
        return False
    case_in_seq1 = False
    case_in_seq2 = False
    # A의 첫글자와 C의 첫글자가 같은 경우
    if (ins1_len != 0) and (in_seq1[0] == out_seq[0]):
        case_in_seq1 = is_pattern_mixed_td(in_seq1[1:], in_seq2, out_seq[1:])
    # B의 첫글자와 C의 첫글자가 같은 경우
    if (ins2_len != 0) and (in_seq2[0] == out_seq[0]):
        case_in_seq2 = is_pattern_mixed_td(in_seq1, in_seq2[1:], out_seq[1:])

    return case_in_seq1 or case_in_seq2

@execute_time
def is_pattern_mixed_bu(in_seq1, in_seq2, out_seq):
   # 두 입력 시퀀스와 출력 시퀀스의 길이
   ins1_len = len(in_seq1)
   ins2_len = len(in_seq2)
   out_len = len(out_seq)

   # A와 B 문자열의 길이의 합이 C 문자열의 길이와 다를 때
   if out_len != ins1_len + ins2_len:
       return False

   # 시퀀스1의 i번째 글자까지의 부분 문자열과
   # 시퀀스2의 j번째 글자까지의 부분 문자열을 사용해
   # 조합된 시퀀스의 i + j 번째 글자 까지의 부분 문자열을
   # 조합할 수 있는지의 여부를 저장하는 2차원 배열
   mixseq = [[True] * (ins2_len + 1) for _ in range(0, ins1_len + 1)]

   # 첫번째 열을 채운다. 시퀀스1와 조합된 글자와 같을 때 까지는 T, 그 뒤로는 F
   for i in range(1, ins1_len + 1):
       if in_seq1[i - 1] != out_seq[i - 1]:
           mixseq[i][0] = False
       else:
           mixseq[i][0] = mixseq[i - 1][0]

   # 첫번째 행을 채운다. 시퀀스2와 조합된 글자와 같을 때 까지는 T, 그 뒤로는 F
   for j in range(1, ins2_len + 1):
       if in_seq2[j - 1] != out_seq[j - 1]:
           mixseq[0][j] = False
       else:
           mixseq[0][j] = mixseq[0][j - 1]

   # 나머지 셀을 채운다.
   # lc_from_i1/i2 는 last letter from in_seq1/in_seq2를 의미하며
   # ll_from_out은 last letter from out_seq를 의미한다.
   for i in range(1, ins1_len + 1):
       for j in range(1, ins2_len + 1):
           # i, j, i + j 번째 각각의 현재 글자들
           ll_from_i1 = in_seq1[i - 1]
           ll_from_i2 = in_seq2[j - 1]
           ll_from_out = out_seq[i + j - 1]
           # 조합 시퀀스의 현재 글자가 시퀀스 1의 현재 글자와만 같을 때
           # -> 조합 시퀀스와 시퀀스 1의 글자를 제외했을 때의 결과와 동일
           if (ll_from_i1 == ll_from_out) and (ll_from_i2 != ll_from_out):
               mixseq[i][j] = mixseq[i - 1][j]
           # 조합 시퀀스의 현재 글자가 시퀀스 2의 현재 글자와만 같을 때
           # -> 조합 시퀀스와 시퀀스 2의 글자를 제외했을 때의 결과와 동일
           elif (ll_from_i1 != ll_from_out) and (ll_from_i2 == ll_from_out):
               mixseq[i][j] = mixseq[i][j - 1]
           # 세 시퀀스의 현재 글자가 모두 같을 때 -> 모두 제외 했을 때의 결과와 동일
           elif (ll_from_i1 == ll_from_out) and (ll_from_i2 == ll_from_out):
               mixseq[i][j] = mixseq[i - 1][j] or mixseq[i][j - 1]
           else:
               mixseq[i][j] = False

   return mixseq[ins1_len][ins2_len]


def main():
    testcases = [('', 'CATG', 'CATG'), ('CATG', '', 'CATG'), ('TGACT', 'GAACACG', 'GTAAGACCTACG'), ('AGTACAAAATT', 'TTTAACT', 'TTATAAGCTTACAAAATT'), ('CGTAACTAAA', 'TTCTCAGGC', 'CGTTAACTTCACAAGGCAA'), ('ACCACGGTGAAGATTACTTCAGCACAGGCGACACCATGTCGGACGGGATGATATGTCTCTTTATTGTCCAGGGAGGCAGG', 'GTCGCCGGGCACGAGTAGCCTTACAGTTGCTCTTCCGCTAGATTCAGTCCCGGGCATCGTCTCATATTTGGTTACCATTG', 'AGCCTCAGCCCGGGCAGCGAGGTTGAAGAGATCCTTTACTACAGTTTCGAGCCATCAGGCGACCTTCCACCGACTTAGGTACTGTGCACGGGATAGGTACCCTATGTGCGTCTTTATTGGTCACTCCAGGGGAGTCTGCATCATAGTTGGGTTACCATTG'), ('ATGGCGCAGGGTAGATGGACACGATCCACGCATGGACTGGTACCTAATGTTGCTCGATCGCAACAGCTTCTGGCGCCAAG', 'GTGCCAAAGCCGTTAGTCCCGACACGCTACTACTATACTTGTCGCTTAAGGACTCGGAGGGGTAAATCAAGTTCGGTTTT', 'AGTTGGCGCCGACAAGGAGCCGGTTATGAATGTGGACCCGACACCACGGATCCACTACTCGCAATCTAGGACTACTGGTTACTGTCCTGAATCGTTAAGGATTGCTCTCCGGACGACGGGGCGTAAACAATCAGCATCAATGTGGTCCGCGCGAAGTTTT')]

    for i, tc in enumerate(testcases):
        print(f'Testcase {i + 1}')
        print(f"    하향식 접근법 : ", end = '')
        print(f"        {'정상적으로 생성' if is_pattern_mixed_td_wrapper(*tc) else '비정상으로 생성'}")
        print(f"    상향식 접근법 : ", end = '')
        print(f"        {'정상적으로 생성' if is_pattern_mixed_bu(*tc) else '비정상으로 생성'}")
        print()

if __name__ == "__main__":
    main()

```

---

# 문제 15. 문서의 형식을 지키는 것

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

얼마전 일이다. K 연구원은 그간의 성과를 정리해 해외 저널에 논문을 한 편 투고했다. 저널에서 논문 심사 결과가 나오기를 기다리던 어느 날, 논문 리뷰를 담당한 한 편집자가 다음과 같은 메일을 보내왔다.

> 논문의 내용은 참 좋은데, 아무리 수식이나 그림이 없는 논문이라 할 지라도 텍스트 파일로 투고하신건 좀 너무하신 것 같습니다. 그래도 내용이 워낙 참신하고 좋아서 넘어가려 했지만, 도저히 참을 수 없는 것은 읽기 좋게 줄바꿈은 해서 다시 보내주셨으면 합니다.

이 회신을 받은 K 연구원은 간단한 프로그램을 만들어서 논문의 텍스트를 80자씩 끊어가면서 줄바꿈을 한 후 논문을 다시 투고했다. 하지만 이번에도 다음과 같은 수정 요청이 돌아왔다.

> 줄바꿈을 해 주신건 좋습니다만, 철학을 가지고 나누어 주셨으면 좋겠습니다. 조금 더 이쁜 모양이 나오도록... 그러니까, 전체적으로 여백이 줄면 어떨까요?

이쯤되면, 워드프로세서나 기타 편집 프로그램을 사용해 논문을 수정할 만 하지만, K 연구원은 평소 묘하게 꼬인데가 있었다. 편집 프로그램을 쓰는 대신 줄바꿈을 하는 프로그램을 대충 수정하면 되지 않을까 이렇게 생각하면서 이래저래 줄바꿈 프로그램을 수정해보았다. 하지만 예쁜 형태로 줄바꿈을 만드는 방법은 쉽게 찾을 수 없었다.

그래서 프로그래밍 지원 게시판에 '이런걸 여쭤봐도 될지 모르겠습니다만...'이라는 제목으로 글을 올렸다.

## 수행목표

- 텍스트가 주어지면, 이 텍스트를 다음 원칙을 기준으로 각 줄을 배치하는 프로그램을 작성한다.
  - 각 줄의 최대 길이는 정해져 있다. 이 길이의 범위 내에서 단어를 배치한다.
  - 텍스트에 포함된 단어와 단어 사이는 공백과 줄바꿈으로만 분리된다.
  - 각 줄의 마지막 단어 뒤에는 공백을 추가하지 않는다.
  - 공백이 아닌 모든 문자는 동등하게 취급된다. 만약 단어 앞 또는 뒤에 쉼표나 각종 문장 부호가 공백 없이 붙어 있다면 합쳐서 하나의 단어로 취급한다.
  - 각 줄의 뒤에 남은 여백의 길이를 제곱한 값의 합이 최소가 되도록 줄바꿈한다.
- 다음 두 개의 텍스트에 대해서 이 원칙을 적용하여 줄바꿈이 된 결과를 출력한다.
  - 각 테스트케이스는 한 줄에 배치할 수 있는 최대 글자의 수와 텍스트의 튜플로 주어진다.
  - 두 번째 테스트케이스는 로버트 프로스트의 The Road Not Taken의 시적 형식을 일부 배제한 텍스트이다. 주어진 텍스트에 줄바꿈은 포함되어 있지 않다.

```python
testcases = [(40, "In real world, there's lots of algorithm challenges. We must solve it for every people who expect technical assist and progress."), (80, "Two roads diverged in a yellow wood, \
And sorry I could not travel both \
And be one traveler, long I stood \
And looked down one as far as I could \
To where it bent in the undergrowth; \
Then took the other, as just as fair, \
And having perhaps the better claim, \
Because it was grassy and wanted wear; \
Though as for that the passing there \
Had worn them really about the same, \
And both that morning equally lay \
In leaves no step had trodden black. \
Oh, I kept the first for another day! \
Yet knowing how way leads on to way, \
I doubted if I should ever come back. \
I shall be telling this with a sigh \
Somewhere ages and ages hence: \
Two roads diverged in a wood, and I— \
I took the one less traveled by, \
And that has made all the difference.")]
```

## 수행단계

- 먼저 문제를 파악해보자.

  - 다음 주어진 문장을 배치하는 경우의 예제이다.

    > In real world, there's lots of algorithm challenges. We must solve it for every people who expect technical assist and progress.

  - 이 때 각 줄 별로 최대한 많은 단어를 배치하고, 이를 첫 줄부터 차례로 배치하면 다음과 같이 배치된다.

  ```
  In real world, there's lots of algorithm 		40
  challenges. We must solve them for every 		40
  people who expect technical assist and 		  38
  progress.						                        9
  ```

  - 그런데, 각 줄의 뒤에 남은 여백의 길이의 제곱의 합을 최소화 하면 다음과 같이 배치된다.

  ```
  In real world, there's lots of			        30
  algorithm challenges. We must solve			    35
  it for every people who expect			        10
  technical assist and progress.			        10
  ```

  - 두 배치에 어떤 차이가 있는지 생각해보자.
  - 후자의 방법은 그래픽 인터페이스를 사용하는 워드프로세서 소프트웨어가 보급되기 전에는 흔히 사용되던 배치 방식이다. 각 줄의 뒤의 숫자는 각 줄에서 배치한 단어와 공백의 길이이다.
    - 두 예시의 여백의 길이의 총 합은 각각 얼마인가?
    - 두 예시의 여백의 길이 제곱의 총 합은 각각 얼마인가?
  - 여백의 길이의 제곱의 합을 최소화 함으로써 배치에 미치는 영향은 무엇인지 추정해보자.

- 상향식 접근 방법을 찾아보자.
  - 우선 목표를 최소가 되는 여백의 길이의 제곱의 합을 구하는 것으로 하고 접근 방법을 찾는다.
  - 상향식 접근 방법으로 여백의 길이의 제곱의 합을 구해가면서, 각 줄에 텍스트를 배치하기 위한 힌트를 남겨야 한다. 어떤 힌트를 어떤 방식으로 남겨야 할지 정리한다.
- 정리한 상향식 접근 방법을 사용해 텍스트를 각 줄 별로 나눈 리스트와 이 때 여백의 길이의 제곱의 합의 값을 반환하는 함수를 dp_exer/smart_cutting.py 파일에 구현한다.

  - 예를 들어 위의 입력에 대한 함수의 반환하는 결과는 다음과 같다.

  ```
  325, ['In real world, there's lots of', 'algorithm challenges. We must solve', 'it for every people who expect', 'technical assist and progress.']
  ```

## 결과예시

```
Testcase 1:
    최소 여백의 제곱 합 : 325
----------
In real world, there's lots of
algorithm challenges. We must solve
it for every people who expect
technical assist and progress.
----------

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/smart_cutting.py 파일에 구현이 되어 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    Testcase 1:
        최소 여백의 제곱 합 : 325
    ----------
    In real world, there's lots of
    algorithm challenges. We must solve
    it for every people who expect
    technical assist and progress.
    ----------

    Testcase 2:
        최소 여백의 제곱 합 : 723
    ----------
    Two roads diverged in a yellow wood, And sorry I could not travel both
    And be one traveler, long I stood And looked down one as far as I could
    To where it bent in the undergrowth; Then took the other, as just as fair,
    And having perhaps the better claim, Because it was grassy and wanted
    wear; Though as for that the passing there Had worn them really about
    the same, And both that morning equally lay In leaves no step had trodden
    black. Oh, I kept the first for another day! Yet knowing how way leads on
    to way, I doubted if I should ever come back. I shall be telling this with
    a sigh Somewhere ages and ages hence: Two roads diverged in a wood, and
    I— I took the one less traveled by, And that has made all the difference.
    ----------
    ```

### [문제에 대한 이해]

- 되는대로 배치하는 경우, 제곱을 최소화하여 배치하는 경우를, 문제 예시의 배치를 통해 미적으로 평가해보자.
  - 아무 답변이나 무관하다. 문제와 완전히 무관한 이야기를 하지 않으면 된다.
- 제곱을 기준으로 여백을 최소화 할 때의 효과에 대해서 설명해보자.
  - 제곱을 기준으로 최소화 함으로써, 줄 별 배치에 있어서 전반적으로 비슷한 길이로 배치되도록 하는 효과가 있다.
- 문제의 구조를 사용해 상향식으로 문제를 해결하는 방법을 제시하라.
  - 문장에서 i번째 단어부터 j번째 단어까지 한 줄에 배치 할 때의 여백의 제곱을 less[i][j]라고 하고, 한 줄에 최대 폭을 max_width라고 하자. (less : line end space square)
  - 모든 조합의 less[i][j]는 두 단계를 거쳐서 구한다.
  - 첫 번째 단계는 i 번째 단어에서 j 번째 단어를 한 줄에 배치할 때의 길이를 구한다.
    - less[i][i]는 i번째 단어의 길이이다.
    - less[i][i + 1]은 i 번째 단어와 i + 1 번째 단어의 길이에 1을 더한 값이다.
    - less[i][j + 1]은 less[i][j] + (j + 1번째 단어의 길이) + 1 이다.
  - 두 번째 단계는 i 번째 단어에서 j 번째 단어를 한 줄에 배치할 때의 여백의 제곱을 구한다.
    - 만약 less[i][j]가 max_width보다 길다면 (즉 한 줄에 배치하지 못한다면) 충분히 큰 값 (float[‘inf’] 또는 sys.maxsize)으로 한다.
    - 그렇지 않다면 (max_width - less[i][j])의 제곱을 less[i][j]의 값으로 한다.
  - min_lesss 배열을 정의한다. 이 배열은 i 번째 단어까지 배치했을 때 여백의 제곱 합의 최소값이다.(min_lesss : minimum line end space square sum)
    - min_lesss[0]은 0으로 초기화한다.
    - 0부터 단어의 갯수까지 상향하면서 min_lesss값을 구한다.
    - min_lesss[j] (j >= i)의 값은 min_cost[i - 1] (i - 1번째 까지의 여백 제곱합의 최소값) 에 cost[i][j](i번째에서 j번째 까지의 남은 여백의 제곱)을 더한 값들의 최소값으로 계산할 수 있다.
      - min_lesss[j] = min(min_cost[i - 1] + cost[i][j])
      - 한 줄을 넘어가는 경우 cost[i][j]를 충분히 큰 값으로 정했으므로 걸러질 수 있다.
      - 한 줄을 넘어가는 경우 cost[i][j]를 충분히 큰 값으로 정했으므로 걸러질 수 있다.
- 텍스트를 배치하기 위한 힌트를 상향식 접근의 각 단계마다 남긴다면, 어떤 힌트를 어떻게 남겨야 하는가?
  - 상향식 과정에서 이 부분은 다양하게 제안할 수 있으며, 그 중 한 가지 예이다.
  - result[j]는 j번째 단어가 줄의 마지막 단어로 배치할 때 이전 줄의 마지막 단어를 의미한다.
  - 즉 result[j] = i라면, 그 줄은 i + 1 번째 단어부터 j번째 단어를 배치한다는 의미이다.
  - min_lesss[j]의 값이 최소가 될 때, 이때 min_lesss[i - 1]의 최소값을 사용하므로, 즉 i 번째에서 j 번째 단어가 한 줄에 배치된다는 의미가 된다.
  - 그러므로 min_lesss[j] = min(min_cost[i - 1] + cost[i][j])일 때 선택된 i가 result[j] = i - 1가 된다.
- 남겨둔 힌트로 텍스트를 배치하는 방법을 제시하라.
  - result[j] = i인 경우 i + 1번째 단어부터 j번째 단어를 한 줄로 배치한다.
  - 이 때의 i에 대해서 result[i] = h - 1인 경우 h + 1번째 단어부터 i 번째 단어까지 배치하고, 이를 가장 앞에 삽입한다.
  - 이렇게 모든 단어를 배치할 때 까지 반복한다.

### [코드 예시]

```python
def pretty_edit(text, max_width):
   # 텍스트를 단어의 리스트로 변환
   words = text.split()
   n = len(words)

   # i번째 단어부터 j번째 단어까지 한 줄에 배치할 때의 남은 여백의 제곱 : less[i - 1][j - 1]
   # 만약 줄 제한을 넘어간다면, 충분히 큰 값 (float('inf'))으로 설정
   less = [[0 for _ in range(n)] for _ in range(n)]
   # 1단계 - i 번째 단어에서 j 번째 단어까지 한 줄에 배치할 때의 길이
   for i in range(n):
       less[i][i] = len(words[i])
       for j in range(i + 1, n):
           less[i][j] = less[i][j - 1] + len(words[j]) + 1 # '1'은 단어 사이 공백
   # 2단계 - i 번째 단어에서 j 번째 단어까지 한 줄에 배치할 때의 남은 여백의 제곱
   # 줄을 넘어가는 경우 충분히 큰 값으로 초기화 한다.
   for i in range(n):
       for j in range(i, n):
           if less[i][j] >= max_width:
               less[i][j] = float('inf')
           else:
               less[i][j] = (max_width - less[i][j]) ** 2

   # i 번째 단어까지 문제의 조건에 맞게 배치했을 때 최소가 되는 여백의 제곱 합
   # min_lesss[0] 은 0으로 초기화하고, 나머지 값은 충분히 큰 값 (float('inf'))으로 초기화
   min_lesss = [0] + [float('inf')] * n
   result = [-1] * n
   for j in range(1, n + 1):
       for i in range(1, j + 1):
           # 작은 문제가 float('inf')이면 계산하지 않는다.
           # i 번째 단어부터 j 번째 단어까지 한 줄에 배치할 수 없으면 계산하지 않는다.
           if min_lesss[i - 1] != float('inf') and less[i - 1][j - 1] != float('inf'):
               # min_lesss[j - 1] + less[i - 1][j - 1] 중 최소의 값이
               # min_lesss[j]의 값이 된다.
               if min_lesss[i - 1] + less[i - 1][j - 1] < min_lesss[j]:
                   min_lesss[j] = min_lesss[i - 1] + less[i - 1][j - 1]
                   result[j - 1] = i - 1

   # 결과 추적
   lines = []
   j = n
   while j > 0:
       i = result[j - 1]
       lines.append(' '.join(words[i:j]))
       j = i
   if min_lesss[n] == float('inf'):
       return -1, None

   return min_lesss[n], list(reversed(lines))

def main():
    testcases = [(40, "In real world, there's lots of algorithm challenges. We must solve it for every people who expect technical assist and progress."), (80, "Two roads diverged in a yellow wood, \
And sorry I could not travel both \
And be one traveler, long I stood \
And looked down one as far as I could \
To where it bent in the undergrowth; \
Then took the other, as just as fair, \
And having perhaps the better claim, \
Because it was grassy and wanted wear; \
Though as for that the passing there \
Had worn them really about the same, \
And both that morning equally lay \
In leaves no step had trodden black. \
Oh, I kept the first for another day! \
Yet knowing how way leads on to way, \
I doubted if I should ever come back. \
I shall be telling this with a sigh \
Somewhere ages and ages hence: \
Two roads diverged in a wood, and I— \
I took the one less traveled by, \
And that has made all the difference.")]

    for i, testcase in enumerate(testcases):
        min_lesss, edited_text = pretty_edit(testcase[1], testcase[0])
        print(f"Testcase {i + 1}:")
        print(f"    최소 여백의 제곱 합 : {min_lesss}")
        print("----------")
        for line in edited_text:
            print(line)
        print("----------")
        print()

if __name__ == "__main__":
    main()
```

---

# 문제 16. 회문 문제

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

K 연구원이 연구지원팀의 지선생을 찾아갔을때, 지선생의 모니터에는 뭔가 익숙한 화면이 보였다.

'어라, 저거 내가 논문 포매팅 관련해서 물어봤던 그 글이잖아?'

지선생은 누가 뒤에서 다가오는 인기척이 느껴지자 인트라넷 프로그램을 내리고 다른 창을 그 위로 덮었다.

"안녕하세요? 저는 K라고 합니다. X 그룹장님이..."

지선생에게 고민하고 있었던 유전자 조합을 검증하는 방법에 대한 적절한 조언을 얻고 자리에 돌아온 K 연구원이 프로그래밍 지원게시판에 들어가보니, 자기가 올린 논문 줄바꿈 문제에 적절한 답변이 달려 있었다.

'아, 게시판에 답변을 열심히 달아주는 분 중에 한 분이 지선생님이구나!'

## 수행목표

- 지선생, K 연구원과, 심지어 K 바이오 연구소와도 큰 상관은 없지만 다이나믹 프로그래밍 연급과 관련해서 반드시 풀어보아야 할 문제는 회문 문제이다. 회문(Palindrom)은 앞으로 읽을 때와 뒤로 읽을 때가 같은 문장을 말한다.
  - 'A man, a plan, a canal, Panama'라는 문장은, 비록 쉼표와 공백을 조절해야 하지만 알파벳의 순서만 보면, 뒤집어도 순서가 유지된다. 이러한 문장을 회문이라고 한다.
  - 공백이 포함되어 있지 않은 소문자로 구성된 문자열이 주어진다. 이 문자열에서 가장 긴 회문을 찾아서 이 회문의 길이와 함께 해당 회문을 출력하는 프로그램을 작성한다.
- 다음 테스트케이스에는 5개의 텍스트가 주어진다. 이 5개의 텍스트 각각에서 가장 긴 회문의 길이와 가장 긴 회문을 출력한다.
  ```python
  TC1 = 'oavhdjksqw'
  TC2 = 'wasitacaroracatisaw'
  TC3 = 'zveabcdcbacbetrmhhktbslwnzbdwuopihqhhqxmybqgemlscsyzcsxzztacocatpsxzaljbtanshudeogbsdnujkwqwvclojhxbyilwxbyocnguie'
  TC4 = 'cdbbciconpbxbctvdvcjudwytytqleimpemczcawocxuyepgnmkjuhmmpmvlqbwzmwfblrlurwxrjfcdxaktkilnrwxmnfdxpwvwihwkrmbzykxdyrvlqwyffelkdkinhiymzclpxjhafeticmhrfpvbyaxsecytqxnwqhhhvqgnvwtsgskemgkscdurgfjivivkqdhjnnlbyswmzirzxxfgxvbqlxtgjrsiwofovibpxisafyyiwqqlxyiyjqzdbodrfhizaudszsqtpghajaovrchvodybqnymxfjnxwekukimdvieaffedgskvyeavexnzirzkhrzinbztvpfiqkshlklbuvoodhhytmevvelvuiennquhvernefdakmrkmlyqgkalpkvpuebrpjldpgifrwtbgzyzpzphtspkuagwmllbwfqemtoilwmeaxwxmickrgcirimplrrnrzvdntzzxwgniqylgqbdhadpikvlqhwgfzpaasantalivedasadevilatnasaohyvdilgsrweeyvsggzsxchjfiipsyyzdtufunsatjqjfoewwkwpvenchdlwdyfwbyomqoafcrbqdmzswmbblrsodjcxfyrqazafuywvddiooiipmoxjdbnxzbngrakfnzshaocrqcwggehnneaurbaytjymafsbzemuzpwjshwxjvmjnufabdeluajkdvoobnnwmozdpzbdrewgawaluggpcvdjqpvjsyvuidrwarmokuyscbgoppmuojnnrihkmrnmtdfysmcazubukxegqrkapsoxofsaotapqajeoqdnwxewysuhwdlyltzftvefdhvdhxxhqmmozjzoamycjejbyxjakhfiilynvjvrmxndssgdfmnqxaxmnaelcmqpcotsqnhlmobexlrbvjylvfyerdklltrnluxtimgeuacpqefqxwlsbgcsjiwfzpimcsmmyniczsbgyovoldkfcxsfqxzaekyspjzmvkbroffwnhatbwqesan'
  TC5 = 'zgmexkfvxgxroqtqajchdkduyclujuynanabbenvwlgwotyttrgiqdrecawxknglmcjtywpkfssyfmcouvgeonwaoopirarzeumyeuqahljfgvcowmggixozqhwayonrabxxjznqprsdcxutxiorghnfxvkiuhyryflkitgvajoylsomyuzwoyhvzudfxgdbqiwtitgwuwgqdnperrizowlsuwotzvpzroraivbrrrreybmpyzvffeiuugrsgyaqhitxhigkvbnfmdvlllcvthqgqdxuqjtyifteosfxwhbilhunflosaejntksiqxgwcblrwxxrywqlmqgtskpzhkwrendrnqzsnccmanbjmlcvaxcfhzqiyrtmmtitoykoeueudqjcvnoxlspkwlvwvznocdwfhicoryfonjolqnfeuvlfnkqitxqgbkwyrvhkjuhtlvtosrhdjsmdmqhrlmbgkgdgylneymqqlyfkfuvacnziqnvruhhyzfitcsyxdcaolsnatiwvtkvihbbxisfeohhccnlkktjwyfnihsoklbzodcexjlfvfyrukxzyltqjwfleqnzvlvuypvktqixjpritjpbzjrxutdpkkurgelhvwftzzkjdpnlcdtrivbjlfxwzawvfvxrjworpqaoamlhthekfvnsxemdwlpyoovutksqxnkysblldpgncznuonsaugapresbpjpzhdjcazvpvjentysutczphankwftpxpsciunemvsmtfubjgsuvddyaqvdlxbodbzxbpvhyaeedvmgwmpolhgxjoafkumgzczgasefglyuucwdgoghywioiskaunfbjvxruqtmeieuozeucjhkurtanxzjrztrycfhhwdffrcbcccyclbsyrokpjevpvkbckinhklyudurmcxxpzbjlvaqvunkrrmsllolcxtrexyjcnjwsyhgpmrvrfigskqmilzbkqtlgkdeldohskilpfuoozmedjcsobmvtvkucmoyvwwwaiscngteqgblirticrinhqfbdrhibcgighhsobzkxjephjvxpaefngesfalwityqrvowjtxlxhdubnqbhbdpjemagnedsrxbvcavhiueuznccyaqitirhjxhblghpnxqtzkvoduyceiqcwdntosyvmlmybwfzmeirebxyufzanasthbuwqogellbteepgtibengzpqclwjflqesotgnytpcpuzaitsfqxlqnkmjgfwttfolerjflstzevqwyheblmlotlgsmpbfbodufcvbsbdtgzuytpqikostjjbblzolqbnsoiovelowjjmvigpjlxaygimoyiunzrrylulivwtdlcresppgbefzgxosixlsqirebxccvlltcydloonmvyjmojraqiwflyqfncpspqldcrssnbuluvagmrcrjzhgmoiixpyrrlmjaleasxguyqyvkywwlfqhlvovezznwuutyjioimzlzvwokoqsxrkvdyphjhnoechoikpdulxjkqjbauqtgcnwkkhsmaksdhqhhazycgcurcwwbgrltdrqstdldxjroccstsggyqcfqnwtrrobetewenbtlblmpujfvvvbctsftuhcagugzoeurothxpdbwyzsyczfzpqziigwvlhxdjneovvjuhdrqtstfbrghjlrjwxhftbjdxblnxbtlibltefvhevmqebgqwkkkxcecqgqjfllqtpscvxwvnjadasmrebnfnvpbylfezuzrtnezegkcemfdrtdzevcffdpvvkkucewoxupwqtdpggtidttqtbtlswiccvgpumvfnsvlgaayqgaogyfrvucvmhmgfvcogvyrksdtalnmzulcwueaswqcvzetteoxwukpmdobtkaxbpwbiyrgfoptzzqcrbnydavysbcfwdoqsmfdoowbrbrnsxubmfzcdmbdpvtukfyoomagondpwxmtyrwoaoiqqlaphacsvwpteclmkhzzfuuemhuapnkzbfzgagzuthdwuetweherugwnyanhtefcaqriymfleavmvapjzfknkrhlumaazhjykvrwcjcrfyatbmjzcsccxojvxpnrxwulbbsqntmgqeobqzzvebzdakeywqilcsthjopyniyyrrxvgdbcmtookouvalkfvgtsafsxqizzibuhyshuxvgllyzdrynjwwqivhlybtfakxvuguhtookgvmifxllnpohynhtpxjidebnqbwmnbuzfbqcgehpavmxymvbyrhfltosuruqteblhwpvozriviphdzvrizhhbyolwrfnxtshdrhddjusjukaekaxfxzrblujcvuwwbsbbjeznxnsjyhgvjsxmllzyndblvyqoopclpuxykgdqwygllurofhgyxavytnncckotdwiarlkqoeetrmzrnneseligjakhibumcoiyuclpfblqhtmzfgerfxjwhapvybmrgozwyfloiqbfkxfjbhjztkpzqrxdythdrbuqvztknnvnkzodmyhocxckrsbmgwabrzpmxgcpkhbzqzwvnmffhlbbogvvwlwghzqdicmgnupgsaxirgoylqsvendiyqvybmschpeweckytokjcryvcqmlwbmwdgqqhjvkxohlebfkgjzhgpvivtubmgalveizzshsxvuppbirxewrkcorqrsvnwqlctcisjtmozodwkvbknoesisehaneatorwqeoprobceghyyhpvhgshligsjbmkbntwzktmqyikcieluayqgbqnoxftyckkdndiuicxolpifbuxclzawwcgdslwquajatwinwelucgaifljkxjcsmukjnzsqrhqjiuxijkxvsoglekwahejlgkjmguzradyzatnagdqgbjdgwsxbblrrxsijcczijcvdonndukbzkzzqrgaxgjyaygxexddhusyovwnvdpzyethytaymqrkdunxnpgxhouuahjeqwbaqzmqdexohfooqfftkykzvdxndckknxdxedrbxtuykohvrrvhgsdysjvbojsckccdpnlkzywfnckktaesyfalrqjsgnblniegywuzzstoyudvfojsugjucjvcvfkecgbuylibvolyueviefdeifiedbnbvdtfatjpnwyzxzentraghhakkcwbxniekiykcxmxqsdsplfsyoowvvcushyrjxpkxbkdbewvrvrtrzhzscuihrgjdxnpfkyxjmpouogyeqxrrbpajluxqwwqmjvivqwfrvdzedyrhichtbnhbqnbiiskiqkpiphiyuokvniymgzggkpyasvbgfpaetunafidreiitdfxfxdvfxxwiaxuftikwwyefmextjvvxmgfauxwqwpdrkcmvewbxhuhjoepmaqpaozgocsjbbifbhtpjzzihrjnqlkbmdmvhtkyhlgawkobxpzrvupchpwdagdghtiqgzibazfnaonqzaukxgimxnkawxkfowfflymymcvxidjmvkliuuhbhmovijfjbnggvzprehlqqxatewtyvtsgxjbworsutdhjagdusdnedewckfkhjdrlgpycujspgnnavtapexdbzusdvskwnvjsidfsvfpqpzclhnvmqctlrxfdbeeenevgrbytqvahylokhxwpujwwiirolrndfthkwvxqgjnrjyrynkdlpvwoeanxydhrytwpetrngkmbloykuauyzjbtdaacqrprezwkxgkfqtyjafnvlzwlcuvhqydozsgquedlkrazdxqgxjixhsvmdnnkfqhkythlitkpxocckgegeamcfrjxriusxvcezwgrhrkeasginvpeiqgiutmwrffvtkpvsxybshjxovhpvyeqvkwiilgxpmdvlnmtevepytjswzpckpkdhlncebjupfyaghkktcblmnkhxobblcfefxkhfvqmazjsxspmthislhfgsqzmyeaojgivobqbglfuagbxngnifzrqrdtpmixnneqkoisqdrdbtkoitbzrfiyejpnmivrjbzifohojegavamfdqnddksplkvimttjjwawmtzoudyrvkbmimjsrvbxitpzhrwbdwyhuagzsdoouqsgzvnnzvbzzltkytayjflbwhacxuzkensnpairswycpldbmwmmyhwoubpjzioiswuzvxwoobarexjyfoniofpgllzhurrdkyosuekpajxvdgqfffjoajtxrwamvenljxbkojfmrflxhoaepobqxushizgtbbakwpggznomtjsowvbfajpmykspdbrjvczetnezwutnrsfgxydmfkritnwpkdjndlghddwexnveywrhaznondknvieasirrggczsvkfwhavvqumlrwsjxdpxilhwfxpwypsmlzourzkdijriqlagqsxvcexidvqqftskzlmpckluqgksriwkmxywdrqpuyzcvdyvytfkngluxfsfavlqvwfkjgteqrgypcmbrfudsjjxwagdqxnyydpxtksjpqkdmlniomdflhwlpaqupmonhjrkslfnufmcgfwdlqjsbttgbhjzfwufvtsktayhhdbvxunxaavkupytawcuffwkgbzjsoylknbdciospjyscfkgbavcbzvdnngmfztpiubosbkspatnqziqntgtkcfcyzmjtsulklzckznzxoithcwxmndsjkhtridkovqcclfvclpsozfuleprzzvqwknxyetjoixdvpecjttokyqsqrkaefjknmfpfyyurfpiinwspmkheymgqbrfijelwhmtmekdeidhqkcuxlqxgdspkcnjakqdhutujacfiqfjscmvvxhrwthcrfslvidxnvarjqjlozicsdblrtznsrsuhxegjjsrrxxghdgzqwgkaqjtwosxpqbblmzzaspncczcamebcaovbajlrwmmksvwswkdctnmpnolvfnulvfiqknqppzcjomurcnuxiirLONGESTPALINDROMICSUBSEQUENCE'
  ```

## 수행단계

- 다이나믹 프로그래밍으로 해결하는데 적절한 회문의 특징을 찾고, 이 특징을 사용해서 가장 긴 회문을 찾는 전략을 찾는다.
- 찾아낸 전략을 사용해서 가장 긴 회문 부분 문자열의 길이와 가장 긴 회문을 반환하는 함수를 dp_exer/palindrom.py 파일에 구현한다.
  - 같은 최대 길이의 회문이 둘 이상 존재하는 경우 모두를 반환한다.
- 제시한 5개의 텍스트에 포함된 가장 긴 회문의 길이와 가장 긴 회문을 반환하는 프로그램을 작성한다.
  - 첫 번째 테스트케이스의 가장 긴 회문의 길이는 1이다. 이 경우는 빈 리스트를 반환한다.

## 결과예시

```
Testcase 1 :
    가장 긴 회문 부분 문자열의 길이 : 1
    가장 긴 회문 부분 문자열의 목록 : []

Testcase 2 :
    가장 긴 회문 부분 문자열의 길이 : 19
    가장 긴 회문 부분 문자열의 목록 : ['wasitacaroracatisaw']
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/palindrom.py 파일에 구현이 되어 있는지 확인한다.
  - 문제를 해결하는데 사용하는 메모리는 정적으로 고정된 크기의 메모리만 사용하는지 확인한다. 물론, 상향식 다이나믹 프로그래밍으로 해결해야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    Testcase 1 :
        가장 긴 회문 부분 문자열의 길이 : 1
        가장 긴 회문 부분 문자열의 목록 : []

    Testcase 2 :
        가장 긴 회문 부분 문자열의 길이 : 19
        가장 긴 회문 부분 문자열의 목록 : ['wasitacaroracatisaw']

    Testcase 3 :
        가장 긴 회문 부분 문자열의 길이 : 7
        가장 긴 회문 부분 문자열의 목록 : ['abcdcba', 'tacocat']

    Testcase 4 :
        가장 긴 회문 부분 문자열의 길이 : 25
        가장 긴 회문 부분 문자열의 목록 : ['asantalivedasadevilatnasa']

    Testcase 5 :
        가장 긴 회문 부분 문자열의 길이 : 7
        가장 긴 회문 부분 문자열의 목록 : ['deified']
    ```

### [문제에 대한 이해]

- 다이나믹 프로그래밍으로 해결하기 위한 회문의 특징을 제시하라.
  - 한 글자로 이루어진 부분 문자열은 모두 회문이다.
  - 두 글자로 이루어진 부분 문자열은 두 글자가 같은 경우에만 회문이다.
  - 세 글자 이상의 부분 문자열은 처음과 마지막 두 글자가 다른 경우 회문이 아니며, 처음과 마지막 두 글자가 같은 경우 이 두 글자를 제외한 나머지 부분도 회문이다.
- 이 특징을 사용해서 다이나믹 프로그래밍 접근법으로 가장 긴 길이 회문의 길이를 구하는 방법을 제시하라.

  - isps[i][j]는 주어진 텍스트의 i번째 글자부터 j 번째 글자 까지가 회문인지의 여부를 저장한다. n은 문자열의 길이이다.
  - isps[i][i] = True이다. (한 글자)
  - isps[i][j]는 다음과 같이 계산할 수 있다.
    - i 번째 글자와 j 번째 글자가 다른 경우 : False
    - i 번째 글자와 j 번째 글자가 같은 경우 : isps[i + 1][j - 1]의 값과 같다. (처음과 마지막 글자를 제외한 경우에 회문인지의 여부)
  - isps를 중복 없이 계산하기 위해서 j - i가 0인 경우부터 n - 1인 경우까지 상향해 계산한다.
  - 계산하면서 최대 길이를 갱신해 나간다.

### [코드 예시]

```python


def longest_palindrom(text):
   n = len(text)
   # 길이가 0인 경우
   if n == 0:
       return 0, ""

   # isps[i][j] : i번째 글자에서 j번째 글자의 부분 문자열이 회문인지 여부를 저장
   isps = [[False] * n for _ in range(n)]
   # longest palindrome length
   lp_length = 1

   # 한 글자 부분 문자열은 항상 회문이다.
   for i in range(n):
       isps[i][i] = True

   # 두 글자 부분 문자열은 두 글자가 같은 경우 회문이다.
   for i in range(n - 1):
       if text[i] == text[i + 1]:
           # 두 글자가 같은 경우 lp_length는 2가 된다.
           isps[i][i + 1] = True
           lp_length = 2

   # 세 글자 이상인 경우, 처음과 끝 글자가 같다면, 이를 제외한 나머지가 회문인지를 확인한다.
   for length in range(3, n + 1):
       for i in range(n - length + 1):
           j = i + length - 1
           # 처음과 끝 글자가 같고, 처음과 끝을 제외한 나머지가 회문인 경우
           if text[i] == text[j] and isps[i + 1][j - 1]:
               isps[i][j] = True
               lp_length = length

   # isps를 사용해 회문을 찾는다.
   # 최장 회문의 길이가 1인 경우 빈 리스트를 반환한다.
   if lp_length == 1:
       return lp_length, []

   lp_list = []
   # 최장 회문의 길이를 기준으로 isps[i][i + lp_length - 1]이 True인 경우
   # i번째 글자에서 j번째 글자 까지가 회문이라는 의미이므로
   # text[i:i + lp_length]를 회문 리스트에 추가한다.
   for i in range(n - lp_length + 1):
       j = i + lp_length - 1
       if isps[i][j]:
           lp_list.append(text[i:j + 1])

   return lp_length, lp_list

def main():
    TC1 = 'oavhdjksqw'
    TC2 = 'wasitacaroracatisaw'
    TC3 = 'zveabcdcbacbetrmhhktbslwnzbdwuopihqhhqxmybqgemlscsyzcsxzztacocatpsxzaljbtanshudeogbsdnujkwqwvclojhxbyilwxbyocnguie'
    TC4 = 'cdbbciconpbxbctvdvcjudwytytqleimpemczcawocxuyepgnmkjuhmmpmvlqbwzmwfblrlurwxrjfcdxaktkilnrwxmnfdxpwvwihwkrmbzykxdyrvlqwyffelkdkinhiymzclpxjhafeticmhrfpvbyaxsecytqxnwqhhhvqgnvwtsgskemgkscdurgfjivivkqdhjnnlbyswmzirzxxfgxvbqlxtgjrsiwofovibpxisafyyiwqqlxyiyjqzdbodrfhizaudszsqtpghajaovrchvodybqnymxfjnxwekukimdvieaffedgskvyeavexnzirzkhrzinbztvpfiqkshlklbuvoodhhytmevvelvuiennquhvernefdakmrkmlyqgkalpkvpuebrpjldpgifrwtbgzyzpzphtspkuagwmllbwfqemtoilwmeaxwxmickrgcirimplrrnrzvdntzzxwgniqylgqbdhadpikvlqhwgfzpaasantalivedasadevilatnasaohyvdilgsrweeyvsggzsxchjfiipsyyzdtufunsatjqjfoewwkwpvenchdlwdyfwbyomqoafcrbqdmzswmbblrsodjcxfyrqazafuywvddiooiipmoxjdbnxzbngrakfnzshaocrqcwggehnneaurbaytjymafsbzemuzpwjshwxjvmjnufabdeluajkdvoobnnwmozdpzbdrewgawaluggpcvdjqpvjsyvuidrwarmokuyscbgoppmuojnnrihkmrnmtdfysmcazubukxegqrkapsoxofsaotapqajeoqdnwxewysuhwdlyltzftvefdhvdhxxhqmmozjzoamycjejbyxjakhfiilynvjvrmxndssgdfmnqxaxmnaelcmqpcotsqnhlmobexlrbvjylvfyerdklltrnluxtimgeuacpqefqxwlsbgcsjiwfzpimcsmmyniczsbgyovoldkfcxsfqxzaekyspjzmvkbroffwnhatbwqesan'
    TC5 = 'zgmexkfvxgxroqtqajchdkduyclujuynanabbenvwlgwotyttrgiqdrecawxknglmcjtywpkfssyfmcouvgeonwaoopirarzeumyeuqahljfgvcowmggixozqhwayonrabxxjznqprsdcxutxiorghnfxvkiuhyryflkitgvajoylsomyuzwoyhvzudfxgdbqiwtitgwuwgqdnperrizowlsuwotzvpzroraivbrrrreybmpyzvffeiuugrsgyaqhitxhigkvbnfmdvlllcvthqgqdxuqjtyifteosfxwhbilhunflosaejntksiqxgwcblrwxxrywqlmqgtskpzhkwrendrnqzsnccmanbjmlcvaxcfhzqiyrtmmtitoykoeueudqjcvnoxlspkwlvwvznocdwfhicoryfonjolqnfeuvlfnkqitxqgbkwyrvhkjuhtlvtosrhdjsmdmqhrlmbgkgdgylneymqqlyfkfuvacnziqnvruhhyzfitcsyxdcaolsnatiwvtkvihbbxisfeohhccnlkktjwyfnihsoklbzodcexjlfvfyrukxzyltqjwfleqnzvlvuypvktqixjpritjpbzjrxutdpkkurgelhvwftzzkjdpnlcdtrivbjlfxwzawvfvxrjworpqaoamlhthekfvnsxemdwlpyoovutksqxnkysblldpgncznuonsaugapresbpjpzhdjcazvpvjentysutczphankwftpxpsciunemvsmtfubjgsuvddyaqvdlxbodbzxbpvhyaeedvmgwmpolhgxjoafkumgzczgasefglyuucwdgoghywioiskaunfbjvxruqtmeieuozeucjhkurtanxzjrztrycfhhwdffrcbcccyclbsyrokpjevpvkbckinhklyudurmcxxpzbjlvaqvunkrrmsllolcxtrexyjcnjwsyhgpmrvrfigskqmilzbkqtlgkdeldohskilpfuoozmedjcsobmvtvkucmoyvwwwaiscngteqgblirticrinhqfbdrhibcgighhsobzkxjephjvxpaefngesfalwityqrvowjtxlxhdubnqbhbdpjemagnedsrxbvcavhiueuznccyaqitirhjxhblghpnxqtzkvoduyceiqcwdntosyvmlmybwfzmeirebxyufzanasthbuwqogellbteepgtibengzpqclwjflqesotgnytpcpuzaitsfqxlqnkmjgfwttfolerjflstzevqwyheblmlotlgsmpbfbodufcvbsbdtgzuytpqikostjjbblzolqbnsoiovelowjjmvigpjlxaygimoyiunzrrylulivwtdlcresppgbefzgxosixlsqirebxccvlltcydloonmvyjmojraqiwflyqfncpspqldcrssnbuluvagmrcrjzhgmoiixpyrrlmjaleasxguyqyvkywwlfqhlvovezznwuutyjioimzlzvwokoqsxrkvdyphjhnoechoikpdulxjkqjbauqtgcnwkkhsmaksdhqhhazycgcurcwwbgrltdrqstdldxjroccstsggyqcfqnwtrrobetewenbtlblmpujfvvvbctsftuhcagugzoeurothxpdbwyzsyczfzpqziigwvlhxdjneovvjuhdrqtstfbrghjlrjwxhftbjdxblnxbtlibltefvhevmqebgqwkkkxcecqgqjfllqtpscvxwvnjadasmrebnfnvpbylfezuzrtnezegkcemfdrtdzevcffdpvvkkucewoxupwqtdpggtidttqtbtlswiccvgpumvfnsvlgaayqgaogyfrvucvmhmgfvcogvyrksdtalnmzulcwueaswqcvzetteoxwukpmdobtkaxbpwbiyrgfoptzzqcrbnydavysbcfwdoqsmfdoowbrbrnsxubmfzcdmbdpvtukfyoomagondpwxmtyrwoaoiqqlaphacsvwpteclmkhzzfuuemhuapnkzbfzgagzuthdwuetweherugwnyanhtefcaqriymfleavmvapjzfknkrhlumaazhjykvrwcjcrfyatbmjzcsccxojvxpnrxwulbbsqntmgqeobqzzvebzdakeywqilcsthjopyniyyrrxvgdbcmtookouvalkfvgtsafsxqizzibuhyshuxvgllyzdrynjwwqivhlybtfakxvuguhtookgvmifxllnpohynhtpxjidebnqbwmnbuzfbqcgehpavmxymvbyrhfltosuruqteblhwpvozriviphdzvrizhhbyolwrfnxtshdrhddjusjukaekaxfxzrblujcvuwwbsbbjeznxnsjyhgvjsxmllzyndblvyqoopclpuxykgdqwygllurofhgyxavytnncckotdwiarlkqoeetrmzrnneseligjakhibumcoiyuclpfblqhtmzfgerfxjwhapvybmrgozwyfloiqbfkxfjbhjztkpzqrxdythdrbuqvztknnvnkzodmyhocxckrsbmgwabrzpmxgcpkhbzqzwvnmffhlbbogvvwlwghzqdicmgnupgsaxirgoylqsvendiyqvybmschpeweckytokjcryvcqmlwbmwdgqqhjvkxohlebfkgjzhgpvivtubmgalveizzshsxvuppbirxewrkcorqrsvnwqlctcisjtmozodwkvbknoesisehaneatorwqeoprobceghyyhpvhgshligsjbmkbntwzktmqyikcieluayqgbqnoxftyckkdndiuicxolpifbuxclzawwcgdslwquajatwinwelucgaifljkxjcsmukjnzsqrhqjiuxijkxvsoglekwahejlgkjmguzradyzatnagdqgbjdgwsxbblrrxsijcczijcvdonndukbzkzzqrgaxgjyaygxexddhusyovwnvdpzyethytaymqrkdunxnpgxhouuahjeqwbaqzmqdexohfooqfftkykzvdxndckknxdxedrbxtuykohvrrvhgsdysjvbojsckccdpnlkzywfnckktaesyfalrqjsgnblniegywuzzstoyudvfojsugjucjvcvfkecgbuylibvolyueviefdeifiedbnbvdtfatjpnwyzxzentraghhakkcwbxniekiykcxmxqsdsplfsyoowvvcushyrjxpkxbkdbewvrvrtrzhzscuihrgjdxnpfkyxjmpouogyeqxrrbpajluxqwwqmjvivqwfrvdzedyrhichtbnhbqnbiiskiqkpiphiyuokvniymgzggkpyasvbgfpaetunafidreiitdfxfxdvfxxwiaxuftikwwyefmextjvvxmgfauxwqwpdrkcmvewbxhuhjoepmaqpaozgocsjbbifbhtpjzzihrjnqlkbmdmvhtkyhlgawkobxpzrvupchpwdagdghtiqgzibazfnaonqzaukxgimxnkawxkfowfflymymcvxidjmvkliuuhbhmovijfjbnggvzprehlqqxatewtyvtsgxjbworsutdhjagdusdnedewckfkhjdrlgpycujspgnnavtapexdbzusdvskwnvjsidfsvfpqpzclhnvmqctlrxfdbeeenevgrbytqvahylokhxwpujwwiirolrndfthkwvxqgjnrjyrynkdlpvwoeanxydhrytwpetrngkmbloykuauyzjbtdaacqrprezwkxgkfqtyjafnvlzwlcuvhqydozsgquedlkrazdxqgxjixhsvmdnnkfqhkythlitkpxocckgegeamcfrjxriusxvcezwgrhrkeasginvpeiqgiutmwrffvtkpvsxybshjxovhpvyeqvkwiilgxpmdvlnmtevepytjswzpckpkdhlncebjupfyaghkktcblmnkhxobblcfefxkhfvqmazjsxspmthislhfgsqzmyeaojgivobqbglfuagbxngnifzrqrdtpmixnneqkoisqdrdbtkoitbzrfiyejpnmivrjbzifohojegavamfdqnddksplkvimttjjwawmtzoudyrvkbmimjsrvbxitpzhrwbdwyhuagzsdoouqsgzvnnzvbzzltkytayjflbwhacxuzkensnpairswycpldbmwmmyhwoubpjzioiswuzvxwoobarexjyfoniofpgllzhurrdkyosuekpajxvdgqfffjoajtxrwamvenljxbkojfmrflxhoaepobqxushizgtbbakwpggznomtjsowvbfajpmykspdbrjvczetnezwutnrsfgxydmfkritnwpkdjndlghddwexnveywrhaznondknvieasirrggczsvkfwhavvqumlrwsjxdpxilhwfxpwypsmlzourzkdijriqlagqsxvcexidvqqftskzlmpckluqgksriwkmxywdrqpuyzcvdyvytfkngluxfsfavlqvwfkjgteqrgypcmbrfudsjjxwagdqxnyydpxtksjpqkdmlniomdflhwlpaqupmonhjrkslfnufmcgfwdlqjsbttgbhjzfwufvtsktayhhdbvxunxaavkupytawcuffwkgbzjsoylknbdciospjyscfkgbavcbzvdnngmfztpiubosbkspatnqziqntgtkcfcyzmjtsulklzckznzxoithcwxmndsjkhtridkovqcclfvclpsozfuleprzzvqwknxyetjoixdvpecjttokyqsqrkaefjknmfpfyyurfpiinwspmkheymgqbrfijelwhmtmekdeidhqkcuxlqxgdspkcnjakqdhutujacfiqfjscmvvxhrwthcrfslvidxnvarjqjlozicsdblrtznsrsuhxegjjsrrxxghdgzqwgkaqjtwosxpqbblmzzaspncczcamebcaovbajlrwmmksvwswkdctnmpnolvfnulvfiqknqppzcjomurcnuxiirLONGESTPALINDROMICSUBSEQUENCE'
    testcases = [TC1, TC2, TC3, TC4, TC5]
    for i, testcase in enumerate(testcases):
        lps_length, lps_list = longest_palindrom(testcase)
        print(f"Testcase {i+1} :")
        print(f"    가장 긴 회문 부분 문자열의 길이 : {lps_length}")
        print(f"    가장 긴 회문 부분 문자열의 목록 : {lps_list}")
        print()


if __name__ == "__main__":
    main()
```
# 단계 7. 자료구조를 활용한 알고리즘

## 스토리

유전자 정보를 연구하는 G 연구원과 T 연구원은 학창 시절부터의 절친이었다. 어쩌다보니 같은 직장에서 근무하게 된 두 사람은 종종 식사나 술자리를 함께 하면서 여전히 좋은 관계를 유지하고 있었다. 어느 가을 저녁, 두 사람은 연구소 근처 맛집에서 저녁을 먹고 있었다. T 연구원은 연구소 밖에서 업무 이야기하는 것을 좋아하지는 않았지만, 요즘 잘 안풀리는 문제가 있다며 G 연구원에게 의견을 물어봤다.

“우리 연구 그룹에서 개발한 스마트 마우스 기억나지?”

“응. 기억 능력에 연산 능력이 있을지도 모른다고 발표했던 그 쥐 말하는거지?”

“응. 그런데 문제가 있어.”

“뭔데?”

“쥐의 지능을 검증하려고 하는데, 우리가 멍청한게 문제지.”

이렇게 시작한 사연은 다음과 같았다.

스마트 동물 연구 그룹에서 개발한 “영리한 쥐”가 연산 능력과 학습 능력이 있는지를 확인하기 위해 다음과 같은 실험을 설계했다.

방이 N개가 있는 미로를 설치한다. 각 방은 1번 방에서 N번 방까지 이름이 붙어 있고, 시작 지점은 방은 아니지만 편의상 0번 방이라고 부르고 있다. 0번 방은 N개의 통로가 있고, 1번 방에서 N번 방까지 연결되어 있다. 1번 방은 N-1개의 통로가 있고 2번 방에서 N번 방까지 연결되어 있다. 이런 식으로 K번 방은 K+1번 방부터 N번 방까지 연결된 통로를 가지고 있다. 각 통로는 길이가 정해져 있으며, 쥐들의 속도는 모두 일정하다. 그리고 N번 방에 도착하면 보상을 주는데, 빨리 도착할 수록 보상이 좋아진다.

“그래서 보상이 뭐야?”

“응. 8년 숙성된 냄새가 엄청난 치즈. 쥐가 그 냄새를 맡으면 미칠 듯이 좋아하더라구. 문제는, 이 치즈가 싸구려라서 시간이 지나면 지날 수록 냄새가 점점 사라진다는건데…”

“그래서?”

“이 치즈 냄새가 통로에 퍼지니까, 기를 쓰고 쥐들이 달리더라구.”

“그리고?”

“영리한 쥐가 매번 1등을 했지.”

“그러면 입증된거 아니야?”

“그런데, 영리한 쥐가 점점 학습을 해서 더 영리해지고 있는지를 확인해야 하니까. 그런데 문제는 영리한 쥐가 최선의 선택을 했는지 확인해보고 싶은데… 그게 계산이 잘 안되더라구.”

“음. 혹시, 실험할 때 방은 몇 개 설치한거야?”

“적당히 설치했어. 한 1000개 정도?”

G 연구원은 순간 할 말을 잃었다. 방이 1000개인 미로라면 방과 방 사이의 통로의 개수만 499500개이다. 적당히라는게 뭔지 모르는 녀석. 아니, 우리 연구소 실험 예산 괜찮은거야?

---

# 문제 1. 이진 검색 트리

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

유전자 목록을 만들고 정렬하는 일을 하고 있는 G 연구원은 문득 이런 생각이 들었다.

'굳이 별도로 정렬을 하지 않고도 자동으로 유전자를 등록하면 정렬이 된 목록이 만들어진다면 더 빠르게 정렬된 목록울 가지게 되지 않을까?'

이 생각을 프로그래밍 지원 게시판에 게시하자, 그 글에 이진 검색 트리를 사용하면 된다는 답변이 달렸다.

## 수행목표

- 값을 사용해서 노드에 추가하면 정렬된 목록을 생성하는데 최적화된 구조로 트리가 생성되는 이진트리를 구현한다.
- 첨부한 파일은 이진트리를 다음과 같이 구성하면서 중간중간 목록을 출력하라는 지시를 포함하고 있다.

  - init : 이진트리를 초기화한다.
  - print : 이진트리에서 오름차순으로 정렬된 목록을 만든 다음, 다음 함수를 사용해 이 목록의 간이 해시값을 출력한다.

  ```python
  import hashlib

  def hash4_from_list(arr):
   return hashlib.sha256(str(arr).encode()).hexdigest()[:4]

  ```

  - 값 - : 지정한 값을 삭제한다.
  - 값 : 지정한 값을 추가한다.

- 첨부한 파일의 지시에 따라 이진트리를 구성하고 출력한다.

## 수행 단계

- 다음 설명에 부합하는 이진 트리를 만드는 파이썬 클래스와 함수를 ds_more/well_made_tree.py 파일에 구현한다.
  - 트리의 노드는 정렬해야 할 값을 저장하는 변수를 가진다. 이 변수는 문자열, 숫자 등 크기를 비교할 수 있는 대상이면 무엇이든 저장할 수 있다.
  - 이 트리를 중위 순회 방식으로 탐사하면서 트리에 포함된 모든 노드의 목록을 작성하는 함수를 구현한다.
  - 값을 사용해서 트리에 노드를 추가하는 함수를 구현한다. 이렇게 생성된 트리를 중위 순회 방식으로 탐사하면서 목록을 생성하면 오름차순으로 정렬된 목록이 만들어진다.
  - 값을 사용해서 트리의 노드를 삭제하는 함수를 구현한다. 삭제하려는 값이 여러 개 있는 경우 그중 하나만 삭제하며, 값이 없는 경우는 트리를 변경하지 않는다. 노드를 삭제하고 난 뒤에도 트리를 주우이 순회 방식으로 탐사하면서 목록을 생성하면 오름차순으로 정렬된 목록이 만들어진다.
- 첨부한 파일은 숫자 또는 간단한 유전자 염기서열을 사용해 이진트리에 값을 추가, 삭제, 초기화하고, 중간중간 현재의 트리의 오름차순 목록을 만든 후, 이 목록의 간이 해시값을 출력하라는 지시사항을 포함하고 있다.
  - 단, 이 목록에 주어진 값이 숫자이더라도 문자열로 취급해서 추가한다. 예를 들어 목록의 10은 숫자 10이 아니라 문자열 '10'으로 취급해 트리에 추가하라는 이야기이다.
- 지시 사항에 따라 순서대로 트리를 구성하고 간이 해시값을 출력한다.

## 결과 예시

```
1aaa
3adb
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - ds_more/well_made_tree.py 파일에 구현이 되어 있는지 확인한다.
  - 목록을 생성할 때 별도의 정렬 없이 중위 순회 만으로 오름차순 정렬된 목록을 생성하도록 구현하였는지 확인한다.
  - 생성된 트리가 이진 검색 트리의 구조를 가지고 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

```
1aaa
3adb
1aaa
dde1
3adb
5159
daf7
8a3d
f07e
fd6e
1268
7eb1
f49f
d538
099c
66db
78f3
78f3
5e2b
fd31
3c6a
c201
4f53
52d9
bce0
1887
f8b3
d99f
837b
97e2
5d6c
bba1
d018
4cbf
16fd
0a6d
ad93
a144
7908
94e3
3396
cfb0
3f4e
```

### [문제에 대한 이해]

- 이 트리에 노드를 추가하는 과정을 설명하라.
  - 루트 노드로부터 값을 비교해서 이진 검색 트리의 구조를 유지할 수 있는 위치를 찾아 해당 위치에 노드를 추가한다는 내용을 설명할 수 있는지 확인한다.
- 이 트리에 노드를 삭제하는 과정을 설명하라. 삭제할 노드를 찾는 과정과 자식이 있는 경우, 자식이 없는 경우 각각 노드를 삭제하는 방법을 설명하라.
  - 이진 검색 트리의 특성을 활용해 삭제할 노드를 확인하는 설명을 제시하는지 확인한다.
  - 삭제할 노드의 자식 노드가 있는 경우 자식 노드가 하나, 둘 인 경우 각각에 대해서 자식 노드들이 링크를 잃어버리지 않도록 삭제할 수 있는지 확인한다.
- 트리에 노드를 추가, 삭제하는 함수의 시간 복잡도를 제시하라.
  - 정상적인 이진검색 트리의 구현의 경우는 로그 시간복잡도로 구현이 된다.
  - 만약 문제의 조건에 부합하면서도 이진검색 트리를 사용하지 않은 경우, 구현에 맞는 시간 복잡도를 제시할 수 있는지 확인한다.

### [코드 예시]

```python
class BSTNode:
    def __init__(self, value):
        self.value = value
        self.left_child = None
        self.right_child = None

def inorder_list(root):
    if root == None:
        return []
    return inorder_list(root.left_child) + [root.value] + inorder_list(root.right_child)

def insert(node, value):
    if node == None:
        return BSTNode(value)
    if value < node.value:
        node.left_child = insert(node.left_child, value)
    else:
        node.right_child = insert(node.right_child, value)
    return node

def remove(root, value):
    if root == None:
        return None
    if value < root.value:
        root.left_child = remove(root.left_child, value)
    elif value > root.value:
        root.right_child = remove(root.right_child, value)
    else:
        if root.left_child == None:
            return root.right_child
        if root.right_child == None:
            return root.left_child
        temp = root.right_child
        while temp.left_child != None:
            temp = temp.left_child
        root.value = temp.value
        root.right_child = remove(root.right_child, temp.value)
    return root

import hashlib

def hash4_from_list(arr):
    return hashlib.sha256(str(arr).encode()).hexdigest()[:4]

def main():
    root = None
    with open("well_made_tree_data.txt", "r") as f:

        while True:
            line = f.readline().strip()
            if not line:
                break
            if line == "init":
                root = None
            elif line == "print":
                print(hash4_from_list(inorder_list(root)))
            elif line[-1] == '-':
                value, _ = line.split(" ")
                root = remove(root, value)
            else:
                value = line
                root = insert(root, value)
if __name__ == '__main__':
    main()
```

---

# 문제 2. 높이가 유지되는 트리

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

K 연구원 이진 검색 트리를 사용해서 빠르게 정렬된 목록을 생성할 수 있게 되었다. 이것 만으로 충분히 만족할 수 있었지만, 다른 기능의 성능도 조금 더 높이고 싶은 욕심이 생겼다. 특정 값이 이 트리에 포함되어 있는지를 확인하는 기능인데, 이 기능은 트리의 왼쪽 오른쪽의 균형이 유지될 때 가장 빠르게 동작한다는 사실을 알게 되었다.

K 연구원은 이진 검색 트리에 데이터를 추가할 때, 이와 같이 균형잡힌 트리를 유지하는 방법이 궁금해졌다.

## 수행목표

- 다음의 성격을 가진 이진 검색 트리를 만든다.
  - 각 노드는 일반적인 이진 검색 트리와 마찬가지로 값, 왼쪽과 오른쪽 자식 노드의 포인터를 가지며, 추가
- 다음과 같은 성격을 가진 이진 검색 트리를 만드는 노드 추가 함수를 구현한다.
  - 트리에 새로운 항목을 추가할 때 이진 검색 트리의 기본 성격을 유지한다.
  - 어떤 순간에서도 트리에 포함된 모든 노드는 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 1 또는 0으로 유지된다.
  - 노드를 추가하는 함수의 시간 복잡도는 O(log n)이다.
- 이러한 성격을 유지하면서 특정 값을 가진 노드를 삭제하는 함수를 구현한다.
  - 트리에 지정한 값을 가진 항목 중 하나를 삭제하는 경우, 그 이후에도 이진 검색 트리의 기본 성격을 유지한다.
  - 어떤 순간에서도 트리에 포함된 모든 노드는 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 1 또는 0으로 유지된다.
  - 노드를 삭제하는 함수의 시간 복잡도는 O(log n)이다.
- 다음 첨부한 테스트케이스는 5개의 유전자 시퀀스 데이터와 5개의 숫자 데이터의 목록으로 구성되어 있다.
  - 각각의 테스트케이스는 두 부분으로 나뉘어져 있다. 첫 번째 부분은 트리를 생성하는 과정이며, 목록의 각 항목은 값과 함께 +, -의 지시자가 함께 제공되는데 +의 경우는 노드에 해당 값을 가지는 항목을 추가하라는 지시자이며, -는 해당 값을 가지는 항목을 삭제하라는 지시자이다. 만약 해당 값을 가지는 항목이 없는 경우, 삭제하지 않는다.
  - 두 번째 부분 역시 +, - 지시자에 따라 트리에 항목을 추가하거나 삭제하는데, 두 번째 부분의 값을 가지는 노드의 값을 추가하거나 삭제하는 경우, 트리의 중위 순회 탐색의 순서를 기준으로 왼쪽 서브 트리의 높이와 오른쪽 서브 트리의 높이를 괄호로 묶어서 출력한다.

## 수행단계

## 결과예시

```

```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/max_sales.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방식으로 구현하였는지 확인한다. 만약 하향식 다이나믹 프로그래밍 방법으로 구현한 경우 메모이제이션이 적용되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다.

    ```
    TC 1:
    최대 매출 : 10억원
    판매 방법 :
        2단위 주문 : 2회

    TC 2:
    최대 매출 : 22억원
    판매 방법 :
        6단위 주문 : 1회
        2단위 주문 : 1회

    TC 3:
    최대 매출 : 10억원
    판매 방법 :
        1단위 주문 : 10회

    TC 4:
    최대 매출 : 10억원
    판매 방법 :
        10단위 주문 : 1회

    TC 5:
    최대 매출 : 267억원
    판매 방법 :
        35단위 주문 : 1회
        34단위 주문 : 1회
        29단위 주문 : 1회
        2단위 주문 : 1회
    ```

### [보너스 과제의 확인]

- 보너스 과제를 지시대로 해결하였는가?
  - 문제의 구조를 사용하는 재귀 호출 방식으로 구현하고 있는지 확인한다.
- 결과가 정확한가?

  - 결과 예시는 다음과 같다.

    ```
    TC 1:
        최대 매출 : 10억원
        판매 방법 :
            2단위 주문 : 2회
        잔여 처리 용량 : 0단위

    TC 2:
        최대 매출 : 16억원
        판매 방법 :
            3단위 주문 : 2회
        잔여 처리 용량 : 2단위

    TC 3:
        최대 매출 : 5억원
        판매 방법 :
            2단위 주문 : 5회
        잔여 처리 용량 : 0단위

    TC 4:
        최대 매출 : 10억원
        판매 방법 :
            8단위 주문 : 1회
            2단위 주문 : 1회
        잔여 처리 용량 : 0단위

    TC 5:
        최대 매출 : 266억원
        판매 방법 :
            29단위 주문 : 3회
            13단위 주문 : 1회
        잔여 처리 용량 : 0단위
    ```

### [문제에 대한 이해]

- n = 4, prices = [1, 5, 8, 9]일 때 최대 매출은 얼마이며, 이 때의 판매 방법은 어떻게 될까?
  - 최고의 매출을 기록하기 위해서는 2단위씩 2번 주문을 받으면 된다. 이 때의 매출은 10억원이다.
- i단위의 요청을 처리했을 때 기대 가능한 최대 매출은 얼마인가? 처리 가능한 용량이 n일 때의 기대 가능한 최대 매출을 max_sales(n)이라 표현하고, i 단위의 가격을 price(i)라고 할 때, 최대 매출을 max_sales와 price를 사용해서 표현하라.
  - i단위의 요청을 처리했을 때의 기대 가능한 최대 매출 : price[i] + max_sales(n - i)
- 문제의 구조를 제시하라.
- 구현한 방식의 시간 복잡도는 얼마인가?

### [코드 예시]

```python

```

---

# 문제 3. 트리의 지름

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

한 세대가 끝나면 여러 개체로 분화해서 새로운 세대를 시작하는 미생물이 있다. E 연구원이 속한 연구 그룹은 이 미생물의 돌연변이를 연구하는 과정에서, ‘특정 돌연변이 개체’가 발생했다가 소멸하는 현상을 발견했다. 이 돌연변이 개체는 공해 물질을 분해하는 능력을 가지게 되어 매우 유용한 발견이지만, 문제는 이 돌연변이 개체는 발생했다가 몇 세대를 지나면 사라진다는 점이었다. 이 돌연변이의 여파로 세대가 종료될 때의 분화하는 개체 수는 최대 2로 제한되었고, 그나마 분화를 하지 못하고 생을 마감하는 개체도 많았기 때문이다.

이 돌연변이 개체를 최대한 길게 유지하기 위한 유도 약물의 개발을 연구하는 과정에서 약물의 효능을 검증하기 위해서 돌연변이가 발생한 개체를 루트로 하고, 돌연변이가 유지된 자손들로 구성된 가계도 트리를 만들었다. 트리의 부모와 자식 사이의 거리를 1이라고 할 때, 이 트리에 포함된 두 노드의 거리가 길면 길수록 약물의 효능이 좋다고 평가할 수 있다.

## 수행목표

- 트리에서 두 노드의 거리는 두 노드 사이에 연결의 갯수로 정의한다. 이 정의를 따르면 부모 노드와 자식 노드의 사이의 거리는 1이된다. 그리고 어떤 트리에서 거리가 가장 먼 두 노드 사이의 연결을 트리의 지름이라고 하며, 이 두 노드 사이의 거리를 트리의 지름의 길이라 한다.
- 어떤 이진 트리의 루트 노드가 주어졌을 때, 이 트리의 지름의 길이를 반환하는 함수를 구현한다.
- 첨부한 파이썬 코드를 사용해 트리 7개의 루트 노드를 얻을 수 있다. 이 4개의 트리에 대애서 각각의 트리의 지름을 출력한다.

## 수행단계

- 다음 예제와 예제에 대한 질문을 통해서 문제 해결의 실마리를 찾는다.
  - 다음 그림의 트리에서 루트 노드의 왼쪽 서브 트리의 높이는 2, 오른쪽 서브 트리의 높이는 2, 그리고 트리 지름의 길이는 6이다.
    ![Alt text](ch7_1.png)
  - 다음 그림의 트리에서 루트 노드의 왼쪽 서브 트리의 높이는 3, 오른쪽 서브 트리의 높이는 0이다.
    ![Alt text](ch7_2.png)
    - 이 트리에서 루트 노드를 지나야 연결이 가능한 두 노드 사이에 가장 거리가 먼 두 노드와, 두 노드 사이의 거리는 얼마인가?
    - 이 트리에서 가장 먼 거리가 먼 두 노드와, 두 노드 사이의 거리 (즉 트리의 지름의 길이)는 얼마인가?
- 이 문제는 다이나믹 프로그래밍 예제에서 그러했듯 하향식, 상향식 두 가지 접근 방법 각각을 사용해 해결할 수 있다. 두 가지 방법 중 하나를 택해서 구현 방법을 정리한다.
- 주어진 노드를 루트로 하는 트리의 지름을 구하는 함수를 ds_more/tree_diameter1.py 파일에 구현한다.
- 첨부한 파이썬 코드의 get_testcases 함수는 어떤 트리의 루트를 항목으로 하는 리스트를 반환한다. 여기에는 7개 트리의 루트가 포함되어 있다.
  - 이 7개의 트리의 지름의 값을 출력한다.
  - 첨부한 파이썬 코드에는 이진 트리를 만드는 파이썬 클래스가 포함되어 있다. 이 클래스의 구조를 확인한 후 구현해야 한다.

## 결과예시

```
Testcase 1 트리의 지름 : 6
Testcase 2 트리의 지름 : 6
(이하 생략)
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - ds_more/tree_diameter1.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 실행 시간은 다를 수 있다.

    ```
    Testcase 1 트리의 지름 : 6
    Testcase 2 트리의 지름 : 6
    Testcase 3 트리의 지름 : 6
    Testcase 4 트리의 지름 : 7
    Testcase 5 트리의 지름 : 1
    Testcase 6 트리의 지름 : 43
    Testcase 7 트리의 지름 : 55
    ```

### [문제에 대한 이해]

- (상향식 접근 방법으로 구현한 경우)가장 작은 문제는 무엇인가?
  - 문제를 특정 노드를 지나가는 트리의 지름으로 정의하면, 리프 노드에 가까울 수록 서브 트리를 감안한 트리의 지름을 계산해야 하므로, 가장 작은 문제는 루트에서 가장 먼 노드를 지나가는 트리의 지름을 구하는 문제가 된다.
- (상향식 접근 방법으로 구현한 경우)상향식 접근 방법으로 트리의 지름을 계산하는 방법을 설명하라.
  - 1단계에서는 트리의 레벨 별로 각 노드를 분류한다.
  - 레벨 별 노드를 저장하는 딕셔너리를 만들고, BFS 방식으로 트리를 탐색해 트리의 모든 노드를 레벨 별 딕셔너리에 저장한다.
  - 2단계에서는 레벨이 높은, 즉 루트 노드에서 먼 노드들부터 상향식으로 모든 노드를 지나가는 트리의 지름을 구해서 올라간다.
  - 이를 위해서 작은 문제의 결과를 저장할 딕셔너리 diameter와 height를 선언한다.
  - 상위 문제의 높이는 하위 문제들 (즉 왼쪽 서브트리의 높이, 오른쪽 서브 트리의 높이) 의 최대값 + 1이 된다.
  - 상위 문제의 지름은 하위 문제들의 최대값이다. 이 때 하위 문제들은 트리의 지름에 해당하는 경로가 현재 노드를 지나가는 경우(왼쪽 서브 트리의 높이 + 오른쪽 서브 트리의 높이 + 2), 현재 노드를 지나가지 않고 왼쪽 서브 트리에 트리의 지름이 속한 경우 (왼쪽 서브 트리의 지름), 오른쪽 서브 트리에 트리의 지름이 속한 경우 (오른쪽 서브 트리의 지름)으로 구성된다.
  - 최종적으로 루트 노드를 기준으로 트리의 지름을 반환한다.
- (하향식 접근 방법으로 구현한 경우)문제의 구조를 설명하는 점화식을 제시하라.
  - 트리의 높이는 리프 노드 중 루트와 가장 먼 리프 노드와의 거리이다.
  - 이 리프 노드는 루트 노드의 두 자식 노드 중 하나의 자손 노드이다.
  - 부모와 자식 노드 사이의 거리는 1이다.
  - 이상의 상황을 종합해 node를 루트로 하는 서브 트리의 높이를 `height(node)`라고 하면 점화식은 다음과 같이 작성할 수 있다.
  - `height(node) = max(height(node.left), height(node.right)) + 1`
- 구현한 함수의 시간 복잡도를 제시하라.
  - 상향식, 하향식 모두 최적 구현은 O(n) 시간 복잡도를 가진다.

### [코드 예시]

```python
from tree_diameter_data import get_testcases
from collections import deque

# 트리의 높이 계산
def height(node, memo):
    # 메모이제이션
    if node in memo:
        return memo[node]
    if node == None:
        return -1

    # 왼쪽 자식 노드의 높이와 오른쪽 자식 노드의 높이를 사용해 현재 노드의 높이를 계산 (재귀 호출)
    memo[node] = 1 + max(height(node.left, memo), height(node.right, memo))
    return memo[node]

# 트리의 지름 계산 하향식 접근 방법
def tree_diameter2(node, memo = None):
    # 메모이제이션에 사용할 딕셔너리 초기화
    if memo == None:
        memo = {}
    if node == None:
        return 0
    # 왼쪽 트리의 지름
    left_diameter = tree_diameter2(node.left, memo)
    # 오른쪽 트리의 지름
    right_diameter = tree_diameter2(node.right, memo)
    # 현재 트리의 지름은
    #   1. 현재 노드를 지나는 경로의 최고 거리
    #   2. 왼쪽 서브 트리의 지름
    #   3. 오른쪽 서브 트리의 지름
    # 중 최대값이다.
    return max(height(node.left, memo) + height(node.right, memo) + 2,
                left_diameter,
                right_diameter)

# 트리의 지름 계산 상향식 접근 방법
def tree_diameter1(root, memo = None):
    if not root:
        return {}

    # 1단계 - 레벨별 노드를 저장하는 딕셔너리를 생성한다.
    # 레벨별 노드를 저장할 딕셔너리
    level_dict = {}
    # 루트 노드를 레벨과 함께 큐에 저장한다.
    queue = deque([(root, 0)])
    # 트리의 최대 레벨
    max_level = 0

    while queue:    # 큐가 빌 때까지 반복
        node, level = queue.popleft()   # 큐의 첫번째 항목의 노드와 레벨

        # 현재 레벨의 노드를 딕셔너리에 추가
        if level not in level_dict:
            level_dict[level] = []
            max_level = level
        level_dict[level].append(node)

        # 자식 노드를 큐에 추가
        if node.left:
            queue.append((node.left, level + 1))
        if node.right:
            queue.append((node.right, level + 1))

    # 2단계 - 상향식으로 모든 노드의 트리의 지름을 구한다.
    diameter = {}
    height = {}
    # 최대 레벨, 즉 가장 아래쪽부터 역순으로 루트까지 반복
    for i in range(max_level, -1, -1):
        # 각 레벨의 모든 노드에 대해서
        for node in level_dict[i]:
            if node.left == None:       # 왼쪽 자식 노드가 없으면
                left_height = -1
                left_diameter = -1
            else:                       # 왼쪽 자식 노드가 있으면
                left_height = height[node.left]
                left_diameter = diameter[node.left]
            if node.right == None:      # 오른쪽 자식 노드가 없으면
                right_height = -1
                right_diameter = -1
            else:                       # 오른쪽 자식 노드가 있으면
                right_height = height[node.right]
                right_diameter = diameter[node.right]

            # 높이와 지름을 계산
            height[node] = 1 + max(left_height, right_height)
            diameter[node] = max(left_height + right_height + 2,
                                    left_diameter,
                                    right_diameter)
    return diameter[root]

def main():
    testcases = get_testcases()
    for i, tc in enumerate(testcases):
        print(f"Testcase {i + 1} 트리의 지름 : {tree_diameter1(tc)}")

if __name__ == "__main__":
    main()
```

---

# 문제 4. 가장 사이가 먼 이들

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

개체의 세대가 바뀜에 따라서 유전자의 돌연변이는 조금씩 생기기 마련이다. 즉, 현재의 트리에서 관계가 가장 먼 두 개체를 비교하면, 조금 더 길게 번식하는 미생물을 만드는 단서를 찾을 수 있을지도 모른다.

E 연구원은 트리의 지름 뿐 아니라, 지름에 해당하는 가장 먼 두 개체를 찾는 작업에 들어갔다.

## 수행목표

- 트리의 지름을 찾는 알고리즘을 사용해 트리에서 가장 먼 두 노드의 쌍을 찾는 함수를 구현한다.
- 이 함수를 사용해 트리에서 가장 먼 두 노드의 쌍을 찾아 이를 출력한다.
  - 트리에서 가장 먼 두 노드의 쌍은 여러개가 존재할 수 있다. 모든 쌍을 찾아 출력한다.
- 테스트데이터는 이전 문제와 동일한 첨부 파일을 사용해 7개의 테스트케이스를 사용할 수 있다.
  - 출력하는 값은 노드의 값을 사용해 출력한다. 테스트케이스 1의 트리는 120의 값을 가진 노드와 160의 값을 가진 노드, 그리고 140의 값을 가진 노드와 160의 값을 가진 노드 간 거리가 6으로 가장 길다. 이 경우 [(120, 160), (140, 160)]을 출력한다.

## 수행단계

- 이전 문제에서 구현한 트리 지름을 계산하는 알고리즘을 토대로 가장 먼 두 노드의 쌍을 찾는 방법을 정리한다.
- 트리의 루트노드가 주어졌을 때, 이 트리에서 지름에 해당되는 거리에 있는 두 노드의 쌍으로 구성된 리스트를 반환하는 함수를 ds_more/tree_diameter2.py 파일에 구현한다.
- 테스트케이스는 이전 문제와 마찬가지로 첨부 파일의 get_testcases 함수를 호출하면 7개의 테스트용 트리의 루트 노드를 얻을 수 있다. 이 7개의 트리에서 가장 먼 노드 쌍을 모두 찾아 출력한다.

## 결과 예시

```
Testcase 1
    트리의 지름 : 6
    가장 먼 노드 쌍 : [(120, 160), (140, 160)]

Testcase 2
    트리의 지름 : 6
    가장 먼 노드 쌍 : [(120, 160), (140, 160)]
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - ds_more/tree_diameter2.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    Testcase 1
        트리의 지름 : 6
        가장 먼 노드 쌍 : [(120, 160), (140, 160)]

    Testcase 2
        트리의 지름 : 6
        가장 먼 노드 쌍 : [(120, 160), (140, 160)]

    Testcase 3
        트리의 지름 : 6
        가장 먼 노드 쌍 : [(120, 200), (140, 200), (160, 200), (120, 160), (140, 160)]

    Testcase 4
        트리의 지름 : 7
        가장 먼 노드 쌍 : [(120, 210), (140, 210), (160, 210)]

    Testcase 5
        트리의 지름 : 1
        가장 먼 노드 쌍 : [(100, 200)]

    Testcase 6
        트리의 지름 : 43
        가장 먼 노드 쌍 : [(-93, -10), (-93, -7), (-84, -10), (-84, -7)]

    Testcase 7
        트리의 지름 : 55
        가장 먼 노드 쌍 : [(-40, 56)]

    ```

### [문제에 대한 이해]

- 어떤 노드가 주어졌을 때 트리의 지름이 그 노드를 지나는 경우, 이 노드의 서브트리에서 가장 먼 두 노드는 어떻게 찾을 수 있을까?
  - 왼쪽 서브트리에서 이 노드로 부터 가장 먼 노드, 즉 왼쪽 서브트리에서 가장 레벨이 큰 노드와 오른쪽 서브트리에서 이 노드로부터 가장 먼 노드, 즉 오른쪽 서브트리에서 가장 레벨이 큰 노드가 가장 먼 노드이다.
- 어떤 노드가 주어졌을 때 트리의 지름이 그 노드를 지나지 않는 경우, 이 노드의 서브트리에서 가장 먼 두 노드는 어떻게 찾을 수 있을까?
  - 왼쪽 서브트리에서 가장 먼 두 노드와 오른쪽 서브트리에서 가장 먼 두 노드 중 더 먼 노드이다.

### [코드 예시]

```python
from tree_diameter_data import get_testcases
from collections import deque

def furthest_nodes(root, memo = None):
    if not root:
        return {}

    # 1단계 - 레벨별 노드를 저장하는 딕셔너리를 생성한다.
    # 레벨별 노드를 저장할 딕셔너리
    level_dict = {}
    # 루트 노드를 레벨과 함께 큐에 저장한다.
    queue = deque([(root, 0)])
    # 트리의 최대 레벨
    max_level = 0

    while queue:    # 큐가 빌 때까지 반복
        node, level = queue.popleft()   # 큐의 첫번째 항목의 노드와 레벨

        # 현재 레벨의 노드를 딕셔너리에 추가
        if level not in level_dict:
            level_dict[level] = []
            max_level = level
        level_dict[level].append(node)


        # 자식 노드를 큐에 추가
        if node.left:
            queue.append((node.left, level + 1))
        if node.right:
            queue.append((node.right, level + 1))


    # 2단계 - 상향식으로 모든 노드의 트리의 지름을 구한다.
    diameter = {}
    height = {}
    farthest_child_data = {}
    # 최대 레벨, 즉 가장 아래쪽부터 역순으로 루트까지 반복
    for i in range(max_level, -1, -1):
        # 각 레벨의 모든 노드에 대해서
        for node in level_dict[i]:
            if node.left == None:       # 왼쪽 자식 노드가 없으면
                left_height = -1
                left_diameter, left_diameter_pair = -1, []
                left_farthest_child_data = [root.data]
            else:                       # 왼쪽 자식 노드가 있으면
                left_height = height[node.left]
                left_diameter, left_diameter_pair = diameter[node.left]
                left_farthest_child_data = farthest_child_data[node.left]
            if node.right == None:      # 오른쪽 자식 노드가 없으면
                right_height = -1
                right_diameter, right_diameter_pair = -1, []
                right_farthest_child_data = [root.data]
            else:                       # 오른쪽 자식 노드가 있으면
                right_height = height[node.right]
                right_diameter, right_diameter_pair = diameter[node.right]
                right_farthest_child_data = farthest_child_data[node.right]


            # 높이와 지름을 계산하면서 가장 먼 자손 노드의 데이터도 저장한다.
            if left_height > right_height:
                height[node] = 1 + left_height
                farthest_child_data[node] = left_farthest_child_data
            elif left_height < right_height:
                height[node] = 1 + right_height
                farthest_child_data[node] = right_farthest_child_data
            else:   # 왼쪽과 오른쪽의 높이가 같은 경우, 양쪽의 가장 먼 자손 노드의 데이터를 합친다.
                height[node] = 1 + left_height
                farthest_child_data[node] = left_farthest_child_data + right_farthest_child_data

            if height[node] == 0:
                farthest_child_data[node] = [node.data]

            diameter_current_node = left_height + right_height + 2
            diameter_from_child = max(left_diameter, right_diameter)

            if diameter_current_node >= diameter_from_child:
                # 트리의 지름이 현재 노드를 지나는 경우
                combi = []
                # 왼쪽 서브 노드에서 가장 먼 노드와 오른쪽 서브 노드에서 가장 먼 노드의 쌍을 구한다.
                for left_data in left_farthest_child_data:
                    for right_data in right_farthest_child_data:
                        combi.append((left_data, right_data))
                # 이 값이 왼쪽 자식 노드의 트리의 지름과 같은 경우
                if diameter_current_node == left_diameter:
                    combi += left_diameter_pair
                if diameter_current_node == right_diameter:
                    combi += right_diameter_pair
                diameter[node] = (diameter_current_node, combi)
            elif left_diameter > right_diameter:
                # 왼쪽 자식 노드의 트리의 지름이 더 큰 경우
                diameter[node] = (left_diameter, left_diameter_pair)
            elif left_diameter < right_diameter:
                # 오른쪽 자식 노드의 트리의 지름이 더 큰 경우
                diameter[node] = (right_diameter, right_diameter_pair)
            else: # 횐쪽 자식 노드와 오튼쪽 자식 노드의 트리의 지름이 같은 경우
                diameter[node] = (left_diameter, left_diameter_pair + right_diameter_pair)
    return diameter[root]

def main():

    testcases = get_testcases()
    for i, tc in enumerate(testcases):
        tree_diameter, furthest_node_pairs = furthest_nodes(tc)
        print(f"Testcase {i + 1}")
        print(f"    트리의 지름 : {tree_diameter}")
        print(f"    가장 먼 노드 쌍 : {furthest_node_pairs}")
        print()

if __name__ == "__main__":
    main()

```

---

# 문제 5. 가장 강한 서브트리 (1)

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

연구원들은 수 년에 걸쳐 연구하고 있는 신기한 유전자 상의 돌연변이가 있었다. '유라'라는 이름을 가진 동물의 특정한 종에서만 발견되는 돌연변이인데, 이 돌연변이 유전자는 특정 성별에서만 발생하고, 해당 성별의 자손으로만 전파되며, 게다가 자식 중 딱 두 마리까지만 전달된다는 독특한 성질 때문에 연구소에서 이 돌연변이에 초점을 맞추어 연구를 진행하고 있었다. 연구를 통해 이 돌연변이 유전자가 실제로 발현되는데 영향을 미치는 어떤 물질을 발견했는데, 이 물질의 양은 직접 측정할 수 없고, 대신 일종의 전압을 측정하는 것과 유사한 방법으로 측정을 할 수 있었기에 이 값은 양수, 음수, 그리고 0 어떤 부호의 값이든 가질 수 있었다. 이 값을 연구소에서는 '반응도 전압'이라고 불렀다.

연구팀은 이 돌연변이가 발생한 유라 개체를 루트 노드로 하고, 이 돌연변이 유전자가 전달된 자손들을 부모와 자식을 연결한 가계도의 형태로 표현한 후, 이 가계도에 포함된 모든 유라의 반응도 전압을 측정한 후, 가계도 안에 값을 기록했다. 이 가계도를 여러 개를 그려놓고 지켜보던 연구원들은, 이 가계도에서 반응 전압이 유달리 높은 일부분이 있음을 직관적으로 알게 되었다. 그 가계도의 일부분에 해당하는 유라의 개체에 실제로 해당 돌연변이의 형질이 발현되었는지를 확인하고 싶은데, 문제는 일부 가계도는 너무 크고 복잡해서 이를 확인하기가 싶지 않다는 것이었다.

연구원들이 지선생을 찾아가 이 가계도에서 그런 부분을 찾아줄 수 있느냐고 묻자, 지선생은 이렇게 말했다.

“이 가계도 위의 각각의 유라의 개체로부터 그 모든 자손들의 반응도 전압을 다 합쳤을 때, 그 값이 최대가 얼마인지 찾으면 되지 않을까요?”

그 말을 들은 연구원들은 되물었다.

“그런데, 그 값을 어떻게 찾지요?”

## 수행목표

- 이진 트리 내부에 포함된 각 노드마다 해당 노드를 루트로 하는 서브트리를 하나씩 정의할 수 있으므로, 이진 트리에는 노드의 수 만큼의 서브트리가 존재한다.
- 이진 트리에 실수의 값을 가지는 변수가 있다. 서브트리마다 이 변수의 합을 구할 수 있다. 노드 수 만큼의 서브트리의 변수의 합 중 최대값을 반환하는 함수를 구현한다.
- 첨부한 파일을 사용해서 8개의 테스트케이스를 얻을 수 있다. 각 테스트케이스에서 가장 큰 서브트리 합을 구해서 출력해보자.

## 수행단계

- 다음 그림의 트리와 질문을 통해서 문제를 파악해보자.
  ![Alt text](ch7_3.png)
  - 트리에 포함된 모든 노드의 값의 합은 얼마인가?
  - 루트 노드의 왼쪽 자식 노드를 루트 노드로 하는 서브 트리의 모든 노드의 값의 합은 얼마인가?
  - 루트 노드의 오른쪽 자식 노드를 루트 노드로 하는 서브 트리의 모든 노드의 값의 합은 얼마인가?
  - 이 트리에서 합이 가장 큰 서브트리의 루트는 무엇이고, 합의 값은 얼마인가?
  - 반대로 트리에서 합이 가장 작은 서브트리의 루트는 무엇인가?
- 주어진 문제를 해결하기 위해서 우선 특정 노드를 루트로 하는 서브트리의 모든 값의 합을 구하는 문제를 해결해보자. 이 문제는 문제의 구조를 파악해 해결한다.
  - 상위 구조와 하위 구조를 정의해보자.
  - 상위 구조와 하위 구조의 관계를 찾아 점화식의 형태로 정리해보자.
- 서브트리의 모든 값의 합을 구하는 문제를 사용해, 합이 최대인 서브트리의 합을 구하는 방법을 정리한다.
- 정리한 내용을 토대로 합이 최대인 서브트리의 합을 구하는 함수를 ds_more/max_power_subtree.py 파일에 구현한다.
- 첨부한 파일의 get_testcases 함수를 호출해서 8개의 테스트케이스 트리의 루트 노드를 얻을 수 있다. 이 노드를 루트로 하는 트리에서 합이 최대인 서브트리의 모든 값의 합을 구하고 이를 출력한다.

## 결과예시

```
Testcase 1에서 합이 최대인 서브트리의 합의 값 : 4

Testcase 2에서 합이 최대인 서브트리의 합의 값 : 3
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - ds_more/max_power_subtree.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

```
Testcase 1에서 합이 최대인 서브트리의 합의 값 : 4

Testcase 2에서 합이 최대인 서브트리의 합의 값 : 3

Testcase 3에서 합이 최대인 서브트리의 합의 값 : 720

Testcase 4에서 합이 최대인 서브트리의 합의 값 : -17

Testcase 5에서 합이 최대인 서브트리의 합의 값 : 770

Testcase 6에서 합이 최대인 서브트리의 합의 값 : 23

Testcase 7에서 합이 최대인 서브트리의 합의 값 : 1562

Testcase 8에서 합이 최대인 서브트리의 합의 값 : 26546
```

### [문제에 대한 이해]

- 트리 상에 어떤 노드에 대해서, 이 노드를 루트로 하는 서브트리의 모든 노드의 값의 합을 구하는 문제를, 문제의 구조 사이의 관계를 통해서 해결하고자 할 때, 어떤 구조를 사용할 수 있는지 설명해보자.
  - 부모 노드의 문제는 왼쪽 자식 노드의 문제와 오른쪽 자식 노드의 문제, 그리고 부모 노드의 값을 합쳐서 해결할 수 있다.
- 여기에서 가장 작은 구조의 문제는 무엇인가?
  - 자식이 없는 노드인 리프 노드의 문제가 가장 작은 구조의 문제이다.
- 주어진 노드를 루트로 하는 서브 트리의 모든 값의 합을 tree_sum(node)라고 할 때, tree_sum(node)를 구하는 문제의 점화식을 제시해보자.
  - tree_sum(node) = node.data + tree_sum(node.left) + tree_sum(node.right)이며, node가 leaf 노드인 경우는, 자신의 값으로 정의된다.
- 주어진 노드를 루트로 하는 서브 트리의 모든 값을 구하는 문제의 접근 방식을 기초로, 합이 가장 큰 서브 트리의 합을 구하는 문제를 해결해보고자 한다. 합이 가장 큰 서브 트리의 합을 max_power(node)라고 할 때 max_power(node)를 구하는 점화식을 max_power, tree_sum을 사용해 표현해보자.
  - max_power(node) = max(tree_sum(node), max_power(node.left), max_power(node.right))이며
  - node가 리프 노드인 경우 max_power(node)는 node의 값이다.

### [코드 예시]

```python
from max_power_subtree_data import get_testcases


def max_power(node):
    if node == None:
        return 0, -float('inf')
    # 현재 노드의 서브트리 합을 현재 노드의 데이터로 초기화한다.
    tree_sum = node.data
    if node.left != None:
        # 왼쪽 자식 노드가 있으면 재귀 호출한다.
        l_max, l_sum = max_power(node.left)
    else:
        # 왼쪽 자식 노드가 없으면 왼쪽 서브트리 합은 0,
        # 최대 서브트리 합은 충분히 작은 값을 사용한다.
        l_max, l_sum = -float('inf'), 0
    # 오른쪽 자식 노드는 왼쪽 자식노드와 동일하게 동작한다.
    if node.right != None:
        r_max, r_sum = max_power(node.right)
    else:
        r_max, r_sum = -float('inf'), 0
    # 현재 노드의 서브트리 합을 계산한다.
    tree_sum += l_sum + r_sum
    # 1. 현재 노드의 서브 트리 합
    # 2. 왼쪽 서브트리의 최대 서브트리 합
    # 3. 오른쪽 서브트리의 최대 서브트리 합
    # 세 값의 최대값을 서브트리 합과 함께 반환한다.
    return max(tree_sum, l_max, r_max), tree_sum

def main():
    testcases = get_testcases()
    for i, root in enumerate(testcases):
        max_sum, _ = max_power(root)
        print(f"Testcase {i + 1}에서 합이 최대인 서브트리의 합의 값 : {max_sum}")
        print()

if __name__ == "__main__":
    main()
```

---

# 문제 6. 가장 강한 서브트리 (2)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

지선생의 가이드에 따라서 알고 싶은 값을 찾아낸 연구원들은, 그 다음 단계로 조건에 맞는 서브트리가 어떤 서브트리인지를 찾기 시작했다.

연구원들은 지선생이 가르쳐 준 방법을 사용해서 어렵지 않게 그 서브트리의 루트를 찾을 수 있었는데, 또 다른 문제가 발생했다. 트리는 너무나 크고 반응도 전압의 값이 같은 유라의 개체도 트리에 너무나 많아서, '반응도 XX인 유라를 루트로 하는 서브 트리'라는 표현이 도움이 되지 않는다는 점이었다.

연구원들의 결론은 다음과 같았다.

"이진 트리에서 모든 노드를 고유하게 구분할 수 있는 방법을 정해서 사용하자."

## 수행목표

- 이진 트리 내부에 노드 수 만큼 존재하는 서브 트리 중에서, 포함된 모든 노드의 값의 합이 최대가 되는 서브 트리를 찾는다.
- 이진 트리에 포함된 각 노드를 고유하게 구분할 수 있는 문자열 형태의 고유값을 정의하고, 찾아낸 서브 트리의 루트노드의 고유값으로 구성된 리스트와 서브트리에 포함된 모든 노드의 값의 합을 반환하는 함수를 구현한다.
  - 만약 합이 최대인 서브트리가 둘 이상 존재한다면 모든 서브트리의 루트를 포함해 반환해야 한다.
- 첨부한 파일을 사용해서 8개의 테스트케이스를 얻을 수 있다. 각 테스트케이스에서 포함된 모든 노드의 값의 합이 최대가 되는 서브 트리의 루트 노드를 정의한 고유값을 사용해 출력한다.

## 수행단계

- 이진 트리에 포함된 모든 노드를 구분할 수 있는 고유값 체계를 정의할 수 있다. 이 고유값은 다음과 같은 성격을 가진다.
  - 일반적인 모든 이진 트리에 적용할 수 있는 일반적인 고유값이어야 한다.
  - 별도로 정의하지 않아도 이진 트리의 특성에 따라 자동적으로 정의되며, 이 값으로 이진 트리의 모든 노드를 구분할 수 있다.
  - 이 값을 사용해서 트리를 재구성할 수 있다.
  - 이 고유한 값은 문자열의 형태를 지닌다.
- 이러한 고유값 정의 방식 중 하나는 어떤 노드를 루트로부터 연결되는 방식으로 표현하는 것이다.
  - 루트 노드를 `@`로 표현한다. 루트 노드의 왼쪽 자식 노드는 `l`을 덧붙여 `@l`로, 오른쪽 자식 노드는 `@r`로 표시한다.
  - 그 이하의 자식 노드도 루트 노드로부터 내려가면서 `l` 또는 `r`을 덧붙여 나가는 방식으로 이진 트리의 모든 노드를 고유하게 구분하는 문자열을 만들 수 있다.
- 이진 트리에서 포함된 노드의 값의 합이 최대가 되는 서브트리의 루트노드를 찾고, 위에서 제시한 방식으로 정의된 서브트리 루트 노드의 고유값을 반환하는 함수를 ds_more/max_power_subtree2.py 파일에 구현한다.
- 첨부한 파일의 get_testcases 함수를 호출해서 8개의 테스트케이스 트리의 루트 노드를 얻을 수 있다. 이 노드를 루트로 하는 트리에서 합이 최대인 서브트리의 모든 값의 합과 이 서브트리의 루트 노드의 고유값을 구하고 이를 출력한다.

## 결과예시

```
Testcase 1
    합이 최대인 서브트리에 포함된 노드들의 값의 합 : 4
    값이 최대가 되는 서브트리의 루트 노드 : ['@l']

Testcase 2
    합이 최대인 서브트리에 포함된 노드들의 값의 합 : 3
    값이 최대가 되는 서브트리의 루트 노드 : ['@l', '@r']
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - ds_more/max_power_subtree2.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과의 예시이다. 결과는 항상 다르게 나오지만, 수행 시간은 거의 지연없이 결과를 확인할 수 있어야 한다.

```
Testcase 1
    합이 최대인 서브트리에 포함된 노드들의 값의 합 : 4
    값이 최대가 되는 서브트리의 루트 노드 : ['@l']

Testcase 2
    합이 최대인 서브트리에 포함된 노드들의 값의 합 : 3
    값이 최대가 되는 서브트리의 루트 노드 : ['@l', '@r']

Testcase 3
    합이 최대인 서브트리에 포함된 노드들의 값의 합 : 720
    값이 최대가 되는 서브트리의 루트 노드 : ['@']

Testcase 4
    합이 최대인 서브트리에 포함된 노드들의 값의 합 : -17
    값이 최대가 되는 서브트리의 루트 노드 : ['@rrl']

Testcase 5
    합이 최대인 서브트리에 포함된 노드들의 값의 합 : 770
    값이 최대가 되는 서브트리의 루트 노드 : ['@r']

Testcase 6
    합이 최대인 서브트리에 포함된 노드들의 값의 합 : 23
    값이 최대가 되는 서브트리의 루트 노드 : ['@lrr', '@lrrr']

Testcase 7
    합이 최대인 서브트리에 포함된 노드들의 값의 합 : 1562
    값이 최대가 되는 서브트리의 루트 노드 : ['@r']

Testcase 8
    합이 최대인 서브트리에 포함된 노드들의 값의 합 : 26546
    값이 최대가 되는 서브트리의 루트 노드 : ['@r']

```

### [문제에 대한 이해]

- 제시한 방식의 고유값 왜 모든 노드에 대해서 중복되지 않는지 설명하라.
  - (예시답변) 이진 트리에서 루트로부터 해당 노드에 도달 가능한 방법을 식별값으로 사용하므로 유일하다고 할 수 있다.
- 제시한 고유값을 사용해 노드를 찾는 방법을 설명하라.
  - (예시답변) @을 제외한 첫 글짜가 l이면 식별자의 첫 글자를 제외한 값으로 왼쪽 자식 노드로 재귀 호출 탐색한다. r인 경우 같은 방식으로 오른쪽 자식 노드로 재귀 호출 탐색한다. 문자열이 빈 문자열이 되었을 때 찾은 노드를 반환한다.
- 루트 노드가 주어졌을 때 트리 상의 어떤 노드의 고유값을 생성하는 알고리즘을 설명해보자.
  - (예시답변) 이진 트리의 in-order 탐색을 식별자 추가 메커니즘으로 식별자를 생성하면서 진행한다. 찾고자 하는 노드에 도착했을 때 생성된 식별자를 반환한다.
- 이전 문제에서 해결한 방법의 과정을 활용해 찾고자 하는 서브 트리의 루트노드를 찾는 방법을 제시하라.
  - 최대 서브트리 합을 탐색 중에 계속 갱신하면서 관리한다.
  - 만약 최대값과 같은 서브 트리를 찾은 경우, 기존 목록에 새로 찾은 서브 트리의 루트 노드의 경로를 추가한다.
  - 최대값보다 큰 새로운 최대값의 서브 트리를 찾은 경우, 기존 목록 대신 새 서브 트리의 루트 경로 목록을 만든다.
    - 만약 이 새로운 서브 트리가 현재 탐색중인 노드를 루트로 한다면, 루트 노드의 경로 하나를 가진 리스트를 새로 생성한다.
    - 만약 이 새로운 서브 트리가 왼쪽 서브트리 또는 오른쪽 서브 트리에 속해 있는 경우, 왼쪽 서브트리 또는 오른쪽 서브 트리의 목록으로 대체한다.

### [코드 예시]

```python
from max_power_subtree_data import get_testcases

def max_power_yura(node, path = '@'):
    if node == None:
        return 0, -float('inf'), []
    # 현재 노드의 서브트리 합을 현재 노드의 데이터로 초기화한다.
    tree_sum = node.data
    if node.left != None:
        # 왼쪽 자식 노드가 있으면 재귀 호출한다. 재귀 호출 시 path에 'l'을 추가한다.
        l_max, l_max_root_nodes, l_sum = max_power_yura(node.left, path + 'l')
    else:
        # 왼쪽 자식 노드가 없으면 왼쪽 서브트리 합은 0,
        # 최대 서브트리 합은 충분히 작은 값을 사용한다.
        l_max, l_max_root_nodes, l_sum = -float('inf'), [], 0
    # 오른쪽 자식 노드는 왼쪽 자식노드와 동일하게 동작한다.
    if node.right != None:
        r_max, r_max_root_nodes, r_sum = max_power_yura(node.right, path + 'r')
    else:
        r_max, r_max_root_nodes, r_sum = -float('inf'), [], 0
    # 현재 노드의 서브트리 합을 계산한다.
    tree_sum += l_sum + r_sum
    # 1. 현재 노드의 서브 트리 합
    # 2. 왼쪽 서브트리의 최대 서브트리 합
    # 3. 오른쪽 서브트리의 최대 서브트리 합
    # 세 값의 최대값을 서브트리 합, 최대 서브트리의 루트의 위치와 목록과 함께 반환한다.

    # 양쪽 서브트리의 결과를 우선 취합
    c_max = max(l_max, r_max)
    if l_max > r_max:
        c_max_root_nodes = l_max_root_nodes
    elif l_max < r_max:
        c_max_root_nodes = r_max_root_nodes
    else:
        c_max_root_nodes = l_max_root_nodes + r_max_root_nodes

    if tree_sum > c_max:
        # 현재 트리의 합이 가장 클 때
        current_max = tree_sum
        current_max_root_nodes = [path]
    elif tree_sum < c_max:
        # 자식 노드의 서브트리 합이 더 클때
        current_max = c_max
        current_max_root_nodes = c_max_root_nodes
    else:
        # 같을 때는 최대 서브트리의 루트 목록에 현재 노드를 추가한다.
        current_max = tree_sum
        current_max_root_nodes = [path] + c_max_root_nodes

    return current_max, current_max_root_nodes, tree_sum

def main():
    testcases = get_testcases()
    for i, root in enumerate(testcases):
        max_sum, max_power_root, _ = max_power_yura(root)
        print(f"Testcase {i + 1}")
        print(f"    합이 최대인 서브트리에 포함된 노드들의 값의 합 : {max_sum}")
        print(f"    값이 최대가 되는 서브트리의 루트 노드 : {max_power_root}")
        print()

if __name__ == "__main__":
    main()
```

---

# 문제 7. 식물의 영양 흡수 패턴

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

"도대체 지선생님의 정체가 뭘까요?"

X 그룹장, K 연구원이 회사 근처 호프집에서 맥주를 한잔 하면서 이야기를 나누고 있었다.

"음. 사실 지선생님은 외국 출신이야."

X 그룹장의 말에 K 연구원이 깜짝 놀랐다. X 그룹장이 말을 이었다.

"잘은 모르지만, 중학교 시절인가 부친이 외국에서 사업을 하셔서 따라 나갔는데, 거기서 수학과로 대학을 진학을 했던거 같아. 그런데, 대학 시절 당시 최첨단 장비였던 컴퓨터에 빠져 버리는 바람에 졸업을 못하고, 군입대 나이가 되어서 졸업을 못하고 귀국해서 군입대를 하려고 했다지 아마. 그런데, 당시 88올림픽 때문에 전산 인력이 부족한 상황이라 그 쪽으로 병역 특례로 복무를 했고, 어찌어찌하다가 다시 외국으로 나가지 못하고 국내 대학에서 행정학을 전공하고 우리 연구소가 만들어질 때 연구지원인력으로 입사했다는 이야기를 언젠가 들은 것 같은데..."

설득력이 있는 스토리였다. 그 이야기를 들은 K 연구원이 말했다.

"그런 분이면, 아예 연구소에서 전산지원팀 이런 것 만들어서 활동하시는게 연구소에 훨씬 도움이 되지 않을까요?"

"그렇지. 그런데, 지선생님 조금 있으면 정년 퇴직이셔서 힘들거야."

그런데, 그 이야기를 유심히 듣던 근처 자리의 연구소 직원이 있었다. 그 직원은 다음날 곧장 연구소장을 찾아가서 재미있는 제안을 했다. 그리고 그날 오후, 연구소장이 지선생을 불러서 식물의 생장 연구와 관련된 난제가 있으니 도와달라는 요청을 직접 전달했다.

> - 뿌리 위쪽의 식물의 구조는 가지가 되었건 줄기가 되었건 복잡한 방식으로 갈라지는 구조를 가지고 있지만, 자세히 보면 모든 가지 또는 줄기는 한 점(갈래점)에서 정확히 둘로 갈라진다. 셋 이상 갈라지는 경우는, 갈래점이 너무 가까워서 그렇게 보이는 것 뿐이다.
> - 식물의 어떤 부위의 영양 상태를 확인하는 방법으로 식물의 갈래점에서 영양물질을 측정하는 방법을 개발해 사용하고 있다.
> - 영양물질이 변화한 정도를 측정하면, 해당 부위에서 영양소를 많이 사용하는지 적게 사용하는지를 알 수 있다. 이 값은 외부에서 영양물질이 전달되기도 하므로 양의 값, 음의 값 모두를 가질 수 있다.
> - 식물의 효과적인 생장을 연구하기 위해 이 영양물질의 변화량의 합이 가장 큰 연결된 부위를 찾아야 한다. 이 부위의 의미는 어떤 식물의 영양물질이 가장 잘 흡수되지 않는 부위라는 의미이다.

## 수행목표

- 이진트리에서 부모 노드와 자식 노드의 연결 구조를 그래프와 같이 취급한다면, 이진트리에서 이 연결관계를 기준으로 경로를 정의할 수 있다.
- 각 노드가 양 또는 음의 실수의 값을 가진 이진트리에서 구성할 수 있는 경로 중에서 이 경로에 포함된 노드의 값의 합이 최대인 경로를 최대 경로합 경로, 그리고 이 때의 노드의 값의 합을 최대 경로합이라고 하자. 이진트리의 최대 경로합 경로의 양 끝 점의 값과 최대 경로합을 반환하는 함수를 구현한다.
- 첨부한 파일을 사용해서 8개의 테스트케이스를 얻을 수 있다. 각 테스트케이스 트리에서 최대 경로합 경로를 찾아, 최대 경로합과 함께 출력한다.

## 수행단계

- 문제의 구조를 분석해보자.
  - 다음 그림의 이진 트리에서 경로에 포함된 노드의 값의 합이 최대가 되는 경로와, 이 경로에 포함된 노드의 값의 합을 구해보자.
    ![Alt text](ch7_4.png)
  - 최대 경로합이 되는 경로가 루트 노드를 지나가는 경우와 루트 노드를 지나가지 않는 경우 각각에 대해서 문제의 해결 방법을 찾는다.
- 최대 경로합 경로의 양 끝 점의 값의 리스트와 최대 경로합을 계산해 반환하는 함수를 ds_more/max_pathsum_tree.py 파일에 구현한다.
  - 최대 경로합 경로는 같은 경로합을 가지는 둘 이상의 경로로 구성될 수 있다. 이 경우 모든 경로의 양 끝 점을 반환한다.
- 첨부한 파일의 get_testcases 함수를 호출해서 8개의 테스트케이스 트리의 루트 노드를 얻을 수 있다. 이 노드를 루트로 하는 트리에서 합이 최대인 서브트리의 모든 값의 합과 이 서브트리의 루트 노드의 고유값을 구하고 이를 출력한다.
  - 최대 경로합 경로는 양 끝 점의 값의 튜플의 형태로 출력한다. 시작점과 끝점은 구분되지 않으므로 순서는 고려하지 않는다.

## 결과예시

```
Testcase 1
    최대 경로합: 11
    최대 경로합 경로의 양 끝 노드의 값 : [(1, 2)]

Testcase 2
    최대 경로합: 3
    최대 경로합 경로의 양 끝 노드의 값 : [(1, 1), (1, 1)]

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - ds_more/max_pathsum_tree.py 파일에 구현이 되어 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```
    Testcase 1
        최대 경로합: 11
        최대 경로합 경로의 양 끝 노드의 값 : [(1, 2)]

    Testcase 2
        최대 경로합: 3
        최대 경로합 경로의 양 끝 노드의 값 : [(1, 1), (1, 1)]

    Testcase 3
        최대 경로합: 513
        최대 경로합 경로의 양 끝 노드의 값 : [(51, 76)]

    Testcase 4
        최대 경로합: -13
        최대 경로합 경로의 양 끝 노드의 값 : [(-13, -13)]

    Testcase 5
        최대 경로합: 558
        최대 경로합 경로의 양 끝 노드의 값 : [(25, 89)]

    Testcase 6
        최대 경로합: 32
        최대 경로합 경로의 양 끝 노드의 값 : [(2, 3)]

    Testcase 7
        최대 경로합: 958
        최대 경로합 경로의 양 끝 노드의 값 : [(62, 92)]

    Testcase 8
        최대 경로합: 2572
        최대 경로합 경로의 양 끝 노드의 값 : [(67, 92)]

    ```

### [문제에 대한 이해]

- 어떤 노드를 루트로 하는 서브트리에서, 이 트리를 지나는 최대 경로합(`max_path_sum_over(node)`)과 이 트리의 자식 노드를 루트로 하는 서브트리에서, 이 서브트리의 루트에서 시작되는 최대 경로합(`max_oneway_path_sum(node.left)` 또는 `max_oneway_path_sum(node.right)`)의 관계를 경우에 따라 분류해 설명해보자.
  - 양쪽 자식 노드 모두의 `max_oneway_path_sum` 이 음수인 경우, 노드를 통과하는 최대 경로합 경로는 해당 노드 하나로만 구성된다. 그러므로 node.data이다.
  - 만약 왼쪽 자식 노드의 `max_oneway_path_sum`만 음수인 경우, 노드를 통과하는 최대 경로합 경로는 해당 노드와 오른쪽 자식 노드에서 시작하는 자식 노드 방향의 최대 경로합으로 구성된다. 그러므로 node.data + max_oneway_path_sum(node.right)이다. 오른쪽도 대칭적으로 변경된다.
  - 만약 자식 노드 모두의 `max_oneway_path_sum`이 음수가 아닌 경우, 노드를 통과하는 최대 경로합 경로는 해당 노드와 왼쪽 방향, 오른쪽 방향의 자식 노드 방향의 최대 경로를 모두 합친 경로이다. 그러므로 node.data + max_oneway_path_sum(node.right) + max_oneway_path_sum(node.left)이다.
- 이 문제의 목적 함수는 max_path_sum_oneway, max_path_sum_over 중 어떤 것인가?
  - 모든 노드에 대해서 max_path_sum_over를 구하고, 이들 중 최대값을 구해야 하므로, 목적 함수는 max_path_sum_over이다.
- 이 문제에서 재귀 호출을 사용해 구해는 값은 max_path_sum_oneway, max_path_sum_oneway 중 어떤 것인가?
  - 이 문제에서 재귀 호출을 사용해 구하는 값은 max_path_sum_oneway이다.
- 재귀 호출로 구하는 대상의 점화식을 제시해보자.
  - max_oneway_path_sum(node) = max(max_oneway_path_sum(node.left), max_oneway_path_sum(node.right), 0) + node.data
  - 종료조건은 node가 None인 경우이다.
- 문제의 목적 함수의 값은 어떤 방식으로 계산하는가?
  - 양쪽 자식 노드의 max_one_way_path_sum을 재귀 호출로 구한 값을 사용해 계산한다.

### [코드 예시]

```python
from max_pathsum_tree_data import get_testcases
import itertools

# 주어진 노드에서 시작해서 하향 방향으로의 최대 경로의 합이다.
# 왼쪽 또는 오른쪽 중 한 쪽 방향으로만 하향한다.
# 반환 값은 두 개이다.
#   1. 나에서 시작하고, 하향하는 경로에서의 최대 경로합
#   2. 나에서 시작하고, 하향하는 경로에서의 반대쪽 끝 노드의 값
#   3. 나를 루트로 하는 서브트리의 최대 경로합
#   4. 나를 루트로 하는 서브트리의 최대 경로합을 만드는 경로의 조합
def absorbing_max_path(node, path = ''):
    # 기저조건
    if node == None:
        return 0, [], -float('inf'), ([], [])
    # 왼쪽 서브트리의 루트에서 시작하는 하향 최대 경로합과, 왼쪽 서브트리의 최대 경로합
    max_left_path_sum, max_leftmost_node, left_max_so_far, left_max_path_ends = absorbing_max_path(node.left, path + "l")

    # 오른쪽 서브트리의 루트에서 시작하는 하향 최대 경로합과, 오른족 서브트리의 최대 경로합
    max_right_path_sum, max_rightmost_node, right_max_so_far, right_max_path_ends = absorbing_max_path(node.right, path + "r")

    # 현재 노드에서 시작하는 하향 최대 경로합.
    # 왼쪽, 오른쪽, 현재 노드 중 최대값을 선택하며 양쪽 다 음수인 경우 둘 다 선택하지 않는다.
    # 각 조건에 맞는 햐향 경로의 끝 노드를 선택한다.
    if max_left_path_sum <= 0 and max_right_path_sum <= 0:
        current_oneway_path_sum = node.data
        current_oneway_path_end = [node.data]
    elif max_left_path_sum == max_right_path_sum:
        current_oneway_path_sum = node.data + max_left_path_sum
        current_oneway_path_end = max_leftmost_node + max_rightmost_node
    elif max_left_path_sum > max_right_path_sum:
        current_oneway_path_sum = node.data + max_left_path_sum
        current_oneway_path_end = max_leftmost_node
    else:
        current_oneway_path_sum = node.data + max_right_path_sum
        current_oneway_path_end = max_rightmost_node

    # 현재 노드를 통과하는 최대 경로합
    # 왼쪽 자식 노드의 하향 최대 경로합, 오른쪽 자식 노드의 하향 최대 경로합이 모두 음수인 경우
    # 현재 노드를 통과하는 최대 경로합 경로의, 조건에 맞는 양 끝 노드의 조합도 구한다.
    current_max_so_far = node.data
    current_max_path_ends = [([node.data], [node.data])]
    if max_left_path_sum <= 0 and max_right_path_sum > 0:
        # 오른쪽 자식 노드의 하향 최대 경로합만 양수인 경우는 현재 노드에 이를 더한다.
        current_max_so_far += max_right_path_sum
        current_max_path_ends = [([node.data], max_rightmost_node)]

    elif max_left_path_sum > 0 and max_right_path_sum <= 0:
        # 왼쪽 자식 노드의 하향 최대 경로합만 양수인 경우는 현재 노드에 이를 더한다.
        current_max_so_far += max_left_path_sum
        current_max_path_ends = [(max_leftmost_node, [node.data])]

    elif max_left_path_sum > 0 and max_right_path_sum > 0:
        # 양쪽 자식 노드의 하향 최대값이 모두 양수이면, 모두 더한다.
        current_max_so_far += max_left_path_sum + max_right_path_sum
        current_max_path_ends = [(max_leftmost_node, max_rightmost_node)]

    # 현재, 그리고 하위 노드들의 최대 경로합 중에서 최대를 선택한다.
    # 각 경우의 양 끝 노드의 조합도 구한다.
    # 만약, 동점 최대 경로가 둘 이상 있는 경우, 각각의 케이스를 케이스는 취합한다.

    # 현재 노드를 지나는 경로가 최대경로합 경로인 경우
    if current_max_so_far > left_max_so_far and current_max_so_far > right_max_so_far:
        max_path_sum_under_node = current_max_so_far
        max_path_ends = current_max_path_ends
    # 현재 노드를 지나는 경로가 최대 경로합이며, 왼쪽 서브트리에도 같은 값의 최대 경로합 경로가 있는 경우
    elif current_max_so_far == left_max_so_far and left_max_so_far > right_max_so_far:
        max_path_sum_under_node = current_max_so_far
        max_path_ends = current_max_path_ends + left_max_path_ends
    # 현재 노드를 지나는 경로가 최대 경로합이며, 오른쪽 서브트리에도 같은 값의 최대 경로합 경로가 있는 경우
    elif current_max_so_far == right_max_so_far and right_max_so_far > left_max_so_far:
        max_path_sum_under_node = current_max_so_far
        max_path_ends = current_max_path_ends + right_max_path_ends
    # 현재 노드를 지나는 경로가 최대 경로합이며, 양쪽 서브트리에도 같은 값의 최대 경로합 경로가 있는 경우
    elif current_max_so_far == left_max_so_far and left_max_so_far == right_max_so_far:
        max_path_sum_under_node = current_max_so_far
        max_path_ends = current_max_path_ends + left_max_path_ends + right_max_path_ends
    # 양쪽 서브트리에만 같은 크기의 최대 경로합 경로가 모두 있는 경우
    elif left_max_so_far == right_max_so_far and left_max_so_far > current_max_so_far:
        max_path_sum_under_node = left_max_so_far
        max_path_ends = left_max_path_ends + right_max_path_ends
    # 왼쪽 서브트리에만 최대 경로합 경로가 있는 경우
    elif left_max_so_far > right_max_so_far and left_max_so_far > current_max_so_far:
        max_path_sum_under_node = left_max_so_far
        max_path_ends = left_max_path_ends
    # 오른족 서브트리에만 최대 경로합 경로가 있는 경우
    elif right_max_so_far > left_max_so_far and right_max_so_far > current_max_so_far:
        max_path_sum_under_node = right_max_so_far
        max_path_ends = right_max_path_ends

    # 반환 - 현재 노드에서 시작하는 하향하는 최대 경로합, 이 때의 반대쪽 노드 리스트, 현재 노드를 루트로 하는 서브트리에서 최대 경로합, 현재 노드를 루트로 하는 서브트리에서 최대 경로합 경로의 양 끝 노드 조합
    return current_oneway_path_sum, current_oneway_path_end, max_path_sum_under_node, max_path_ends

def main():
    testcases = get_testcases()
    for i, testcase_root in enumerate(testcases):
        result = []
        _, _, max_path_sum, max_path_ends = absorbing_max_path(testcase_root)
        for path in max_path_ends:
            combinations = list(itertools.product(*path))
            result += combinations

        print(f"Testcase {i + 1}")
        print(f"    최대 경로합: {max_path_sum}")
        print(f"    최대 경로합 경로의 양 끝 노드의 값 : {result}")
        print()

if __name__ == '__main__':
    main()

```

---

# 문제 8. 그래프의 사이클 탐지

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

식물의 생장 연구와 관련된 문제를 지선생이 해결했다는 이야기를 들은 연구소장은 지선생을 호출했다.

호출을 받은 지선생이 연구소장에게 가려는데 E 연구원이 연구지원팀으로 들어오면서 지선생에게 도움을 청했다. E 연구원이 들고 온 문제를 보니 다음과 같았다.

> - 플라나리아와 같은 생물은 여러 조각으로 잘라내면 각 조각이 각각의 개체로 성장하는 특이한 형태를 보인다. 이러한 생물을 관찰한 결과는 트리 형태로 표현할 수 있다. 그런데, 이 데이터를 만든 사람이 이러한 생물종에 대한 이해가 깊지 않아서 이를 인접 리스트를 사용한 그래프로 표현하였다. 물론, 트리도 방향성 그래프의 일종으로 생각할 수 있기 때문에 여기까지는 큰 문제가 없다.
> - 그런데 데이터가 꼬여서 일부 그래프가 트리의 형태가 아닌 데이터가 되어 버렸다. 이 경우, 분열되어 새로 발생한 플라나리아가 다시 분열해서 원래의 플라나리아가 되는 것 같은 표현이 이 그래프에 포함될 수 있다.
> - 여러 그래프 중에서 이런 문제가 있는 그래프 데이터를 찾아야 한다.

문제를 훓어 본 지선생은 이렇게 말했다.

"지금 연구소장이 호출해서 시간이 별로 없는데, 그래프의 사이클을 감지하는 알고리즘을 만들어보세요."

## 수행목표

- 방향성 그래프를 구성하는 데이터가 있다. 이 데이터를 인접 리스트를 사용하는 그래프의 객체로 만들 수 있는 파이썬 클래스를 구현한다.
- 이러한 방향성 그래프가 주어졌을 때, 이 그래프에 사이클이 존재하는지 확인하는 함수를 구현한다.
- 주어진 데이터는 10개의 그래프 데이터가 포함되어 있다. 이 10개의 그래프에 사이클이 존재하는지 검사하고 그 결과를 출력한다.

## 수행단계

- 방향성 그래프에서 사이클이란 무엇인지 확인한다.
- 인접 리스트를 사용하는 그래프를 생성하는 파이썬 클래스를 만들고, 만들어진 그래프 객체에 사이클이 존재하는지 검사하는 메소드를 구현한다. 이 클래스는 ds_more/find_cycle.py 파일에 구현한다.
- 첨부한 파일에는 10개의 그래프 데이터가 포함되어 있다.
  - 그래프는 testcase 번호 줄로 구분된다.
  - 각각의 그래프의 데이터는 컴마로 구분된 그래프 꼭짓점 고유값 한 쌍으로 표현하는 변을 한 줄에 하나씩 표현하고 있다. 이 변은 방향성을 가지고 있으며, 첫 번째 꼭짓점이 시작 꼭짓점, 두 번째 꼭짓점이 끝 꼭짓점에 해당된다.
  - 이 데이터를 사용해 10개의 방향성 그래프 객체를 만들고, 그래프 객체에 사이클이 존재하는지 검사한 결과를 출력한다.

## 결과예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/filter2..py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍 접근 방법으로 해결하고 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- n이 홀수인 경우는 어떤 결과가 나오는가?
- 문제의 구조를 하위 문제를 사용해 설명하라.
- n x 3에서 가능한 모든 실험 설정의 수를 case(n)으로 표기할 때, case(n)의 상위 문제와 하위 문제의 관계를 나타내는 점화식을 제시하라.

### [코드 예시]

```python

```

---

# 문제 9. 그래프의 커넥티드 컴포넌트

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

연구소장의 호출을 받아 모종의 제안을 받고 돌아온 지선생은 자리에 돌아와서 습관처럼 프로그래밍 지원 게시판을 열었다. 게시판에는 도움을 청하는 문제가 몇 개 올라와 있었는데, 그 중 하나는 잠시 전 만났던 E 연구원의 요청이었다. 아까 그 문제를 해결하지 못했나 싶어서 살펴보니, 그 문제는 아닌 다른 문제를 물어보고 있었다.

> 벌이나 개미와 같이 군집을 이루어 생활하는 동물 중 일부는 하나의 개체로부터 군집의 모든 개체가 발생하는 경우가 있다. 그리고, 군집의 크기가 커지면 군집이 독립해서 별도 군집을 이루는데 이 경우에도 결국 원래 군집으로부터 분리한 군집이므로 유전자를 확인하면 어떤 군집으로부터 발생했는지 추정할 수 있다.
> 여러 마리의 벌의 유전자를 확인해서 유전자가 일정 수준 이상 가까운 벌들을 연결해서 그래프를 그린 후, 직접 혹은 간접적으로 연결된 모든 벌들을 하나의 군집에 속한 벌이거나, 하나의 군집으로부터 파생된 벌이라 간주할 수 있다. 그리고 이렇게 연결된 형태를 파악하면, 이 그래프에 속한 벌들이 총 몇 개의 군집으로부터 파생되었는지도 추정할 수 있다.
> 그래프가 작으면 그래프를 종이에 그려보면서 눈으로 군집의 수를 셀 수 있지만, 그래프의 크기가 커지면 이 작업은 쉬운 작업이 아니다.

서로 다른 군집의 벌을 비교하면서 돌연변이 유전자의 발현을 확인하려는 연구원 E가 알고 싶은 것은 그래프에 속한 벌들이 하나의 군집으로부터 발생된 벌인지, 그렇지 않다면 이 벌들의 출생 군집의 수가 몇 개인지에 관한 것이다.

## 수행목표

- 비방향성 그래프를 구성하는 데이터가 있다. 이 데이터를 인접 리스트를 사용하는 그래프의 객체로 만들 수 있는 파이썬 클래스와 인접 행렬을 사용하는 그래프의 객체로 만들 수 있는 파이썬 클래스를 구현한다.
  - 클래스의 메소드로 그래프에 변을 추가하는 메소드와 연결된 집단의 수를 반환하는 메소드를 구현한다.
- 주어진 데이터는 10개의 그래프 데이터가 포함되어 있다. 이 10개의 그래프 각각이 몇 개의 집단으로 구성되어 있는지를 출력한다.

## 수행단계

- 그래프를 구현하는 방법은 크게 인접 리스트를 사용하는 방법과 인접 행렬을 사용하는 방법이 있다. 지금까지 그래프 관련 문제를 해결할 때 인접 리스트를 사용해왔다. 인접 행렬을 사용해 그래프를 구현하는 방법에 대해서 조사한다.
- 인접 리스트를 사용하는 그래프 클래스와 인접 행렬을 사용하는 그래프 클래스를 ds_more/connected_count.py에 구현한다.
  - 두 클래스는 각각 연결된 두 개의 꼭짓점을 파라미터로 받아서 꼭짓점과 변을 추가하는 메소드를 가진다.
  - 인접 행렬의 경우, 구현의 용이성을 위해서 최대 꼭지점 수를 미리 정해두기도 한다. 구현하는 인접 행렬의 꼭짓점은 최대 200개로 한다.
  - 그래프는 비방향성 그래프로 구현한다.
- 인접 리스트와 인접 행렬을 사용하는 각각의 그래프 클래스에서, 그래프 객체의 연결된 집단이 총 몇 개인지를 계산해 반환하는 메소드를 구현한다.
  - 두 꼭짓점이 직접 연결된 변, 또는 다른 꼭짓점을 지나서 여러 개의 변으로 연결된 경우 두 꼭짓점은 같은 집단에 속하는 것으로 집단을 정의한다.
- 첨부한 파일에는 10개의 그래프 데이터가 포함되어 있다.
  - 그래프는 testcase 번호 줄로 구분된다.
  - 각각의 그래프의 데이터는 컴마로 구분된 그래프 꼭짓점 고유값 한 쌍으로 표현하는 변을 한 줄에 하나씩 표현하고 있다. 이 변은 방향성이 없으므로 변을 구성하는 꼭짓점들의 순서는 그래프의 구조와 무관한다.
  - 이 데이터를 사용해 비방향성 그래프 객체를 인접 행렬 그래프와 인접 리스트 그래프 각각 2개씩 20개를 만들고, 그래프 객체에 몇 개의 집단이 포함되어 있는지 출력한다.
- 집단의 수를 계산하는 함수를 인접 리스트와 인접 행렬로 구현했을 때 두 구현의 시간 복잡도를 비교한다.

## 결과예시

```

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/monkey_banana.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식, 하향식 각각의 방법을 사용한 두 가지 모두 구현되어 있어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- 하향식 다이나믹 프로그래밍 해결 전략을 제시해보자. 재귀 호출 함수가 하는 일, 종료 조건, 메모이제이션 변수의 정의, 그리고 목록을 작성하는 방법을 설명해야 한다.
  - 목표 점수에서 취할 수 있는 점수 만큼을 뺀 값을 재귀 호출 한 후, 반환되는 전체 목록에 뺀 점수의 항목을 앞에 각각 붙이고 취합하는 방식으로 구현할 수 있다.
  - 종료 조건은 0점이 되었을 때 (성공), 혹은 점수가 남았으나 취할 수 있는 행동이 없을 때(실패) 이다.
  - 목록을 취합하는 방식은 성공의 경우는 해당 항목을 반환하는 경로에 합치고, 실패의 경우에는 버린다.
  - 메모이제이션은 딕셔너리를 사용하며, ws_memo[i]는 i 점을 받기 위한 행동 시퀀스이다.
- 상향식 다이나믹 프로그래밍으로 문제를 해결할 때, 가장 작은 문제를 정의해보자.
  - 가장 작은 문제는 0점을 달성하는 목록을 구하는 문제이다.
- 상향식 다이나믹 프로그래밍으로 문제를 해결할 때, 이전에 계산한 결과를 저장하는 변수를 정의하고 초기화 하는 방법을 제시해보자.
  - 크기 별 문제의 결과를 저장하기 위해서 target + 1 크기의 배열을 빈 배열로 초기화하면서 생성한다.
- 두 가지 구현 방법의 시간 복잡도를 제시하라.

### [코드 예시]

```python

```

---

# 문제 10. 그래프를 트리로

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

신경 세포간의 연결은 생물의 발생 과정에서 이루어지는 자연스러운 현상이다. 하지만, 이러한 신경 세포의 구조를 사용해 생체 디바이스를 인공적으로 만들기 위해서는 신경 세포간의 연결을 인공적으로 만들어줄 필요가 발생한다.

N 연구원은 개발중인 생체 디바이스에서 최소한의 비용으로 인공 신경 세포 사이를 모두 연결하는 방법을 고안하고 있다. 그냥 적당히 설계도에 나열되어 있는 인공 신경 세포 사이에 끊어지지 않게 줄만 그으면 되는 문제인 것 같지만, 인공 신경 세포가 배치된 위치에 따라 연결 비용이 모두 다르고, 대량 생산을 염두에 두는 제품화 단계에서는 이 비용의 조그만 차이가 수익에 큰 영향을 미치게 되기 때문에 최적의 조합을 찾아내는 일이 제품 설계에서 매우 중요한 작업이 된다.

## 수행목표

- 'C', 'T', 'A', 'G' 네 글자로 구성된 문자열이 주어진다. 이 문자열의 부분 순열 중, C, T, A, G 순으로 배치된 부분 문자열의 최장 길이와 이 부분 순열 패턴을 찾아 출력하는 프로그램을 작성한다.
  - 예를 들어 주어진 문자열이 CTAGTACG인 경우, 이 문자열에서 `__A__ACG`의 오름차순 부분 순열이 가장 긴 오름차순 부분 순열이 된다. (같은 값의 경우 오름차순으로 간주한다.) 이 경우 4와 함께 AACG를 출력한다.
  - CTAGGTACG의 경우 `C__GGT___`, `__AGGT___` 등 여러 개의 길이가 4인 오름차순 부분 순열을 찾을 수 있으며, 이 부분순열이 가장 긴 오름차순 부분 순열이다. 이 경우 4와 함께 찾을 수 있는 부분 순열 중 하나를 출력한다.
- 다음 테스트케이스에는 16개의 문자열이 주어진다. 이 문자열에서 가장 긴 오름차순 부분 순열의 길이와 부분 순열 중 하나를 출력한다.
  ```python
  testcases = ['CTAGTACG', 'CTAGGTACG', 'AAA', 'ACGT', 'TGCA', 'ACTTTTTTTCGGGGGGT', 'ACTTTTTCT', 'ACTTTTTCGGGT', 'ACTTTTTCGGGGGGTTTTTT', 'GCCTGCTGGT', 'CCCATCTTCCGTCATTATAG', 'ACCAAGAAACTGTAATCTCCTTCTTCTCGA', 'TCCGTTCGGCATACCCCCCGGCGGGGATATCGAACTGGAG', 'GTCCGAGGGGCAAGCAAGCGGGTTGACGCATCCTGAAGCTCTTTCACAGG', 'ATGGGTGAAAACCCCCATTAACATAACTGGCGCCGGGAGTTACGAATCTCGTGCTTGAAGAAGGGCAAACTGTTTTACGAGAGGTGGGGACAGACTACCT', 'CAATCATCTGGCCTCCAATTAAGACTTTATGCTGCTGCTAGCCAGAAATTTATTGACCACCACGGATGCGACGGCTCGACGCTGATGGTGTGACGTTGCAAAAGCTGGTCTATGGCTTGGTTTAGTGGTGGCCATGGACCCCTCACTCGTAATTTGTAAATGTAATAATAGGCGCCAAATTCAGTGTCTGATGCTGGTTCCCCAGCTGTCTCTTGCAAGTCGGCGCCAATCGTTTTCCACGGAACGACTTGTCTGCGGCCTATGCATCGTTCGCTAGCCAGTTAAATGGCATATGCTAGTTCACCTAACCACTTCAAAGTATCAGCCCAAGGATTTTCACCAGGTAGGGAAATTATTAGGATCGCTAAGCAACCCACTGTCCGATACGACAGCCCGCTGCCAGCGTTTCATTATAGTCTTGGAATACCGTTCCGTTGTTTTCAAACCGTTCCAACCCCCCTGATGCGCCAGCGTCTAGGTTTGTCGGCGCTAGTGGCCACCAGCGCGTGCCATACACGCGGTGTTGGCCTAATCAGTTGCTAAGTACCTAGAACGACAGCTAACCGAAAGAGAAAACATCGAGCTTTTACGTAATTTCTACACTATACGCCCTGGACGACATACTAGTCTGCGTTTGGTCTATATCTATATGTTCACTCCGAAGCTCTCAGATCTGATACAGACACATGAGGGTCTTGTAGCATTCCTAGAGCTTCTATACGCGTGGTTCGCCGGCCAGGATATGGGTCACACGGGTACATTCAACTCCTACTACGAGAGGGGGTGTTTAAACTATCCGTAAAGCCACAGTAATCGAGATTTACCCATAGGCGACCGATCAAATCGTCTATGGACAGAAGTGGCTCCGCCCGCGAAGCTAACATAAGGTCCAATTACATTGTTACCTAAGCTCTTGTACTAAAATCTAGTGATCATAATCCCGGCCCCGTTATCGCCACCATGGCAATATTTGAACGCGCCCTCGTAGAGCTCATAAGGA']
  ```

## 수행단계

- 문제의 구조를 분석한다.
- 문제의 구조를 사용하는 다이나믹 프로그래밍 접근 방식으로 최장 부분 순열 중 하나를 문자열로 만들어 반환하는 함수를 dp_exer/ascending_pattern.py 파일에 구현한다.
  - 다이나믹 프로그래밍 방식으로 구현하며, 구현한 알고리즘의 시간 복잡도를 확인한다. -
- 테스트케이스로 제시된 16개의 문자열에서 가장 긴 오름차순 부분 문자열 중 하나를 만들어 길이와 함께 출력한다.

## 결과예시

```
Testcase 1
    가장 긴 오름차순 부분 순열의 길이 : 4
    가장 긴 오름차순 부분 순열 중 하나 : AACG

Testcase 2
    가장 긴 오름차순 부분 순열의 길이 : 4
    가장 긴 오름차순 부분 순열 중 하나 : CGGT
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/ascending_pattern.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 접근방법을 사용해 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

  ```
  Testcase 1
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : AACG

  Testcase 2
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : CGGT

  Testcase 3
      가장 긴 오름차순 부분 순열의 길이 : 3
      가장 긴 오름차순 부분 순열 중 하나 : AAA

  Testcase 4
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : ACGT

  Testcase 5
      가장 긴 오름차순 부분 순열의 길이 : 1
      가장 긴 오름차순 부분 순열 중 하나 : T

  Testcase 6
      가장 긴 오름차순 부분 순열의 길이 : 10
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTTTT

  Testcase 7
      가장 긴 오름차순 부분 순열의 길이 : 8
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTT

  Testcase 8
      가장 긴 오름차순 부분 순열의 길이 : 8
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTT

  Testcase 9
      가장 긴 오름차순 부분 순열의 길이 : 15
      가장 긴 오름차순 부분 순열 중 하나 : ACCGGGGGGTTTTTT

  Testcase 10
      가장 긴 오름차순 부분 순열의 길이 : 6
      가장 긴 오름차순 부분 순열 중 하나 : CCGGGT

  Testcase 11
      가장 긴 오름차순 부분 순열의 길이 : 11
      가장 긴 오름차순 부분 순열 중 하나 : CCCCCCGTTTT

  Testcase 12
      가장 긴 오름차순 부분 순열의 길이 : 16
      가장 긴 오름차순 부분 순열 중 하나 : AAAAAACTTTTTTTTT

  Testcase 13
      가장 긴 오름차순 부분 순열의 길이 : 20
      가장 긴 오름차순 부분 순열 중 하나 : CCCCCCCCCCGGGGGGGGGG

  Testcase 14
      가장 긴 오름차순 부분 순열의 길이 : 20
      가장 긴 오름차순 부분 순열 중 하나 : CCGGGGGGGGGGTTTTTTTT

  Testcase 15
      가장 긴 오름차순 부분 순열의 길이 : 39
      가장 긴 오름차순 부분 순열 중 하나 : AAAAACCCCCCCGGGGGGGGGGGGGGGGGGGGGGGGGTT

  Testcase 16
      가장 긴 오름차순 부분 순열의 길이 : 274
      가장 긴 오름차순 부분 순열 중 하나 : AAAAAAAAAAAAAAAACCCCCGGGGGGGGGGGGGGGGGGTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
  ```

### [문제에 대한 이해]

- 문제의 구조를 제시하라.
  - 문자열의 i 번째 글자의 값을 마지막 값으로 반드시 포함하는 가장 긴 부분 순열의 길이를 dp[i]라고 표현하면, 임의의 dp[j]의 값은 j 보다 작은 모든 k에 대해서 다음 모든 값들의 최대값이 되는 구조가 성립한다.
    - 만약 k 번째 글자보다 j 번째 글자가 같거나 더 큰 값의 글자인 경우 : dp[k] + 1
    - 그렇지 않은 경우 : 1
- 가장 긴 오름차순 부분 순열을 찾는 방법을 설명하라.
  - 가장 긴 오름차순 부분 순열의 길이를 문자열의 모든 인덱스에 대해서 갱신할 때, j번 인덱스의 글자로 끝나는 오름차순 부분 순열의 이전 글자는 k번째 인덱스의 글자가
    된다. 이를 모든 인덱스 별로 관리한 다음, 부분 문자열의 길이가 최대가 되는 j에 대해서 역순으로 이전 글자를 이어 붙이는 과정으로 가장 긴 오름차순 부분 순열을 찾을 수 있다.
- 구현한 알고리즘의 시간 복잡도를 제시하라.
  - 모든 글자에 대해서 더 작은 글자를 반복하는 구조이므로 n의 이중 루프 구조를 가진다. O(n^2)에 해당된다.
- 만약 문제의 조건이 가장 긴 '연속된 오름차순 부분 문자열'인 경우 문제를 어떻게 해결할 수 있는지 접근 전략을 제시해보자.
  - 슬라이딩 윈도우, 헤드와 테일 포인터 등을 유지하면서 전체 문자열을 스캔하는 방법 등 적당한 전략을 제시할 수 있는지 확인한다.

### [코드 예시]

```python
def find_lap(input_seq):
    if not input_seq:
        return ''

    dp = [1] * len(input_seq)
    prev = [-1] * len(input_seq)

    max_len = 0
    max_index = 0

    for i in range(1, len(input_seq)):
        for j in range(i):
            if input_seq[j] <= input_seq[i] and dp[j] + 1 > dp[i]:
                dp[i] = dp[j] + 1
                prev[i] = j
                if dp[i] > max_len:
                    max_len = dp[i]
                    max_index = i

    longest_ascending_pattern = ''
    while max_index != -1:
        longest_ascending_pattern += input_seq[max_index]
        max_index = prev[max_index]
    return longest_ascending_pattern[::-1]


def main():

    testcases = ['CTAGTACG', 'CTAGGTACG', 'AAA', 'ACGT', 'TGCA', 'ACTTTTTTTCGGGGGGT', 'ACTTTTTCT', 'ACTTTTTCGGGT', 'ACTTTTTCGGGGGGTTTTTT', 'GCCTGCTGGT', 'CCCATCTTCCGTCATTATAG', 'ACCAAGAAACTGTAATCTCCTTCTTCTCGA', 'TCCGTTCGGCATACCCCCCGGCGGGGATATCGAACTGGAG', 'GTCCGAGGGGCAAGCAAGCGGGTTGACGCATCCTGAAGCTCTTTCACAGG', 'ATGGGTGAAAACCCCCATTAACATAACTGGCGCCGGGAGTTACGAATCTCGTGCTTGAAGAAGGGCAAACTGTTTTACGAGAGGTGGGGACAGACTACCT', 'CAATCATCTGGCCTCCAATTAAGACTTTATGCTGCTGCTAGCCAGAAATTTATTGACCACCACGGATGCGACGGCTCGACGCTGATGGTGTGACGTTGCAAAAGCTGGTCTATGGCTTGGTTTAGTGGTGGCCATGGACCCCTCACTCGTAATTTGTAAATGTAATAATAGGCGCCAAATTCAGTGTCTGATGCTGGTTCCCCAGCTGTCTCTTGCAAGTCGGCGCCAATCGTTTTCCACGGAACGACTTGTCTGCGGCCTATGCATCGTTCGCTAGCCAGTTAAATGGCATATGCTAGTTCACCTAACCACTTCAAAGTATCAGCCCAAGGATTTTCACCAGGTAGGGAAATTATTAGGATCGCTAAGCAACCCACTGTCCGATACGACAGCCCGCTGCCAGCGTTTCATTATAGTCTTGGAATACCGTTCCGTTGTTTTCAAACCGTTCCAACCCCCCTGATGCGCCAGCGTCTAGGTTTGTCGGCGCTAGTGGCCACCAGCGCGTGCCATACACGCGGTGTTGGCCTAATCAGTTGCTAAGTACCTAGAACGACAGCTAACCGAAAGAGAAAACATCGAGCTTTTACGTAATTTCTACACTATACGCCCTGGACGACATACTAGTCTGCGTTTGGTCTATATCTATATGTTCACTCCGAAGCTCTCAGATCTGATACAGACACATGAGGGTCTTGTAGCATTCCTAGAGCTTCTATACGCGTGGTTCGCCGGCCAGGATATGGGTCACACGGGTACATTCAACTCCTACTACGAGAGGGGGTGTTTAAACTATCCGTAAAGCCACAGTAATCGAGATTTACCCATAGGCGACCGATCAAATCGTCTATGGACAGAAGTGGCTCCGCCCGCGAAGCTAACATAAGGTCCAATTACATTGTTACCTAAGCTCTTGTACTAAAATCTAGTGATCATAATCCCGGCCCCGTTATCGCCACCATGGCAATATTTGAACGCGCCCTCGTAGAGCTCATAAGGA']

    for i, tc in enumerate(testcases):
        print(f"Testcase {i + 1}")
        longest_ascending_pattern = find_lap(tc)
        length_of_lap = len(longest_ascending_pattern)
        print(f"    가장 긴 오름차순 부분 순열의 길이 : {length_of_lap}")
        print(f"    가장 긴 오름차순 부분 순열 중 하나 : {longest_ascending_pattern}")
        print()

if __name__ == '__main__':
    main()


```

---

# 문제 11. 최적 경로

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

D 연구원은 오름차순 패턴의 길이와 관련된 염기 서열과 유전 정보와의 관계를 찾는데 실패했다. 하지만 불굴의 의지로 또 다른 가능성을 찾아보고 있었다. 그런 그가 문득 DNA 염기 서열에서 특수한 패턴을 확인하는 프로그램이 있으면 편하지 않을까란 생각을 했다.

D 연구원이 생각하는 특수 패턴 확인 프로그램은 일반적인 '와일드카드' 매칭과 동일한 방법이다. 즉, `*`와 `?`를 사용해서 검사를 하자는 아이디어였다.

## 수행목표

- 'C', 'T', 'A', 'G' 네 글자로 구성된 문자열 형태의 유전자 염기 서열과 패턴이 주어진다. 문자열에 패턴이 포함되어 있는지를 검사하고 그 결과를 출력하는 프로그램을 작성한다. 패턴은 다음과 같다.
  - 단순 문자열 패턴 : 패턴이 문자열에 포함되어 있는지를 검사한다. 예를 들어 주어진 문자열이 `CTATTAG`이고, 패턴이 `TAT`인 경우는 `_TAT___`로 패턴이 문자열에 포함되어 있으므로 '포함'을 출력한다.
  - `?` 와일드카드 패턴 : `?`는 아무 한 글자와 매칭되며, 이러한 패턴이 문자열에 포함되어 있는지 검사한다. 주어진 문자열이 `CTATTAG`이고, 패턴이 `T?T`인 경우는 `_T?T___`로 패턴이 문자열에 포함되어 있으므로 '포함'을, 패턴이 `A?G`인 경우는 이런 패턴이 포함되어 있지 않으므로 '불포함'을 출력한다.
  - `*` 와일드카드 패턴 : `*`는 아무 여러 글자와 매칭되며, 이러한 패턴이 문자열에 포함되어 있는지 검사한다. 주어진 문자열이 `CTATTAG`이고 패턴이 `TA*AG`인 경우 '포함'을, 패턴이 `TA*AT`인 경우 '불포함'을 출력한다. 또한 `*`는 0글자 이상의 아무 여러 글자이므로 문자열이 `CCCAGTT`일 때 패턴이 `AG`, `A*G`는 포함, `A?G`는 불포함을 의미한다.
  - 패턴은 `*`와 `?`를 0개 이상 여러번 사용해서 구성된다. 문자열이 `CGTATGTAGCCGTGTA`이고 패턴이 `AT*CG?GT`인 경우 '포함'을 출력한다. (`___AT_____CG_GT_`)
- 다음 첨부 파일에는 15개의 테스트케이스가 포함되어 있다. 각 테스트케이스는 문자열과 패턴의 튜플로 구성되어 있으며, 마지막 두 개의 테스트케이스는 공백 문자를 포함한 일반적인 문자열에 해당한다. (공백 문자도 하나의 글자로 처리한다.) 이 15개의 테스트케이스에서 주어진 패턴이 포함되어 있는지 검사한 결과를 출력한다.

## 수행단계

- 문제의 구조를 분석한다.
- 이 문제를 상향식 다이나믹 프로그래밍으로 구현하기 위한 방법을 정리한다.
  - 힌트 - 이 문제를 해결하기 위한 상향식 접근 방법에서는 작은 문제의 결과를 저장하기 위한 자료형으로 이차원 배열을 사용한다.
    - dp[s][p], 0 <= s <= 문자열의 길이, 0 <= p <= 패턴의 길이
- 문제의 구조를 사용하는 다이나믹 프로그래밍 접근 방식으로 패턴이 문자열에 포함되어 있는지를 검사하는 함수를 dp_exer/wildcard_pattern.py 파일에 구현한다.
  - 다이나믹 프로그래밍 방식으로 구현한다.
- 테스트케이스로 제시된 15개의 문자열과 패턴에 대해서 검사 결과를 출력한다.

## 결과예시

```
Testcase 1 : 포함

Testcase 2 : 포함

Testcase 3 : 불포함

Testcase 4 : 포함

Testcase 5 : 불포함
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/wildcard_pattern.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍 접근방법을 사용해 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

  ```
  Testcase 1 : 포함

  Testcase 2 : 포함

  Testcase 3 : 불포함

  Testcase 4 : 포함

  Testcase 5 : 불포함

  Testcase 6 : 포함

  Testcase 7 : 포함

  Testcase 8 : 불포함

  Testcase 9 : 포함

  Testcase 10 : 포함

  Testcase 11 : 불포함

  Testcase 12 : 포함

  Testcase 13 : 불포함

  Testcase 14 : 포함

  Testcase 15 : 불포함
  ```

### [문제에 대한 이해]

- 문제의 구조와 상향식으로 문제를 전개해나가는 방식을 설명하라.
  - 모든 패턴은 시작이 `*`이 아닌 경우 처음에 `*`을 추가하고, 마지막이 `*`이 아닌 경우 마지막에 `*`를 추가한다.
  - dp[i][j]를 i번째 글자 까지의 문자열과 j번째 글자 까지의 패턴에 대해서 검사한 결과라 하자. (참거짓값)
  - 우선 패턴 시작의 `*`의 크기만큼 dp[0][j]를 True로 초기화한다.
  - 패턴을 하나씩 추가하면서 차례대로 검사하고, 이 과정을 문자열의 글자를 추가해가면서 검사하는 방향으로 상향식으로 계산해 나간다.
  - 추가한 패턴이 `*`인 경우 `dp[i][j]`는 `dp[i][j - 1]`가 참이거나(`*` 이전 까지 참이었는가) `dp[i - 1][j]`가 참인 경우(이전 글자까지 참이었는가) 참이 된다.
  - 그렇지 않은 경우 추가한 패턴의 글자와 문자열의 추가한 글자가 일치한 경우에 `dp[i][j]`은 `dp[i - 1][j - 1]`와 동일한 값을 가지며, 일치하지 않는 경우는 거짓이 된다. `?`패턴인 경우는 패턴의 추가한 글자와 문자열의 추가한 글자가 일치하는 것으로 간주하고 처리한다.
- 상향식으로 문제를 해결하기 위한 가장 간단한 문제는 무엇이며, 이 값은 무엇으로 초기화되는가?
  - 빈 문자열을 빈 패턴과 비교하는 경우이며, 이는 참으로 초기화된다.
  - 패턴 앞 부분에 `*`의 길이 만큼 `dp[0][j]`는 참이 된다.

### [코드 예시]

```python
from wildcard_pattern_data import testcases
def isMatch(sequence, pattern):
    seq_size = len(sequence)
    pat_size = len(pattern)
    dp = [[False] * (pat_size + 1) for _ in range(seq_size + 1)]
    dp[0][0] = True
    for j in range(1, pat_size + 1):
        if pattern[j - 1] == '*':
            dp[0][j] = dp[0][j - 1]

    for i in range(1, seq_size + 1):
        for j in range(1, pat_size + 1):
            if pattern[j - 1] == '*':
                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
            elif pattern[j - 1] == '?' or sequence[i - 1] == pattern[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]

    return dp[seq_size][pat_size]


def main():

    for i, tc in enumerate(testcases):
        sequence, pattern = tc
        pattern = '*' + pattern + '*'
        print(f"Testcase {i + 1} : {'포함' if isMatch(sequence, pattern) else '불포함'}")
        print()

if __name__ == '__main__':
    main()
```
# 단계 8. 길을 찾는 방법들

## 스토리

유전자 정보를 연구하는 G 연구원과 T 연구원은 학창 시절부터의 절친이었다. 어쩌다보니 같은 직장에서 근무하게 된 두 사람은 종종 식사나 술자리를 함께 하면서 여전히 좋은 관계를 유지하고 있었다. 어느 가을 저녁, 두 사람은 연구소 근처 맛집에서 저녁을 먹고 있었다. T 연구원은 연구소 밖에서 업무 이야기하는 것을 좋아하지는 않았지만, 요즘 잘 안풀리는 문제가 있다며 G 연구원에게 의견을 물어봤다.

“우리 연구 그룹에서 개발한 스마트 마우스 기억나지?”

“응. 기억 능력에 연산 능력이 있을지도 모른다고 발표했던 그 쥐 말하는거지?”

“응. 그런데 문제가 있어.”

“뭔데?”

“쥐의 지능을 검증하려고 하는데, 우리가 멍청한게 문제지.”

이렇게 시작한 사연은 다음과 같았다.

스마트 동물 연구 그룹에서 개발한 “영리한 쥐”가 연산 능력과 학습 능력이 있는지를 확인하기 위해 다음과 같은 실험을 설계했다.

방이 N개가 있는 미로를 설치한다. 각 방은 1번 방에서 N번 방까지 이름이 붙어 있고, 시작 지점은 방은 아니지만 편의상 0번 방이라고 부르고 있다. 0번 방은 N개의 통로가 있고, 1번 방에서 N번 방까지 연결되어 있다. 1번 방은 N-1개의 통로가 있고 2번 방에서 N번 방까지 연결되어 있다. 이런 식으로 K번 방은 K+1번 방부터 N번 방까지 연결된 통로를 가지고 있다. 각 통로는 길이가 정해져 있으며, 쥐들의 속도는 모두 일정하다. 그리고 N번 방에 도착하면 보상을 주는데, 빨리 도착할 수록 보상이 좋아진다.

“그래서 보상이 뭐야?”

“응. 8년 숙성된 냄새가 엄청난 치즈. 쥐가 그 냄새를 맡으면 미칠 듯이 좋아하더라구. 문제는, 이 치즈가 싸구려라서 시간이 지나면 지날 수록 냄새가 점점 사라진다는건데…”

“그래서?”

“이 치즈 냄새가 통로에 퍼지니까, 기를 쓰고 쥐들이 달리더라구.”

“그리고?”

“영리한 쥐가 매번 1등을 했지.”

“그러면 입증된거 아니야?”

“그런데, 영리한 쥐가 점점 학습을 해서 더 영리해지고 있는지를 확인해야 하니까. 그런데 문제는 영리한 쥐가 최선의 선택을 했는지 확인해보고 싶은데… 그게 계산이 잘 안되더라구.”

“음. 혹시, 실험할 때 방은 몇 개 설치한거야?”

“적당히 설치했어. 한 1000개 정도?”

G 연구원은 순간 할 말을 잃었다. 방이 1000개인 미로라면 방과 방 사이의 통로의 개수만 499500개이다. 적당히라는게 뭔지 모르는 녀석. 아니, 우리 연구소 실험 예산 괜찮은거야?

---

# 문제 1. 모든 경로

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

S 연구원은 논문 성과가 탁월한 연구원이다. 그러다 보니 논문 발표를 위해서 해외 출장도 잦은 편이다. 그런 그도 이런 신기한 동전을 발행하는 나라는 처음이었다.

'1 다음이 7, 그리고 그 다음이 15?'

알고보니 그 국가의 오래전 역사 시대에 초대 국왕 1명이 7명의 기사들과 15개의 주변 왕국을 정복한 역사를 기념하기 위한 주화 시스템이었던 것이다. 그리고 33원 동전이 있었는데, 이 동전이 왜 발행되고 있는지는 도무지 알 수가 없었다.

여하튼 S 연구원은 이 나라에서도 동전을 사용해 이곳저곳을 방문해야 한다.

## 수행목표

- 편의상 어떤 국가의 화폐 단위를 원이라고 부르기로 하자. S 연구원이 방문한 국가의 동전은 1원 동전, 7원 동전, 15원 동전, 33원 동전으로 구성되어 있다.
- 이 나라의 일반 버스 요금은 1117원, 고급 버스 요금은 2521원, 지하철 요금은 1923원이다. 네 종류의 동전을 제한없이 사용할 수 있을 때, 최소 개수의 동전으로 일반 버스, 고급 버스, 지하철을 탑승할 때 사용해야 할 동전 별 개수를 출력해보자.
- S 연구원이 귀국하기 전에 인플레이션으로 인한 영향으로 1원 동전이 사용금지되고, 대신 53원 동전이 새로 발행되었다. 세로운 네 종류의 동전이 있을 때 최소 개수의 동전으로 세 종류의 대중교통을 탑승할 때 사용해야 할 동전의 개수와 손해보는 금액이 얼마인지를 출력해보자.

## 수행단계

- `dp_exer/bus_fare_dynamic.py` 파일에 다음을 구현한다.
  - 어떤 구성의 동전으로도 정해진 요금을 최소 개수의 동전으로 이용하는데 필요한 각 동전 별 개수와 정확히 지정한 요금을 만들 수 없을 때 손해를 보아야 하는 금액이 얼마인지를 반환하는 함수를 구현한다.
  - 각 동전의 사용 개수에는 제한이 없다.
  - 사용 가능한 동전 조합으로 정해진 금액을 지불할 수 없는 경우 이 금액을 초과하는 최소 요금을 지불하며, 이 차액이 손해를 보아야 하는 금액이 된다.
  - 다이나믹 프로그래밍을 사용해서 구현한다.
- 사용 가능한 동전이 1원, 7원, 15원, 33원 네 종류일 때 1117원, 2521원, 1923원을 최소 개수의 동전으로 각각 지불할 때 필요한 각 동전의 개수를 출력한다.
- 사용 가능한 동전이 7원, 15원, 33원, 53원 네 종류일 때 1117원, 2521원, 1923원을 최소 개수의 동전으로 각각 지불할 때 필요한 각 동전의 개수와 손해를 보게 되는 경우 손해 금액을 출력한다.

## 결과 예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 호주머니에 사용 가능한 동전의 수가 제한되어 있는 상황에서 다이나믹 프로그래밍 방식으로 최소한의 동전으로 요금을 지불하는 방법을 알려주는 함수를 구현한다.
  - 만약 모든 동전을 사용해도 요금을 지불할 수 없는 경우는 모자란 금액을, 동전이 남은 상태에서 정확히 지정한 요금을 지불할 수 없는 경우는 최소한의 손해를 보고 요금을 지불할 때, 이 최소한의 손해가 얼마인지도 반환한다.
- 7원, 15원, 33원, 53원 동전이 각각 20개씩 있을 때, 1117원, 2521원, 1923원을 최소 개수의 동전으로 지불해야 하는 경우의 필요한 각 동전의 개수, 모자란 금액 또는 손해를 보는 금액이 얼마인지를 출력한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/bus_fare_dynamic.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방식을 적용해 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```

    ```

### [보너스 과제 확인]

- 보너스 과제를 지시한 대로 해결하였으며 그 결과는 정확한가?
  - 동전이 제한되어 있을 때 요금을 지불하는 방법과 모자란 요금 또는 손해보는 요금의 금액을 반환하는 함수를 다이나믹 프로그래밍 방식을 사용해 구현하였는지 확인한다.
  - 결과 예시는 다음과 같다.

```

```

### [문제에 대한 이해]

- 그리디 알고리즘으로 최소의 동전 개수를 사용하는 거스름돈을 계산 방법을 제공해주지 못하는 이유는 무엇인가? 이전 문제의 예제와 위에서 제시한 경우를 비교해서 답해보라.
  - 탐욕적인 선택이 최적해를 보장하지 못하는 경우이다.
  - 상위 동전이 하위 동전의 정수배로만 구성되어 있는 경우, 상위 동전이 하위 동전의 선택을 완전히 커버할 수 있는 반면, 그렇지 않은 경우 상위 동전을 선택했을 때 하위 동전의 선택보다 못한 경우가 발생하기 때문이다.
- 그리디 알고리즘에서 탐욕적 선택을 한 후의 상황은 마치 다이나믹 프로그래밍에서 어떤 문제의 일부를 해결한 상황과 유사하다. 이 시점에서 그리디 알고리즘과 다이나믹 프로그램의 차이는 무엇인가?
  - 다이나믹 프로그래밍의 경우 하위 문제가 상위 문제에 속해 있고, 가장 작은 문제가 최적의 문제라는 조건이 있다.
  - 그리디 알고리즘은 하위 문제가 상위 문제에 속하지 못하는 경우가 발생한다.
- 최소 동전을 사용해 거스름돈 거슬러 주는 다이나믹 프로그래밍 접근 전략을 제시하라.
  - 금액 별로 최소 개수를 저장하고, 가장 작은 경우 (0센트) 부터 시작해 목표 금액 까지 거슬러 주는 방법을 상향식으로 계산해 올라가면서, 작은 금액에 대해서 계산한 결과를 사용한다.
  - 점화식은 다음과 같다. 거슬러 주는 동전의 개수를 coin_count(n)이라고 하면 coin_count(n) = min(coin_coint(n), 1 + [n - coin]) for all coin이 된다.
- 사용 가능한 동전 종류의 배열이 정렬되어 있다고 가정하자. 동전의 개수가 m, 거슬러주는 목표 금액이 n인 경우, 그리디 알고리즘으로 구현한 경우의 시간 복잡도를 제시하라.
  - 금액과 무관하게 가장 큰 동전부터 나눗셈을 한 번씩 하면 된다. 시간 복잡도는 O(m)이다.
- 동전의 개수가 m, 거슬러주는 목표 금액이 n인 경우, 다이나믹 프로그래밍으로 접근한 경우의 시간 복잡도를 제시하라.
  - 금액 별(n)로 반복하면서 매 반복 시에 동전의 개수(m) 만큼 반복하므로, 시간 복잡도는 O(mn)이다.

### [코드 예시]

```python

```

---

# 문제 2. 제한된 모든 경로

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

연구소의 예산은 주로 국가에서 지원해주지만, 그것만으로 모든 연구 예산을 확보할 수가 없었다. 그래서 연구소에는 몇 가지 수익 사업을 병행하고 있었다. 그 중 하나가 다른 기관의 의뢰를 받아서 DNA 염기 서열을 해독해 주는 일이었다.
이 사업의 사업 책임자 P 책임 행정원은 지선생의 입사동기로 오래된 벗이었다. 그 친구가 어느날 지선생을 찾아와 물었다.
“이걸 어떻게 굴려야 돈일 더 벌 수 있을까?”

## 수행목표

- 지선생은 이 문제를 다음과 같이 정의했다.
  > - 연구소는 한 번에 주문에서 처리하는 DNA의 최소 개수를 1단위로 정해놓고 있으며, 이 최소 단위의 정수배에 해당하는 요청만 받고 있다. 그리고 염기서열 해독 시스템은 매월 연구 진행상황에 따라 사업에 사용할 수 있는 요청 건수, 그리고 요청의 개수에 따른 가격이 바뀐다.
  > - 이에 따라 특정 월의 사업에서 다음의 값이 고정되어 있다.
  >   - 사업을 통해 받아서 처리해 줄 수 전체 요청 건수(기준 : 단위)
  >   - 주문당 요청의 단위 별 가격 배열 (억원)
  > - 구하고자 하는 해답은 다음과 같다.
  >   - 가능한 최대 매출액과 최고의 매출을 기록할 수 있도록 판매하는 방법을 반환한다. 단 같은 최대 매출을 기록하는 판매 방법이 있는 경우, 처리하는 주문의 횟수가 최소인 방법을 출력하며, 처리하는 주문의 횟수가 동일한 경우, 아무거나 출력해도 무방하다.
- 다음 테스트케이스의 결과를 출력한다.
  - 각 테스트케이스는 (n, price)의 튜플로 구성되며, n은 처리 가능한 전체 요청 건수이며, price는 단위 별 가격의 배열이며, 이 때의 단위는 각 배열의 항목에 대응되는 인덱스 값에 1을 더한 값이다.
  - 예를 들어 price 배열이 [1, 5, 8, 9]인 경우, 1단위 주문의 가격은 1억원, 4단위 주문의 가격은 9억원이라는 의미가 된다.

```python
TC1 = (4, [1, 5, 8, 9])
TC2 = (8, [2, 5, 8, 9, 10, 17, 17, 20])
TC3 = (10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
TC4 = (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
TC5 = (100, [2, 5, 7, 8, 10, 14, 16, 17, 20, 24, 27, 29, 32, 33, 37, 38, 41, 43, 47, 49, 51, 54, 56, 60, 64, 68, 71, 75, 78, 80, 82, 84, 87, 91, 93, 94, 95, 99, 100, 104, 106, 107, 109, 111, 115, 118, 120, 124, 126, 130, 133, 136, 138, 140, 142, 145, 149, 153, 155, 158, 162, 163, 165, 166, 168, 172, 174, 175, 179, 182, 183, 186, 188, 189, 193, 196, 200, 203, 204, 207, 211, 214, 218, 220, 223, 227, 228, 230, 231, 232, 233, 236, 239, 240, 242, 244, 246, 248, 251, 253])
```

## 수행단계

- 문제의 구조를 분석한다. 다음 흐름을 따라가 보면 분석에 도움이 될 수도 있다.
  - 이 문제를 처리 가능한 단위수 n, 주문의 요청 단위가 n일 때의 가격을 price[n - 1], max_sales(n)은 처리 가능 단위수가 n일 때의 최대의 매출로 정의하고 다음 사항을 확인해보자.
  - n단위의 처리가 가능한 상태에서 1단위의 요청을 처리했을 때, 기대 가능한 최대 매출은 얼마인가? price 배열과 max_sales 함수로 표현해보자.
  - 2단위의 요청을 처리했을 때 기대 가능한 최대 매출은 얼마인가?
  - i단위의 요청을 처리했을 때 기대 가능한 최대 매출은 얼마인가?
  - 이렇게 구한 매출들을 어떤 방식으로 취합해야 n 단위가 있을 때의 최대 매출이 될까?
- 이 문제를 다이나믹 프로그래밍 방식을 사용해 해결하는 함수를 dp_exer/max_sales.py 파일에 구현한다.
  - 만약 하향식 다이나믹 프로그래밍으로 구현하는 경우 메모이제이션을 적용한다.
  - 최대 기대 매출 뿐 아니라 어떻게 주문을 받아야 하는지도 계산해 함께 반환한다.
- 테스트 케이스를 구현한 함수를 사용해 결과를 구하고 출력하는 테스트 코드를 main 함수에 구현한다.

## 결과예시

```
TC 1:
최대 매출 : 10억원
판매 방법 :
    2단위 주문 : 2회
(이하 생략)
```

## 참고사항

- 이전 문제의 테스트 데이터와 비교하면 첫 번째, 다섯 번째 테스트케이스의 데이터만 다르고 나머지는 같다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 지선생의 도움을 받아서 사업이 번창하자, 이번에는 실제 염기 서열 해독 작업을 진행하는 연구원들의 불만이 쇄도했다. 그들의 요구는 번잡한 1단위 주문은 더 이상 받지 말자는 것이었고, 어짜피 일손은 부족하고 사업은 번창하고 있는 상황이라 이를 수용하기로 했다. 이 경우 다음과 같은 고려 사항이 추가된다.
  - 가격 배열에 1단위 처리의 가격이 적혀 있더라도 이 값은 더 이상 사용하지 않는 값이 된다.
  - 1단위 이외에도 처리하지 않는 단위가 추가된다. 이 경우 해당 단위의 금액은 0으로 제시된다.
  - 최소 요청 건수에 제한이 발생하면서, 최대 매출을 기록하면서도 남는 처리 용량이 발생할 수 있다. 남는 처리 용량도 함께 반환한다.
- 다음 테스트 케이스에 대해서, 최대 기대 매출, 판매 방법, 잔여 처리 용량을 출력한다.

```
TC1 = (4, prices = [0, 5, 0, 9])
TC2 = (8, prices = [0, 0, 8, 0, 0, 0, 14, 0])
TC3 = (10, prices = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1])
TC4 = (10, prices = [0, 2, 3, 4, 5, 6, 7, 8, 9, 0])
TC5 = (100, prices = [0, 0, 7, 8, 10, 14, 16, 17, 20, 24, 27, 29, 32, 33, 37, 38, 41, 43, 47, 49, 51, 54, 56, 60, 64, 68, 71, 75, 78, 80, 0, 0, 0, 0, 0, 94, 95, 99, 100, 104, 106, 107, 109, 111, 115, 118, 120, 124, 126, 130, 133, 136, 138, 140, 142, 145, 149, 153, 155, 158, 162, 163, 165, 166, 168, 172, 174, 175, 179, 182, 183, 186, 188, 189, 193, 196, 200, 203, 204, 207, 211, 214, 218, 220, 223, 227, 228, 230, 231, 232, 233, 236, 239, 240, 242, 244, 246, 248, 251, 253])
```

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/max_sales.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방식으로 구현하였는지 확인한다. 만약 하향식 다이나믹 프로그래밍 방법으로 구현한 경우 메모이제이션이 적용되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다.

    ```
    TC 1:
    최대 매출 : 10억원
    판매 방법 :
        2단위 주문 : 2회

    TC 2:
    최대 매출 : 22억원
    판매 방법 :
        6단위 주문 : 1회
        2단위 주문 : 1회

    TC 3:
    최대 매출 : 10억원
    판매 방법 :
        1단위 주문 : 10회

    TC 4:
    최대 매출 : 10억원
    판매 방법 :
        10단위 주문 : 1회

    TC 5:
    최대 매출 : 267억원
    판매 방법 :
        35단위 주문 : 1회
        34단위 주문 : 1회
        29단위 주문 : 1회
        2단위 주문 : 1회
    ```

### [보너스 과제의 확인]

- 보너스 과제를 지시대로 해결하였는가?
  - 문제의 구조를 사용하는 재귀 호출 방식으로 구현하고 있는지 확인한다.
- 결과가 정확한가?

  - 결과 예시는 다음과 같다.

    ```
    TC 1:
        최대 매출 : 10억원
        판매 방법 :
            2단위 주문 : 2회
        잔여 처리 용량 : 0단위

    TC 2:
        최대 매출 : 16억원
        판매 방법 :
            3단위 주문 : 2회
        잔여 처리 용량 : 2단위

    TC 3:
        최대 매출 : 5억원
        판매 방법 :
            2단위 주문 : 5회
        잔여 처리 용량 : 0단위

    TC 4:
        최대 매출 : 10억원
        판매 방법 :
            8단위 주문 : 1회
            2단위 주문 : 1회
        잔여 처리 용량 : 0단위

    TC 5:
        최대 매출 : 266억원
        판매 방법 :
            29단위 주문 : 3회
            13단위 주문 : 1회
        잔여 처리 용량 : 0단위
    ```

### [문제에 대한 이해]

- n = 4, prices = [1, 5, 8, 9]일 때 최대 매출은 얼마이며, 이 때의 판매 방법은 어떻게 될까?
  - 최고의 매출을 기록하기 위해서는 2단위씩 2번 주문을 받으면 된다. 이 때의 매출은 10억원이다.
- i단위의 요청을 처리했을 때 기대 가능한 최대 매출은 얼마인가? 처리 가능한 용량이 n일 때의 기대 가능한 최대 매출을 max_sales(n)이라 표현하고, i 단위의 가격을 price(i)라고 할 때, 최대 매출을 max_sales와 price를 사용해서 표현하라.
  - i단위의 요청을 처리했을 때의 기대 가능한 최대 매출 : price[i] + max_sales(n - i)
- 문제의 구조를 제시하라.
- 구현한 방식의 시간 복잡도는 얼마인가?

### [코드 예시]

```python

```

---

# 문제 3. 경로합이 최소인 경로

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

목에 건 직원증에 ‘E’이라는 이름이 적혀 있는 연구원이 어이없는 표정으로 멍하니 앉아 있었다. 그가 뒷목을 잡게 된 사연은 다음과 같다.

> - 넓은 사막을 가진 Z국은 전 세계에서 가장 많은 화석을 발견할 수 있는 나라이다. 그런데, 최근 Z국이 어느 나라의 연구자가 발굴하건 간에, 화석의 가치를 종류별로 정하고 각 국가별로 반출할 수 있는 화석의 전체 가치의 크기를 정했다. 만약 정확히 그 가치를 맞추지 못하고 그 값을 넘거나, 모자라는 경우 화석을 반출 할 수 없었다. 다행인 것은 종류별로 개수의 제한은 없다는 점이었다. 즉 가치가 작은 화석은 많은 수를 반출할 수 있으며, 수는 작더라도 가치가 높은 화석을 위주로 반출하는 선택도 가능한 상황이었다.
> - 주로 화석을 연구하는 진화생물학 연구 그룹에서는 반입 가능한 모든 ‘경우의 수’를 살펴보기로 했다. 그래서 E 연구원에게 내려진 특명은 반입 가능한 모든 ‘경우의 수’를 구해오라는 것이었다. 하지만, 일일이 목록의 수를 세어보는것은, 너무나 힘든 일이었다.

진화계통도와 관련된 프로그램을 몇 개 작성한 것이 사람들의 기대감을 지나치게 높여버렸다. E 연구원은 문제를 분석하다가 다시 프로그래밍 지원 게시판의 문을 두드렸다.

## 수행목표

- 반입이 허용된 화석 가치의 총 합과 화석 별 가치가 포함된 배열이 주어진다. 이 상황에서 정확하게 반입 허용 화석 가치를 구성할 수 있는 모든 반입 목록을 작성할 때, 이 반입 목록의 개수를 반환하는 함수를 구현한다.
- 다음 6개의 테스트케이스에 포함된 각각의 테스트케이스는 반입 목표 가치와 화석별 가치의 배열로 구성된 튜플이다.
  - 첫 번째 테스트케이스는 각 화석의 가치가 34, 47, 55일 때, 이 화석들을 조합해 가치 501을 만들 수 있는 목록의 개수를 반환해야 하며, 501을 만들 수 없으므로 반환하는 값은 0이 된다.
  - 두 번째 테스트케이스는 각 화석의 가치가 2, 2일 때 이 화석들을 조합해 가치 8을 만들 수 있는 목록의 개수를 반환해야 한다. 주의할 점은, 두 화석의 가치가 같더라도, 서로 다른 화석이라는 점을 고려해 목록을 만들어야 한다는 것이다. 이 경우, (첫 번째 화석의 개수, 두 번째 화석의 개수) 기준으로 (4, 0), (3, 1), (2, 2), (1, 3), (0, 4) 5개의 목록을 만들 수 있고, 5를 반환한다.
- 다음 테스트케이스의 각각에 대한 결과를 출력한다.

```python
TC1 = (501, [34, 47, 55])
TC2 = (8, [2, 2])
TC3 = (99, [3, 4, 5, 6])
TC4 = (590, [2, 6, 9, 3, 10])
TC5 = (500, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
TC6 = (1000, [1, 2, 3, 4, 5])
```

## 수행단계

- 문제의 구조를 분석하고, 이 문제를 상향식 접근법과 하향식 접근법 각각을 사용해서 해결하는 경우의 해결 방법을 정리한다.
- 반입이 허용된 화석 가치의 총 합과 화석 별 가치가 포함된 배열이 주어진다. 이 상황에서 정확하게 반입 허용 화석 가치를 구성할 수 있는 모든 반입 목록을 작성할 때, 이 반입 목록의 개수를 반환하는 함수를 dp_exer/fossil1.py 파일에 구현한다.
  - 상향식 접근법과 하향식 접근법 각각을 사용하는 두 개의 별도의 함수를 모두 구현한다.
  - 하향식 접근법으로 구현하는 경우 메모이제이션을 적용한다.
- 주어진 테스트케이스에 대해서 결과를 구한 후, 이를 출력한다.
  - 상향식, 하향식 각 접근법으로 답을 구하는데 걸린 시간을 각각 측정해 출력한다.
- 상향식, 하향식 두 접근법의 차이를 구현 방식과 함수의 성능 양 측면에서 비교해보자.

## 결과예시

```
하향식 다이나믹 프로그래밍
    수행 시간: 0.00033283233642578125 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 1.0967254638671875e-05 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
    수행 시간: 0.0011639595031738281 초
(중간 생략)
상향식 다이나믹 프로그래밍
    수행 시간: 9.226799011230469e-05 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 2.1457672119140625e-06 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
(이하 생략)
```

## 참고사항

- 이 문제의 테스트케이스 중 처음 10개는 이전 문제의 테스트케이스와 동일하며, 뒤의 2개가 추가되었다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/fossil1.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍, 메모이제이션을 적용한 하향식 다이나믹 프로그래밍 방법을 사용한 각각의 함수가 구현되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 상향식, 하향식 두 접근 방법의 결과는 동일해야 한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 실행 시간은 다를 수 있다.

```
하향식 다이나믹 프로그래밍
    수행 시간: 0.00033283233642578125 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 1.0967254638671875e-05 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
    수행 시간: 0.0011639595031738281 초
    TC 3에서 생성할 수 있는 반입 목록의 경우의 수 : 585
    수행 시간: 0.041081905364990234 초
    TC 4에서 생성할 수 있는 반입 목록의 경우의 수 : 1722389
    수행 시간: 0.0815131664276123 초
    TC 5에서 생성할 수 있는 반입 목록의 경우의 수 : 2391508958235
    수행 시간: 0.1903541088104248 초
    TC 6에서 생성할 수 있는 반입 목록의 경우의 수 : 357746987
상향식 다이나믹 프로그래밍
    수행 시간: 9.226799011230469e-05 초
    TC 1에서 생성할 수 있는 반입 목록의 경우의 수 : 0
    수행 시간: 2.1457672119140625e-06 초
    TC 2에서 생성할 수 있는 반입 목록의 경우의 수 : 5
    수행 시간: 2.7894973754882812e-05 초
    TC 3에서 생성할 수 있는 반입 목록의 경우의 수 : 585
    수행 시간: 0.000186920166015625 초
    TC 4에서 생성할 수 있는 반입 목록의 경우의 수 : 1722389
    수행 시간: 0.00030112266540527344 초
    TC 5에서 생성할 수 있는 반입 목록의 경우의 수 : 2391508958235
    수행 시간: 0.0003070831298828125 초
    TC 6에서 생성할 수 있는 반입 목록의 경우의 수 : 357746987
```

### [문제에 대한 이해]

- 문제의 구조를 설명하라.
- 상향식 접근법, 하향식 접근법 각각의 해결 전략을 제시하라.
- 두 접근법의 차이를 분석하라. 만약 두 함수의 실행 시간 기준의 성능 차이가 존재한다면, 분석을 통해 이 차이를 설명할 수 있어야 한다.

### [코드 예시]

```python

```

---

# 문제 4. 경로합이 최대인 경로

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

“그 경우의 수가 그 경우의 수가 아니다!”

진화생물학 연구그룹의 그룹장이 E 연구원에게 핀잔을 줬다. 우리는 ‘경우의 수'라는 말을 쓸 때, ‘경우의 개수'로 쓰기도 하지만 ‘모든 경우의 목록'에도 경우의 수라는 표현을 쓰곤 한다. 물론 E 연구원도 ‘경우의 수’가 그 ‘경우의 수’일지도 모른다는 생각은 했지만, 계산 결과 나온 어마어마한 크기의 ‘경우의 수’를 보고, 전체 가능한 목록을 가지고 오라는 이야기는 아니겠지 생각했던 것이다. 그래서, E 연구원은 그룹장에게 되물었다.

“2조개가 넘는 목록을 다 보시겠다구요?”

그룹장의 말.

“내가 알아서 할 테니까…”

## 수행목표

- 이전 문제에서 해결한 방법 중 상향식 접근법을 사용해서 문제를 해결하면서 동시에 목록의 개수 뿐 아니라 모든 목록을 출력하는 프로그램을 작성한다.
- 다음 데이터를 사용해 각 테스트케이스의 목록의 개수 및 모든 목록을 구하고, 이를 출력한다.

```python
TC1 = (501, [34, 47, 55])
TC2 = (5, [1, 2, 3])
TC3 = (25, [3, 4, 5, 6])
```

## 수행단계

- 이전 문제에서 구현한 두 가지 방식 중 상향식 다이나믹 프로그래밍 접근 방법을 사용할 때, 목록의 개수 뿐 아니라 모든 목록을 작성하도록 수정하는 방법을 정리한다.
- 상향식 접근 방법을 사용해서 주어진 데이터로 생성 가능한 전체 목록의 수와 모든 목록을 반환하는 함수를 dp_exer/fossil2.py 파일에 구현한다.
- 주어진 3개의 테스트케이스에 대해서 각각의 결과를 출력한다.

## 결과 예시

```
TC2에서 생성할 수 있는 반입 목록의 수 : 5
TC2에서 생성할 수 있는 반입 목록 : [[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], [1, 1, 3], [2, 3]]
(TC1, TC3 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp/shortest_path4.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 접근 방법으로 최단 거리와 최단 경로를 구하는 함수를 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

```
    TC1에서 생성할 수 있는 반입 목록의 수 : 0
    TC1에서 생성할 수 있는 반입 목록 : []

    TC2에서 생성할 수 있는 반입 목록의 수 : 5
    TC2에서 생성할 수 있는 반입 목록 : [[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], [1, 1, 3], [2, 3]]

    TC3에서 생성할 수 있는 반입 목록의 수 : 17
    TC3에서 생성할 수 있는 반입 목록 : [[3, 3, 3, 3, 3, 3, 3, 4], [3, 3, 3, 4, 4, 4, 4], [3, 3, 3, 3, 4, 4, 5], [4, 4, 4, 4, 4, 5], [3, 3, 3, 3, 3, 5, 5], [3, 4, 4, 4, 5, 5], [3, 3, 4, 5, 5, 5], [5, 5, 5, 5, 5], [3, 3, 3, 3, 3, 4, 6], [3, 4, 4, 4, 4, 6], [3, 3, 4, 4, 5, 6], [3, 3, 3, 5, 5, 6], [4, 5, 5, 5, 6], [3, 3, 3, 4, 6, 6], [4, 4, 5, 6, 6], [3, 5, 5, 6, 6], [3, 4, 6, 6, 6]]
```

### [문제에 대한 이해]

- 모든 목록을 반환하기 위해서 이 목록들을 저장하는 변수의 자료형은 무엇이며 어떻게 정의하고 초기화 하였는가?
  - 리스트를 사용한다.
  - 생성하는 크기는 (target_value + 1)의 크기로 생성한다.
  - 초기화 값은 cases[0]은 아무것도 반입하지 않는 경우의 빈 리스트가 존재하므로 `[[]]`로 초기화한다.
  - 나머지 경우는 계산 전이므로 `[]`로 초기화한다.
- 모든 목록을 반환하기 위해 구현한 알고리즘의 동작 방식을 설명하라.
  - 경우의 수를 구할 때는 num_case에 하위 문제의 경우의 수를 더했던 부분에서
  - 대신 현재 선택 가능한 모든 경우에 대해서,
  - 현재 화석의 가치를 추가한 새로운 경우를 생성하고,
  - 이를 목록 배열에 추가해 모두 취합한다.

### [코드 예시]

```python

```

---

# 문제 5. 최대경로합 (3방향)

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

E 연구원은 그룹장의 명령만 수행하는 수동적인 연구원은 아니고, 본인의 고유한 연구 주제를 가지고 있었다. 그는 진화생물학을 전공했지만, 오늘날 여러 이론의 발전으로 각 분야의 연구가 서로에게 도움이 되다 보니, 진화생물학에 DNA 구조 분석을 접목하는 접근 방법을 찾고 있었다.

E 연구원은 본인이 발견한, 아니 발견했다고 주장하는 이론이 있다. 그런데, 그 이론을 검증하려면 복잡한 계산이 필요한데, 다이나믹 프로그래밍의 개념을 접하자, 그 문제도 다이나믹 프로그래밍으로 풀 수 있다는 사실을 알게 되었다. 그의 이론은 다음과 같다.

> - 특별한 종의 미생물들은 유전자 염기서열은 몇 개의 패턴으로만 중첩 없이 구성되며, 이 특징으로 특정 진화의 갈래를 확인할 수 있다는 것이었다. 예를 들어서 CTAGC와 TAGGCT 두 개의 염기서열 패턴만으로 구성되는 예제는 다음과 같다.
>   - CTAGC, TAGGCT (패턴 그 자체)
>   - CTAGCT-TAGGCT, TAGGCT-CTAGC, CTAGC-CTAGC-TAGGCT-CTAGC (패턴들의 조합)
> - 다음은 여기에 해당되지 않는 예제이다.
>   - C-TAGGCT-AGCA-TAGGCT (해당 패턴이 포함되어는 있지만, 해당 패턴 만으로 구성되지 않음)
>   - TAGG-CT-AGC (TAGGCT, CTAGC가 포함되어 있지만, 중첩되어 있다.)

이 이론을 검증하기 위해서 실제 어떤 유전자가 특정 패턴으로만 구성되어 있는지 확인해야 하는데, 이 문제가 어려운 이유는 간단한 미생물 정도만 해도 몇 백만에서 천만 정도의 길이에 달할 정도로 유전자 염기서열이 길다는 것이었다. 이 중 1% 정도만 샘플링해서 조사한다 해도 1만 정도의 길이가 된다. 연구원 L은 유전자 염기 서열에서 1만 이하의 길이를 가지는 부분을 샘플링해서 테스트 작업을 시작하고 있는 중이었다.

## 수행목표

- E 연구원이 풀어야 하는 문제는 다음과 같다.
  - 패턴은 C, T, A, G 네 글자가 조합된 문자열로 주어진다.
  - 주어진 문자열이 지정된 패턴 만으로 중첩없이 구성되어 있는지를 검사하고, 결과에 따라 True 또는 False를 반환한다.
- E 연구원이 풀어야 하는 문제를 해결해주는 함수를 구현한다.
- 다음은 검사할 패턴(patterns 리스트)과 테스트 대상 DNA 염기 서열(문자열)들이 기재되어 있다. 11개의 DNA 염기 서열에 대해서 해당 염기 서열이 검사할 패턴 만으로 중첩 없이 구성되어 있는지 검사한 결과를 출력한다.
  ```python
  patterns = ['CTAG', 'GCC', 'CTA']
  test1 = "CTAG"
  test2 = "GCCCTACTAG"
  test3 = "CCCCCCCCCC"
  test4 = "GTTTCAGGGA"
  test5 = "CTAGCTAGCC"
  test6 = "CTACTAGCTAGCC"
  test7 = "ACCAGAGTCTCTCCTCTTAC"
  test8 = "GCCCTACTAGCCCTAGCTAGCCCTAGGCCCTAGCCCTAGCCGCCGCCCTACTAGCCCTACTA"
  test9 = "GCCCTAGCTAGCTAGCCGCCGCCCTACTACTAGCCGCCGCCTAGCCGCCCTACTACTAGGCCCTAG"
  test10 = "CTAGCTACTACTAGCTAGCTAGCTAGCTAGCTACTAGCTACTAGCTAGCCCTAGCTACTAGCTAGCTAGCTAGCTAGGCCGCCCTAGCTAGGCCGCCCTAGCTAGCTAGGCCGCCCTAGCTAGGCCGCCCTAGCTAGCTAGCTACTAGCTACTAGCTAGCCGCCCTAGCCCTACTAG"
  test11 = "GCCCTAGCTACTAGCTAGCTAGCCGCCCTACTAGGCCGCCCTACTACTAGGCCGCCGCCCTAGCTAGGCCGCCCTACTAGCTACTAGCTAGCTACTAGCTACTAGCTACTAGGCCGCCCTACTAGGCCCTACTAGGCCCTAGCCGCCCTAGCTAGGCCGCCCTACTAGGCCCTACTACTAGGCCCTAGCTACTAGCTAGGCCCTAGGCCGCCCTAGGCCCTACTACTACTAGCCGCCGCCCTACTAGGCCCTACTACTAGCCCTAGGCCCTAGCTAGCTACTAGCCGCCCTAGCTAGGCCGCCGCCGCCCTAGGCCGCCCTAGCCGCCCTACTACTACTACTAGCTACTACTAGCTAGCTACTAGCTACTAGGCCGCCGCCGCCCTACTAGGCCCTACTAGCTACTAGCCCTACTACTACTACTAGCCGCCGCCCTAGCTAGCCGCCCTAGGCCCTACTACTACTAGCCGCCCTAGGCCCTACTAGCCCTAGGCCCTAGCCCTAGCTAGCCCTAGCTAGCTAGCCGCCCTACTACTAGCTACTAGCTAGCTAGCTAGGCCCTAGCTAGGCCGCCGCCCTAGGCCCTACTAGCTAGCCGCCCTACTAGGCCGCCCTAGCTAGCCCTAGCCCTAGCCGCCCTAGCTAGCTACTAGCCCTACTAGCTAGCTAGCCCTACTAGCTACTAGCTAGCCCTACTACTAGCCCTACTAGCTACTACTAGCCCTAGGCCCTAGGCCCTAGCTACTACTAGGCCGCCGCCCTACTAGCCGCCGCCCTAGGCCCTACTACTAGGCCGCCGCCCTAGCTAGCCCTAGGCCCTAGCTAGGCCCTAGCCCTACTAGGCCCTAGCTAGCTAGCTAGGCCGCCCTAGCTAGCTAGCCGCCGCCGCCCTAGCCCTAGGCCCTAGCTAGCCGCCGCCCTAGCCCTAGCCGCCCTACTAGCTAGCTACTACTAGCTAGCTACTAGCTACTAGCTAGCCCTAGCCCTAGGCCGCCGCCGCCCTAGCCCTACTACTACTAGCCCTAGGCCCTACTAGCTAGGCCGCCCTAGCCCTAGCTAGCTAGCTAGCTACTACTAGGCCCTAGCTAGCCCTAGGCCGCCCTACTAGCTAGCTACTAGCTAGCTAGCTAGCCGCCCTAGGCCGCCCTAGCCCTAGGCCGCCGCCCTACTACTAGCCCTACTACTAGCTACTAGCTAGCTACTAGCTAGCTAGGCCCTACTAGCTACTAGCCCTAGCTAGCTAGCCCTAGCTAGGCCCTAGCCCTACTAGCCGCCCTAGCCGCCCTACTAGGCCGCCCTAGCTACTAGCTAGCTACTACTAGCCCTAGCCGCCGCCGCCCTACTAGCTAGGCCGCCGCCGCCCTAGCTAGCCCTACTAGCTAGCTAGCTAGCTAGCTAGGCCGCCCTAGCTAGCCCTACTAGCTACTAGGCCCTAGCTACTAGCCCTAGGCCCTACTACTAGCTACTAGCTAGCCCTACTAGCTAGCTAGCCCTAGCTACTAGGCCCTACTAGCTAGCTAGCCCTACTAGCTAGCTACTAGCCCTAGCTAGCTACTAGCCCTAGGCCGCCGCCCTAGCCCTAGCTACTAGCTAGCTAGCTACTAGCTAGCTAGCTAGCCCTACTACTACTAGCCGCCCTAGCTACTACTACTAGCCCTAGCTAGCTAGCCCTACTACTACTAGCTAGCCCTACTAGCTAGCCGCCCTAGCTAGCTAGCTACTAGCCCTACTAGCCCTACTACTAGCTACTAGGCCCTAGGCCGCCCTAGCCCTAGGCCCTACTAGCTACTACTAGCTAGCTAGGCCGCCCTACTACTACTACTAGCTACTACTAGCTAGCTAGCCGCCCTAGCTAGGCCGCCGCCCTAGCTAGCTAGCTAGCTAGCTAGCTACTAGCTAGCTACTAGCTACTAGCCCTAGCTAGCTAGCTAGCTACTAGCTACTAGCTACTAGCCCTAGCCCTAGGCCGCCGCCGCCCTAGCTAGGCCCTAGCTAGCCGCCCTACTAGGCCCTAGCTAGCTACTAGGCCGCCGCCCTACTAGCTAGGCCGCCCTACTAGGCCCTAGCCCTACTAGCTACTAGCCGCCCTACTAGGCCCTAGCTAGCTACTAGCTACTACTAGCCGCCCTAGCCCTAGCTACTAGCTAGCCCTACTACTAGCTAGCTACTAGCTACTAGCCCTACTACTAGCCCTAGCTACTAGGCCCTAGCCGCCCTAGCCCTACTAGGCCGCCCTACTACTAGCCGCCCTACTAGGCCCTAGCTAGCTACTAGCTAGCCCTACTACTAGCTACTAGGCCCTAGCTACTAGCCCTAGCTACTAGCTAGCTAGGCCCTAGCTAGCTAGCTAGCTACTAGCTACTAGCTAGCTAGGCCCTACTAGCTACTAGGCCCTAGCTAGCCGCCCTAGCTAGCTAGCCCTAGCTAGGCCGCCGCCGCCCTACTAGCTACTACTAGCTAGCCGCCCTACTAGCCCTAGCTACTACTAGCTAGGCCGCCCTAGGCCCTACTAGCCCTAGCCCTACTAGCTAGGCCGCCCTAGGCCCTACTACTAGGCCGCCGCCCTACTAGCTAGCTAGCTAGCTAGCCCTACTAGGCCCTAGCCCTAGGCCCTACTACTAGCTAGCTACTACTAGGCCCTAGGCCCTACTAGCTAGCTACTAGCTAGGCCCTAGCTAGCTAGGCCCTAGCTACTAGCCGCCCTAGCTAGCTAGCCCTACTAGGCCCTAGGCCGCCCTACTAGCTAGCCGCCGCCCTAGGCCGCCCTAGCTACTAGCTAGCCGCCCTAGCTAGCTAGCCCTACTAGGCCCTAGCTAGCTAGCTAGGCCCTACTACTACTAGCCCTAGCTAGGCCCTACTAGCTACTAGCTACTAGGCCCTAGCCCTAGGCCGCCCTAGCTACTACTACTAGCCCTAGCTAGGCCCTAGCTAGCTAGCTACTACTAGCCGCCCTACTAGCCCGATTAGCTACTAGGCCGCCCTACTAGCTAGCTAGCTACTAGCTAG"
  ```

## 수행단계

- 문제의 구조를 분석하고, 문제를 해결하기 위한 하향식 접근법과 상향식 접근법을 각각 정리한다.
- dp_exer/simple_dna.py 파일에 주어진 문자열이 패턴 만으로 중첩없이 구성되어 있는지를 검사해 그 결과를 반환하는 함수를 구현한다.
  - 하향식 접근법과 상향식 접근법 각각의 함수를 구현한다.
- 주어진 테스트케이스 11개에 대해서 함께 제공된 패턴만으로 중첩없이 구성되어 있는지를 두 함수 각각에 대해서 검사하고, 그 결과를 출력한다.
- 상향식, 하향식 두 접근 전략을 비교 분석한다.
  - 이 문제의 경우 하향식 접근법을 사용할 때 메모이제이션을 사용해도 큰 도움이 되지 않는다. 그 이유가 무엇인지 정리한다.

## 결과예시

```
수행 시간: 1.9073486328125e-06 초
TC 1 하향식 접근법 : True
수행 시간: 5.7220458984375e-06 초
TC 1 상향식 접근법 : True
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/simple_dna.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식, 하향식 각각의 접근 방법을 사용한 두 개의 함수가 구현되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

```
수행 시간: 1.9073486328125e-06 초
TC1 하향식 접근법 : True
수행 시간: 5.7220458984375e-06 초
TC1 상향식 접근법 : True

수행 시간: 2.86102294921875e-06 초
TC2 하향식 접근법 : True
수행 시간: 9.059906005859375e-06 초
TC2 상향식 접근법 : True

수행 시간: 9.5367431640625e-07 초
TC3 하향식 접근법 : False
수행 시간: 5.9604644775390625e-06 초
TC3 상향식 접근법 : False

수행 시간: 9.5367431640625e-07 초
TC4 하향식 접근법 : False
수행 시간: 5.9604644775390625e-06 초
TC4 상향식 접근법 : False

수행 시간: 4.0531158447265625e-06 초
TC5 하향식 접근법 : True
수행 시간: 7.867813110351562e-06 초
TC5 상향식 접근법 : True

수행 시간: 4.0531158447265625e-06 초
TC6 하향식 접근법 : True
수행 시간: 1.0967254638671875e-05 초
TC6 상향식 접근법 : True

수행 시간: 1.1920928955078125e-06 초
TC7 하향식 접근법 : False
수행 시간: 1.3113021850585938e-05 초
TC7 상향식 접근법 : False

수행 시간: 1.9073486328125e-05 초
TC8 하향식 접근법 : True
수행 시간: 0.00020813941955566406 초
TC8 상향식 접근법 : True

수행 시간: 1.5974044799804688e-05 초
TC9 하향식 접근법 : False
수행 시간: 0.00020194053649902344 초
TC9 상향식 접근법 : False

수행 시간: 0.00013375282287597656 초
TC10 하향식 접근법 : True
수행 시간: 0.0015680789947509766 초
TC10 상향식 접근법 : True

수행 시간: 0.001992940902709961 초
TC11 하향식 접근법 : False
수행 시간: 0.3107450008392334 초
TC11 상향식 접근법 : False
```

### [문제에 대한 이해]

- 하향식 다이나믹 프로그래밍 전략을 사용하기 위한 문제의 구조와 해결 전략을 제시하라.
- 상향식 다이나믹 프로그래밍 전략을 사용하기 위한 문제의 구조와 해결 전략을 제시하라.
- 하향식 접근법과 상향식 접근법을 비교 분석해보라. 성능 차이가 발생하였다면, 그 이유도 함께 제시하라.

### [코드 예시]

```python

```

---

# 문제 6. 최대경로합 (좌에서 우)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

E 연구원은 실험을 통해 이론을 검증한 후, 이 내용을 정리해 해외 유명 진화생물학 저널에 논문을 투고했다. 논문이 실린 저널이 출판된지 한 달쯤 지나서 E 연구원에게 메일이 하나 도착했다. 이 분야에서 연구를 하는 사람이면 누구나 알고 있는 해외 유명 연구자의 메일이었다.

> - 좋은 논문 발표해 주셔서 감사합니다. 정말 좋은 성과라고 생각합니다.
> - 그런데 논문을 꼼꼼히 읽어보던 중에, 재미있는 것을 발견했습니다. 마침 제가 하던 연구와 결합이 가능할 것 같은데, 혹시 시퀀스 몇 개에 대해 패턴으로 쪼갠 결과를 보내주실 수 있으신지요? 그리고 하나의 시퀀스가 주어진 패턴에 대해서 쪼갠 결과가 둘 이상이면, 모두 다 보내주실 수 있으시면 큰 도움이 될 것 같습니다.
> - 제 사견입니다만, 10년 안에 저와 L님이 공동으로 노벨 생리의학상 후보가 될 수 있지 않을까라는 기대도 하게 됩니다. 부디 꼭 부탁드립니다.

## 수행목표

- 패턴과 문자열이 주어졌을 때, 문자열이 패턴 만으로 중첩없이 검사하는 것으로 그치지말고, 패턴을 사용해 문자열을 구성한 방식을 반환하도록 수정된 함수를 구현한다.
  - 예를 들어 패턴이 [‘CT’, ‘TA’, ‘AG’, ‘CTT’, ‘AAG’]로 주어지고, 검사해야 할 문자열이 'CTTAAG'인 경우, 이 문자열은 CTT-AAG로 패턴을 사용해 나눌 수 있다. 그런데 'CTTAAG'는 CT-TA-AG로 패턴을 사용해서 나눌 수 있는 다른 방법이 존재한다. 함수의 반환 결과는 이를 모두 포함한 ['CTT-AAG', 'CT-TA-AG']를 반환해야 한다.
  - 만약 패턴만으로 중첩 없이 입력 문자열을 나눌 수 없는 경우 빈 리스트[]를 반환한다.
- 다음 테스트케이스 3개에 대해서 실행 결과를 출력한다.
  ```python
  patterns = ['CT', 'TA', 'AG', 'CTT', 'AAG']
  test1 = "CTTAAG"
  test2 = "GCCCTACTAGCCCTAGCTAGCCCTAGGCCCTAGCCCTAGCCGCCGCCCTACTAGCCCTACTA"
  test3 = "AGCTCTTAAAGAAGTATAAGCTTCTCTTCTCTTCTTAAGTAAGCTCTTACTCTTAAGCTAGAGAGAGAG"
  ```

## 수행단계

- 하향식 접근법을 사용해 패턴만으로 중첩없이 문자열이 구성되어 있는지를 검사하는 함수를 이전 문제에서 구현한 바 있다. 하향식 접근법으로 구성 가능 여부를 반환하는 대신 패턴으로 구성하는 방법의 목록을 반환하는 함수를 dp_exer/simple_dna2.py 파일에 구현한다.
- 주어진 테스트케이스 각각에 대해서 입력 문자열을 패턴으로 나눈 결과를 출력한다.

## 결과예시

```
TC1을 자른 결과 : ['CT-TA-AG', 'CTT-AAG']

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/simple_dna2.py 파일에 구현이 되어 있는지 확인한다.
  - 하향식 접근방법을 메모이제이션과 함께 사용하여 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과의 예시이다. 결과는 항상 다르게 나오지만, 수행 시간은 거의 지연없이 결과를 확인할 수 있어야 한다.

```
TC1을 자른 결과 : ['CT-TA-AG', 'CTT-AAG']

TC2을 자른 결과 : []

TC3을-자른-결과-:-['AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CT-TA-AG-TA-AG-CT-CT-TA-CT-CT-TA-AG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CT-TA-AG-TA-AG-CT-CT-TA-CT-CTT-AAG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CTT-AAG-TA-AG-CT-CT-TA-CT-CT-TA-AG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CTT-AAG-TA-AG-CT-CT-TA-CT-CTT-AAG-CT-AG-AG-AG-AG-AG']
```

### [문제에 대한 이해]

- 패턴을 자른 결과를 취합하기 위해서 재귀 함수는 어떤 전략을 사용하는가?
  - 파라미터에 뮤터블 객체를 전달해 자른 결과를 취합하는 방식과 반환값을 리스트로 받아서 모든 리스트를확장해 나가는 방식의 구현에 따라 답이 달라진다. 아래 예시 답변은 후자의 경우이다.
  - 문자열의 가장 앞 부분이 주어진 패턴과 매칭 되는 경우, 나머지 부분을 재귀 호출한다.
  - 재귀 호출의 결과가 비어 있지 않은 리스트인 경우 리스트의 모든 결과의 앞에 매칭된 패턴을 추가한다.
  - 재귀 호출의 결과가 리스트인 경우 그대로 빈 리스트를 반환한다.
  - 문자열의 가장 앞 부분이 주어진 패턴과 매칭이 되지 않는 경우 빈 리스트를 반환한다.

### [코드 예시]

```python

```

---

# 문제 7. 바이러스의 등잔 밑

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

바이러스 연구를 위해 신규 도입된 특수한 바이러스 배양 장치는 배양하는 조건을 다양하게 설정해 다양한 목적으로 활용할 수 있는 최첨단 장비이다. 생태 환경을 통제해 바이러스의 세대별 주기가 배양 조건에 따라 서로 다른 진화가 가능한지를 확인하기 위해서 T 연구원은 이 장비를 사용하기로 했다.

‘이것이 장비의 매뉴얼이구나?’

장비의 매뉴얼에는 장비의 사용 방법이 다음과 같이 적혀 있었다.

> - 배양기는 n X 2의 크기이다.
> - 이 장비는 바이러스가 유출되지 못하게 가둬 두는 1X2 크기의 바이오 세이프티 필터와 바이러스가 자유롭게 드나들 수 있는 2X1 크기의 바이오 컴패터블 필터를 바닥에 설치해야 한다.
> - 이 설치 방식에 따라 모두 다른 실험 결과를 얻을 수 있다.
> - 바닥에 필터가 설치되어 있지 않은 영역이 조금이라도 있는 경우 바이러스가 배양기 외부로 유출될 위험이 매우 높으므로, 절대 주의해야 한다.

T 연구원은 이 장비를 사용하기에 앞서 총 몇 종류의 설정이 가능한지 알아야 했다. 실험 계획을 세우기 위해서 반드시 필요한 값이기 때문이었다.

## 수행목표

- 배양기는 n X 2의 구조를 가지고 있다. (가로가 양의 정수 n의 크기이다.) 그리고 배양기 바닥은 1 X 2 또는 2 X 1 크기의 필터로 빠짐없이 채워야 장비가 정상적으로 동작하며, 필터의 종류와 무관하게 필터를 배치한 형태만으로 서로 다른 실험 환경이 설정된다고 할 때, 서로 다른 전체 실험 설정의 수를 계산해 반환하는 함수를 구현한다.
- n = 2, 10, 30, 50, 100일 때 서로 다른 전체 실험 설정의 수를 계산하고, 이를 출력한다.

## 수행단계

- 문제의 구조를 분석한다.
- 다이나믹 프로그래밍 접근 방법을 사용해 문제를 해결하는 방법을 정리한다.
- dp_exer/filtering1.py 파일에 서로 다른 전체 실험 설정의 수를 반환하는 함수를 구현한다.
  - 이 함수는 다이나믹 프로그래밍으로 구현한다. 접근 방법은 각자 선택하되, 시간 복잡도는 O(n) 이하가 되도록 구현하여야 한다.
- n = 2, 10, 30, 50, 100일 때의 결과를 각각 출력한다.

## 결과예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/filtering1.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방법을 사용해서 O(n) 시간 복잡도 이내로 동작하는 알고리즘으로 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- 이 문제의 점화식을 설명과 함께 제시하라.
- 구현한 알고리즘의 시간 복잡도를 설명과 함께 제시하라.

### [코드 예시]

```python

```

---

# 문제 8. 뉴로스티닉스를 좋아하는 바이러스

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

정작 배양기 사용 하가를 받아서 배양기의 덮개를 열어보니, 배양기는 n x 2 구조가 아니라 n x 3 구조였다. 매뉴얼이 옛날 구버전의 것이었는데, 연구소의 인트라넷에 새 버전으로 업데이트가 되지 않았던 것이다.

T 연구원은 뭔가 더 많은 경우를 테스트 할 수 있을 것이라는 생각에 횡재한 기분이었다. 하지만 들뜬 기분도 잠시. 전체 실험 가능한 설정의 수를 다시 계산해야 한다는 생각에 우울감이 몰려왔다. 게다가 문제의 난이도가 n x 2일 때보다 훨씬 복잡해졌음을 직관적으로 깨달을 수 있었다.

'뭐, 일단 부딪혀보고 안되면 프로그래밍 지원 게시판에 도움을 청하면 어떻게 되지 않겠어?'

## 수행목표

- 이전 문제와 달리 이번에는 n X 3 구조의 배양기에 1 x 2 또는 2 x 1 크기의 필터를 빠짐없이 배치해야 한다. (n은 양의 짝수이다.) 이와 같이 배양기의 구조가 변경된 상황에서 필터의 종류와 무관하게 필터를 배치한 형태만으로 서로 다른 실험 환경이 설정된다고 할 때, 서로 다른 전체 실험 설정의 수를 계산해 반환하는 함수를 구현한다.
- 이 함수를 사용해 배양기의 구조가 2 x 3, 4 x 3, ..., 20 x 3 인 10개의 배양기에서 설정 가능한 실험의 총 수를 각각 계산해 출력한다.

## 수행단계

- 문제의 구조를 단계별로 확인해보자.
  - 2 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - 4 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - 6 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - n이 8 이상일 때 배양기에 필터를 배치하는 방법을 작은 크기의 배양기에 필터를 배치하는 방법을 사용해 경우 별로 분류해서 정리해보자.
    - (n - 2) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하는 경우 (배치 A)
    - (n - 4) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하되, 배치 A에 포함되지 않는 경우 (배치 B)
    - (n - 6) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하되, 배치 A와 배치 B에 포함되지 않는 경우 (배치 C)
    - 배치 A, 배치 B, 배치 C와 무관하며, 작은 크기의 배양기에 필터를 배치하는 방법과도 완전히 무관한 별도의 경우
- 이 문제를 상향식 접근 방법으로 해결하는 함수를 dp_exer/filter2.py 파일에 구현한다.
- n = 2, 4, ..., 20일 때의 결과를 출력한다.

## 결과예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/filter2..py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍 접근 방법으로 해결하고 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- n이 홀수인 경우는 어떤 결과가 나오는가?
- 문제의 구조를 하위 문제를 사용해 설명하라.
- n x 3에서 가능한 모든 실험 설정의 수를 case(n)으로 표기할 때, case(n)의 상위 문제와 하위 문제의 관계를 나타내는 점화식을 제시하라.

### [코드 예시]

```python

```

---

# 문제 9. 퀀텀 점프

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

동물 지능 연구그룹을 이끄는 X 그룹장은 어느날 지선생을 찾아갔다. X 그룹장은 지선생이 기가 막힐 정도로 천재라는 사실을 눈치채고 있는 소수의 연구원 중 한 사람이었다. 사실 그것이 아니라도 평소 연구 업무에 크게 도움을 주고 있는 지선생을 연구소의 훌륭한 선배로 받들어 모시는 그런 사람이기도 했다.

"요즘 원숭이들의 규칙 준수 가능성을 확인하기 위해서, 원숭이들 행동을 점수로 평가하고 있어요."

"아니 원숭이랑 생긴 일을 왜 나한테 가지고 와서 그래?"

"그런데, 그 녀석들에게 요즘 가르치고 있는게 있거든요."

"뭔데?"

"정확히 100점을 받으면 바나나를 상으로 주고 있어요."

"뭔 소리야?"

"100점을 초과해버리면 안준단 소리죠."

"너 그러다 원숭이한테 맞겠다."

"여튼, 이거 방법을 좀 알려주셨으면..."

"뭔데?"

"원숭이들이 정확히 100점을 받을 수 있는 가능한 모든 행동 시퀀스를 구하는 방법이 필요해요."

"음. 어렵지는 않은데, 점수표는 좀 조절해야겠네?"

"어떻게요?"

"행동에 점수를 매길 때, 행동 별로 같은 점수가 없도록 만들어주면 좋겠네."

"아, 그래요? 그거야, 뭐 어렵지 않죠. 오히려 실험 결과를 식별하기에는 더 편할 것 같은데요?"

"아... 그런데, 원숭이는 예외없이 바나나를 좋아하는거 맞는거지?"

두 사람은 문제를 검토한 후, 머리를 맞대고 방법을 찾아나가기 시작했다.

## 수행목표

- 점수 배열과 목표 점수가 주어진다. 점수 배열은 각 행동 별 점수를 나타내며, 중복된 값을 포함하지 않는다.
- 목표 점수를 정확히 달성하는데 필요한 행동의 시퀀스를 모두 작성해 반환한다.
  - 목표 점수가 30점이고 행동 점수 배열이 [10, 20]인 경우, 이 함수는 [[0, 0, 0], [0, 1], [1, 0]]을 반환한다. 10점 행동을 3번 연달아하거나, 10점 행동 이후에 20점 행동을 하거나, 20점 행동 이후에 10점 행동을 한 세 가지 경우를 해당 점수의 인덱스를 사용해 만든 리스트의 리스트에 해당한다.
  - 목표 점수가 90점이고 행동 점수 배열이 [40, 20]인 경우, 목표 점수를 달성할 수 있는 가능성이 전무하므로 빈 리스트 []를 반환한다.
- 다음 테스트케이스는 점수 배열과 목표 점수의 튜플로 구성되어 있다. 총 5개의 테스트케이스가 제시되며, 각각의 결과를 출력한다.
  ```python
  testcases = [([15, 20], 10), ([1, 2, 3], 6), ([12, 14, 16, 18, 20], 105), ([13, 17, 19], 56)]
  ```

## 수행단계

- 문제의 구조를 분석한다.
  - 하향식으로 접근하기 위해서 목표 점수를 달성하기 전 단계를 사용해서 상위 문제와 하위 문제의 관계를 정리한다.
  - 상향식으로 접근하기 위해서 가장 작은 문제와 상향식 전개 과정을 정리한다.
- 이 문제를 상향식 접근 방법 및 햐힝식 접근 방법 각각의 방식으로 해결하는 두 개의 함수를 dp_exer/monkey_banana.py 파일에 구현한다.
- 제시된 테스트케이스를 사용해 문제를 해결한 결과를 출력한다.

## 결과예시

```

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/monkey_banana.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식, 하향식 각각의 방법을 사용한 두 가지 모두 구현되어 있어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- 하향식 다이나믹 프로그래밍 해결 전략을 제시해보자. 재귀 호출 함수가 하는 일, 종료 조건, 메모이제이션 변수의 정의, 그리고 목록을 작성하는 방법을 설명해야 한다.
  - 목표 점수에서 취할 수 있는 점수 만큼을 뺀 값을 재귀 호출 한 후, 반환되는 전체 목록에 뺀 점수의 항목을 앞에 각각 붙이고 취합하는 방식으로 구현할 수 있다.
  - 종료 조건은 0점이 되었을 때 (성공), 혹은 점수가 남았으나 취할 수 있는 행동이 없을 때(실패) 이다.
  - 목록을 취합하는 방식은 성공의 경우는 해당 항목을 반환하는 경로에 합치고, 실패의 경우에는 버린다.
  - 메모이제이션은 딕셔너리를 사용하며, ws_memo[i]는 i 점을 받기 위한 행동 시퀀스이다.
- 상향식 다이나믹 프로그래밍으로 문제를 해결할 때, 가장 작은 문제를 정의해보자.
  - 가장 작은 문제는 0점을 달성하는 목록을 구하는 문제이다.
- 상향식 다이나믹 프로그래밍으로 문제를 해결할 때, 이전에 계산한 결과를 저장하는 변수를 정의하고 초기화 하는 방법을 제시해보자.
  - 크기 별 문제의 결과를 저장하기 위해서 target + 1 크기의 배열을 빈 배열로 초기화하면서 생성한다.
- 두 가지 구현 방법의 시간 복잡도를 제시하라.

### [코드 예시]

```python

```

---

# 문제 10. 퀀텀 점프 (2)

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

유전 정보의 코딩을 연구하는 D 연구원은 자나깨나 염기 서열의 배치 특징을 생각하는 삶을 살고 있다. 문득 이런 생각이 들었다.

'어떤 배치 구조가 길면 길수록 어떤 특징이 나타나지 않을까? 일단 염기 서열의 오름차순 배치 구조부터 확인해봐야겠다.'

## 수행목표

- 'C', 'T', 'A', 'G' 네 글자로 구성된 문자열이 주어진다. 이 문자열의 부분 순열 중, C, T, A, G 순으로 배치된 부분 문자열의 최장 길이와 이 부분 순열 패턴을 찾아 출력하는 프로그램을 작성한다.
  - 예를 들어 주어진 문자열이 CTAGTACG인 경우, 이 문자열에서 `__A__ACG`의 오름차순 부분 순열이 가장 긴 오름차순 부분 순열이 된다. (같은 값의 경우 오름차순으로 간주한다.) 이 경우 4와 함께 AACG를 출력한다.
  - CTAGGTACG의 경우 `C__GGT___`, `__AGGT___` 등 여러 개의 길이가 4인 오름차순 부분 순열을 찾을 수 있으며, 이 부분순열이 가장 긴 오름차순 부분 순열이다. 이 경우 4와 함께 찾을 수 있는 부분 순열 중 하나를 출력한다.
- 다음 테스트케이스에는 16개의 문자열이 주어진다. 이 문자열에서 가장 긴 오름차순 부분 순열의 길이와 부분 순열 중 하나를 출력한다.
  ```python
  testcases = ['CTAGTACG', 'CTAGGTACG', 'AAA', 'ACGT', 'TGCA', 'ACTTTTTTTCGGGGGGT', 'ACTTTTTCT', 'ACTTTTTCGGGT', 'ACTTTTTCGGGGGGTTTTTT', 'GCCTGCTGGT', 'CCCATCTTCCGTCATTATAG', 'ACCAAGAAACTGTAATCTCCTTCTTCTCGA', 'TCCGTTCGGCATACCCCCCGGCGGGGATATCGAACTGGAG', 'GTCCGAGGGGCAAGCAAGCGGGTTGACGCATCCTGAAGCTCTTTCACAGG', 'ATGGGTGAAAACCCCCATTAACATAACTGGCGCCGGGAGTTACGAATCTCGTGCTTGAAGAAGGGCAAACTGTTTTACGAGAGGTGGGGACAGACTACCT', 'CAATCATCTGGCCTCCAATTAAGACTTTATGCTGCTGCTAGCCAGAAATTTATTGACCACCACGGATGCGACGGCTCGACGCTGATGGTGTGACGTTGCAAAAGCTGGTCTATGGCTTGGTTTAGTGGTGGCCATGGACCCCTCACTCGTAATTTGTAAATGTAATAATAGGCGCCAAATTCAGTGTCTGATGCTGGTTCCCCAGCTGTCTCTTGCAAGTCGGCGCCAATCGTTTTCCACGGAACGACTTGTCTGCGGCCTATGCATCGTTCGCTAGCCAGTTAAATGGCATATGCTAGTTCACCTAACCACTTCAAAGTATCAGCCCAAGGATTTTCACCAGGTAGGGAAATTATTAGGATCGCTAAGCAACCCACTGTCCGATACGACAGCCCGCTGCCAGCGTTTCATTATAGTCTTGGAATACCGTTCCGTTGTTTTCAAACCGTTCCAACCCCCCTGATGCGCCAGCGTCTAGGTTTGTCGGCGCTAGTGGCCACCAGCGCGTGCCATACACGCGGTGTTGGCCTAATCAGTTGCTAAGTACCTAGAACGACAGCTAACCGAAAGAGAAAACATCGAGCTTTTACGTAATTTCTACACTATACGCCCTGGACGACATACTAGTCTGCGTTTGGTCTATATCTATATGTTCACTCCGAAGCTCTCAGATCTGATACAGACACATGAGGGTCTTGTAGCATTCCTAGAGCTTCTATACGCGTGGTTCGCCGGCCAGGATATGGGTCACACGGGTACATTCAACTCCTACTACGAGAGGGGGTGTTTAAACTATCCGTAAAGCCACAGTAATCGAGATTTACCCATAGGCGACCGATCAAATCGTCTATGGACAGAAGTGGCTCCGCCCGCGAAGCTAACATAAGGTCCAATTACATTGTTACCTAAGCTCTTGTACTAAAATCTAGTGATCATAATCCCGGCCCCGTTATCGCCACCATGGCAATATTTGAACGCGCCCTCGTAGAGCTCATAAGGA']
  ```

## 수행단계

- 문제의 구조를 분석한다.
- 문제의 구조를 사용하는 다이나믹 프로그래밍 접근 방식으로 최장 부분 순열 중 하나를 문자열로 만들어 반환하는 함수를 dp_exer/ascending_pattern.py 파일에 구현한다.
  - 다이나믹 프로그래밍 방식으로 구현하며, 구현한 알고리즘의 시간 복잡도를 확인한다. -
- 테스트케이스로 제시된 16개의 문자열에서 가장 긴 오름차순 부분 문자열 중 하나를 만들어 길이와 함께 출력한다.

## 결과예시

```
Testcase 1
    가장 긴 오름차순 부분 순열의 길이 : 4
    가장 긴 오름차순 부분 순열 중 하나 : AACG

Testcase 2
    가장 긴 오름차순 부분 순열의 길이 : 4
    가장 긴 오름차순 부분 순열 중 하나 : CGGT
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/ascending_pattern.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 접근방법을 사용해 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

  ```
  Testcase 1
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : AACG

  Testcase 2
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : CGGT

  Testcase 3
      가장 긴 오름차순 부분 순열의 길이 : 3
      가장 긴 오름차순 부분 순열 중 하나 : AAA

  Testcase 4
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : ACGT

  Testcase 5
      가장 긴 오름차순 부분 순열의 길이 : 1
      가장 긴 오름차순 부분 순열 중 하나 : T

  Testcase 6
      가장 긴 오름차순 부분 순열의 길이 : 10
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTTTT

  Testcase 7
      가장 긴 오름차순 부분 순열의 길이 : 8
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTT

  Testcase 8
      가장 긴 오름차순 부분 순열의 길이 : 8
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTT

  Testcase 9
      가장 긴 오름차순 부분 순열의 길이 : 15
      가장 긴 오름차순 부분 순열 중 하나 : ACCGGGGGGTTTTTT

  Testcase 10
      가장 긴 오름차순 부분 순열의 길이 : 6
      가장 긴 오름차순 부분 순열 중 하나 : CCGGGT

  Testcase 11
      가장 긴 오름차순 부분 순열의 길이 : 11
      가장 긴 오름차순 부분 순열 중 하나 : CCCCCCGTTTT

  Testcase 12
      가장 긴 오름차순 부분 순열의 길이 : 16
      가장 긴 오름차순 부분 순열 중 하나 : AAAAAACTTTTTTTTT

  Testcase 13
      가장 긴 오름차순 부분 순열의 길이 : 20
      가장 긴 오름차순 부분 순열 중 하나 : CCCCCCCCCCGGGGGGGGGG

  Testcase 14
      가장 긴 오름차순 부분 순열의 길이 : 20
      가장 긴 오름차순 부분 순열 중 하나 : CCGGGGGGGGGGTTTTTTTT

  Testcase 15
      가장 긴 오름차순 부분 순열의 길이 : 39
      가장 긴 오름차순 부분 순열 중 하나 : AAAAACCCCCCCGGGGGGGGGGGGGGGGGGGGGGGGGTT

  Testcase 16
      가장 긴 오름차순 부분 순열의 길이 : 274
      가장 긴 오름차순 부분 순열 중 하나 : AAAAAAAAAAAAAAAACCCCCGGGGGGGGGGGGGGGGGGTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
  ```

### [문제에 대한 이해]

- 문제의 구조를 제시하라.
  - 문자열의 i 번째 글자의 값을 마지막 값으로 반드시 포함하는 가장 긴 부분 순열의 길이를 dp[i]라고 표현하면, 임의의 dp[j]의 값은 j 보다 작은 모든 k에 대해서 다음 모든 값들의 최대값이 되는 구조가 성립한다.
    - 만약 k 번째 글자보다 j 번째 글자가 같거나 더 큰 값의 글자인 경우 : dp[k] + 1
    - 그렇지 않은 경우 : 1
- 가장 긴 오름차순 부분 순열을 찾는 방법을 설명하라.
  - 가장 긴 오름차순 부분 순열의 길이를 문자열의 모든 인덱스에 대해서 갱신할 때, j번 인덱스의 글자로 끝나는 오름차순 부분 순열의 이전 글자는 k번째 인덱스의 글자가
    된다. 이를 모든 인덱스 별로 관리한 다음, 부분 문자열의 길이가 최대가 되는 j에 대해서 역순으로 이전 글자를 이어 붙이는 과정으로 가장 긴 오름차순 부분 순열을 찾을 수 있다.
- 구현한 알고리즘의 시간 복잡도를 제시하라.
  - 모든 글자에 대해서 더 작은 글자를 반복하는 구조이므로 n의 이중 루프 구조를 가진다. O(n^2)에 해당된다.
- 만약 문제의 조건이 가장 긴 '연속된 오름차순 부분 문자열'인 경우 문제를 어떻게 해결할 수 있는지 접근 전략을 제시해보자.
  - 슬라이딩 윈도우, 헤드와 테일 포인터 등을 유지하면서 전체 문자열을 스캔하는 방법 등 적당한 전략을 제시할 수 있는지 확인한다.

### [코드 예시]

```python
def find_lap(input_seq):
    if not input_seq:
        return ''

    dp = [1] * len(input_seq)
    prev = [-1] * len(input_seq)

    max_len = 0
    max_index = 0

    for i in range(1, len(input_seq)):
        for j in range(i):
            if input_seq[j] <= input_seq[i] and dp[j] + 1 > dp[i]:
                dp[i] = dp[j] + 1
                prev[i] = j
                if dp[i] > max_len:
                    max_len = dp[i]
                    max_index = i

    longest_ascending_pattern = ''
    while max_index != -1:
        longest_ascending_pattern += input_seq[max_index]
        max_index = prev[max_index]
    return longest_ascending_pattern[::-1]


def main():

    testcases = ['CTAGTACG', 'CTAGGTACG', 'AAA', 'ACGT', 'TGCA', 'ACTTTTTTTCGGGGGGT', 'ACTTTTTCT', 'ACTTTTTCGGGT', 'ACTTTTTCGGGGGGTTTTTT', 'GCCTGCTGGT', 'CCCATCTTCCGTCATTATAG', 'ACCAAGAAACTGTAATCTCCTTCTTCTCGA', 'TCCGTTCGGCATACCCCCCGGCGGGGATATCGAACTGGAG', 'GTCCGAGGGGCAAGCAAGCGGGTTGACGCATCCTGAAGCTCTTTCACAGG', 'ATGGGTGAAAACCCCCATTAACATAACTGGCGCCGGGAGTTACGAATCTCGTGCTTGAAGAAGGGCAAACTGTTTTACGAGAGGTGGGGACAGACTACCT', 'CAATCATCTGGCCTCCAATTAAGACTTTATGCTGCTGCTAGCCAGAAATTTATTGACCACCACGGATGCGACGGCTCGACGCTGATGGTGTGACGTTGCAAAAGCTGGTCTATGGCTTGGTTTAGTGGTGGCCATGGACCCCTCACTCGTAATTTGTAAATGTAATAATAGGCGCCAAATTCAGTGTCTGATGCTGGTTCCCCAGCTGTCTCTTGCAAGTCGGCGCCAATCGTTTTCCACGGAACGACTTGTCTGCGGCCTATGCATCGTTCGCTAGCCAGTTAAATGGCATATGCTAGTTCACCTAACCACTTCAAAGTATCAGCCCAAGGATTTTCACCAGGTAGGGAAATTATTAGGATCGCTAAGCAACCCACTGTCCGATACGACAGCCCGCTGCCAGCGTTTCATTATAGTCTTGGAATACCGTTCCGTTGTTTTCAAACCGTTCCAACCCCCCTGATGCGCCAGCGTCTAGGTTTGTCGGCGCTAGTGGCCACCAGCGCGTGCCATACACGCGGTGTTGGCCTAATCAGTTGCTAAGTACCTAGAACGACAGCTAACCGAAAGAGAAAACATCGAGCTTTTACGTAATTTCTACACTATACGCCCTGGACGACATACTAGTCTGCGTTTGGTCTATATCTATATGTTCACTCCGAAGCTCTCAGATCTGATACAGACACATGAGGGTCTTGTAGCATTCCTAGAGCTTCTATACGCGTGGTTCGCCGGCCAGGATATGGGTCACACGGGTACATTCAACTCCTACTACGAGAGGGGGTGTTTAAACTATCCGTAAAGCCACAGTAATCGAGATTTACCCATAGGCGACCGATCAAATCGTCTATGGACAGAAGTGGCTCCGCCCGCGAAGCTAACATAAGGTCCAATTACATTGTTACCTAAGCTCTTGTACTAAAATCTAGTGATCATAATCCCGGCCCCGTTATCGCCACCATGGCAATATTTGAACGCGCCCTCGTAGAGCTCATAAGGA']

    for i, tc in enumerate(testcases):
        print(f"Testcase {i + 1}")
        longest_ascending_pattern = find_lap(tc)
        length_of_lap = len(longest_ascending_pattern)
        print(f"    가장 긴 오름차순 부분 순열의 길이 : {length_of_lap}")
        print(f"    가장 긴 오름차순 부분 순열 중 하나 : {longest_ascending_pattern}")
        print()

if __name__ == '__main__':
    main()


```
