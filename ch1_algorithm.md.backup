# 단계 1. 알고리즘에 대해서

## 스토리

닥터 G는 K 바이오 연구소 유전정보 연구그룹에서 유전자 정보를 연구하는 연구자이다. 유전정보 연구그룹에서 지금까지 연구한 수십만 개 정도의 샘플 유전자 염기서열을 조건에 따라 조회하는 일이 잦았다. 조건 중 하나는 사전순 정렬이었다. 닥터 G는 십여년 간 지속적으로 조회 대상 유전자 염기서열이 증가하는 것을 목격해왔고, 이에 따라 사전 순 정렬의 성능이 점점 나빠진다는 사실을 경험해왔다.

물론 매우 길고 많은 유전자 염기서열을 효율적으로 정렬하기 위한 소프트웨어 도구 또는 빅데이터 플랫폼을 사용하는 것도 방법이겠지만, 연구비가 아쉬운 연구그룹의 입장에서 핵심 연구 활동에서 거리가 있는 이런 부분에 예산을 사용하기란 쉬운 결정이 아니었다. 결국 닥터 G는 유전자 목록이 주어졌을 때, 이 유전자 목록을 빠르고 효율적으로 정렬할 수 있는 방법을 일단 찾아보기로 결정했다.

이 과정이 '알고리즘 입문'이라는 사실을 처음에는 알 수 없었다.

---

# 문제 1. 알고리즘이 뭐야?

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 G는 IT 분야에서 일하는 친구에게 자문을 구했다. 그러자 친구가 다음과 같이 답변을 했다.
"의외로 가장 기본적인 접근 방법이 가장 유효한 방법인거 같은데?"
"그러니까 그 방법이 뭐야?"
"좋은 알고리즘을 사용하는 것이지."
"좋은 알고리즘? 아니 알고리즘이 뭐야?"

## 수행목표

- 알고리즘의 기본 개념을 학습한다.
- 다음 문제를 해결하는 알고리즘을 제시하고, 이를 파이썬 프로그램으로 작성한다.
  > - 1에서 n까지 모든 정수를 덧셈한 결과를 계산해 출력한다. (n은 1 이상의 양의 정수)
- 다음 입력에 대한 프로그램 결과를 출력한다.
  - n = 10, 100, 1000, 10000, 100000, 1000000

## 수행단계

- 알고리즘의 기본 개념을 조사한다.
  - 알고리즘의 입력, 출력, 단계, 명확성, 유한성, 일반성과 같은 알고리즘의 특징도 조사하고 숙지한다.
- 1에서 k까지 모든 정수를 덧헴한 결과를 계산해 출력하는 프로그램을 algorithm/sigma.py 파일에 작성한다.
  - 작성한 프로그램의 알고리즘을 기준으로, 알고리즘의 입력, 출력, 단계, 명확성, 유한성, 일반성 등을 확인한다.

## 결과 예시

```
testcase 1: 55
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 닥터 G는 주어진 유전자 염기서열을 사전순으로 정렬하는 프로그램을 다음과 같이 작성했다. 다음 프로그램의 알고리즘이 어떤 문제가 있는지 확인해 제시하라.

```python
def pseudo_sort(arr):
    for i in range(len(arr) - 1):
        if arr[i] > arr[i + 1]:
            arr[i], arr[i + 1] = arr[i + 1], arr[i]
```

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/sigma.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    testcase 1: 55
    testcase 2: 5050
    testcase 3: 500500
    testcase 4: 50005000
    testcase 5: 5000050000
    testcase 6: 500000500000
    ```

### [보너스 과제 확인]

- 제시한 정렬 프로그램의 문제를 정확하게 지적할 수 있는가?
  - 가장 큰 값을 제일 뒤로 보내기만 한다는 점을 지적할 수 있는지 확인한다.

### [문제에 대한 이해]

- 알고리즘의 정의는 무엇인가?
  - 알고리즘의 목적(문제 해결), 알고리즘의 구성(절차 또는 단계의 집합)을 기준으로 답변할 수 있어야 한다.
- 알고리즘의 입력과 출력은 무엇인가?
  - (예시 답변)결과를 생성하는데 사용하는 목적으로 제공되는 주어진 값이 입력이며, 입력을 기반으로 생성된 결과가 출력이다.
- 알고리즘의 입력의 개수는 얼마인가?
  - 입력이 없이 동작하는 알고리즘을 이해할 수 있는지 확인한다.
  - (예시 답변) 0개 이상이다.
- 알고리즘의 출력의 개수는 얼마이며, 알고리즘의 출력은 무엇에 의해 결정되는가?
  - 알고리즘의 출력은 알고리즘 자체 뿐 아니라 입력에 의해서도 결정된다는 사실을 이해하는지 확인한다.
  - (예시 답변) 알고리즘의 출력은 1개 이상이며, 알고리즘의 출력은 알고리즘의 각 단계와 순서, 그리고 입력에 의해서 결정된다.
- 알고리즘의 특징 중 명확성, 유한성, 일반성 중 알고리즘의 단계와 관련이 가장 큰 특징은 무엇인가?
  - 알고리즘의 명확성에 대한 이해를 확인한다.
  - (예시 답변) 알고리즘의 각 단계가 모호하지 않아야 한다는 것이 명확성이므로 명확성이 단계와 관련이 있다.
- 알고리즘의 유한성은 무슨 의미인가? 무엇을 기준으로 유한해야 한다는 의미인가?
  - 알고리즘의 유한성에 대한 이해를 확인한다.
  - (예시 답변)알고리즘은 반드시 종료되어야 한다는 의미이다. 입력이나 출력과 무관하며 알고리즘이 수행되는 단계 또는 수행에 필요한 시간을 기준으로 유한하다는 의미이다.
- 알고리즘의 일반성은 무슨 의미인가?
  - 알고리즘의 일반성에 대한 이래와 알고리즘이 특정 입력에만 동작해서는 안된다는 의미를 이해하고 있는지 확인한다.
  - (예시 답변) 알고리즘은 특정 입력 뿐 아니라, 조건에 맞는 모든 가능한 입력에 대해서도 동일한 규칙으로 동작해야 한다.
- 일반적인 알고리즘은 항상 좋은 것일까?
  - 알고리즘의 일반성이 알고리즘의 제약 조건으로 동작한다는 사실을 이해하고 있는지 확인한다.
  - (예시 답변) 일반적인 알고리즘은 보편적으로 좋지만, 특수한 상황에서 좋은 성능을 내야 하는 경우 일반적인 알고리즘 보다는 특수한 입력에서만 동작하는 특수한 알고리즘이 더 좋을 수 있다.
- 문제에서 제시한 작업 이외의 다른 작업을 제시하고, 이 작업에 대한 알고리즘을 순서도 등의 방법으로 표시해보자. (예를 들어 핸드폰의 배터리를 80%까지 충전하는 작업)
  - 제시한 작업을 명확하게 제시된 단계를 사용해 정확하고 유한하게 동작하도록 알고리즘을 순서도로 제시할 수 있는지 확인한다.
  - 발생 가능한 예외 사항 (예를 들어 배터리의 충전이 전혀 되고 있지 않을 때) 알고리즘이 이를 어떻게 처리할 지를 제시할 수 있어야 한다.
- 제시한 알고리즘에서 입력, 출력, 명확성, 유한성, 일반성 등 알고리즘의 특징을 정리해 제시하라.
  - 알고리즘의 특징을 예시를 들어 제대로 이해하고 있는지 확인한다.

### [코드 예시]

```python
def sigma(n):
    result = 0
    if n < 1:
        return 0
    for i in range(1, n+1):
        result += i
    return result

def main():
    testcases = [10, 100, 1000, 10000, 100000, 1000000]
    for i, n in enumerate(testcases):
        result = sigma(n)
        print(f"testcase {i + 1}: {result}")

if __name__ == "__main__":
    main()
```

---

# 문제 2. 알고리즘의 평가

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

닥터 G는 주어진 유전자 염기서열의 목록을 정렬하는 간단한 정렬 아이디어를 정리한 후 친구에게 보여주었다. 그러자 친구는 아이디어의 오류와 함께 수정한 정렬 알고리즘을 설명해 주면서, 그 정렬 방법이 '버블 정렬' 알고리즘임을 알려주었다.

자리로 돌아온 닥터 G는 버블 정렬 방식으로 유전자의 목록을 정렬하는 프로그램을 작성한 후, 가지고 있는 유전자 목록을 정렬해 보았다. 하지만 꽤 오랜 시간이 걸렸고 뭔가 조금 더 쓸만한 방법을 찾아야겠다고 생각했다.

'아니, 그 전에 알고리즘을 평가하는 방법을 찾아야겠는걸?'

## 수행목표

- 버블 정렬 알고리즘을 구현한다.
- 입력 리스트의 길이가 10, 100, 1000, 10000일 때, 버블 정렬 알고리즘 구현 함수의 실행 시간을 측정해 출력한다.

## 수행단계

- 버블 정렬 방법에 대해서 조사한다.
- 버블 정렬 방식으로 리스트를 정렬하는 프로그램 algorithm/bubble_sort.py을 작성한다.
  - 이 프로그램은 정렬 결과를 출력하는 대신 리스트를 정렬하는데 걸린 시간을 출력한다.
  - 1에서 100 사이의 무작위 정수로 구성된 정해진 길이의 리스트를 만든다. 길이가 각각 10, 100, 1000, 10000일 때 리스트를 정렬하는데 필요한 시간을 출력한다.

## 결과 예시

```
testcase 1 : bubble_sort 수행 시간 - 7.152557373046875e-06 초
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 테스트코드에서 함수를 호출하면 '자동으로' 함수의 실행 시간을 출력하는 방법이 있다. 이 방법을 찾아 적용해보자.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/bubble_sort.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 실행 시간은 입력이 10배가 될 때 대략 실행 소요 시간은 100배 정도의 비율로 증가하는 결과가 정상적인 결과이다.
    ```
    testcase 1 : bubble_sort 수행 시간 - 7.152557373046875e-06 초
    testcase 2 : bubble_sort 수행 시간 - 0.00037288665771484375 초
    testcase 3 : bubble_sort 수행 시간 - 0.03979611396789551 초
    testcase 4 : bubble_sort 수행 시간 - 4.126990079879761 초
    ```

### [보너스 과제 확인]

- 함수 호출 만으로 함수의 실행 시간을 출력할 수 있도록 구현하였는가?
  - 파이썬 데코레이터 등의 방법을 사용해 지시한대로 구현이 되었는지 확인한다.

### [문제에 대한 이해]

- 이 문제에서 입력 데이터와 함수의 실행 시간의 관계에 대해서 설명하라.
  - 입력 데이터가 증가함에 따라 함수의 실행 시간도 증가하고 있음을 이해해야 한다.
- 실제 업무용 시스템에 적용하는 경우라면, 닥터 G가 의도한대로 10만개 정도의 유전자 염기 서열을 정렬하는데 이 정렬 알고리즘을 사용할 수 있을지 의견을 제시해보자.
  - 실행 결과를 바탕으로 10만개 정도 크기의 리스트를 정렬하는데 필요한 시간이 어느 정도인지 제시하고, 이를 기초로 이야기 할 수 있어야 한다.
  - 실제 업무용 시스템에서 사용하기에는 부적절한 성능이라는 늬앙스의 답변이 필요하지만, 이 알고리즘이 느리기 때문에 더 좋은 시스템을 사용해야 한다는 취지의 답변도 무방하다.
- 파이썬에서 함수나 특정 코드의 실행 시간을 측정하는 방법은 무엇인가?
  - 실행 시작과 끝의 시간을 구한 후 그 차이를 실행 시간으로 계산할 수 있다.
  - 이를 위해서 시간을 구하는 방법을 구체적으로 제시할 수 있어야 한다.
- 실행 시간을 지표로 삼아서 알고리즘을 평가할 때, 무엇을 평가할 수 있는가?
  - (예시 답변) 알고리즘의 성능을 평가한다.
- 실행 시간으로 평가 지표로 알고리즘의 성능을 평가하는 방식의 유효성에 대해서 평가해보자.
  - 같은 시스템에서 다른 알고리즘이나 다른 입력에 따른 알고리즘의 성능을 상대적으로는 평가할 수 있는 간이 평가 방식 수준이라는 점을 지적해야 한다.
  - 하지만 같은 시스템이라도 시스템의 상태가 달라지면 값이 달라질 수 있으므로 안정성이 부족한 평가 방법이라는 점과 함께 서로 다른 시스템의 결과를 절대적으로 평가할 수 없다는 한계를 제시해야 한다.
- 실행 시간을 더욱 안정적인 평가 지표로 사용하고자 한다면, 이를 보완하는 방법은 무엇인지 제시해보자.
  - 시스템의 상태를 일정하게 유지하고, 여러 번 반복 테스트한 결과를 아웃라이어를 배제하거나 충분한 횟수의 평균을 사용하는 등의 방법으로 안정성을 추가하는 방법을 제시해야 한다.
- 아무리 보완하더라도 실행 시간을 지표로 삼을 때 한계가 존재한다면, 그 한계는 무엇인지 이야기해보자.
  - 모든 시스템에 대해서 같은 값의 실행 시간을 동등하게 평가할 수 없다는 한계는 극복할 수 없음을 이해해야 한다.

### [코드 예시]

```python
import time
import random

def execute_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 수행 시간 - {end - start} 초")
        return result
    return wrapper

@execute_time
def bubble_sort(arr):
    for i in range(len(arr) - 1):
        for j in range(len(arr) - i - 1):
            if arr[j + 1] < arr[j]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]


def main():
    for i in range(4):
        testcase = [random.randint(1, 100) for _ in range(10 ** (i + 1))]
        print(f"testcase {i + 1} :", end=" ")
        bubble_sort(testcase)

if __name__ == '__main__':
    main()
```

---

# 문제 3. 복잡도

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

10만개의 유전자에 버블 정렬 알고리즘을 적용해본 닥터 G는 이 속도라면 만족할 수 없다는 느낌을 받는다. 그런데, 이 느낌을 체계화하고 싶은 연구원 특유의 감성이 자극받게 된다.

프로그래밍 게시판에 이를 체계화 할 수 있는 방법을 문의하자, '빅 오 노테이션'을 사용해 체계화할 수 있다는 답변을 확인하게 된다.

## 수행목표

- 알고리즘의 효율을 체계적으로 평가하기 위한 체계에 대해서 조사하고, 그 결과를 정리해 공유한다.

## 수행단계

- 알고리즘의 효율을 체계적으로 평가하기 위한 개념인 '복잡도'에 대해서 다음 사항을 조사한다.
  - 시간 복잡도의 개념
  - 빅 오 노테이션의 개념
  - 빅 오 노테이션의 예시 : 다음 각 함수를 빅 오 노테이션으로 표현하라.
    - $f(x)=100$
    - $f(x) =20x+7$
    - $f(x)=-5x^2+7$
    - $f(x)=e^x + 5x^k$, k는 임의의 양의 정수
  - 루프와 시간 복잡도의 관계
  - 대표적인 빅 오 노테이션 : 상수 시간 복잡도, 선형 시간 복잡도, 다항식 시간 복잡도, 로그 시간 복잡도, 선형 로그 시간 복잡도, 지수 시간 복잡도, 계승 시간 복잡도 각각이 무엇이며, 어떤 복잡도가 더 효율적인지에 대한 정리
  - 빅 오메가 노테이션의 개념
  - 공간 복잡도의 개념
- 정리한 내용을 마크다운 형식으로 정리해 algorithm/complexity.md 파일을 작성한다.

## 결과 예시

- 없음

## 참고사항

- 없음

## 제약사항

- 없음

## 개발환경

- 없음

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - 마크다운 형식의 algorithm/complexity.md 파일을 작성하였는지를 확인한다.
- 지시한 내용이 문서에 포함되어 있는가?
  - 문서에 다음 내용이 포함되어 있는지 확인한다.
    - 시간 복잡도의 개념
    - 빅 오 노테이션의 개념과 제시한 함수의 빅 오 노테이션 표현 결과
    - 대표적인 빅 오 노테이션의 표현과 빅 오 노테이션 간 효율성 비교
    - 빅 오메가 노테이션의 정의
    - 공간 복잡도의 개념
- 문서의 내용이 정확한가?
  - 예시 함수의 빅 오 노테이션 표현은 다음과 같다.
    - $f(x)=100$ : $\mathcal{O}(1)$
    - $f(x) =20x+7$ : $\mathcal{O}(x)$
    - $f(x)=-5x^2+7$ : $\mathcal{O}(x^2)$
    - $f(x)=e^x + 5x^k$, k는 임의의 양의 정수 : $\mathcal{O}(e^x)$
  - 대표적인 빅 오 노테이션의 표현과 효율성의 순서는 다음과 같다.
    - 상수 시간 복잡도 : $\mathcal{O}(1)$
    - 선형 시간 복잡도 : $\mathcal{O}(n)$
    - 다항식 시간 복잡도 : $\mathcal{O}(n^k)$, k는 1보다 큰 양의 정수
    - 로그 시간 복잡도 : $\mathcal{O}(\log n)$
    - 선형 로그 시간 복잡도 : $\mathcal{O}(n\log n)$
    - 지수 시간 복잡도 : $\mathcal{O}(c^n)$, c는 1보다 큰 양의 정수
    - 계승 시간 복잡도 : $\mathcal{O}(n!)$
    - 좋은 알고리즘부터 나쁜 알고리즘의 순으로 나열한 순서 : 상수 시간 복잡도 < 로그 시간 복잡도 < 선형 시간 복잡도 < 선형 로그 시간 복잡도 < 다항식 시간 복잡도 < 지수 시간 복잡도 < 계승 시간 복잡도

### [문제에 대한 이해]

- 시간 복잡도는 무엇인가?
  - ‘입력 크기의 변화량을 기준으로 실행 시간의 변화량’이라는 입력 크기의 변화량에 상대적인 지표임을 이야기 할 수 있어야 한다.
- 시간 복잡도로 알고리즘을 평가하는 것은 실행 시간으로 평가하는 것과 비교해 어떤 장점이 있는가?
  - 시간 복잡도는 구조 분석에 해당되며, 그로 인해 테스트 환경에 무관하게 평가할 수 있다는 장점이 있음을 이야기 할 수 있어야 한다.
- 최악의 상황, 최선의 상황, 평균의 상황 각각을 가정하고 알고리즘을 평가한다는 것은 무슨 의미인가?
  - 각각의 상황이 입력에 따라 존재할 수 있으며, 같은 크기의 입력에 대해서 가장 느린 경우 또는 가장 빠른 경우를 평가한다는 의미라는 답변이 필요하다.
- 일반적으로 알고리즘을 평가할 때 최악의 상황, 최선의 상황, 평균의 상황 중 어떤 상황을 가정하는가? 그 이유는 무엇인가?
  - 최악의 상황을 일반적으로 가정하며, 최악의 상황이 더 큰 문제가 되기 때문임을 이야기 할 수 있어야 한다.
- 다항식으로 구성된 함수의 빅 오 노테이션은 어떻게 되는가?
  - (예시 답변)최고차 항의 계수를 제외한 값이다.
- 다항식으로 구성된 함수의 최고차 항의 계수가 음수일 때 빅 오 노테이션은 어떻게 되는가?
  - 항의 계수의 부호와 무관하게 빅 오 노테이션이 표현됨을 이야기 할 수 있어야 한다.
- 알고리즘의 시간 복잡도가 상수 시간 복잡도라면, 그 의미에 대해서 ‘시간 복잡도’라는 표현을 사용하지 말고 표현해보자.
  - 입력의 크기와 상관없이 성능이 일정하다는 취지의 답변인지 확인한다.
- 알고리즘의 시간 복잡도가 선형 시간 복잡도라면, 그 의미에 대해서 ‘시간 복잡도’라는 표현을 사용하지 말고 표현해보자.
  - 입력의 크기와 비례해 실행 속도가 증가한다는 취지의 답변인지 확인한다.
- 어떤 알고리즘의 시간 복잡도가 지수 시간 복잡도일 때, 이 알고리즘의 성능을 ‘시간 복잡도’라는 표현을 사용하지 말고 표현해보자.
  - 입력의 크기가 커질 수록 실행 속도는 지수 스케일에 비례해 증가한다는 취지의 답변인지 확인한다.
- 어떤 문제를 해결하기 위해서 여러 가지 구현 방식이 가능하다. 구현하기 쉽고 누구나 이해할 수 있는 지수 시간 복잡도의 구현 방식과 구현하기 난해하고 거의 모든 사람이 이해할 수 없는 선형 시간 복잡도의 구현 방식이 있다면, 어떤 구현 방식을 사용할지 선택하고 선택의 근거를 제시해보자.
  - 이 문제는 경우마다 다른 답변이 나올 수 있으므로 근거가 합리적이며, 그 근거를 사용한 합리적인 선택인지를 확인한다.
  - (예시 답변)다른 사람과 공유해서 사용해야 하는 경우 알고리즘의 간결성이 중요한 평가 지표가 되기 때문에, 입력의 크기를 제한할 수 있다면 지수 시간 복잡도를 사용할 수 있으며, 그렇지 않다면 선형 시간 복잡도를 사용한다.
- 이전 문제에서 구현한 버블 정렬의 시간 복잡도는 얼마인가?
  - 버블 정렬의 시간 복잡도는 $\mathcal O(n^2)$임을 제시하되, 답 뿐 아니라 왜 그런지도 설명할 수 있는지 확인한다.
- 공간 복잡도는 무엇인가?
  - 알고리즘을 수행할 때 필요한 메모리의 크기도 알고리즘을 평가하는데 사용하는 지표이며, 이를 체계적화하는데 사용된다는 사실을 설명할 수 있는지 확인한다.

---

# 문제 4. 재귀호출과 점화식

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 G는 조금 더 효율적인 정렬 방법을 찾아보기로 했다. 인터넷에서 조사를 해 보니 여러 효율적인 정렬 방법이 소개되고 있었다. 그런데 그 정렬 방법들은 모두 알고리즘을 구현한 함수가 다시 자기 자신을 호출하고 있는 이상한 형태로 되어 있었다.

이러한 형태를 찾아보니 이러한 알고리즘 구현 방식을 '재귀호출'이라 부른다는 사실을 알게 되었다. 문득 고등학교 수학 시간에 수열을 배울 때 비슷한 구조의 수식을 사용해 수열을 정의했던 일이 머리속에 떠올랐다.

## 수행목표

- 재귀 호출의 개념을 학습한다.
- 재귀 호출을 사용해 1에서 n까지의 정수를 더하는 알고리즘을 점화식으로 표현하고, 이를 계산하는 함수를 파이썬으로 구현한다.
- 피보나치 수열을 점화식으로 표현하고, 피보나치 수열의 일반항을 구하는 함수를 파이썬으로 구현한다.
- n의 값이 10, 15, 20, 25, 30일때 1에서 n까지 더한 값과 피보나치 수열의 n번째 항을 구현한 함수를 사용해 출력한다.

## 수행단계

- 재귀 호출과 점화식의 개념에 대해서 조사한다.
  - 재귀 호출에서의 종료조건에 대해서도 조사한다.
  - 재귀 호출에서 입력이 잘못 주어졌을 때 일어나는 일도 확인한다.
- 피보나치 수열은 고대의 여러 서적에서 흔적을 찾을 수 있지만, 이를 제외하면 이탈리아의 수학자 레오나르도 피사노, 일명 피보나치에 의해 13세기 초에 소개된 것으로 알려져있다. 피보나치 수열의 n번째 항 $fib_n$을 다음과 같이 정의한다.
  > - 첫 번째 항 $fib_1 = 1$
  > - 두 번째 항 $fib_2 = 1$
  > - 그 이후의 항은 이전 두 항의 합으로 계산한다.
  > - 피보나치 수열의 아홉번째 항까지를 나열하면 1, 1, 2, 3, 5, 8, 13, 21, 34이다.
- 1에서 n까지 정수의 합을 구하는 알고리즘과 피보나치 수열의 일반항을 구하는 알고리즘에 대해서 각각의 점화식을 정리한다.
- 정리한 점화식을 사용해 다음에 지시하는 바를 algorithm/recursive.py 파일에 구현한다.
  - 1에서 n까지의 모든 정수의 합을 구해서 반환하는 함수 sigma(n)
  - 피보나치 수열의 n번째 항을 계산해 반환하는 함수 fibonacci(n)
  - n = 10, 15, 20, 25, 30일 때의 두 함수의 결과를 각각 출력한다.

## 결과 예시

```
n = 10일 때
  1에서 n까지의 합 : 55
  피보나치 수열의 일반항 : 55
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 어떤 n이 주어지더라도 처리되지 않은 예외가 발생하지 않고 프로그램은 정상적으로 종료되어야 한다.
- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 재귀 알고리즘에서 입력이 잘못 주어지는 경우 다양한 문제가 발생할 수 있다. 이 경우 try ~ except 구문을 사용해 함수가 이를 예외 처리하여 발생한 예외 상황을 명확하게 보여줄 수 있도록 구현을 수정해보자.
- n = 0.5, 0, -1일 때 결과를 출력해보자.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/recursive.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    n = 10일 때
      1에서 n까지의 합 : 55
      피보나치 수열의 일반항 : 55
    n = 15일 때
      1에서 n까지의 합 : 120
      피보나치 수열의 일반항 : 610
    n = 20일 때
      1에서 n까지의 합 : 210
      피보나치 수열의 일반항 : 6765
    n = 25일 때
      1에서 n까지의 합 : 325
      피보나치 수열의 일반항 : 75025
    n = 30일 때
      1에서 n까지의 합 : 465
      피보나치 수열의 일반항 : 832040
    ```
  - 음수, 정수가 아닌 유리수, 0의 경우에도 프로그램이 적절한 결과를 출력하고 프로그램이 처리하지 않은 예외를 발생시키지 않고 종료되는지 확인한다.

### [보너스 과제 확인]

- 이상 입력에 대한 예외 처리가 구현되었는가?
  - try ~ except 구문을 사용해 이상 입력에 대한 예외츨 처리하였는지 확인한다.
  - 0, -1, 0.5 입력에 대해서 예외처리 결과를 출력하였는지 확인한다. 다음은 결과 예시이다.
    ```
    n = 0.5일 때
      예외 발생 : Input must be integer
    n = 0일 때
      예외 발생 : Input must be positive integer
    n = -1일 때
      예외 발생 : Input must be positive integer
    ```

### [문제에 대한 이해]

- 재귀 호출은 어떤 것인지 설명하라.
  - 재귀 호출은 함수가 자기 자신을 다시 호출하는 형태를 말한다.
- 재귀 호출의 종료조건은 무엇인가?
  - 재귀 호출이 종료되는 시점 뿐 아니라, 이 경우에는 자명한 값이 주어질 수 있어야 한다는 부분도 설명할 수 있어야 한다.
- 재귀 호출에서 조건에 맞지 않은 입력이 주어졌을 때 발생할 수 있는 일을 설명하라.
  - 무한 반복, 잘못된 계산 등을 최소한 포함하는 상황을 제시할 수 있는지 확인한다.
- 점화식은 무엇인가? 점화식은 알고리즘을 구현할 때 어떤 형태로 사용되는지를 설명하라.
  - 현재 상태가 이전 상태와 관련이 있을 때, 현재 상태를 이전상태를 사용해 표현한 식을 점화식이라고 한다.
  - 알고리즘을 구현할 때, 현재 상태를 구하기 위한 이전 상태를 재귀 호출하는 형태로 쉽게 알고리즘을 구현할 수 있다.
- 1에서 n까지 더하는 알고리즘의 점화식을 제시하라.
  - $a_n = a_{n-1} + n$을 기본으로 종료조건과 함께 제시할 수 있는지 확인한다.
- 피보나치 수열의 일반항을 구하는 알고리즘의 점화식을 제시하라.
  - $a_n = a_{n - 1} + a_{n - 2}$를 기본으로 종료조건과 함께 제시할 수 있는지 확인한다.
- 구현한 함수의 종료조건에 대해서 설명하라.
  - 각자 구현한 함수의 종료조건에 대해서 설명할 수 있는지 확인한다.

### [코드 예시]

```python
def fibonacci(n):
    if not isinstance(n, int):
        raise TypeError("Input must be integer")
    if n < 1:
        raise ValueError("Input must be positive integer")
    if n == 1 or n == 2:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

def sigma(n):
    if not isinstance(n, int):
        raise TypeError("Input must be integer")
    if n == 1:
        return 1
    if n < 1:
        raise ValueError("Input must be positive integer")
    return n + sigma(n - 1)

def main():
    testcase = [10, 15, 20, 25, 30, 0.5, 0, -1]
    for n in testcase:
        try:
            print(f"n = {n}일 때")
            fib_result = fibonacci(n)
            sig_result = sigma(n)
            print(f"  1에서 n까지의 합 : {sig_result}")
            print(f"  피보나치 수열의 일반항 : {fib_result}")
        except TypeError as e:
            print(f"  예외 발생 : {e}")
        except ValueError as e:
            print(f"  예외 발생 : {e}")

if __name__ == "__main__":
    main()
```

---

# 문제 5. 재귀호출의 구현

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 G는 재귀 호출에 조금 더 익숙해질 필요가 있다는 생각이 들었다. 그때 프로그래밍 지원게시판에 눈에 들어오는 문제가 하나 있었다. 조금 재미있어 보이는 이 문제를 해결하고 나면, 재귀 호출에 꽤 익숙해질 것 같은 확신이 생겨났다. 왜 그런 확신이 생겼는지는 모르겠지만...

## 수행목표

- 닥터 G의 친구이자 동료인 닥터 S는 바이오 필터를 연구하고 있다. 닥터 S가 연구하는 바이오 필터의 성질은 다음과 같다.
  - 바이오 필터는 필터의 격자 크기에 따라 구분이 되며, 격자 크기가 작을수록 작은 바이러스를 차단하는 효과를 나타낸다.
  - 미세필터 하나만 사용하면 정해진 크기 이상의 모든 바이러스를 차단할 수 있지만, 격자 크기가 작을수록 필터의 내구도가 떨어져서 쉽게 망가지는 문제가 있어서 바이어 필터를 여러층으로 배치해서 사용하고 있다.
  - 효율적인 필터 활용을 위해서 필터 배치는 항상 위로 올라갈 수록 격자의 크기가 작아지도록 배치해야 한다.
    - 물론 최종 제품만 이러한 형태로 배치되면 제품화를 할 수는 있지만, 육안으로는 필터의 격자의 크기를 구분할 수 없으므로 실험 또는 제품 생산 과정에서 필터를 옮길 때도 반드시 이 원칙을 지켜야 한다.
- 닥터 S는 필터를 배치하기 위해 3개의 실험판을 사용한다. 필터의 오염을 막기 위해서 3개의 실험판 이외의 장소에 필터를 배치할 수 없다. 이 실험판은 수명이 정해져 있어서 주기적으로 실험판을 교체해야 한다. 다만 3개의 실험판을 동시에 교체하는 경우 바이오 필터를 모두 버려야 하기 때문에 실험판 1 위에 쌓여 있는 바이오 필터를 모두 실험판 2로 옮긴 후 실험판 1을 새 실험판으로 교체하는 방식으로 이루어진다.
- 닥터 S는 n개의 서로 다른 크기의 바이오 필터를 세 개의 실험판 중 하나에 모두 쌓아두었다. 실험판을 교체하기 위해서 이 바이오 필터를 모두 다른 두 개의 실험판 중 하나로 옮겨야 한다. 바이오 필터 하나를 옮기는 회수를 1로 계산할 때 n개의 바이오 필터를 모두 다른 실험판 하나 위로 옮기는데 필요한 바이오 필터의 이동 회수를 구하는 함수를 재귀 호출 방식으로 구현한다.
- n = 3, 5, 10일 때 필요한 바이오 필터의 이동 회수를 출력하라.

## 수행단계

- 바이오 필터의 개수 n = 3일 때 바이오 필터를 다른 실험판으로 옮기는 과정은 다음과 같다.
  - 격자의 크기 순으로 필터를 $f_1$, $f_2$, $f_3$으로 부른다. 격자의 크기가 클 수록 필터의 번호가 커진다.
  - 실험판은 각각 $p_1$, $p_2$, $p_3$으로 부른다. 현재 배치되어 있는 실험판을 $p_1$이라고 하고, $p_2$, $p_3$ 둘 중 어느 쪽으로 이동해도 무방하다.
  - 초기상황 : $p_1$에 아래로부터 $f_3$, $f_2$, $f_1$ 순으로 배치되어 있다. 이를 ([3-2-1, X, X]으로 표시한다.)
  - $p_1$의 가장 위의 필터를 $p_2$로 이동한다. 이를 $p_1 \rightarrow p_2$로 표현한다. 이동 후의 상태는 [3-2, 1, X]이 된다. 이 과정과 결과 상태를 다음과 같이 표현한다.
    - $p_1 \rightarrow p_2$ : [3-2, 1, X]
  - $p_1 \rightarrow p_3$ : [3, 1, 2]
  - $p_2 \rightarrow p_3$ : [3, X, 2-1]
  - $p_1 \rightarrow p_2$ : [X, 3, 2-1]
  - $p_3 \rightarrow p_1$ : [1, 3, 2]
  - $p_3 \rightarrow p_2$ : [1, 3-2, X]
  - $p_1 \rightarrow p_2$ : [X, 3-2-1, X]
  - 이와 같은 과정을 거쳐 총 7번 격자를 이동해서 $p_1$ 위의 바이오 필터를 모두 $p_2$로 옮길 수 있다.
- 위의 이동 과정에서 n = 3일 때의 이동 회수와 n = 2일 때의 이동 회수의 관계를 찾아서 이를 점화식으로 정리한다.
- 이 점화식을 사용해 바이오 필터의 개수가 n일 때 필요한 최소 이동 회수를 계산하는 함수를 구현하고, 그 결과를 출력하는 파이썬 프로그램을 algorithm/moving_filter.py 파일에 작성한다.
  - n은 항상 양의 정수로 주어진다.
  - n = 3, 4, 5, 10, 100일 때 필요한 이동 회수를 출력한다.

## 결과예시

```
3개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 7
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 재귀 호출을 사용해 바이오 필터를 옮기는 순서를 출력하는 함수를 구현한다.
  - 이 때 최초의 실험판의 이름과 목표 실험판의 이름을 명시한다.
- n = 3, 4, 5일 때 이동 과정을 출력한다. 다음은 n = 3일 때의 결과예시이다.

  ```
  3개의 바이오 필터를 p1 실험판에서 p2 실험판으로 옮기는 과정
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p1 -> p2
      p3 -> p1
      p3 -> p2
      p1 -> p2
  ```

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/moving_filter.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    3개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 7
    4개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 15
    5개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 31
    10개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 1023
    100개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : 1267650600228229401496703205375
    ```

### [보너스 과제 확인]

- 재귀 호출로 구현한 함수를 사용해 바이오 필터 이동 과정을 정확하게 출력하였는가?

  - 다음은 바이오 필터의 개수가 3, 4, 5개일 때의 출력 결과이다. 결과에서 시작 실험판과 목표 실험판은 반드시 1, 2일 필요는 없다. 다만 반드시 두 실험판은 다른 실험판이어야 한다.

  ```
  3개의 바이오 필터를 p1 실험판에서 p2 실험판으로 옮기는 과정
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p1 -> p2
      p3 -> p1
      p3 -> p2
      p1 -> p2

  4개의 바이오 필터를 p1 실험판에서 p2 실험판으로 옮기는 과정
      p1 -> p3
      p1 -> p2
      p3 -> p2
      p1 -> p3
      p2 -> p1
      p2 -> p3
      p1 -> p3
      p1 -> p2
      p3 -> p2
      p3 -> p1
      p2 -> p1
      p3 -> p2
      p1 -> p3
      p1 -> p2
      p3 -> p2

  5개의 바이오 필터를 p1 실험판에서 p2 실험판으로 옮기는 과정
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p1 -> p2
      p3 -> p1
      p3 -> p2
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p2 -> p1
      p3 -> p1
      p2 -> p3
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p1 -> p2
      p3 -> p1
      p3 -> p2
      p1 -> p2
      p3 -> p1
      p2 -> p3
      p2 -> p1
      p3 -> p1
      p3 -> p2
      p1 -> p2
      p1 -> p3
      p2 -> p3
      p1 -> p2
      p3 -> p1
      p3 -> p2
      p1 -> p2
  ```

### [문제에 대한 이해]

- 바이오 필터가 n개 일 때 바이오 필터를 다른 실험판으로 옮기는 과정을 설명하라. 단 '어떤 실험판의 바이오 필터 1개를 어떤 실험판으로 옮긴다.'와 '어떤 실험판의 바이오 필터 n-1개를 어떤 실험판으로 옮긴다.' 두 가지 형태로만 과정을 단순화해 제시해야 한다.
  - 바이오 필터를 n-1개와 1개의 순서로 다른 실험판에 옮긴 후, n-1개를 가장 큰 격자의 바이오필터 하나로 옮기는 형태의 3단계로 제시하는지 확인한다.
- n개의 바이오 필터가 주어졌을 때, 이동 회수를 구하는데 사용할 수 있는 점화식을 제시하고, 그 점화식이 왜 그렇게 만들어졌는지를 설명하라.
  - n개의 바이오 필터에서 n-1개를 옮기는 횟수, 그리고 남은 1개의 바이오 필터를 옮긴 후, 다시 n - 1개의 바이오 필터를 1개의 바이오 필터 위로 옮기는데 필요한 횟수를 기반해서 점화식을 제시하는지 확인한다.
  - n개의 바이오 필터를 옮기는데 필요한 최소 이동 횟수를 $t_n$이라고 하면, 점화식은 $t_n = 2\times t_{n-1} + 1$이다.
- (보너스 문제를 해결한 경우) 회수를 구하는 대신 옮기는 과정을 출력하기 위해서 어떤 방법으로 알고리즘을 구성하였는가?
  - 재귀 호출 과정에서 횟수를 더하는 대신, 그 과정을 출력하도록 재귀 호출 함수를 수정하였음을 확인한다.
  - 또한 시작 실험판과 목표 실험판의 위치를 명확히 지정하는 알고리즘이 구현되었는지를 확인한다.
- 이 문제를 통해 재귀 호출의 필요성을 이야기해보라.
  - 재귀 호출을 사용하는 구현의 직관성에 대해서 설명할 수 있는지 확인한다.

### [코드 예시]

```python
def moving_count(n):
    if n == 1:
        return 1
    return 2 * moving_count(n - 1) + 1

def moving_guide(src, dest, room, n):
    if n == 0:
        return
    moving_guide(src, room, dest, n - 1)
    print(f"    {src} -> {dest}")
    moving_guide(room, dest, src, n - 1)

def main():
    testcases = [3, 4, 5, 10, 100]
    for tc in testcases:
        print(f"{tc}개의 바이오 필터를 다른 실험판으로 옮길 때의 최소 이동 회수 : {moving_count(tc)}")

    testcases = [3, 4, 5]
    for tc in testcases:
        print(f"{tc}개의 바이오 필터를 p1 실험판에서 p2 실험판으로 옮기는 과정")
        moving_guide('p1', 'p2', 'p3', tc)
        print()

if __name__ == '__main__':
    main()
```

---

# 문제 6. 알고리즘의 시간 복잡도

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

바이오 필터 이동 문제를 해결한 닥터 G는 구현한 알고리즘의 시간 복잡도가 어떻게 될지가 갑자기 궁금해졌다. 루프를 사용한 일반적인 알고리즘의 경우는 루프의 중첩 회수를 사용해 시간 복잡도를 계산할 수 있었지만, 재귀 함수의 경우는 시간 복잡도를 어떻게 판단해야 하는지 잘 연상이 되지 않았다. 하지만 알고리즘은 어떤 방식으로건 시간 복잡도를 파악할 수 있어야 좋은 알고리즘인지의 여부를 확인할 수 있으니 이를 피할 수 없었다.

프로그래밍 지원게시판에 이를 어떻게 계산하는지를 물어보기로 했다.

## 수행목표

- 1에서 n까지 모든 정수의 합을 구하는 알고리즘은 다음과 같이 유사코드로 표현할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION sigma(n)
    IF n < 1 THEN RETURN 0
    ELSE IF n == 1 THEN RETURN 1
    ELSE RETURN sigma(n - 1) + n
```

- n개의 양의 정수 중 최대값을 찾는 알고리즘을 다음과 같이 유사코드로 표현할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION max_number1(arr, size)
    result = 0
    FOR i FROM 0 TO size - 1
        IF arr[i] > result THEN
            result = arr[i]
    RETURN result
```

- n개의 정수 중 최대값을 찾는 알고리즘을 다음과 같이 두개 씩 비교한 결과를 취합하는 방식으로 재귀 호출 알고리즘으로 구현할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION max_number2(arr, start, end):
    IF start == end THEN
        RETURN arr[start]
    ELSE
        mid = (end + start) // 2
        leading_max = max_number2(arr, start, mid)
        trailing_max = max_number2(arr, mid + 1, end)
        IF leading_max > trailing_max THEN
            RETURN leading_max
        ELSE
            RETURN trailing_max
```

- 위의 알고리즘을 다음과 같이 조금 더 효율적으로 변경할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION max_number3(arr, start, end):
    IF start == end THEN
        RETURN arr[start]
    ELSE IF start + 1 == end THEN
        IF arr[start] > arr[end] THEN RETURN arr[start]
        ELSE RETURN arr[end]
    ELSE
        mid = (end + start) // 2
        leading_max = max_number3(arr, start, mid)
        trailing_max = max_number3(arr, mid + 1, end)
        IF leading_max > trailing_max THEN
            RETURN leading_max
        ELSE
            RETURN trailing_max
```

- n개의 서로 다른 정수가 오름차순으로 정렬된 리스트 arr에서 특정 값(k)의 인덱스를 찾는 알고리즘을 다음과 같이 구현할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION find_number1(arr, size, k)
    FOR i FROM 0 TO size - 1
        IF arr[i] > k THEN RETURN -1
        IF arr[i] == k THEN RETURN i
    RETURN -1
```

- n개의 서로 다른 정수가 오름차순으로 정렬된 리스트 arr에서 특정 값(k)의 인덱스를 찾는 알고리즘을 다음과 같이 재귀 호출 알고리즘으로 구현할 수 있다. 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라. (n > 0)

```
FUNCTION find_number2(arr, start, end, k)
    IF start == end THEN
        IF arr[start] == k THEN RETURN start
        ELSE RETURN -1
    mid = (start + end) // 2
    IF arr[mid] > k THEN RETURN find_number2(arr, start, mid, k)
    ELSE RETURN find_number2(arr, mid + 1, end, k)
```

## 수행단계

- algorithm/find_complexity.py 파일에 다음을 구현한다.
  - 주어진 5개의 유사 코드를 파이썬 함수로 구현한다.
  - n = 512일 때 1에서 n까지의 모든 정수의 합을 구하도록 함수를 호출하고, 그 결과를 출력한다.
  - 1에서 10000 범위의 서로 다른 정수로 구성된 길이 512, 511인 무작위 리스트를 두 개 생성한다. 단, 이 리스트에는 반드시 5000이 포함되도록 리스트를 생성한다.
  - 이 두 개의 리스트 각각에 대해서 max_number1, max_number2, max_number3 알고리즘의 결과를 구하도록 함수를 호출하고, 그 결과를 출력한다.
  - 위에서 생성한 두 개의 리스트를 오름차순으로 정렬한 후, 두 개의 리스트 각각에 대해서 값 인덱스 5000을 구하도록 함수를 호출하고, 그 결과를 출력한다.
- 구현한 함수를 대상으로 다음 질문에 대한 답을 마크다운 형식으로 정리해 algorithm/find_complexity.md 파일에 작성한다.
  - sigma 알고리즘의 시간 복잡도를 계산한다.
    - n이 512일 때 함수가 호출되는 회수는 몇 번인가?
    - n이 증가하면 함수의 호출되는 회수는 어떻게 증가하는가?
    - 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - max_number1 알고리즘의 시간 복잡도를 계산한다.
    - n이 512일 때, max_number1 함수가 호출되는 회수는 몇 번인가?
    - n이 증가하면 함수의 호출되는 회수는 어떻게 증가하는가?
    - 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - max_number2 알고리즘의 시간 복잡도를 계산한다.
    - n = 1, 2, 3, 4, 5, 6, 7, 8일 때 max_number2 함수가 호출되는 회수는 각각 몇 번인가?
    - 위 결과를 바탕으로 max_number2에서 입력 리스트의 길이가 n일 때 함수 호출 회수는 몇 번이 될 지를 수식으로 제시하라.
    - 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - max_number3 알고리즘의 시간 복잡도를 계산한다.
    - n = 1, 2, 3, 4, 5, 6, 7, 8일 때 max_number3 함수가 호출되는 회수는 각각 몇 번인가?
    - 위 결과를 바탕으로 max_number3에서 입력 리스트의 길이가 n일 때 함수 호출 회수는 몇 번이 될 지를 수식으로 제시하라.
    - 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - max_number1, max_number2, max_number3 세 알고리즘의 효율성을 평가해보자.
  - find_number1 알고리즘의 시간 복잡도를 계산한다.
    - 리스트의 길이가 512일 때 가장 빠르게 결과를 반환하는 경우는 어떤 경우이며, 이 때의 루프 반복 횟수는 얼마인가?
    - 리스트의 길이가 512일 때 가장 느리게 결과를 반환하는 경우는 어떤 경우이며, 이 때의 루프 반복 횟수는 얼마인가?
    - n이 증가함에 따라 루프의 반복 횟수는 어떻게 되는가?
    - 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - find_number2 알고리즘의 시간 복잡도를 계산한다.
    - 리스트의 길이가 512일 때, 이 함수는 어떤 값의 인덱스를 찾기 위해서 몇 번 호출되는가?
    - 리스트의 길이가 256일 때, 이 함수는 어떤 값의 인덱스를 찾기 위해서 몇 번 호출되는가?
    - 리스트의 길이가 511일 때, 이 함수는 어떤 값의 인덱스를 찾기 위해서 몇 번 호출되는가? 만약 두 가지 이상의 경우가 존재한다면 각각 어떤 경우에 해당하는지를 설명하라.
    - 위의 결과를 바탕으로 리스트의 길이가 $n = 2^k$일 때, 이 함수는 어떤 값의 인덱스를 찾기 위해서 함수가 호출되는 횟수는 몇 번인지 추정해보자.
    - 위의 결과를 바탕으로 리스트의 길이가 $2^{k - 1} + 1$ 이상 $2^{k}$이하의 값일 때 함수가 호출되는 횟수는 몇 번인지 추정해보자.
    - 2^k = n일 때 밑이 2인 log n의 값은 얼마인가?
    - 빅 오 노테이션의 정의를 고려해서 이 알고리즘의 시간 복잡도를 빅 오 노테이션으로 표현하라.
  - find_number1, find_number2 두 알고리즘의 효율성을 평가해보자.
  - 이전 문제에서 구현한 바이오필터 이동 횟수 구하는 재귀 호출 알고리즘의 시간 복잡도를 계산한다.
    - 재귀 호출을 재외한 함수의 시간 복잡도는 어떻게 되는가?
    - 바이오 필터의 개수가 n일 때와 바이오 필터의 개수가 n - 1일 때의 재귀 함수의 총 호출 회수의 관계를 점화식의 형태로 작상하라.
    - 바이오 필터의 개수가 n일 때 재귀 함수의 총 호출 회수는 몇 번인가?
    - 빅 오 노테이션으로 이 알고리즘의 시간 복잡도를 표현하라.

## 결과예시

```
sigma(512)의 결과 : XXX
길이 512의 리스트에서의 최댓값
    max_number1의 결과 : XXX
    max_number2의 결과 : XXX
    max_number3의 결과 : XXX
정렬된 길이 512의 리스트에서 5000의 인덱스 번호
    find_number1의 결과 : XXX
    find_number2의 결과 : XXX
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 이전 문제에서 구현한 적 있는 피보나치 수열의 일반항을 구하는 재귀 호출 알고리즘의 시간 복잡도를 제시하라.
  - 제시한 시간 복잡도의 근거로 함께 제시할 수 있어야 한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/find_complexity.py 파일에 구현이 되어 있는지 확인한다.
  - 시간 복잡도를 분석한 리포트를 algorithm/find_complexity.md 파일에 마크다운 형식으로 작성하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 또한 최댓값과 인덱스의 결과도 무작위 생성된 리스트의 내용에 따라 달라질 수 있지만, 최댓값, 그리고 인덱스 번호는 하나의 리스트에서 모두 동일하게 출력되어야 한다.

    ```
    sigma(512)의 결과 : 131328
    길이 512의 리스트에서의 최댓값
        max_number1의 결과 : 9993
        max_number2의 결과 : 9993
        max_number3의 결과 : 9993
    정렬된 길이 512의 리스트에서 5000의 인덱스 번호
        find_number1의 결과 : 256
        find_number2의 결과 : 256
    길이 511의 리스트에서의 최댓값
        max_number1의 결과 : 9982
        max_number2의 결과 : 9982
        max_number3의 결과 : 9982
    정렬된 길이 511의 리스트에서 5000의 인덱스 번호
        find_number1의 결과 : 274
        find_number2의 결과 : 274
    ```

  - 리포트에서 제시한 각 함수의 시간 복잡도는 다음과 같다.
    - sigma : $\mathcal O(n)$
    - max_number1 : $\mathcal O(n)$
    - max_number2 : $\mathcal O(n)$
    - max_number3 : $\mathcal O(n)$
    - find_number1 : $\mathcal O(n)$
    - find_number2 : $\mathcal O(\log n)$ - 로그의 밑을 2로 표기하거나 밑을 표기하지 않아도 무방하다.
    - 바이오 필터 이동 회수 : $\mathcal O(2^n)$
  - 리포트에서는 max_number1, max_number2, max_number3의 호출 또는 반복 횟수는 달라도 시간 복잡도가 같은 동일한 시간 복잡도를 가진 알고리즘으로 평가할 수 있어야 한다. 다만 실제 성능 자체는 다를 수 있다고 표기할 수 있다.
  - 리포트에서 find_number1 보다 find_number2의 알고리즘이 더 효율적이라고 이야기 할 수 있어야 한다.

### [보너스 과제 확인]

- 피보나치 수열의 시간 복잡도를 계산 방식과 함께 정확히 제시할 수 있는가?
  - 피보나치 수열의 시간 복잡도는 $\mathcal O(2^n)$이다.
  - 충분히 큰 n에 대해서 재귀의 깊이는 n에 가깝고, 각 단계에서 재귀 호출 회수는 두 배씩 증가하므로, 이를 바탕으로 지수 시간 복잡도에 해당함을 설명할 수 있는지 확인한다.

### [문제에 대한 이해]

- 최대값을 찾는 세 함수의 반복 또는 재귀 호출 횟수는 모두 다르다. 그럼에도 불구하고 시간 복잡도가 동일하므로 세 함수의 실제 성능은 동일하다고 이야기 할 수 있는가?
  - 어디까지나 '시간복잡도'를 기준으로 평가한 결과이며, 실제 실행 성능은 다를 수 있다고 이야기 할 수 있어야 한다.
  - 또한 시간 복잡도는 n의 값이 커짐에 따라서 늘어나는 시간의 비율의 스케일을 이야기 하는 것으로 절대 성능과 무관하기 때문에 실제 성능과 차이가 있다고 이야기 할 수도 있다.
- 각 함수가 한 번의 재귀 호출을 할 때, 입력의 크기가 절반으로 줄어드는 경우의 시간 복잡도는 어떻게 될까? 단, 재귀 호출을 제외한 나머지 부분의 시간 복잡도는 상수 시간복잡도라고 가정한다.
  - 로그 시간 복잡도
- 각 함수가 한 번의 재귀 호출을 할 때, 입력의 크기가 절반으로 줄어드는 경우의 시간 복잡도는 어떻게 될까? 단, 재귀 호출을 제외한 나머지 부분의 시간 복잡도는 $\mathcal O(n)$이라고 가정한다.
  - 선형 로그 시간 복잡도 ($\mathcal O(n \log n))$
- 각 함수가 한 번의 재귀 호출을 할 때, 입력의 크기가 1씩 줄어드는 경우의 시간 복잡도는 어떻게 될까? 단, 재귀 호출을 제외한 나머지 부분의 시간 복잡도는 상수 시간복잡도라고 가정한다.
  - 선형 시간 복잡도
- 각 함수가 두 번의 재귀 호출을 할 때, 입력의 크기가 1씩 줄어드는 경우의 시간 복잡도는 어떻게 될까? 단, 재귀 호출을 제외한 나머지 부분의 시간 복잡도는 상수 시간복잡도라고 가정한다.
  - 지수 시간 복잡도

### [코드 예시]

```python
def sigma(n):
    if n < 1:
        return 0
    if n == 1:
        return 1
    return sigma(n - 1) + n

def max_number1(arr, size):
    result = 0
    for i in range(size):
        if arr[i] > result:
            result = arr[i]
    return result

def max_number2(arr, start, end):
    if start == end:
        return arr[start]
    mid = (start + end) // 2
    leading_max = max_number2(arr, start, mid)
    trailing_max = max_number2(arr, mid + 1, end)
    if leading_max > trailing_max:
        return leading_max
    else:
        return trailing_max

def max_number3(arr, start, end):
    if start == end:
        return arr[start]
    if start + 1 == end:
        return arr[start] if arr[start] > arr[end] else arr[end]
    mid = (start + end) // 2
    leading_max = max_number3(arr, start, mid)
    trailing_max = max_number3(arr, mid + 1, end)
    if leading_max > trailing_max:
        return leading_max
    else:
        return trailing_max

def find_number1(arr, size, k):
    for i in range(size):
        if arr[i] > k:
            return -1
        if arr[i] == k:
            return i
    return -1

def find_number2(arr, start, end, k):
    if start == end:
        if arr[start] == k:
            return start
        else:
            return -1
    mid = (start + end) // 2
    if arr[mid] == k:
        return mid
    elif arr[mid] > k:
        return find_number2(arr, start, mid, k)
    else:
        return find_number2(arr, mid + 1, end, k)

import random

def make_distinct_random_list(size):
    arr = [5000]
    while len(arr) < size:
        num = random.randint(1, 10000)
        if num not in arr:
            arr.append(num)
    return arr

def test_c(n):
    if n == 1:
        return 1
    if n % 2 == 0:
        return 2 * test_c(n // 2) + 1
    else:
        return test_c((n + 1) // 2) + test_c((n - 1) // 2) + 1
def main():
    print("sigma(512)의 결과 :", sigma(512))
    size1 = 512
    arr1 = make_distinct_random_list(size1)
    size2 = 511
    arr2 = make_distinct_random_list(size2)

    arr1_sorted = sorted(arr1)
    arr2_sorted = sorted(arr2)
    print("길이 512의 리스트에서의 최댓값")
    print("    max_number1의 결과 :", max_number1(arr1, size1))
    print("    max_number2의 결과 :", max_number2(arr1, 0, size1 - 1))
    print("    max_number3의 결과 :", max_number3(arr1, 0, size1 - 1))
    print("정렬된 길이 512의 리스트에서 5000의 인덱스 번호")
    print("    find_number1의 결과 :", find_number1(arr1_sorted, size1, 5000))
    print("    find_number2의 결과 :", find_number2(arr1_sorted, 0, size1 - 1, 5000))

    print("길이 511의 리스트에서의 최댓값")
    print("    max_number1의 결과 :", max_number1(arr2, size2))
    print("    max_number2의 결과 :", max_number2(arr2, 0, size2 - 1))
    print("    max_number3의 결과 :", max_number3(arr2, 0, size2 - 1))
    print("정렬된 길이 511의 리스트에서 5000의 인덱스 번호")
    print("    find_number1의 결과 :", find_number1(arr2_sorted, size2, 5000))
    print("    find_number2의 결과 :", find_number2(arr2_sorted, 0, size2 - 1, 5000))

if __name__ == '__main__':
    main()
```

---

# 문제 7. 재귀 호출의 구조

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

닥터 G는 마치 체인을 연결한 것 처럼 이루어지는 유전자 변형 과정을 예측하는 작업을 진행하고 있었다. 유전자의 변형 결과는 이전 유전자 변형 결과를 사용해고, 또 그 이전의 결과를 사용하는 방식으로 이루어지는 과정의 시뮬레이션의 필요성을 접하는 순간 얼마전에 알게 된 재귀호출로 이 문제를 해결할 수 있겠다고 생각했다.

이 과정을 통해 시뮬레이션 결과를 예측할 수 있었는데, 긱 딘계의 번호를 출력하는데 문제가 발생했다.
'어? 왜 숫자가 거꾸로 나와?'

닥터 G가 원한 결과는 다음과 같았다.

```
1단계 처리 완료
2단계 처리 완료
...
10단계 처리 완료
```

그런데 화면에 나온 결과는 다음과 같았다.

```
10단계 처리 완료
9단계 처리 완료
...
1단계 처리 완료
```

## 수행목표

- 재귀 호출을 하면서 다음과 같이 출력하는 함수를 구현한다.

```
1
2
3
...
10
```

- 이 함수에서 코드의 순서만 바꾸고 다음과 같이 출력하는 함수를 구현한다.

```
10
9
8
...
1
```

- 파이썬에서 재귀 호출 함수를 구현할 때 주의해야 할 점을 추가로 조사한다.

## 수행단계

- algorithm/recursion_warning.py 파일에 다음 재귀 함수를 구현한다.
  - 재귀 함수는 반복 회수를 파라미터로 받는다. (파라미터는 양의 정수만 주어진다.) 재귀 호출 함수는 현재의 누적 호출 회수룰 다음과 같이 출력한다.
  - 출력 결과는 다음과 같다. 파라미터로 10으로 지정했을 때의 결과이다.
  ```
  1
  2
  3
  ...
  10
  ```
- 위의 재귀 호출 함수와 모든 것이 동일하지만, 코드 상에서 두 줄의 위치만 변경해서 다음과 같이 출력되는 재귀 함수를 구현한다.
  ```
  10
  9
  8
  ...
  1
  ```
- 두 함수의 구현 차이를 확인하고, 어떤 차이가 이러한 결과를 발생시켰는지를 확인한다.
- 파라미터를 2000으로 지정했을 때 어떤 결과가 나오는지 확인한다.
  - 재귀의 깊이가 너무 깊어졌을 때 발생 가능한 문제를 조사한다.
- 재귀 호출에서 재귀 호출의 깊이와 관련된 문제점을 다음 순서로 조사한다.
  - 스택 메모리와 힙 메모리의 개념
  - 파이썬 함수가 메모리를 사용하는 방식
  - 재귀 호출과 공간 복잡도의 관계
  - 재귀 호출의 깊이가 과도하게 길어졌을 때 발생 가능한 문제점 (메모리 사용과 관련된 문제점을 중심으로 조사한다)
  - 파이썬에서 과도한 재귀 호출을 제한하는 이유와 방식

## 결과예시

- 없음

## 참고사항

- 없음

## 제약사항

- 이 문제에 한해서 아무런 제약사항을 두지 않는다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 파이썬에서는 과도한 재귀 호출을 제한하고 있는데, 이 제한을 완화시키는 방법이 있다. 이 방법을 사용해 파라미터가 2000일 때의 결과를 확인할 수 있도록 코드를 수정해보자.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/recursion_warning.py 파일에 구현이 되어 있는지 확인한다.
  - 두 개의 함수가 코드의 순서 이외에 모두 동일한지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    정방향 출력
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    역방향 출력
    10
    9
    8
    7
    6
    5
    4
    3
    2
    1
    큰 수가 입력 되었을 때
    Traceback (most recent call last):
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 25, in <module>
        main()
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 22, in main
        count(10000)
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 7, in count
        count(n - 1)
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 7, in count
        count(n - 1)
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 7, in count
        count(n - 1)
    [Previous line repeated 994 more times]
    File "/Users/edbergbak/work/pbl/algo/algorithm/check_sequence.py", line 5, in count
        if n == 0:
    RecursionError: maximum recursion depth exceeded in comparison
    ```

### [보너스 과제 확인]

- 재귀 호출의 제한을 완화시키는 코드를 추가하였는가?
  - sys.setrecursionlimit(1000000)와 같이 재귀 호출의 깊이 제한을 충분하게 설정해 두었는지 확인한다.
  - 실행 결과 예외가 발생하지 않아야 한다.

### [문제에 대한 이해]

- 두 함수의 구현의 차이는 무엇인가?
  - 출력과 재귀 호출의 선후 순서의 차이이다.
- 재귀 호출에서 재귀 호출의 위치에 따른 차이를 설명하라.
  - 재귀 호출 이후에 출력을 하는 경우, 가능한 재귀 호출을 다 수행한 후 출력을 역순으로 하면서 거슬러 올라오기 때문에 1부터 10의 순서로 출력하게 된다.
  - 재귀 호출 이전에 출력을 하는 경우, 우선 출력을 한 후 재귀 호출을 하기 때문에 10부터 1의 순서로 출력하게 된다.
- 스택 메모리와 힙 메모리의 개념에 대해서 설명하라.
  - 힙 메모리
    - 동적 메모리 할당을 위해서 사용되는 메모리를 힙 메모리라고 한다.
    - 동적으로 메모리를 할당받는 객체가 생성되거나, 이러한 객체들이 동적으로 메모리의 크기를 추가로 사용할 때 할당되는 메모리 영역이다.
  - 스택 메모리
    - 함수가 호출될 때 함수에 포함된 지역 변수, 매개 변수, 반환 주소값 등을 가지고 있는 스택 프레임이 저장되는 메모리이다.
- 파이썬에서 함수를 호출할 때 어떤 메모리를 고정적으로 추가 사용하게 되는가?
  - 스택 메모리를 추가로 사용하게 된다.
- 재귀 호출이 과도할 때 발생할 수 있는 메모리 오류에 대해서 설명하라.
  - 시스템의 스택의 크기는 고정되어 있다. 이러한 스택 메모리를 과도하게 사용함으로써 공간 복잡도가 증가하고 결국 정해진 크기의 스택 메모리의 용량을 넘어서는 스택 오버플로우 오류의 발생 가능성이 있다.
- 파이썬에서 재귀 호출의 깊이를 제한하고 있는 이유를 설명하라.
  - 스택 오버플로우를 방지해 시스템의 안정성을 확보하기 위해서이다.
- (보너스 문제를 해결한 경우)재귀 호출의 깊이를 완화하는 설정이 가능하다. 이 방법은 만병통치약 처럼 언제나 사용할 수 있는 방법인지 의견을 제시해보자.
  - 이 제한을 풀어버리면 발생 가능한 메모리 오류의 위험성이 커지므로 만병통치약처럼 사용해서는 안된다.

### [코드 예시]

```python
import sys
sys.setrecursionlimit(1000000)

def count(n):
    if n == 0:
        return 0
    count(n - 1)
    print(n)

def count_reverse(n):
    if n == 0:
        return 0
    print(n)
    count_reverse(n - 1)

def main():
    print("정방향 출력")
    count(10)
    print("역방향 출력")
    count_reverse(10)
    print("큰 수가 입력 되었을 때")
    count(10000)

if __name__ == "__main__":
    main()
```

---

# 문제 8. 첫 번째 정렬 알고리즘

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

어느 정도 알고리즘과 재귀 호출 방식에 익숙해진 닥터 G는 재귀 호출을 사용한 효율적인 정렬 알고리즘을 구상하기 시작했다. 닥터 G의 첫 번째 정렬 알고리즘의 아이디어는 다음과 같았다.

> - 목록에서 임의로 하나의 유전자 시퀀스를 선택한다.
> - 선택한 유전자 시퀀스보다 사전순으로 앞에 위치한 항목들의 리스트(즉 작은 값을 가진 항목의 리스트)와, 선택한 유전자 시퀀스보다 사전순으로 뒤에 위치한 항목들의 리스트(즉 큰 값을 가진 항목의 리스트)를 각각 만든다.
> - 두 개의 리스트를 각각 정렬한 다음, 정렬된 작은 값을 가진 항목의 리스트, 선택한 시퀀스, 정렬된 큰 값을 가진 항목의 리스트를 순서대로 이어 붙인다.
>   - 두 개의 리스트를 각각 정렬할 때, 만들고 있는 알고리즘을 재귀 호출해서 정렬한다.
>   - 더 이상 정렬할 필요가 없는 작은 크기의 리스트(즉, 크기가 1 또는 0인 리스트)에 도달할 때 까지 재귀 호출을 반복한다.

## 수행목표

- 닥터 G의 아이디어를 정렬 함수로 구현한다.
  - 단 닥터 G의 아이디어에 사소한 결함이 하나 있다. 이 결함을 찾아내고 이를 수정한 아이디어로 정렬 함수를 구현해야 한다.
- 다음 두 개의 파일에는 숫자와 유전자 시퀀스로 구성된 8개씩의 목록을 포함하고 있으며, 각각의 목록은 testcase 번호, 목록에 포함된 항목의 수, 그리고 각 줄마다 하나씩의 항목에 해당하는 리스트의 내용으로 구성된다. 예를 들어서 5개의 시퀀스를 가진 목록은 파일에 다음과 같이 기록되어 있다.

```
testcase 1
5
CTCAT
TACAG
GACT
TAGGC
ATCTA
```

- 두 개의 파일에 포함된 16개의 목록을 정렬한 후, 그 결과를 수행단계에서 지시한 방식으로 가공해서 출력한다.

## 수행단계

- algorithm/first_sort.py 파일에 닥터 G의 정렬 아이디어대로 주어진 리스트를 정렬하는 함수를 구현한다.
  - 닥터 G의 정렬 아이디어에 숨겨진 결함을 찾아서, 아이디어를 수정한 후 이를 구현한다.
  - 이 함수는 정렬할 대상을 포함하는 리스트만 파라미터로 받는다.
  - 리스트의 항목이 문자열이건 숫자이건 상관없이 동작해야 한다. 문자열의 경우는 사전순으로, 숫자의 경우는 오름차순으로 정렬한 결과를 반환한다.
  - 정렬 후에도 파라미터로 전달한 원래의 리스트의 항목의 순서는 그대로 유지되어야 한다.
- 파일에 포함된 20개의 목록을 정렬한 후, 정렬 결과를 다음과 같이 가공해 출력한다.

  - 숫자의 경우 마지막 자리 수를 이어 붙인 문자열을 생성한다.
  - 문자열의 경우 마지막 글자를 이어 붙인 문자열을 생성한다.
  - 생성한 문자열을 다음 함수를 사용해 '간이 해시값'을 생성한 후 이를 출력한다.

  ```python
  import hashlib

  def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]
  ```

## 결과예시

```
숫자 리스트
testcase 1
    계산한 간이 해시 값 : 827c
(이하 생략)

유전자 시퀀스 리스트
testcase 1
    계산한 간이 해시 값 : d793
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/first_sort.py 파일에 구현이 되어 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    Testcase 1
    	BFS 문자열 표현의 간이 해시값 : 669e

	Testcase 2
	    BFS 문자열 표현의 간이 해시값 : 3d7c
	
	Testcase 3
	    BFS 문자열 표현의 간이 해시값 : 669e
	
	Testcase 4
	    BFS 문자열 표현의 간이 해시값 : 433b
	
	Testcase 5
	    BFS 문자열 표현의 간이 해시값 : 4254
	
	Testcase 6
	    BFS 문자열 표현의 간이 해시값 : 5698
	
	Testcase 7
	    BFS 문자열 표현의 간이 해시값 : 7917
	
	Testcase 8
	    BFS 문자열 표현의 간이 해시값 : 399b

    ```

### [문제에 대한 이해]

- 닥터 G의 아이디어의 결함은 무엇인가?
  - 피벗에 해당하는 수가 중복해 리스트에 포함된 경우, 정렬된 리스트에 피벗이 단 한번만 반영된다. 이렇게 재귀 호출 과정에서 지속적으로 피벗에 해당하는 숫자의 항목들이 누락되는 문제가 발생한다.

### [코드 예시]

```python
def qsort(arr):
    if len(arr) < 2:
        return arr

    pivot = arr[0]
    left = []
    right = []
    pivot_count = 1

    for i in range(1, len(arr)):
        if arr[i] < pivot:
            left.append(arr[i])
        elif arr[i] > pivot:
            right.append(arr[i])
        else:
            pivot_count += 1
    return qsort(left) + [pivot] * pivot_count + qsort(right)

import hashlib
def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]


def main():
    print("숫자 리스트")
    with open('testcase1.txt', 'r') as f:
        number_list = []
        i = 0
        line = f.readline()
        while True:
            if not line or line[0:8] == 'testcase':
                if i == 0:
                    i += 1
                    line = f.readline()
                else:
                    print(f"testcase {i}")
                    sorted_list = qsort(number_list)
                    result = ''
                    for n in sorted_list:
                        result += str(n % 10)
                    print(f"    계산한 간이 해시 값 : {hash4(result)}")
                    number_list = []
                    i += 1
                    line = f.readline()
                if not line:
                    break

            else:
                number_list.append(int(line.strip()))
            line = f.readline()

    print("\n유전자 시퀀스 리스트")
    with open('testcase2.txt', 'r') as f:
        sequence_list = []
        i = 0
        line = f.readline()
        while True:
            if not line or line[0:8] == 'testcase':
                if i == 0:
                    i += 1
                    line = f.readline()
                else:
                    print(f"testcase {i}")
                    sorted_list = qsort(sequence_list)
                    result = ''
                    for sequence in sorted_list:
                        result += sequence[0]
                    print(f"    계산한 간이 해시 값 : {hash4(result)}")
                    sequence_list = []
                    i += 1
                    line = f.readline()
                if not line:
                    break

            else:
                sequence_list.append(line.strip())
            line = f.readline()

if __name__ == '__main__':
    main()
```

---

# 문제 9. 두 번째 정렬 알고리즘

## 문제 분류

- 중요도 : 4/5
- 난이도 : 4/5
- 목표 수행 시간 : 4시간

## 스토리

첫 번째 정렬 아이디어를 구현하던 닥터 G는 두 번째 정렬 아이디어가 떠올랐다. 이 아이디어는 다음과 같다.

> - 목록을 크기가 같거나, 크기 차이가 1인 두 개의 리스트로 나눈다. 이 때 항목의 크기는 신경쓰지 않고 순서대로 그냥 나눈다.
> - 나눈 두 개의 리스트 각각을 정렬한다.
>   - 두 개의 작은 리스트를 정렬할 때 만들고 있는 알고리즘을 재귀 호출해서 정렬한다.
> - 정렬된 두 개의 리스트를 합친다.
>   - 이 때, 정렬된 두 리스트의 앞에서부터 차례대로 가장 작은 항목을 추가해나가는 방식으로 합친다.

## 수행목표

- 닥터 G의 두 번째 정렬 아이디어를 정렬 함수로 구현한다.
- 다음 두 개의 파일에는 숫자와 유전자 시퀀스로 구성된 8개씩의 목록을 포함하고 있으며, 각각의 목록은 testcase 번호, 목록에 포함된 항목의 수, 그리고 각 줄마다 하나씩의 항목에 해당하는 리스트의 내용으로 구성된다. 예를 들어서 5개의 시퀀스를 가진 목록은 파일에 다음과 같이 기록되어 있다.

```
testcase 1
5
CTCAT
TACAG
GACT
TAGGC
ATCTA
```

- 두 개의 파일에 포함된 16개의 목록을 정렬한 후, 그 결과를 수행단계에서 지시한 방식으로 가공해서 출력한다.

## 수행단계

- algorithm/second_sort.py 파일에 닥터 G의 정렬 아이디어대로 주어진 리스트를 정렬하는 함수를 구현한다.
  - 이 함수는 정렬할 대상을 포함하는 리스트만 파라미터로 받는다.
  - 리스트의 항목이 문자열이건 숫자이건 상관없이 동작해야 한다. 문자열의 경우는 사전순으로, 숫자의 경우는 오름차순으로 정렬한 결과를 반환한다.
  - 정렬 후에도 파라미터로 전달한 원래의 리스트의 항목의 순서는 그대로 유지되어야 한다.
- 파일에 포함된 20개의 목록을 정렬한 후, 정렬 결과를 다음과 같이 가공해 출력한다.

  - 숫자의 경우 마지막 자리 수를 이어 붙인 문자열을 생성한다.
  - 문자열의 경우 마지막 글자를 이어 붙인 문자열을 생성한다.
  - 생성한 문자열을 다음 함수를 사용해 '간이 해시값'을 생성한 후 이를 출력한다.

  ```python
  import hashlib

  def hash4(input):
    return hashlib.md5(input.encode()).hexdigigest()[:4]
  ```

## 결과예시

```
숫자 리스트
testcase 1
    계산한 간이 해시 값 : 827c
(이하 생략)

유전자 시퀀스 리스트
testcase 1
    계산한 간이 해시 값 : d793
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/second_sort.py 파일에 구현이 되어 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    숫자 리스트
    testcase 1
        계산한 간이 해시 값 : 827c
    testcase 2
        계산한 간이 해시 값 : c4ca
    testcase 3
        계산한 간이 해시 값 : b0ba
    testcase 4
        계산한 간이 해시 값 : 827c
    testcase 5
        계산한 간이 해시 값 : 827c
    testcase 6
        계산한 간이 해시 값 : 98be
    testcase 7
        계산한 간이 해시 값 : 3b10
    testcase 8
        계산한 간이 해시 값 : cf21

    유전자 시퀀스 리스트
    testcase 1
        계산한 간이 해시 값 : d793
    testcase 2
        계산한 간이 해시 값 : 0d61
    testcase 3
        계산한 간이 해시 값 : e86a
    testcase 4
        계산한 간이 해시 값 : d793
    testcase 5
        계산한 간이 해시 값 : d793
    testcase 6
        계산한 간이 해시 값 : 4c9a
    testcase 7
        계산한 간이 해시 값 : ed28
    testcase 8
        계산한 간이 해시 값 : 14e9
    ```

### [문제에 대한 이해]

- 두 개의 정렬된 리스트를 병합하는 과정을 설명하라.
  - 두 리스트를 통틀어 가장 작은 항목을 병합된 리스트에 추가하되, 이를 위해서 하나의 리스트를 두 번 이상 반복해서 읽지 않는 방법을 제시하는지 확인한다.

### [코드 예시]

```python
def msort(arr):
    if len(arr) < 2:
        return arr

    mid = len(arr) // 2
    left = msort(arr[:mid])
    right = msort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    merged = []
    left_index = 0
    right_index = 0
    while left_index < len(left) or right_index < len(right):
        if left_index >= len(left):
            merged.append(right[right_index])
            right_index += 1
        elif right_index >= len(right):
            merged.append(left[left_index])
            left_index += 1
        elif left[left_index] <= right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            right_index += 1
    return merged

import hashlib
def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]


def main():
    print("숫자 리스트")
    with open('testcase1.txt', 'r') as f:
        number_list = []
        i = 0
        line = f.readline()
        while True:
            if not line or line[0:8] == 'testcase':
                if i == 0:
                    i += 1
                    line = f.readline()
                else:
                    print(f"testcase {i}")
                    sorted_list = msort(number_list)
                    result = ''
                    for n in sorted_list:
                        result += str(n % 10)
                    print(f"    계산한 간이 해시 값 : {hash4(result)}")
                    number_list = []
                    i += 1
                    line = f.readline()
                if not line:
                    break

            else:
                number_list.append(int(line.strip()))
            line = f.readline()

    print("\n유전자 시퀀스 리스트")
    with open('testcase2.txt', 'r') as f:
        sequence_list = []
        i = 0
        line = f.readline()
        while True:
            if not line or line[0:8] == 'testcase':
                if i == 0:
                    i += 1
                    line = f.readline()
                else:
                    print(f"testcase {i}")
                    sorted_list = msort(sequence_list)
                    result = ''
                    for sequence in sorted_list:
                        result += sequence[0]
                    print(f"    계산한 간이 해시 값 : {hash4(result)}")
                    sequence_list = []
                    i += 1
                    line = f.readline()
                if not line:
                    break

            else:
                sequence_list.append(line.strip())
            line = f.readline()

if __name__ == '__main__':
    main()
```

---

# 문제 10. 두 정렬 알고리즘의 평가

## 문제 분류

- 중요도 : 4/5
- 난이도 : 4/5
- 목표 수행 시간 : 4시간

## 스토리

닥터 J가 조금 더 조사해보니 첫 번째 정렬은 ‘퀵 정렬’, 두 번째 정렬은 ‘병합 정렬’이라는 이름의 유명한 정렬 알고리즘이라는 사실을 알게 되었다. 어느 쪽을 써도 좋은 상황이라면, 둘 중 하나를 선택하기 위해서 두 개의 알고리즘이 매우 큰 리스트를 정렬하는데 쓸만한지를 테스트 해 보고, 둘 중 더 좋은게 어떤 것인지도 확인해보고자 했다.

## 수행목표

- 구현한 두 정렬 알고리즘의 시간 복잡도를 확인한다.
- 두 정렬 알고리즘의 성능을 시간 기준으로 측정해 비교해본다.
  - 길이 100, 1000, 10000, 100000, 1000000인 무작위 리스트를 만들고, 두 정렬 알고리즘의 실행 시간을 출력한다.
- 시간 복잡도와 알고리즘의 실행 시간을 기준으로 두 정렬 알고리즘을 평가한다.

## 수행단계

- 퀵 정렬의 시간 복잡도를 계산해보자.
  - 퀵 정렬의 시간 복잡도를 최악의 경우를 기준으로 계산한다.
- 병합 정렬의 시간 복잡도를 계산해보자.
  - 병합 정렬의 시간 복잡도를 최악의 경우를 기준으로 계산한다.
- algorithm/sort_compare.py 파일에 다음 기능을 수행하는 프로그램을 작성한다.
  - 1에서 10000 사이의 무작위 정수로 구성된 리스트를 5개 만든다. 리스트의 크기는 각각 100, 1000, 10000, 100000, 1000000으로 한다.
  - 이 리스트를 두 정렬 알고리즘을 사용해 정렬하는데 소요된 시간을 측정해 출력한다.
- 계산한 시간 복잡도와 측정된 실행 시간을 교차 검토하고, 그 결과를 확인한다.
  - 만약 교차 검토한 결과가 기대한 바와 다르다면, 그 이유가 무엇인지 조사한다.

## 결과예시

```
길이가 100인 리스트 정렬에 걸린 시간
  퀵 정렬: XXX초
  병합 정렬: XXX초

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - algorithm/sort_compare.py 파일에 구현이 되어 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    길이가 100인 리스트 정렬에 걸린 시간
        퀵 정렬: 0.00012421607971191406초
        병합 정렬: 0.0001690387725830078초

    길이가 1000인 리스트 정렬에 걸린 시간
        퀵 정렬: 0.0010440349578857422초
        병합 정렬: 0.002103090286254883초

    길이가 10000인 리스트 정렬에 걸린 시간
        퀵 정렬: 0.01375579833984375초
        병합 정렬: 0.025216102600097656초

    길이가 100000인 리스트 정렬에 걸린 시간
        퀵 정렬: 0.13886785507202148초
        병합 정렬: 0.3139970302581787초

    길이가 1000000인 리스트 정렬에 걸린 시간
        퀵 정렬: 1.691460132598877초
        병합 정렬: 4.043997049331665초
    ```

### [문제에 대한 이해]

- 퀵 정렬의 시간 복잡도를 제시하라. 시간 복잡도가 왜 이렇게 제시되었는지도 설명할 수 있어야 한다.
  - 퀵 정렬의 시간 복잡도는 최악의 경우를 기준으로 $\mathcal O(n^2)$임을 제시할 수 있어야 한다.
  - 최악의 경우는 선택한 피벗 숫자가 최대, 혹은 최소값으로 계속 선택되어 리스트를 둘로 나누는 과정에서 극단적인 불균형이 누적되는 경우이다.
- 병합 정렬의 시간 복잡도를 제시하라. 시간 복잡도가 왜 이렇게 제시되었는지도 설명할 수 있어야 한다.
  - 병합 정렬의 시간 복잡도는 항상 $\mathcal O(n \log n)$임을 제시할 수 있어야 한다.
  - 매 단계마다 리스트의 크기는 반으로 줄어들고 ($\mathcal O(\log n)$), 매 단계에서 원래 크기 만큼의 리스트를 병합하기 때문이라는 설명이 제시되었는지 확인한다.
- 시간 복잡도를 기준으로 어떤 정렬 알고리즘이 더 효율적일 것으로 기대되는가?
  - 시간 복잡도 기준으로는 병합 정렬이 더 효율적일 것으로 기대된다.
- 실제 실행 시간을 측정한 결과는 시간 복잡도 기준의 분석 결과와 일치하는가?
  - 그렇지 않다.
- 실제 실행 시간이 왜 그렇게 나오는지 조사한 결과를 제시하라.
  - 일반적인 상황은 최악의 상황이 아니라는 점을 제시하면 정답으로 간주한다.
  - 이외에 하드웨어 최적화, 프로그래밍 언어의 최적화 등을 제시해도 정답으로 간주할 수 있다.
  - 퀵 정렬은 최악의 경우 다항식 시간 복잡도의 알고리즘이지만 평균적으로는 지수 시간 복잡도로 병합 정렬과 비슷하다.
  - 퀵 정렬은 별도의 저장 공간이 필요 없으며, 퀵 정렬의 특성 상 주어진 배열 또는 리스트의 연속적인 부분을 정렬하므로, CPU 등에서 제공하는 캐시가 더욱 효율적으로 활용될 수 있다는 추가적인 장점(Reference Locality)이 있기 때문에, 실질적으로는 주로 퀵 정렬이 사용된다.

### [코드 예시]

```python
def qsort(arr):
    if len(arr) < 2:
        return arr

    pivot = arr[0]
    left = []
    right = []
    pivot_count = 1

    for i in range(1, len(arr)):
        if arr[i] < pivot:
            left.append(arr[i])
        elif arr[i] > pivot:
            right.append(arr[i])
        else:
            pivot_count += 1
    return qsort(left) + [pivot] * pivot_count + qsort(right)

def msort(arr):
    if len(arr) < 2:
        return arr

    mid = len(arr) // 2
    left = msort(arr[:mid])
    right = msort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    merged = []
    left_index = 0
    right_index = 0
    while left_index < len(left) or right_index < len(right):
        if left_index >= len(left):
            merged.append(right[right_index])
            right_index += 1
        elif right_index >= len(right):
            merged.append(left[left_index])
            left_index += 1
        elif left[left_index] <= right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            right_index += 1
    return merged

import random, time

def main():
    for i in range(5):
        list = []
        for _ in range(10 ** (i + 2)):
            list.append(random.randint(1, 10000))

        qsort_start = time.time()
        qsort(list)
        qsort_end = time.time()
        m_sort_start = time.time()
        msort(list)
        m_sort_end = time.time()
        print(f"길이가 {10 ** (i + 2)}인 리스트 정렬에 걸린 시간")
        print(f"    퀵 정렬: {qsort_end - qsort_start}초")
        print(f"    병합 정렬: {m_sort_end - m_sort_start}초")
        print()

if __name__ == "__main__":
    main()
```
