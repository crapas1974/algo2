# 단계 7. 자료구조를 활용한 알고리즘

## 스토리

유전자 정보를 연구하는 G 연구원과 T 연구원은 학창 시절부터의 절친이었다. 어쩌다보니 같은 직장에서 근무하게 된 두 사람은 종종 식사나 술자리를 함께 하면서 여전히 좋은 관계를 유지하고 있었다. 어느 가을 저녁, 두 사람은 연구소 근처 맛집에서 저녁을 먹고 있었다. T 연구원은 연구소 밖에서 업무 이야기하는 것을 좋아하지는 않았지만, 요즘 잘 안풀리는 문제가 있다며 G 연구원에게 의견을 물어봤다.

“우리 연구 그룹에서 개발한 스마트 마우스 기억나지?”

“응. 기억 능력에 연산 능력이 있을지도 모른다고 발표했던 그 쥐 말하는거지?”

“응. 그런데 문제가 있어.”

“뭔데?”

“쥐의 지능을 검증하려고 하는데, 우리가 멍청한게 문제지.”

이렇게 시작한 사연은 다음과 같았다.

스마트 동물 연구 그룹에서 개발한 “영리한 쥐”가 연산 능력과 학습 능력이 있는지를 확인하기 위해 다음과 같은 실험을 설계했다.

방이 N개가 있는 미로를 설치한다. 각 방은 1번 방에서 N번 방까지 이름이 붙어 있고, 시작 지점은 방은 아니지만 편의상 0번 방이라고 부르고 있다. 0번 방은 N개의 통로가 있고, 1번 방에서 N번 방까지 연결되어 있다. 1번 방은 N-1개의 통로가 있고 2번 방에서 N번 방까지 연결되어 있다. 이런 식으로 K번 방은 K+1번 방부터 N번 방까지 연결된 통로를 가지고 있다. 각 통로는 길이가 정해져 있으며, 쥐들의 속도는 모두 일정하다. 그리고 N번 방에 도착하면 보상을 주는데, 빨리 도착할 수록 보상이 좋아진다.

“그래서 보상이 뭐야?”

“응. 8년 숙성된 냄새가 엄청난 치즈. 쥐가 그 냄새를 맡으면 미칠 듯이 좋아하더라구. 문제는, 이 치즈가 싸구려라서 시간이 지나면 지날 수록 냄새가 점점 사라진다는건데…”

“그래서?”

“이 치즈 냄새가 통로에 퍼지니까, 기를 쓰고 쥐들이 달리더라구.”

“그리고?”

“영리한 쥐가 매번 1등을 했지.”

“그러면 입증된거 아니야?”

“그런데, 영리한 쥐가 점점 학습을 해서 더 영리해지고 있는지를 확인해야 하니까. 그런데 문제는 영리한 쥐가 최선의 선택을 했는지 확인해보고 싶은데… 그게 계산이 잘 안되더라구.”

“음. 혹시, 실험할 때 방은 몇 개 설치한거야?”

“적당히 설치했어. 한 1000개 정도?”

G 연구원은 순간 할 말을 잃었다. 방이 1000개인 미로라면 방과 방 사이의 통로의 개수만 499500개이다. 적당히라는게 뭔지 모르는 녀석. 아니, 우리 연구소 실험 예산 괜찮은거야?

---

# 문제 1. 이진 검색 트리

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

유전자 목록을 만들고 정렬하는 일을 하고 있는 G 연구원은 문득 이런 생각이 들었다.

'굳이 별도로 정렬을 하지 않고도 자동으로 유전자를 등록하면 정렬이 된 목록이 만들어진다면 더 빠르게 정렬된 목록울 가지게 되지 않을까?'

이 생각을 프로그래밍 지원 게시판에 게시하자, 그 글에 이진 검색 트리를 사용하면 된다는 답변이 달렸다.

## 수행목표

- 다음과 같은 성격을 가진 이진 트리와 관련 함수를 구현한다.
  - 트리에 크기를 비교할 수 있는 기준을 가진 값을 추가하면, 이 값에 해당하는 노드가 만들어지고 트리에 추가된다.
  - 트리에 노드가 추가되는 위치는 미리 정해진 위치에 고정되어 추가된다. 트리에 노드를 추가하는데 필요한 시간 복잡도는 O(log n)이다.
  - 전체 트리에 포함된 데이터의 정렬된 목록을 만드는데 필요한 시간 복잡도는 O(n)이다.
  - 이러한 트리의 성격을 유지하면서 트리에 값을 추가하는 함수를 구현한다.
  - 이러한 트리의 성격을 유지하면서 트리의 특정 값을 가진 노드를 삭제하는 함수를 구현한다.
  - 이러한 성격을 가진 트리로부터 오름차순으로 정렬된 목록을 반환하는 함수를 구현한다.
- 다음 첨부한 테스트케이스는 5개의 유전자 시퀀스 데이터와 5개의 숫자 데이터의 목록으로 구성되어 있다. 이 10개의 목록으로 10개의 이진 트리를 생성한다. 이 때 트리에 데이터는 목록의 순서대로 입력한다. 트리를 생성하고 난 후 다음을 출력한다.
  - 루트 트리의 왼쪽 서브 트리의 노드의 수와 오른쪽 서브 트리의 노드의 수
  - 오름차순으로 정렬된 목록

## 수행 단계

## 결과 예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/bus_fare_dynamic.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```

    ```

```

```

### [문제에 대한 이해]

### [코드 예시]

```python

```

---

# 문제 2. 높이가 유지되는 트리

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

K 연구원 이진 검색 트리를 사용해서 빠르게 정렬된 목록을 생성할 수 있게 되었다. 이것 만으로 충분히 만족할 수 있었지만, 다른 기능의 성능도 조금 더 높이고 싶은 욕심이 생겼다. 특정 값이 이 트리에 포함되어 있는지를 확인하는 기능인데, 이 기능은 트리의 왼쪽 오른쪽의 균형이 유지될 때 가장 빠르게 동작한다는 사실을 알게 되었다.

K 연구원은 이진 검색 트리에 데이터를 추가할 때, 이와 같이 균형잡힌 트리를 유지하는 방법이 궁금해졌다.

## 수행목표

- 다음과 같은 성격을 가진 이진 검색 트리를 만드는 노드 추가 함수를 구현한다.
  - 트리에 새로운 항목을 추가할 때 이진 검색 트리의 기본 성격을 유지한다.
  - 어떤 순간에서도 트리에 포함된 모든 노드는 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 1 또는 0으로 유지된다.
  - 노드를 추가하는 함수의 시간 복잡도는 O(log n)이다.
- 이러한 성격을 유지하면서 특정 값을 가진 노드를 삭제하는 함수를 구현한다.
  - 트리에 지정한 값을 가진 항목 중 하나를 삭제하는 경우, 그 이후에도 이진 검색 트리의 기본 성격을 유지한다.
  - 어떤 순간에서도 트리에 포함된 모든 노드는 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 1 또는 0으로 유지된다.
  - 노드를 삭제하는 함수의 시간 복잡도는 O(log n)이다.
- 다음 첨부한 테스트케이스는 5개의 유전자 시퀀스 데이터와 5개의 숫자 데이터의 목록으로 구성되어 있다.
  - 각각의 테스트케이스는 두 부분으로 나뉘어져 있다. 첫 번째 부분은 트리를 생성하는 과정이며, 목록의 각 항목은 값과 함께 +, -의 지시자가 함께 제공되는데 +의 경우는 노드에 해당 값을 가지는 항목을 추가하라는 지시자이며, -는 해당 값을 가지는 항목을 삭제하라는 지시자이다. 만약 해당 값을 가지는 항목이 없는 경우, 삭제하지 않는다.
  - 두 번째 부분 역시 +, - 지시자에 따라 트리에 항목을 추가하거나 삭제하는데, 두 번째 부분의 값을 가지는 노드의 값을 추가하거나 삭제하는 경우, 트리의 중위 순회 탐색의 순서를 기준으로 왼쪽 서브 트리의 높이와 오른쪽 서브 트리의 높이를 괄호로 묶어서 출력한다.

## 수행단계

## 결과예시

```

```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/max_sales.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방식으로 구현하였는지 확인한다. 만약 하향식 다이나믹 프로그래밍 방법으로 구현한 경우 메모이제이션이 적용되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다.

    ```
    TC 1:
    최대 매출 : 10억원
    판매 방법 :
        2단위 주문 : 2회

    TC 2:
    최대 매출 : 22억원
    판매 방법 :
        6단위 주문 : 1회
        2단위 주문 : 1회

    TC 3:
    최대 매출 : 10억원
    판매 방법 :
        1단위 주문 : 10회

    TC 4:
    최대 매출 : 10억원
    판매 방법 :
        10단위 주문 : 1회

    TC 5:
    최대 매출 : 267억원
    판매 방법 :
        35단위 주문 : 1회
        34단위 주문 : 1회
        29단위 주문 : 1회
        2단위 주문 : 1회
    ```

### [보너스 과제의 확인]

- 보너스 과제를 지시대로 해결하였는가?
  - 문제의 구조를 사용하는 재귀 호출 방식으로 구현하고 있는지 확인한다.
- 결과가 정확한가?

  - 결과 예시는 다음과 같다.

    ```
    TC 1:
        최대 매출 : 10억원
        판매 방법 :
            2단위 주문 : 2회
        잔여 처리 용량 : 0단위

    TC 2:
        최대 매출 : 16억원
        판매 방법 :
            3단위 주문 : 2회
        잔여 처리 용량 : 2단위

    TC 3:
        최대 매출 : 5억원
        판매 방법 :
            2단위 주문 : 5회
        잔여 처리 용량 : 0단위

    TC 4:
        최대 매출 : 10억원
        판매 방법 :
            8단위 주문 : 1회
            2단위 주문 : 1회
        잔여 처리 용량 : 0단위

    TC 5:
        최대 매출 : 266억원
        판매 방법 :
            29단위 주문 : 3회
            13단위 주문 : 1회
        잔여 처리 용량 : 0단위
    ```

### [문제에 대한 이해]

- n = 4, prices = [1, 5, 8, 9]일 때 최대 매출은 얼마이며, 이 때의 판매 방법은 어떻게 될까?
  - 최고의 매출을 기록하기 위해서는 2단위씩 2번 주문을 받으면 된다. 이 때의 매출은 10억원이다.
- i단위의 요청을 처리했을 때 기대 가능한 최대 매출은 얼마인가? 처리 가능한 용량이 n일 때의 기대 가능한 최대 매출을 max_sales(n)이라 표현하고, i 단위의 가격을 price(i)라고 할 때, 최대 매출을 max_sales와 price를 사용해서 표현하라.
  - i단위의 요청을 처리했을 때의 기대 가능한 최대 매출 : price[i] + max_sales(n - i)
- 문제의 구조를 제시하라.
- 구현한 방식의 시간 복잡도는 얼마인가?

### [코드 예시]

```python

```

---

# 문제 3. 트리의 지름

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

한 세대가 끝나면 여러 개체로 분화해서 새로운 세대를 시작하는 미생물이 있다. E 연구원이 속한 연구 그룹은 이 미생물의 돌연변이를 연구하는 과정에서, ‘특정 돌연변이 개체’가 발생했다가 소멸하는 현상을 발견했다. 이 돌연변이 개체는 공해 물질을 분해하는 능력을 가지게 되어 매우 유용한 발견이지만, 문제는 이 돌연변이 개체는 발생했다가 몇 세대를 지나면 사라진다는 점이었다. 이 돌연변이의 여파로 세대가 종료될 때의 분화하는 개체 수는 최대 2로 제한되었고, 그나마 분화를 하지 못하고 생을 마감하는 개체도 많았기 때문이다.

이 돌연변이 개체를 최대한 길게 유지하기 위한 유도 약물의 개발을 연구하는 과정에서 약물의 효능을 검증하기 위해서 돌연변이가 발생한 개체를 루트로 하고, 돌연변이가 유지된 자손들로 구성된 가계도 트리를 만들었다. 트리의 부모와 자식 사이의 거리를 1이라고 할 때, 이 트리에 포함된 두 노드의 거리가 길면 길수록 약물의 효능이 좋다고 평가할 수 있다.

## 수행목표

- 트리에서 두 노드의 거리는 두 노드 사이에 연결의 갯수로 정의한다. 이 정의를 따르면 부모 노드와 자식 노드의 사이의 거리는 1이된다. 그리고 어떤 트리에서 거리가 가장 먼 두 노드 사이의 연결을 트리의 지름이라고 하며, 이 두 노드 사이의 거리를 트리의 지름의 길이라 한다.
- 어떤 이진 트리의 루트 노드가 주어졌을 때, 이 트리의 지름의 길이를 반환하는 함수를 구현한다.
- 첨부한 파이썬 코드를 사용해 트리 7개의 루트 노드를 얻을 수 있다. 이 4개의 트리에 대애서 각각의 트리의 지름을 출력한다.

## 수행단계

- 다음 예제와 예제에 대한 질문을 통해서 문제 해결의 실마리를 찾는다.
  - 다음 그림의 트리에서 루트 노드의 왼쪽 서브 트리의 높이는 2, 오른쪽 서브 트리의 높이는 2, 그리고 트리 지름의 길이는 6이다.
    ![Alt text](ch7_1.png)
  - 다음 그림의 트리에서 루트 노드의 왼쪽 서브 트리의 높이는 3, 오른쪽 서브 트리의 높이는 0이다.
    ![Alt text](ch7_2.png)
    - 이 트리에서 루트 노드를 지나야 연결이 가능한 두 노드 사이에 가장 거리가 먼 두 노드와, 두 노드 사이의 거리는 얼마인가?
    - 이 트리에서 가장 먼 거리가 먼 두 노드와, 두 노드 사이의 거리 (즉 트리의 지름의 길이)는 얼마인가?
- 이 문제는 다이나믹 프로그래밍 예제에서 그러했듯 하향식, 상향식 두 가지 접근 방법 각각을 사용해 해결할 수 있다. 두 가지 방법 중 하나를 택해서 구현 방법을 정리한다.
- 주어진 노드를 루트로 하는 트리의 지름을 구하는 함수를 ds_more/tree_diameter1.py 파일에 구현한다.
- 첨부한 파이썬 코드의 get_testcases 함수는 어떤 트리의 루트를 항목으로 하는 리스트를 반환한다. 여기에는 7개 트리의 루트가 포함되어 있다.
  - 이 7개의 트리의 지름의 값을 출력한다.
  - 첨부한 파이썬 코드에는 이진 트리를 만드는 파이썬 클래스가 포함되어 있다. 이 클래스의 구조를 확인한 후 구현해야 한다.

## 결과예시

```
Testcase 1 트리의 지름 : 6
Testcase 2 트리의 지름 : 6
(이하 생략)
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - ds_more/tree_diameter1.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 실행 시간은 다를 수 있다.

    ```
    Testcase 1 트리의 지름 : 6
    Testcase 2 트리의 지름 : 6
    Testcase 3 트리의 지름 : 6
    Testcase 4 트리의 지름 : 7
    Testcase 5 트리의 지름 : 1
    Testcase 6 트리의 지름 : 43
    Testcase 7 트리의 지름 : 55
    ```

### [문제에 대한 이해]

- (상향식 접근 방법으로 구현한 경우)가장 작은 문제는 무엇인가?
  - 문제를 특정 노드를 지나가는 트리의 지름으로 정의하면, 리프 노드에 가까울 수록 서브 트리를 감안한 트리의 지름을 계산해야 하므로, 가장 작은 문제는 루트에서 가장 먼 노드를 지나가는 트리의 지름을 구하는 문제가 된다.
- (상향식 접근 방법으로 구현한 경우)상향식 접근 방법으로 트리의 지름을 계산하는 방법을 설명하라.
  - 1단계에서는 트리의 레벨 별로 각 노드를 분류한다.
  - 레벨 별 노드를 저장하는 딕셔너리를 만들고, BFS 방식으로 트리를 탐색해 트리의 모든 노드를 레벨 별 딕셔너리에 저장한다.
  - 2단계에서는 레벨이 높은, 즉 루트 노드에서 먼 노드들부터 상향식으로 모든 노드를 지나가는 트리의 지름을 구해서 올라간다.
  - 이를 위해서 작은 문제의 결과를 저장할 딕셔너리 diameter와 height를 선언한다.
  - 상위 문제의 높이는 하위 문제들 (즉 왼쪽 서브트리의 높이, 오른쪽 서브 트리의 높이) 의 최대값 + 1이 된다.
  - 상위 문제의 지름은 하위 문제들의 최대값이다. 이 때 하위 문제들은 트리의 지름에 해당하는 경로가 현재 노드를 지나가는 경우(왼쪽 서브 트리의 높이 + 오른쪽 서브 트리의 높이 + 2), 현재 노드를 지나가지 않고 왼쪽 서브 트리에 트리의 지름이 속한 경우 (왼쪽 서브 트리의 지름), 오른쪽 서브 트리에 트리의 지름이 속한 경우 (오른쪽 서브 트리의 지름)으로 구성된다.
  - 최종적으로 루트 노드를 기준으로 트리의 지름을 반환한다.
- (하향식 접근 방법으로 구현한 경우)문제의 구조를 설명하는 점화식을 제시하라.
  - 트리의 높이는 리프 노드 중 루트와 가장 먼 리프 노드와의 거리이다.
  - 이 리프 노드는 루트 노드의 두 자식 노드 중 하나의 자손 노드이다.
  - 부모와 자식 노드 사이의 거리는 1이다.
  - 이상의 상황을 종합해 node를 루트로 하는 서브 트리의 높이를 `height(node)`라고 하면 점화식은 다음과 같이 작성할 수 있다.
  - `height(node) = max(height(node.left), height(node.right)) + 1`
- 구현한 함수의 시간 복잡도를 제시하라.
  - 상향식, 하향식 모두 최적 구현은 O(n) 시간 복잡도를 가진다.

### [코드 예시]

```python
from tree_diameter_data import get_testcases
from collections import deque

# 트리의 높이 계산
def height(node, memo):
    # 메모이제이션
    if node in memo:
        return memo[node]
    if node == None:
        return -1

    # 왼쪽 자식 노드의 높이와 오른쪽 자식 노드의 높이를 사용해 현재 노드의 높이를 계산 (재귀 호출)
    memo[node] = 1 + max(height(node.left, memo), height(node.right, memo))
    return memo[node]

# 트리의 지름 계산 하향식 접근 방법
def tree_diameter2(node, memo = None):
    # 메모이제이션에 사용할 딕셔너리 초기화
    if memo == None:
        memo = {}
    if node == None:
        return 0
    # 왼쪽 트리의 지름
    left_diameter = tree_diameter2(node.left, memo)
    # 오른쪽 트리의 지름
    right_diameter = tree_diameter2(node.right, memo)
    # 현재 트리의 지름은
    #   1. 현재 노드를 지나는 경로의 최고 거리
    #   2. 왼쪽 서브 트리의 지름
    #   3. 오른쪽 서브 트리의 지름
    # 중 최대값이다.
    return max(height(node.left, memo) + height(node.right, memo) + 2,
                left_diameter,
                right_diameter)

# 트리의 지름 계산 상향식 접근 방법
def tree_diameter1(root, memo = None):
    if not root:
        return {}

    # 1단계 - 레벨별 노드를 저장하는 딕셔너리를 생성한다.
    # 레벨별 노드를 저장할 딕셔너리
    level_dict = {}
    # 루트 노드를 레벨과 함께 큐에 저장한다.
    queue = deque([(root, 0)])
    # 트리의 최대 레벨
    max_level = 0

    while queue:    # 큐가 빌 때까지 반복
        node, level = queue.popleft()   # 큐의 첫번째 항목의 노드와 레벨

        # 현재 레벨의 노드를 딕셔너리에 추가
        if level not in level_dict:
            level_dict[level] = []
            max_level = level
        level_dict[level].append(node)

        # 자식 노드를 큐에 추가
        if node.left:
            queue.append((node.left, level + 1))
        if node.right:
            queue.append((node.right, level + 1))

    # 2단계 - 상향식으로 모든 노드의 트리의 지름을 구한다.
    diameter = {}
    height = {}
    # 최대 레벨, 즉 가장 아래쪽부터 역순으로 루트까지 반복
    for i in range(max_level, -1, -1):
        # 각 레벨의 모든 노드에 대해서
        for node in level_dict[i]:
            if node.left == None:       # 왼쪽 자식 노드가 없으면
                left_height = -1
                left_diameter = -1
            else:                       # 왼쪽 자식 노드가 있으면
                left_height = height[node.left]
                left_diameter = diameter[node.left]
            if node.right == None:      # 오른쪽 자식 노드가 없으면
                right_height = -1
                right_diameter = -1
            else:                       # 오른쪽 자식 노드가 있으면
                right_height = height[node.right]
                right_diameter = diameter[node.right]

            # 높이와 지름을 계산
            height[node] = 1 + max(left_height, right_height)
            diameter[node] = max(left_height + right_height + 2,
                                    left_diameter,
                                    right_diameter)
    return diameter[root]

def main():
    testcases = get_testcases()
    for i, tc in enumerate(testcases):
        print(f"Testcase {i + 1} 트리의 지름 : {tree_diameter1(tc)}")

if __name__ == "__main__":
    main()
```

---

# 문제 4. 가장 사이가 먼 이들

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

개체의 세대가 바뀜에 따라서 유전자의 돌연변이는 조금씩 생기기 마련이다. 즉, 현재의 트리에서 관계가 가장 먼 두 개체를 비교하면, 조금 더 길게 번식하는 미생물을 만드는 단서를 찾을 수 있을지도 모른다.

E 연구원은 트리의 지름 뿐 아니라, 지름에 해당하는 가장 먼 두 개체를 찾는 작업에 들어갔다.

## 수행목표

- 트리의 지름을 찾는 알고리즘을 사용해 트리에서 가장 먼 두 노드의 쌍을 찾는 함수를 구현한다.
- 이 함수를 사용해 트리에서 가장 먼 두 노드의 쌍을 찾아 이를 출력한다.
  - 트리에서 가장 먼 두 노드의 쌍은 여러개가 존재할 수 있다. 모든 쌍을 찾아 출력한다.
- 테스트데이터는 이전 문제와 동일한 첨부 파일을 사용해 7개의 테스트케이스를 사용할 수 있다.
  - 출력하는 값은 노드의 값을 사용해 출력한다. 테스트케이스 1의 트리는 120의 값을 가진 노드와 160의 값을 가진 노드, 그리고 140의 값을 가진 노드와 160의 값을 가진 노드 간 거리가 6으로 가장 길다. 이 경우 [(120, 160), (140, 160)]을 출력한다.

## 수행단계

- 이전 문제에서 구현한 트리 지름을 계산하는 알고리즘을 토대로 가장 먼 두 노드의 쌍을 찾는 방법을 정리한다.
- 트리의 루트노드가 주어졌을 때, 이 트리에서 지름에 해당되는 거리에 있는 두 노드의 쌍으로 구성된 리스트를 반환하는 함수를 ds_more/tree_diameter2.py 파일에 구현한다.
- 테스트케이스는 이전 문제와 마찬가지로 첨부 파일의 get_testcases 함수를 호출하면 7개의 테스트용 트리의 루트 노드를 얻을 수 있다. 이 7개의 트리에서 가장 먼 노드 쌍을 모두 찾아 출력한다.

## 결과 예시

```
Testcase 1
    트리의 지름 : 6
    가장 먼 노드 쌍 : [(120, 160), (140, 160)]

Testcase 2
    트리의 지름 : 6
    가장 먼 노드 쌍 : [(120, 160), (140, 160)]
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - ds_more/tree_diameter2.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    Testcase 1
        트리의 지름 : 6
        가장 먼 노드 쌍 : [(120, 160), (140, 160)]

    Testcase 2
        트리의 지름 : 6
        가장 먼 노드 쌍 : [(120, 160), (140, 160)]

    Testcase 3
        트리의 지름 : 6
        가장 먼 노드 쌍 : [(120, 200), (140, 200), (160, 200), (120, 160), (140, 160)]

    Testcase 4
        트리의 지름 : 7
        가장 먼 노드 쌍 : [(120, 210), (140, 210), (160, 210)]

    Testcase 5
        트리의 지름 : 1
        가장 먼 노드 쌍 : [(100, 200)]

    Testcase 6
        트리의 지름 : 43
        가장 먼 노드 쌍 : [(-93, -10), (-93, -7), (-84, -10), (-84, -7)]

    Testcase 7
        트리의 지름 : 55
        가장 먼 노드 쌍 : [(-40, 56)]

    ```

### [문제에 대한 이해]

- 어떤 노드가 주어졌을 때 트리의 지름이 그 노드를 지나는 경우, 이 노드의 서브트리에서 가장 먼 두 노드는 어떻게 찾을 수 있을까?
  - 왼쪽 서브트리에서 이 노드로 부터 가장 먼 노드, 즉 왼쪽 서브트리에서 가장 레벨이 큰 노드와 오른쪽 서브트리에서 이 노드로부터 가장 먼 노드, 즉 오른쪽 서브트리에서 가장 레벨이 큰 노드가 가장 먼 노드이다.
- 어떤 노드가 주어졌을 때 트리의 지름이 그 노드를 지나지 않는 경우, 이 노드의 서브트리에서 가장 먼 두 노드는 어떻게 찾을 수 있을까?
  - 왼쪽 서브트리에서 가장 먼 두 노드와 오른쪽 서브트리에서 가장 먼 두 노드 중 더 먼 노드이다.

### [코드 예시]

```python
from tree_diameter_data import get_testcases
from collections import deque

def furthest_nodes(root, memo = None):
    if not root:
        return {}

    # 1단계 - 레벨별 노드를 저장하는 딕셔너리를 생성한다.
    # 레벨별 노드를 저장할 딕셔너리
    level_dict = {}
    # 루트 노드를 레벨과 함께 큐에 저장한다.
    queue = deque([(root, 0)])
    # 트리의 최대 레벨
    max_level = 0

    while queue:    # 큐가 빌 때까지 반복
        node, level = queue.popleft()   # 큐의 첫번째 항목의 노드와 레벨

        # 현재 레벨의 노드를 딕셔너리에 추가
        if level not in level_dict:
            level_dict[level] = []
            max_level = level
        level_dict[level].append(node)


        # 자식 노드를 큐에 추가
        if node.left:
            queue.append((node.left, level + 1))
        if node.right:
            queue.append((node.right, level + 1))


    # 2단계 - 상향식으로 모든 노드의 트리의 지름을 구한다.
    diameter = {}
    height = {}
    farthest_child_data = {}
    # 최대 레벨, 즉 가장 아래쪽부터 역순으로 루트까지 반복
    for i in range(max_level, -1, -1):
        # 각 레벨의 모든 노드에 대해서
        for node in level_dict[i]:
            if node.left == None:       # 왼쪽 자식 노드가 없으면
                left_height = -1
                left_diameter, left_diameter_pair = -1, []
                left_farthest_child_data = [root.data]
            else:                       # 왼쪽 자식 노드가 있으면
                left_height = height[node.left]
                left_diameter, left_diameter_pair = diameter[node.left]
                left_farthest_child_data = farthest_child_data[node.left]
            if node.right == None:      # 오른쪽 자식 노드가 없으면
                right_height = -1
                right_diameter, right_diameter_pair = -1, []
                right_farthest_child_data = [root.data]
            else:                       # 오른쪽 자식 노드가 있으면
                right_height = height[node.right]
                right_diameter, right_diameter_pair = diameter[node.right]
                right_farthest_child_data = farthest_child_data[node.right]


            # 높이와 지름을 계산하면서 가장 먼 자손 노드의 데이터도 저장한다.
            if left_height > right_height:
                height[node] = 1 + left_height
                farthest_child_data[node] = left_farthest_child_data
            elif left_height < right_height:
                height[node] = 1 + right_height
                farthest_child_data[node] = right_farthest_child_data
            else:   # 왼쪽과 오른쪽의 높이가 같은 경우, 양쪽의 가장 먼 자손 노드의 데이터를 합친다.
                height[node] = 1 + left_height
                farthest_child_data[node] = left_farthest_child_data + right_farthest_child_data

            if height[node] == 0:
                farthest_child_data[node] = [node.data]

            diameter_current_node = left_height + right_height + 2
            diameter_from_child = max(left_diameter, right_diameter)

            if diameter_current_node >= diameter_from_child:
                # 트리의 지름이 현재 노드를 지나는 경우
                combi = []
                # 왼쪽 서브 노드에서 가장 먼 노드와 오른쪽 서브 노드에서 가장 먼 노드의 쌍을 구한다.
                for left_data in left_farthest_child_data:
                    for right_data in right_farthest_child_data:
                        combi.append((left_data, right_data))
                # 이 값이 왼쪽 자식 노드의 트리의 지름과 같은 경우
                if diameter_current_node == left_diameter:
                    combi += left_diameter_pair
                if diameter_current_node == right_diameter:
                    combi += right_diameter_pair
                diameter[node] = (diameter_current_node, combi)
            elif left_diameter > right_diameter:
                # 왼쪽 자식 노드의 트리의 지름이 더 큰 경우
                diameter[node] = (left_diameter, left_diameter_pair)
            elif left_diameter < right_diameter:
                # 오른쪽 자식 노드의 트리의 지름이 더 큰 경우
                diameter[node] = (right_diameter, right_diameter_pair)
            else: # 횐쪽 자식 노드와 오튼쪽 자식 노드의 트리의 지름이 같은 경우
                diameter[node] = (left_diameter, left_diameter_pair + right_diameter_pair)
    return diameter[root]

def main():

    testcases = get_testcases()
    for i, tc in enumerate(testcases):
        tree_diameter, furthest_node_pairs = furthest_nodes(tc)
        print(f"Testcase {i + 1}")
        print(f"    트리의 지름 : {tree_diameter}")
        print(f"    가장 먼 노드 쌍 : {furthest_node_pairs}")
        print()

if __name__ == "__main__":
    main()

```

---

# 문제 5. 가장 강한 서브트리

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

연구원들은 수 년에 걸쳐 연구하고 있는 신기한 유전자 상의 돌연변이가 있었다. '유라'라는 이름을 가진 동물의 특정한 종에서만 발견되는 돌연변이인데, 이 돌연변이 유전자는 특정 성별에서만 발생하고, 해당 성별의 자손으로만 전파되며, 게다가 자식 중 딱 두 마리까지만 전달된다는 독특한 성질 때문에 연구소에서 이 돌연변이에 초점을 맞추어 연구를 진행하고 있었다. 연구를 통해 이 돌연변이 유전자가 실제로 발현되는데 영향을 미치는 어떤 물질을 발견했는데, 이 물질의 양은 직접 측정할 수 없고, 대신 일종의 전압을 측정하는 것과 유사한 방법으로 측정을 할 수 있었기에 이 값은 양수, 음수, 그리고 0 어떤 부호의 값이든 가질 수 있었다. 이 값을 연구소에서는 '반응도 전압'이라고 불렀다.

연구팀은 이 돌연변이가 발생한 유라 개체를 루트 노드로 하고, 이 돌연변이 유전자가 전달된 자손들을 부모와 자식을 연결한 가계도의 형태로 표현한 후, 이 가계도에 포함된 모든 유라의 반응도 전압을 측정한 후, 가계도 안에 값을 기록했다. 이 가계도를 여러 개를 그려놓고 지켜보던 연구원들은, 이 가계도에서 반응 전압이 유달리 높은 일부분이 있음을 직관적으로 알게 되었다. 그 가계도의 일부분에 해당하는 유라의 개체에 실제로 해당 돌연변이의 형질이 발현되었는지를 확인하고 싶은데, 문제는 일부 가계도는 너무 크고 복잡해서 이를 확인하기가 싶지 않다는 것이었다.

연구원들이 지선생을 찾아가 이 가계도에서 그런 부분을 찾아줄 수 있느냐고 묻자, 지선생은 이렇게 말했다.

“이 가계도 위의 각각의 유라의 개체로부터 그 모든 자손들의 반응도 전압을 다 합쳤을 때, 그 값이 최대가 얼마인지 찾으면 되지 않을까요?”

그 말을 들은 연구원들은 되물었다.

“그런데, 그 값을 어떻게 찾지요?”

## 수행목표

- 이진 트리 내부에 포함된 각 노드마다 해당 노드를 루트로 하는 서브트리를 하나씩 정의할 수 있으므로, 이진 트리에는 노드의 수 만큼의 서브트리가 존재한다.
- 이진 트리에 실수의 값을 가지는 변수가 있다. 서브트리마다 이 변수의 합을 구할 수 있다. 노드 수 만큼의 서브트리의 변수의 합 중 최대값을 반환하는 함수를 구현한다.
- 첨부한 파일을 사용해서 8개의 테스트케이스를 얻을 수 있다. 각 테스트케이스에서 가장 큰 서브트리 합을 구해서 출력해보자.

## 수행단계

- 다음 그림의 트리와 질문을 통해서 문제를 파악해보자.
  ![Alt text](ch7_3.png)
  - 트리에 포함된 모든 노드의 값의 합은 얼마인가?
  - 루트 노드의 왼쪽 자식 노드를 루트 노드로 하는 서브 트리의 모든 노드의 값의 합은 얼마인가?
  - 루트 노드의 오른쪽 자식 노드를 루트 노드로 하는 서브 트리의 모든 노드의 값의 합은 얼마인가?
  - 이 트리에서 합이 가장 큰 서브트리의 루트는 무엇이고, 합의 값은 얼마인가?
  - 반대로 트리에서 합이 가장 작은 서브트리의 루트는 무엇인가?
- 주어진 문제를 해결하기 위해서 우선 특정 노드를 루트로 하는 서브트리의 모든 값의 합을 구하는 문제를 해결해보자. 이 문제는 문제의 구조를 파악해 해결한다.
  - 상위 구조와 하위 구조를 정의해보자.
  - 상위 구조와 하위 구조의 관계를 찾아 점화식의 형태로 정리해보자.
- 서브트리의 모든 값의 합을 구하는 문제를 사용해, 합이 최대인 서브트리의 합을 구하는 방법을 정리한다.
- 정리한 내용을 토대로 합이 최대인 서브트리의 합을 구하는 함수를 ds_more/max_power_subtree.py 파일에 구현한다.
-

- 문제의 구조를 분석하고, 문제를 해결하기 위한 하향식 접근법과 상향식 접근법을 각각 정리한다.
- dp_exer/simple_dna.py 파일에 주어진 문자열이 패턴 만으로 중첩없이 구성되어 있는지를 검사해 그 결과를 반환하는 함수를 구현한다.
  - 하향식 접근법과 상향식 접근법 각각의 함수를 구현한다.
- 주어진 테스트케이스 11개에 대해서 함께 제공된 패턴만으로 중첩없이 구성되어 있는지를 두 함수 각각에 대해서 검사하고, 그 결과를 출력한다.
- 상향식, 하향식 두 접근 전략을 비교 분석한다.
  - 이 문제의 경우 하향식 접근법을 사용할 때 메모이제이션을 사용해도 큰 도움이 되지 않는다. 그 이유가 무엇인지 정리한다.

## 결과예시

```
수행 시간: 1.9073486328125e-06 초
TC 1 하향식 접근법 : True
수행 시간: 5.7220458984375e-06 초
TC 1 상향식 접근법 : True
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/simple_dna.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식, 하향식 각각의 접근 방법을 사용한 두 개의 함수가 구현되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

```
수행 시간: 1.9073486328125e-06 초
TC1 하향식 접근법 : True
수행 시간: 5.7220458984375e-06 초
TC1 상향식 접근법 : True

수행 시간: 2.86102294921875e-06 초
TC2 하향식 접근법 : True
수행 시간: 9.059906005859375e-06 초
TC2 상향식 접근법 : True

수행 시간: 9.5367431640625e-07 초
TC3 하향식 접근법 : False
수행 시간: 5.9604644775390625e-06 초
TC3 상향식 접근법 : False

수행 시간: 9.5367431640625e-07 초
TC4 하향식 접근법 : False
수행 시간: 5.9604644775390625e-06 초
TC4 상향식 접근법 : False

수행 시간: 4.0531158447265625e-06 초
TC5 하향식 접근법 : True
수행 시간: 7.867813110351562e-06 초
TC5 상향식 접근법 : True

수행 시간: 4.0531158447265625e-06 초
TC6 하향식 접근법 : True
수행 시간: 1.0967254638671875e-05 초
TC6 상향식 접근법 : True

수행 시간: 1.1920928955078125e-06 초
TC7 하향식 접근법 : False
수행 시간: 1.3113021850585938e-05 초
TC7 상향식 접근법 : False

수행 시간: 1.9073486328125e-05 초
TC8 하향식 접근법 : True
수행 시간: 0.00020813941955566406 초
TC8 상향식 접근법 : True

수행 시간: 1.5974044799804688e-05 초
TC9 하향식 접근법 : False
수행 시간: 0.00020194053649902344 초
TC9 상향식 접근법 : False

수행 시간: 0.00013375282287597656 초
TC10 하향식 접근법 : True
수행 시간: 0.0015680789947509766 초
TC10 상향식 접근법 : True

수행 시간: 0.001992940902709961 초
TC11 하향식 접근법 : False
수행 시간: 0.3107450008392334 초
TC11 상향식 접근법 : False
```

### [문제에 대한 이해]

- 하향식 다이나믹 프로그래밍 전략을 사용하기 위한 문제의 구조와 해결 전략을 제시하라.
- 상향식 다이나믹 프로그래밍 전략을 사용하기 위한 문제의 구조와 해결 전략을 제시하라.
- 하향식 접근법과 상향식 접근법을 비교 분석해보라. 성능 차이가 발생하였다면, 그 이유도 함께 제시하라.

### [코드 예시]

```python

```

---

# 문제 6. 서브트리의 합이 최대가 되는 서브트리의 루트

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

E 연구원은 실험을 통해 이론을 검증한 후, 이 내용을 정리해 해외 유명 진화생물학 저널에 논문을 투고했다. 논문이 실린 저널이 출판된지 한 달쯤 지나서 E 연구원에게 메일이 하나 도착했다. 이 분야에서 연구를 하는 사람이면 누구나 알고 있는 해외 유명 연구자의 메일이었다.

> - 좋은 논문 발표해 주셔서 감사합니다. 정말 좋은 성과라고 생각합니다.
> - 그런데 논문을 꼼꼼히 읽어보던 중에, 재미있는 것을 발견했습니다. 마침 제가 하던 연구와 결합이 가능할 것 같은데, 혹시 시퀀스 몇 개에 대해 패턴으로 쪼갠 결과를 보내주실 수 있으신지요? 그리고 하나의 시퀀스가 주어진 패턴에 대해서 쪼갠 결과가 둘 이상이면, 모두 다 보내주실 수 있으시면 큰 도움이 될 것 같습니다.
> - 제 사견입니다만, 10년 안에 저와 L님이 공동으로 노벨 생리의학상 후보가 될 수 있지 않을까라는 기대도 하게 됩니다. 부디 꼭 부탁드립니다.

## 수행목표

- 패턴과 문자열이 주어졌을 때, 문자열이 패턴 만으로 중첩없이 검사하는 것으로 그치지말고, 패턴을 사용해 문자열을 구성한 방식을 반환하도록 수정된 함수를 구현한다.
  - 예를 들어 패턴이 [‘CT’, ‘TA’, ‘AG’, ‘CTT’, ‘AAG’]로 주어지고, 검사해야 할 문자열이 'CTTAAG'인 경우, 이 문자열은 CTT-AAG로 패턴을 사용해 나눌 수 있다. 그런데 'CTTAAG'는 CT-TA-AG로 패턴을 사용해서 나눌 수 있는 다른 방법이 존재한다. 함수의 반환 결과는 이를 모두 포함한 ['CTT-AAG', 'CT-TA-AG']를 반환해야 한다.
  - 만약 패턴만으로 중첩 없이 입력 문자열을 나눌 수 없는 경우 빈 리스트[]를 반환한다.
- 다음 테스트케이스 3개에 대해서 실행 결과를 출력한다.
  ```python
  patterns = ['CT', 'TA', 'AG', 'CTT', 'AAG']
  test1 = "CTTAAG"
  test2 = "GCCCTACTAGCCCTAGCTAGCCCTAGGCCCTAGCCCTAGCCGCCGCCCTACTAGCCCTACTA"
  test3 = "AGCTCTTAAAGAAGTATAAGCTTCTCTTCTCTTCTTAAGTAAGCTCTTACTCTTAAGCTAGAGAGAGAG"
  ```

## 수행단계

- 하향식 접근법을 사용해 패턴만으로 중첩없이 문자열이 구성되어 있는지를 검사하는 함수를 이전 문제에서 구현한 바 있다. 하향식 접근법으로 구성 가능 여부를 반환하는 대신 패턴으로 구성하는 방법의 목록을 반환하는 함수를 dp_exer/simple_dna2.py 파일에 구현한다.
- 주어진 테스트케이스 각각에 대해서 입력 문자열을 패턴으로 나눈 결과를 출력한다.

## 결과예시

```
TC1을 자른 결과 : ['CT-TA-AG', 'CTT-AAG']

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/simple_dna2.py 파일에 구현이 되어 있는지 확인한다.
  - 하향식 접근방법을 메모이제이션과 함께 사용하여 구현하였는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과의 예시이다. 결과는 항상 다르게 나오지만, 수행 시간은 거의 지연없이 결과를 확인할 수 있어야 한다.

```
TC1을 자른 결과 : ['CT-TA-AG', 'CTT-AAG']

TC2을 자른 결과 : []

TC3을-자른-결과-:-['AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CT-TA-AG-TA-AG-CT-CT-TA-CT-CT-TA-AG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CT-TA-AG-TA-AG-CT-CT-TA-CT-CTT-AAG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CTT-AAG-TA-AG-CT-CT-TA-CT-CT-TA-AG-CT-AG-AG-AG-AG-AG', 'AG-CT-CT-TA-AAG-AAG-TA-TA-AG-CTT-CT-CTT-CT-CTT-CTT-AAG-TA-AG-CT-CT-TA-CT-CTT-AAG-CT-AG-AG-AG-AG-AG']
```

### [문제에 대한 이해]

- 패턴을 자른 결과를 취합하기 위해서 재귀 함수는 어떤 전략을 사용하는가?
  - 파라미터에 뮤터블 객체를 전달해 자른 결과를 취합하는 방식과 반환값을 리스트로 받아서 모든 리스트를확장해 나가는 방식의 구현에 따라 답이 달라진다. 아래 예시 답변은 후자의 경우이다.
  - 문자열의 가장 앞 부분이 주어진 패턴과 매칭 되는 경우, 나머지 부분을 재귀 호출한다.
  - 재귀 호출의 결과가 비어 있지 않은 리스트인 경우 리스트의 모든 결과의 앞에 매칭된 패턴을 추가한다.
  - 재귀 호출의 결과가 리스트인 경우 그대로 빈 리스트를 반환한다.
  - 문자열의 가장 앞 부분이 주어진 패턴과 매칭이 되지 않는 경우 빈 리스트를 반환한다.

### [코드 예시]

```python

```

---

# 문제 7. 식물의 영양 흡수 패턴

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

바이러스 연구를 위해 신규 도입된 특수한 바이러스 배양 장치는 배양하는 조건을 다양하게 설정해 다양한 목적으로 활용할 수 있는 최첨단 장비이다. 생태 환경을 통제해 바이러스의 세대별 주기가 배양 조건에 따라 서로 다른 진화가 가능한지를 확인하기 위해서 T 연구원은 이 장비를 사용하기로 했다.

‘이것이 장비의 매뉴얼이구나?’

장비의 매뉴얼에는 장비의 사용 방법이 다음과 같이 적혀 있었다.

> - 배양기는 n X 2의 크기이다.
> - 이 장비는 바이러스가 유출되지 못하게 가둬 두는 1X2 크기의 바이오 세이프티 필터와 바이러스가 자유롭게 드나들 수 있는 2X1 크기의 바이오 컴패터블 필터를 바닥에 설치해야 한다.
> - 이 설치 방식에 따라 모두 다른 실험 결과를 얻을 수 있다.
> - 바닥에 필터가 설치되어 있지 않은 영역이 조금이라도 있는 경우 바이러스가 배양기 외부로 유출될 위험이 매우 높으므로, 절대 주의해야 한다.

T 연구원은 이 장비를 사용하기에 앞서 총 몇 종류의 설정이 가능한지 알아야 했다. 실험 계획을 세우기 위해서 반드시 필요한 값이기 때문이었다.

## 수행목표

- 배양기는 n X 2의 구조를 가지고 있다. (가로가 양의 정수 n의 크기이다.) 그리고 배양기 바닥은 1 X 2 또는 2 X 1 크기의 필터로 빠짐없이 채워야 장비가 정상적으로 동작하며, 필터의 종류와 무관하게 필터를 배치한 형태만으로 서로 다른 실험 환경이 설정된다고 할 때, 서로 다른 전체 실험 설정의 수를 계산해 반환하는 함수를 구현한다.
- n = 2, 10, 30, 50, 100일 때 서로 다른 전체 실험 설정의 수를 계산하고, 이를 출력한다.

## 수행단계

- 문제의 구조를 분석한다.
- 다이나믹 프로그래밍 접근 방법을 사용해 문제를 해결하는 방법을 정리한다.
- dp_exer/filtering1.py 파일에 서로 다른 전체 실험 설정의 수를 반환하는 함수를 구현한다.
  - 이 함수는 다이나믹 프로그래밍으로 구현한다. 접근 방법은 각자 선택하되, 시간 복잡도는 O(n) 이하가 되도록 구현하여야 한다.
- n = 2, 10, 30, 50, 100일 때의 결과를 각각 출력한다.

## 결과예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/filtering1.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 방법을 사용해서 O(n) 시간 복잡도 이내로 동작하는 알고리즘으로 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- 이 문제의 점화식을 설명과 함께 제시하라.
- 구현한 알고리즘의 시간 복잡도를 설명과 함께 제시하라.

### [코드 예시]

```python

```

---

# 문제 8. 그래프의 사이클 탐지

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

정작 배양기 사용 하가를 받아서 배양기의 덮개를 열어보니, 배양기는 n x 2 구조가 아니라 n x 3 구조였다. 매뉴얼이 옛날 구버전의 것이었는데, 연구소의 인트라넷에 새 버전으로 업데이트가 되지 않았던 것이다.

T 연구원은 뭔가 더 많은 경우를 테스트 할 수 있을 것이라는 생각에 횡재한 기분이었다. 하지만 들뜬 기분도 잠시. 전체 실험 가능한 설정의 수를 다시 계산해야 한다는 생각에 우울감이 몰려왔다. 게다가 문제의 난이도가 n x 2일 때보다 훨씬 복잡해졌음을 직관적으로 깨달을 수 있었다.

'뭐, 일단 부딪혀보고 안되면 프로그래밍 지원 게시판에 도움을 청하면 어떻게 되지 않겠어?'

## 수행목표

- 이전 문제와 달리 이번에는 n X 3 구조의 배양기에 1 x 2 또는 2 x 1 크기의 필터를 빠짐없이 배치해야 한다. (n은 양의 짝수이다.) 이와 같이 배양기의 구조가 변경된 상황에서 필터의 종류와 무관하게 필터를 배치한 형태만으로 서로 다른 실험 환경이 설정된다고 할 때, 서로 다른 전체 실험 설정의 수를 계산해 반환하는 함수를 구현한다.
- 이 함수를 사용해 배양기의 구조가 2 x 3, 4 x 3, ..., 20 x 3 인 10개의 배양기에서 설정 가능한 실험의 총 수를 각각 계산해 출력한다.

## 수행단계

- 문제의 구조를 단계별로 확인해보자.
  - 2 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - 4 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - 6 x 3 크기의 배양기에 필터를 배치하는 모든 방법을 정리해보자.
  - n이 8 이상일 때 배양기에 필터를 배치하는 방법을 작은 크기의 배양기에 필터를 배치하는 방법을 사용해 경우 별로 분류해서 정리해보자.
    - (n - 2) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하는 경우 (배치 A)
    - (n - 4) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하되, 배치 A에 포함되지 않는 경우 (배치 B)
    - (n - 6) x 3 크기의 공간에 필터를 배치한 다음 남은 공간에 추가로 필터를 배치하되, 배치 A와 배치 B에 포함되지 않는 경우 (배치 C)
    - 배치 A, 배치 B, 배치 C와 무관하며, 작은 크기의 배양기에 필터를 배치하는 방법과도 완전히 무관한 별도의 경우
- 이 문제를 상향식 접근 방법으로 해결하는 함수를 dp_exer/filter2.py 파일에 구현한다.
- n = 2, 4, ..., 20일 때의 결과를 출력한다.

## 결과예시

```
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/filter2..py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍 접근 방법으로 해결하고 있는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- n이 홀수인 경우는 어떤 결과가 나오는가?
- 문제의 구조를 하위 문제를 사용해 설명하라.
- n x 3에서 가능한 모든 실험 설정의 수를 case(n)으로 표기할 때, case(n)의 상위 문제와 하위 문제의 관계를 나타내는 점화식을 제시하라.

### [코드 예시]

```python

```

---

# 문제 9. 그래프의 커넥티드 컴포넌트

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

동물 지능 연구그룹을 이끄는 X 그룹장은 어느날 지선생을 찾아갔다. X 그룹장은 지선생이 기가 막힐 정도로 천재라는 사실을 눈치채고 있는 소수의 연구원 중 한 사람이었다. 사실 그것이 아니라도 평소 연구 업무에 크게 도움을 주고 있는 지선생을 연구소의 훌륭한 선배로 받들어 모시는 그런 사람이기도 했다.

"요즘 원숭이들의 규칙 준수 가능성을 확인하기 위해서, 원숭이들 행동을 점수로 평가하고 있어요."

"아니 원숭이랑 생긴 일을 왜 나한테 가지고 와서 그래?"

"그런데, 그 녀석들에게 요즘 가르치고 있는게 있거든요."

"뭔데?"

"정확히 100점을 받으면 바나나를 상으로 주고 있어요."

"뭔 소리야?"

"100점을 초과해버리면 안준단 소리죠."

"너 그러다 원숭이한테 맞겠다."

"여튼, 이거 방법을 좀 알려주셨으면..."

"뭔데?"

"원숭이들이 정확히 100점을 받을 수 있는 가능한 모든 행동 시퀀스를 구하는 방법이 필요해요."

"음. 어렵지는 않은데, 점수표는 좀 조절해야겠네?"

"어떻게요?"

"행동에 점수를 매길 때, 행동 별로 같은 점수가 없도록 만들어주면 좋겠네."

"아, 그래요? 그거야, 뭐 어렵지 않죠. 오히려 실험 결과를 식별하기에는 더 편할 것 같은데요?"

"아... 그런데, 원숭이는 예외없이 바나나를 좋아하는거 맞는거지?"

두 사람은 문제를 검토한 후, 머리를 맞대고 방법을 찾아나가기 시작했다.

## 수행목표

- 점수 배열과 목표 점수가 주어진다. 점수 배열은 각 행동 별 점수를 나타내며, 중복된 값을 포함하지 않는다.
- 목표 점수를 정확히 달성하는데 필요한 행동의 시퀀스를 모두 작성해 반환한다.
  - 목표 점수가 30점이고 행동 점수 배열이 [10, 20]인 경우, 이 함수는 [[0, 0, 0], [0, 1], [1, 0]]을 반환한다. 10점 행동을 3번 연달아하거나, 10점 행동 이후에 20점 행동을 하거나, 20점 행동 이후에 10점 행동을 한 세 가지 경우를 해당 점수의 인덱스를 사용해 만든 리스트의 리스트에 해당한다.
  - 목표 점수가 90점이고 행동 점수 배열이 [40, 20]인 경우, 목표 점수를 달성할 수 있는 가능성이 전무하므로 빈 리스트 []를 반환한다.
- 다음 테스트케이스는 점수 배열과 목표 점수의 튜플로 구성되어 있다. 총 5개의 테스트케이스가 제시되며, 각각의 결과를 출력한다.
  ```python
  testcases = [([15, 20], 10), ([1, 2, 3], 6), ([12, 14, 16, 18, 20], 105), ([13, 17, 19], 56)]
  ```

## 수행단계

- 문제의 구조를 분석한다.
  - 하향식으로 접근하기 위해서 목표 점수를 달성하기 전 단계를 사용해서 상위 문제와 하위 문제의 관계를 정리한다.
  - 상향식으로 접근하기 위해서 가장 작은 문제와 상향식 전개 과정을 정리한다.
- 이 문제를 상향식 접근 방법 및 햐힝식 접근 방법 각각의 방식으로 해결하는 두 개의 함수를 dp_exer/monkey_banana.py 파일에 구현한다.
- 제시된 테스트케이스를 사용해 문제를 해결한 결과를 출력한다.

## 결과예시

```

(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/monkey_banana.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식, 하향식 각각의 방법을 사용한 두 가지 모두 구현되어 있어야 한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

    ```

    ```

### [문제에 대한 이해]

- 하향식 다이나믹 프로그래밍 해결 전략을 제시해보자. 재귀 호출 함수가 하는 일, 종료 조건, 메모이제이션 변수의 정의, 그리고 목록을 작성하는 방법을 설명해야 한다.
  - 목표 점수에서 취할 수 있는 점수 만큼을 뺀 값을 재귀 호출 한 후, 반환되는 전체 목록에 뺀 점수의 항목을 앞에 각각 붙이고 취합하는 방식으로 구현할 수 있다.
  - 종료 조건은 0점이 되었을 때 (성공), 혹은 점수가 남았으나 취할 수 있는 행동이 없을 때(실패) 이다.
  - 목록을 취합하는 방식은 성공의 경우는 해당 항목을 반환하는 경로에 합치고, 실패의 경우에는 버린다.
  - 메모이제이션은 딕셔너리를 사용하며, ws_memo[i]는 i 점을 받기 위한 행동 시퀀스이다.
- 상향식 다이나믹 프로그래밍으로 문제를 해결할 때, 가장 작은 문제를 정의해보자.
  - 가장 작은 문제는 0점을 달성하는 목록을 구하는 문제이다.
- 상향식 다이나믹 프로그래밍으로 문제를 해결할 때, 이전에 계산한 결과를 저장하는 변수를 정의하고 초기화 하는 방법을 제시해보자.
  - 크기 별 문제의 결과를 저장하기 위해서 target + 1 크기의 배열을 빈 배열로 초기화하면서 생성한다.
- 두 가지 구현 방법의 시간 복잡도를 제시하라.

### [코드 예시]

```python

```

---

# 문제 10. 그래프를 트리로

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

유전 정보의 코딩을 연구하는 D 연구원은 자나깨나 염기 서열의 배치 특징을 생각하는 삶을 살고 있다. 문득 이런 생각이 들었다.

'어떤 배치 구조가 길면 길수록 어떤 특징이 나타나지 않을까? 일단 염기 서열의 오름차순 배치 구조부터 확인해봐야겠다.'

## 수행목표

- 'C', 'T', 'A', 'G' 네 글자로 구성된 문자열이 주어진다. 이 문자열의 부분 순열 중, C, T, A, G 순으로 배치된 부분 문자열의 최장 길이와 이 부분 순열 패턴을 찾아 출력하는 프로그램을 작성한다.
  - 예를 들어 주어진 문자열이 CTAGTACG인 경우, 이 문자열에서 `__A__ACG`의 오름차순 부분 순열이 가장 긴 오름차순 부분 순열이 된다. (같은 값의 경우 오름차순으로 간주한다.) 이 경우 4와 함께 AACG를 출력한다.
  - CTAGGTACG의 경우 `C__GGT___`, `__AGGT___` 등 여러 개의 길이가 4인 오름차순 부분 순열을 찾을 수 있으며, 이 부분순열이 가장 긴 오름차순 부분 순열이다. 이 경우 4와 함께 찾을 수 있는 부분 순열 중 하나를 출력한다.
- 다음 테스트케이스에는 16개의 문자열이 주어진다. 이 문자열에서 가장 긴 오름차순 부분 순열의 길이와 부분 순열 중 하나를 출력한다.
  ```python
  testcases = ['CTAGTACG', 'CTAGGTACG', 'AAA', 'ACGT', 'TGCA', 'ACTTTTTTTCGGGGGGT', 'ACTTTTTCT', 'ACTTTTTCGGGT', 'ACTTTTTCGGGGGGTTTTTT', 'GCCTGCTGGT', 'CCCATCTTCCGTCATTATAG', 'ACCAAGAAACTGTAATCTCCTTCTTCTCGA', 'TCCGTTCGGCATACCCCCCGGCGGGGATATCGAACTGGAG', 'GTCCGAGGGGCAAGCAAGCGGGTTGACGCATCCTGAAGCTCTTTCACAGG', 'ATGGGTGAAAACCCCCATTAACATAACTGGCGCCGGGAGTTACGAATCTCGTGCTTGAAGAAGGGCAAACTGTTTTACGAGAGGTGGGGACAGACTACCT', 'CAATCATCTGGCCTCCAATTAAGACTTTATGCTGCTGCTAGCCAGAAATTTATTGACCACCACGGATGCGACGGCTCGACGCTGATGGTGTGACGTTGCAAAAGCTGGTCTATGGCTTGGTTTAGTGGTGGCCATGGACCCCTCACTCGTAATTTGTAAATGTAATAATAGGCGCCAAATTCAGTGTCTGATGCTGGTTCCCCAGCTGTCTCTTGCAAGTCGGCGCCAATCGTTTTCCACGGAACGACTTGTCTGCGGCCTATGCATCGTTCGCTAGCCAGTTAAATGGCATATGCTAGTTCACCTAACCACTTCAAAGTATCAGCCCAAGGATTTTCACCAGGTAGGGAAATTATTAGGATCGCTAAGCAACCCACTGTCCGATACGACAGCCCGCTGCCAGCGTTTCATTATAGTCTTGGAATACCGTTCCGTTGTTTTCAAACCGTTCCAACCCCCCTGATGCGCCAGCGTCTAGGTTTGTCGGCGCTAGTGGCCACCAGCGCGTGCCATACACGCGGTGTTGGCCTAATCAGTTGCTAAGTACCTAGAACGACAGCTAACCGAAAGAGAAAACATCGAGCTTTTACGTAATTTCTACACTATACGCCCTGGACGACATACTAGTCTGCGTTTGGTCTATATCTATATGTTCACTCCGAAGCTCTCAGATCTGATACAGACACATGAGGGTCTTGTAGCATTCCTAGAGCTTCTATACGCGTGGTTCGCCGGCCAGGATATGGGTCACACGGGTACATTCAACTCCTACTACGAGAGGGGGTGTTTAAACTATCCGTAAAGCCACAGTAATCGAGATTTACCCATAGGCGACCGATCAAATCGTCTATGGACAGAAGTGGCTCCGCCCGCGAAGCTAACATAAGGTCCAATTACATTGTTACCTAAGCTCTTGTACTAAAATCTAGTGATCATAATCCCGGCCCCGTTATCGCCACCATGGCAATATTTGAACGCGCCCTCGTAGAGCTCATAAGGA']
  ```

## 수행단계

- 문제의 구조를 분석한다.
- 문제의 구조를 사용하는 다이나믹 프로그래밍 접근 방식으로 최장 부분 순열 중 하나를 문자열로 만들어 반환하는 함수를 dp_exer/ascending_pattern.py 파일에 구현한다.
  - 다이나믹 프로그래밍 방식으로 구현하며, 구현한 알고리즘의 시간 복잡도를 확인한다. -
- 테스트케이스로 제시된 16개의 문자열에서 가장 긴 오름차순 부분 문자열 중 하나를 만들어 길이와 함께 출력한다.

## 결과예시

```
Testcase 1
    가장 긴 오름차순 부분 순열의 길이 : 4
    가장 긴 오름차순 부분 순열 중 하나 : AACG

Testcase 2
    가장 긴 오름차순 부분 순열의 길이 : 4
    가장 긴 오름차순 부분 순열 중 하나 : CGGT
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/ascending_pattern.py 파일에 구현이 되어 있는지 확인한다.
  - 다이나믹 프로그래밍 접근방법을 사용해 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

  ```
  Testcase 1
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : AACG

  Testcase 2
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : CGGT

  Testcase 3
      가장 긴 오름차순 부분 순열의 길이 : 3
      가장 긴 오름차순 부분 순열 중 하나 : AAA

  Testcase 4
      가장 긴 오름차순 부분 순열의 길이 : 4
      가장 긴 오름차순 부분 순열 중 하나 : ACGT

  Testcase 5
      가장 긴 오름차순 부분 순열의 길이 : 1
      가장 긴 오름차순 부분 순열 중 하나 : T

  Testcase 6
      가장 긴 오름차순 부분 순열의 길이 : 10
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTTTT

  Testcase 7
      가장 긴 오름차순 부분 순열의 길이 : 8
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTT

  Testcase 8
      가장 긴 오름차순 부분 순열의 길이 : 8
      가장 긴 오름차순 부분 순열 중 하나 : ACTTTTTT

  Testcase 9
      가장 긴 오름차순 부분 순열의 길이 : 15
      가장 긴 오름차순 부분 순열 중 하나 : ACCGGGGGGTTTTTT

  Testcase 10
      가장 긴 오름차순 부분 순열의 길이 : 6
      가장 긴 오름차순 부분 순열 중 하나 : CCGGGT

  Testcase 11
      가장 긴 오름차순 부분 순열의 길이 : 11
      가장 긴 오름차순 부분 순열 중 하나 : CCCCCCGTTTT

  Testcase 12
      가장 긴 오름차순 부분 순열의 길이 : 16
      가장 긴 오름차순 부분 순열 중 하나 : AAAAAACTTTTTTTTT

  Testcase 13
      가장 긴 오름차순 부분 순열의 길이 : 20
      가장 긴 오름차순 부분 순열 중 하나 : CCCCCCCCCCGGGGGGGGGG

  Testcase 14
      가장 긴 오름차순 부분 순열의 길이 : 20
      가장 긴 오름차순 부분 순열 중 하나 : CCGGGGGGGGGGTTTTTTTT

  Testcase 15
      가장 긴 오름차순 부분 순열의 길이 : 39
      가장 긴 오름차순 부분 순열 중 하나 : AAAAACCCCCCCGGGGGGGGGGGGGGGGGGGGGGGGGTT

  Testcase 16
      가장 긴 오름차순 부분 순열의 길이 : 274
      가장 긴 오름차순 부분 순열 중 하나 : AAAAAAAAAAAAAAAACCCCCGGGGGGGGGGGGGGGGGGTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
  ```

### [문제에 대한 이해]

- 문제의 구조를 제시하라.
  - 문자열의 i 번째 글자의 값을 마지막 값으로 반드시 포함하는 가장 긴 부분 순열의 길이를 dp[i]라고 표현하면, 임의의 dp[j]의 값은 j 보다 작은 모든 k에 대해서 다음 모든 값들의 최대값이 되는 구조가 성립한다.
    - 만약 k 번째 글자보다 j 번째 글자가 같거나 더 큰 값의 글자인 경우 : dp[k] + 1
    - 그렇지 않은 경우 : 1
- 가장 긴 오름차순 부분 순열을 찾는 방법을 설명하라.
  - 가장 긴 오름차순 부분 순열의 길이를 문자열의 모든 인덱스에 대해서 갱신할 때, j번 인덱스의 글자로 끝나는 오름차순 부분 순열의 이전 글자는 k번째 인덱스의 글자가
    된다. 이를 모든 인덱스 별로 관리한 다음, 부분 문자열의 길이가 최대가 되는 j에 대해서 역순으로 이전 글자를 이어 붙이는 과정으로 가장 긴 오름차순 부분 순열을 찾을 수 있다.
- 구현한 알고리즘의 시간 복잡도를 제시하라.
  - 모든 글자에 대해서 더 작은 글자를 반복하는 구조이므로 n의 이중 루프 구조를 가진다. O(n^2)에 해당된다.
- 만약 문제의 조건이 가장 긴 '연속된 오름차순 부분 문자열'인 경우 문제를 어떻게 해결할 수 있는지 접근 전략을 제시해보자.
  - 슬라이딩 윈도우, 헤드와 테일 포인터 등을 유지하면서 전체 문자열을 스캔하는 방법 등 적당한 전략을 제시할 수 있는지 확인한다.

### [코드 예시]

```python
def find_lap(input_seq):
    if not input_seq:
        return ''

    dp = [1] * len(input_seq)
    prev = [-1] * len(input_seq)

    max_len = 0
    max_index = 0

    for i in range(1, len(input_seq)):
        for j in range(i):
            if input_seq[j] <= input_seq[i] and dp[j] + 1 > dp[i]:
                dp[i] = dp[j] + 1
                prev[i] = j
                if dp[i] > max_len:
                    max_len = dp[i]
                    max_index = i

    longest_ascending_pattern = ''
    while max_index != -1:
        longest_ascending_pattern += input_seq[max_index]
        max_index = prev[max_index]
    return longest_ascending_pattern[::-1]


def main():

    testcases = ['CTAGTACG', 'CTAGGTACG', 'AAA', 'ACGT', 'TGCA', 'ACTTTTTTTCGGGGGGT', 'ACTTTTTCT', 'ACTTTTTCGGGT', 'ACTTTTTCGGGGGGTTTTTT', 'GCCTGCTGGT', 'CCCATCTTCCGTCATTATAG', 'ACCAAGAAACTGTAATCTCCTTCTTCTCGA', 'TCCGTTCGGCATACCCCCCGGCGGGGATATCGAACTGGAG', 'GTCCGAGGGGCAAGCAAGCGGGTTGACGCATCCTGAAGCTCTTTCACAGG', 'ATGGGTGAAAACCCCCATTAACATAACTGGCGCCGGGAGTTACGAATCTCGTGCTTGAAGAAGGGCAAACTGTTTTACGAGAGGTGGGGACAGACTACCT', 'CAATCATCTGGCCTCCAATTAAGACTTTATGCTGCTGCTAGCCAGAAATTTATTGACCACCACGGATGCGACGGCTCGACGCTGATGGTGTGACGTTGCAAAAGCTGGTCTATGGCTTGGTTTAGTGGTGGCCATGGACCCCTCACTCGTAATTTGTAAATGTAATAATAGGCGCCAAATTCAGTGTCTGATGCTGGTTCCCCAGCTGTCTCTTGCAAGTCGGCGCCAATCGTTTTCCACGGAACGACTTGTCTGCGGCCTATGCATCGTTCGCTAGCCAGTTAAATGGCATATGCTAGTTCACCTAACCACTTCAAAGTATCAGCCCAAGGATTTTCACCAGGTAGGGAAATTATTAGGATCGCTAAGCAACCCACTGTCCGATACGACAGCCCGCTGCCAGCGTTTCATTATAGTCTTGGAATACCGTTCCGTTGTTTTCAAACCGTTCCAACCCCCCTGATGCGCCAGCGTCTAGGTTTGTCGGCGCTAGTGGCCACCAGCGCGTGCCATACACGCGGTGTTGGCCTAATCAGTTGCTAAGTACCTAGAACGACAGCTAACCGAAAGAGAAAACATCGAGCTTTTACGTAATTTCTACACTATACGCCCTGGACGACATACTAGTCTGCGTTTGGTCTATATCTATATGTTCACTCCGAAGCTCTCAGATCTGATACAGACACATGAGGGTCTTGTAGCATTCCTAGAGCTTCTATACGCGTGGTTCGCCGGCCAGGATATGGGTCACACGGGTACATTCAACTCCTACTACGAGAGGGGGTGTTTAAACTATCCGTAAAGCCACAGTAATCGAGATTTACCCATAGGCGACCGATCAAATCGTCTATGGACAGAAGTGGCTCCGCCCGCGAAGCTAACATAAGGTCCAATTACATTGTTACCTAAGCTCTTGTACTAAAATCTAGTGATCATAATCCCGGCCCCGTTATCGCCACCATGGCAATATTTGAACGCGCCCTCGTAGAGCTCATAAGGA']

    for i, tc in enumerate(testcases):
        print(f"Testcase {i + 1}")
        longest_ascending_pattern = find_lap(tc)
        length_of_lap = len(longest_ascending_pattern)
        print(f"    가장 긴 오름차순 부분 순열의 길이 : {length_of_lap}")
        print(f"    가장 긴 오름차순 부분 순열 중 하나 : {longest_ascending_pattern}")
        print()

if __name__ == '__main__':
    main()


```

---

# 문제 11. 최적 경로

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

D 연구원은 오름차순 패턴의 길이와 관련된 염기 서열과 유전 정보와의 관계를 찾는데 실패했다. 하지만 불굴의 의지로 또 다른 가능성을 찾아보고 있었다. 그런 그가 문득 DNA 염기 서열에서 특수한 패턴을 확인하는 프로그램이 있으면 편하지 않을까란 생각을 했다.

D 연구원이 생각하는 특수 패턴 확인 프로그램은 일반적인 '와일드카드' 매칭과 동일한 방법이다. 즉, `*`와 `?`를 사용해서 검사를 하자는 아이디어였다.

## 수행목표

- 'C', 'T', 'A', 'G' 네 글자로 구성된 문자열 형태의 유전자 염기 서열과 패턴이 주어진다. 문자열에 패턴이 포함되어 있는지를 검사하고 그 결과를 출력하는 프로그램을 작성한다. 패턴은 다음과 같다.
  - 단순 문자열 패턴 : 패턴이 문자열에 포함되어 있는지를 검사한다. 예를 들어 주어진 문자열이 `CTATTAG`이고, 패턴이 `TAT`인 경우는 `_TAT___`로 패턴이 문자열에 포함되어 있으므로 '포함'을 출력한다.
  - `?` 와일드카드 패턴 : `?`는 아무 한 글자와 매칭되며, 이러한 패턴이 문자열에 포함되어 있는지 검사한다. 주어진 문자열이 `CTATTAG`이고, 패턴이 `T?T`인 경우는 `_T?T___`로 패턴이 문자열에 포함되어 있으므로 '포함'을, 패턴이 `A?G`인 경우는 이런 패턴이 포함되어 있지 않으므로 '불포함'을 출력한다.
  - `*` 와일드카드 패턴 : `*`는 아무 여러 글자와 매칭되며, 이러한 패턴이 문자열에 포함되어 있는지 검사한다. 주어진 문자열이 `CTATTAG`이고 패턴이 `TA*AG`인 경우 '포함'을, 패턴이 `TA*AT`인 경우 '불포함'을 출력한다. 또한 `*`는 0글자 이상의 아무 여러 글자이므로 문자열이 `CCCAGTT`일 때 패턴이 `AG`, `A*G`는 포함, `A?G`는 불포함을 의미한다.
  - 패턴은 `*`와 `?`를 0개 이상 여러번 사용해서 구성된다. 문자열이 `CGTATGTAGCCGTGTA`이고 패턴이 `AT*CG?GT`인 경우 '포함'을 출력한다. (`___AT_____CG_GT_`)
- 다음 첨부 파일에는 15개의 테스트케이스가 포함되어 있다. 각 테스트케이스는 문자열과 패턴의 튜플로 구성되어 있으며, 마지막 두 개의 테스트케이스는 공백 문자를 포함한 일반적인 문자열에 해당한다. (공백 문자도 하나의 글자로 처리한다.) 이 15개의 테스트케이스에서 주어진 패턴이 포함되어 있는지 검사한 결과를 출력한다.

## 수행단계

- 문제의 구조를 분석한다.
- 이 문제를 상향식 다이나믹 프로그래밍으로 구현하기 위한 방법을 정리한다.
  - 힌트 - 이 문제를 해결하기 위한 상향식 접근 방법에서는 작은 문제의 결과를 저장하기 위한 자료형으로 이차원 배열을 사용한다.
    - dp[s][p], 0 <= s <= 문자열의 길이, 0 <= p <= 패턴의 길이
- 문제의 구조를 사용하는 다이나믹 프로그래밍 접근 방식으로 패턴이 문자열에 포함되어 있는지를 검사하는 함수를 dp_exer/wildcard_pattern.py 파일에 구현한다.
  - 다이나믹 프로그래밍 방식으로 구현한다.
- 테스트케이스로 제시된 15개의 문자열과 패턴에 대해서 검사 결과를 출력한다.

## 결과예시

```
Testcase 1 : 포함

Testcase 2 : 포함

Testcase 3 : 불포함

Testcase 4 : 포함

Testcase 5 : 불포함
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - dp_exer/wildcard_pattern.py 파일에 구현이 되어 있는지 확인한다.
  - 상향식 다이나믹 프로그래밍 접근방법을 사용해 구현하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다.

  ```
  Testcase 1 : 포함

  Testcase 2 : 포함

  Testcase 3 : 불포함

  Testcase 4 : 포함

  Testcase 5 : 불포함

  Testcase 6 : 포함

  Testcase 7 : 포함

  Testcase 8 : 불포함

  Testcase 9 : 포함

  Testcase 10 : 포함

  Testcase 11 : 불포함

  Testcase 12 : 포함

  Testcase 13 : 불포함

  Testcase 14 : 포함

  Testcase 15 : 불포함
  ```

### [문제에 대한 이해]

- 문제의 구조와 상향식으로 문제를 전개해나가는 방식을 설명하라.
  - 모든 패턴은 시작이 `*`이 아닌 경우 처음에 `*`을 추가하고, 마지막이 `*`이 아닌 경우 마지막에 `*`를 추가한다.
  - dp[i][j]를 i번째 글자 까지의 문자열과 j번째 글자 까지의 패턴에 대해서 검사한 결과라 하자. (참거짓값)
  - 우선 패턴 시작의 `*`의 크기만큼 dp[0][j]를 True로 초기화한다.
  - 패턴을 하나씩 추가하면서 차례대로 검사하고, 이 과정을 문자열의 글자를 추가해가면서 검사하는 방향으로 상향식으로 계산해 나간다.
  - 추가한 패턴이 `*`인 경우 `dp[i][j]`는 `dp[i][j - 1]`가 참이거나(`*` 이전 까지 참이었는가) `dp[i - 1][j]`가 참인 경우(이전 글자까지 참이었는가) 참이 된다.
  - 그렇지 않은 경우 추가한 패턴의 글자와 문자열의 추가한 글자가 일치한 경우에 `dp[i][j]`은 `dp[i - 1][j - 1]`와 동일한 값을 가지며, 일치하지 않는 경우는 거짓이 된다. `?`패턴인 경우는 패턴의 추가한 글자와 문자열의 추가한 글자가 일치하는 것으로 간주하고 처리한다.
- 상향식으로 문제를 해결하기 위한 가장 간단한 문제는 무엇이며, 이 값은 무엇으로 초기화되는가?
  - 빈 문자열을 빈 패턴과 비교하는 경우이며, 이는 참으로 초기화된다.
  - 패턴 앞 부분에 `*`의 길이 만큼 `dp[0][j]`는 참이 된다.

### [코드 예시]

```python
from wildcard_pattern_data import testcases
def isMatch(sequence, pattern):
    seq_size = len(sequence)
    pat_size = len(pattern)
    dp = [[False] * (pat_size + 1) for _ in range(seq_size + 1)]
    dp[0][0] = True
    for j in range(1, pat_size + 1):
        if pattern[j - 1] == '*':
            dp[0][j] = dp[0][j - 1]

    for i in range(1, seq_size + 1):
        for j in range(1, pat_size + 1):
            if pattern[j - 1] == '*':
                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
            elif pattern[j - 1] == '?' or sequence[i - 1] == pattern[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]

    return dp[seq_size][pat_size]


def main():

    for i, tc in enumerate(testcases):
        sequence, pattern = tc
        pattern = '*' + pattern + '*'
        print(f"Testcase {i + 1} : {'포함' if isMatch(sequence, pattern) else '불포함'}")
        print()

if __name__ == '__main__':
    main()
```
