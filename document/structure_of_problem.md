# 문제의 구조

---

## 2, 4, 8, 16, ... 수열의 일반항을 구하는 문제

- 문제의 구조 : 수열의 일반항을 구하는 문제
- 구조 크기의 기준 : 항의 순서
- 상위 구조와 하위 구조의 관계 : 하위 항에 2를 곱하면 상위 항이 된다.
- 가장 간단한 구조 : 첫 번째 항 (2)
- 점화식 : $a_n = a_{n - 1} \times 2 \,\,(n > 1)$, $a_1=2$
- 각 하위 구조의 문제를 사용해 상위 구조를 계산할 수 있으므로 최적 부분 구조를 가지고 있는 문제이다.

## 퀵 정렬

- 문제의 구조 : 정렬된 리스트를 구하는 문제
- 구조 크기의 기준 : 리스트의 길이
- 상위 구조와 하위 구조의 관계 : 값이 작은 하위 리스트, 선택된 값, 값이 큰 하위 리스트를 합치면 상위 리스트가 된다.
- 가장 간단한 구조 : 크기가 1 또는 0인 리스트
- 점화식 : `List(n, [condition])`는 크기가 `n`인 `condition`을 만족하는 리스트이며, `concatenate[...]`는 리스트를 순서대로 이어 붙이는 연산이다.
    - `List(n, [every elements]) = concatenate(List(i, [element for all element < p]), [p], List(j, [element for all element > p])`, $i + j + 1 = n$
    - `List(1, [element]) = [element]`
    - `List(0, []) = []`
- 하위 문제를 구성하는 리스트가 p에 의해서 완전히 분리되어 있으므로, 하위 문제 간에는 겹치지 않는다. 이에 따라 하위 문제를 취합해서 상위 문제를 해결할 수 있으므로 최적 부분 구조를 가지고 있는 문제이다.

## 병합 정렬

- 문제의 구조 : 정렬된 리스트를 구하는 문제
- 구조 크기의 기준 : 리스트의 길이
- 상위 구조와 하위 구조의 관계 : 하위 리스트를 항목의 순서가 유지되도록 합치면 상위 리스트가 된다.
- 가장 간단한 구조 : 크기가 1 또는 0인 리스트
- 점화식 : `List(n, [])`는 크기가 n인 리스트 []이며 `Merge(L1, L2)`는 두 리스트에서 값의 순서를 고려해서 합치는 연산이다. 
    - `List(n, []) = Merge(List(n/2, []), List(n/2, []))`
    - `List(1, []) = []`
    - `List(0, []) = []`
- 하위 문제를 구성하는 두 리스트는 서로 독립된 상태에서 병합해서 상위 리스트를 구성할 수 있다. 그러므로 최적 부분 구조를 가지고 있는 문제이다.

## 하노이의 탑의 원판을 옮기는 횟수를 구하는 문제

- 문제의 구조 : 탑을 순서를 유지하면서 옮기는 문제
- 구조 크기의 기준 : 원판의 수
- 상위 구조와 하위 구조의 관계 : 상위 구조의 문제에서 가장 큰 원판을 제외한 나머지가 하위 구조의 문제이다.
- 가장 간단한 구조 : 하나의 원판으로 이루어진 하노이의 탑
- 점화식 
    - `T(n) = 2 *  T(n - 1) + 1` ($n > 1$)
    - `T(1) = 1`
- 하위 문제 하나만으로 상위 문제를 구성할 수 있으므로 최적 부분 구조를 가지고 있는 문제이다.

## 이전 트리의 중위 순회 탐색

- 문제의 구조 : 트리를 탐색하는 문제
- 구조 크기의 기준 : 트리의 루트 노드로부터의 거리 (거리가 멀 수록 하위 문제이다.)
- 상위 구조와 하위 구조의 관계 : 하위 구조의 문제에서의 노드는 상위 구조의 문제에서의 노드의 자식 노드이다.
- 가장 간단한 구조 : 자식 노드가 없는 리프 노드
- 점화식 : `concatenate(...)`는 탐색 결과를 취합하는 함수이고 `S(node)`는 중위 탐색의 표현이다.
    - `S(node) = concatenate(S(node.left_child), node.data, S(node.right_child))`
    - `S(node) = None` if `node == None`
- 문제를 구성하는 왼쪽 서브 트리와 오른쪽 서브 트리는 완전히 독립적으로 구성되어 있다. 그러므로 최적 부분 구조를 가지고 있는 문제이다.



- 서울에서 부산 사이의 최장 경로는 서울 - 춘천 - 대구 - 대전 - 광주 - 부산을 연결하는 930km의 경로이다.
- 서울과 부산 사이의 최장 경로 사이에 있는 도시는 순서대로 춘천 - 대구 - 대전 - 광주 4개의 도시이다.
- 대구와 대전사이의 모든 경로는 다음과 같다.

|경로|거리|
|--|--|
|대전 - 대구|140km|
|대전 - 서울 - 춘천 - 대구|520km|
|대전 - 광주 - 부산 - 대구|540km|
|대전 - 광주 - 부산 - 경주 - 대구|560km|

- 대구와 대전 사이의 최장 경로는 대전 - 광주 - 부산 - 경주 - 대구를 연결하는 560km의 경로이다. 

|서울 부산 사이의 최장 경로의 각 구간|각 구간의 최장 경로|최장 거리|
|-|-|-|
|서울 - 춘천|서울 - 대전 - 광주 - 부산 - 경주 - 대구 - 춘천|1000km|
|춘천 - 대구|춘천 - 서울 - 대전 - 광주 - 부산 - 경주 - 대구|800km|
|대구 - 대전|대구 - 경주 - 부산 - 광주 - 대전|560km|
|대전 - 광주|대전 - 서울 - 춘천 - 대구 - 경주 - 부산 - 광주|920km|
|광주 - 부산|광주 - 대전 - 서울 - 춘천 - 대구 - 경주 - 부산|810km|

- 서울과 부산 사이의 최장 경로를 구성하는 단위 구간의 최장 거리의 합 : 4090km
- 최장 경로를 구하는 문제는 가장 간단한 하위 문제의 합으로 해결할 수 없다.

## 최장 경로를 구하는 문제가 하위 문제를 사용해 해결할 수 없는 이유

- 대전 - 대구 사이의 최장 경로는 서울 - 부산 사이의 최장 경로에 포함되지 않는다.
- 최장 경로를 구하는 문제는 같은 구조를 가진 하위 문제는 존재하지만, 그 문제가 상위 문제의 부분집합이라고는 할 수 없다.
