# 단계 3. 수와 논리

## 스토리

! 스토리 추가

---

# 문제 1. 소수를 찾아라!
## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

진화를 연구하는 닥터 E는 유전자만 확인하면 두 생물이 같은 조상을 가지고 있다는 것을 확인할 수 있는 방법을 찾기 위해서 온갖 시뮬레이션을 거듭하고 있다. 두 생물의 유전자를 비교할 때 비교 회수를 줄이기 위해서 '소수'에 해당하는 길이의 유전자 패턴을 비교해 보기로 한 닥터 E는 특정 숫자 까지의 소수의 목록을 만들고 있었다.

닥터 E에게 이 정도는 굳이 프로그래밍 게시판의 도움을 받을 필요가 없었다. 다음과 같이 소수를 구하기로 했다.

> * 2부터 n 까지 각 수에 대해서 2부터 그 수의 제곱근까지 나눠보며 소수인지를 판별한다.

이 방법을 통해서 모든 소수를 구할 수는 있었지만, 천만 이하의 모든 소수를 구하는데 정말 오랜 시간이 걸렸다. 좀 더 빠르게 구할 수 있는 방법이 없을까 고민하던 닥터 E는 결국 프로그래밍 지원 게시판의 도움을 청하게 되었다.

## 수행목표
- 어떤 수 n(2 이상의 양의 정수)가 주어졌을 때, n이하의 모든 소수(prime number)를 빠르게 찾는 함수를 구현한다.
- 이 함수를 사용해 천만 이하의 모든 소수를 찾고, 이를 지시한대로 가공해 출력한다.

## 수행단계

- 소수는 양의 정수 중 1과 자기 자신 이외의 약수를 가지지 않는 수를 말한다. 우선 닥터 E의 아이디어를 구현한 후, 10000000이하의 모든 소수를 구하는데 필요한 실행 시간을 측정한다.
- 소수의 성질을 사용해 주어진 수 n 이하의 모든 소수의 리스트를 반환하는 함수를 number/prime_numbers.py 파일에 구현한다.
  - 이 함수의 시간 복잡도는 닥터 E가 제시한 방법보다 더 작아야 한다. 참고로 일반적인 n에 대해서 n 이하의 모든 소수를 구하는 가장 빠른 알고리즘은 $\mathcal O( n/ \log \log n)$으로 알려져 있고, 출제자가 원하는 시간 복잡도는 $\mathcal O(n \log \log n)$ 수준이다. 천만 이하의 모든 소수를 구할 때, 닥터 E의 아이디어로 100초 정도 걸리는 환경에서라면, 구현한 결과는 대략 2초 내외에서 답을 얻을 수 있어야 한다.

- 1000 이하의 모든 소수와 3000000 이하의 모든 소수의 목록을 구한 후, 각각에 대해 소수의 개수 및 모든 소수의 합을 실행 시간과 함께 출력한다.

## 결과 예시
```
prime_numbers_fast 수행 시간 - 0.00011205673217773438 초
1000 이하의 모든 소수는 168개이며, 소수의 합은 76127 입니다.
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- n이하의 소수의 개수가 k개라고 할 때, $k < (n + 1) / \ln n$으로 알려져 있다. $f(n) = (n + 1) / \ln n$이라고 할 때, 공간 복잡도가 $\mathcal O (f(n))$인 n 이하의 소수를 모두 구하는 함수를 구현하라.
  - 공간 복잡도를 제한함으로써 이 프로그램의 실행 시간은 조금 더 걸리게 되겠지만, 기본적으로 동일한 아이디어에서 공간을 절약하는 방법을 제시해야 한다.


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/prime_numbers.py 파일에 구현이 되어 있는지 확인한다.
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 시간은 10000000 이하의 모든 소수를 구하는데 일반적인 시스템에서 3초 이내로 결과를 확인할 수 있어야 한다. 만약 에라토스테네스의 채 또는 이에 준하는 방식으로 구현하였다면 이 정도 시간 내에 결과를 확인할 수 있다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    prime_numbers_fast 수행 시간 - 0.00011205673217773438 초
    1000 이하의 모든 소수는 168개이며, 소수의 합은 76127 입니다.
    prime_numbers_fast 수행 시간 - 1.6674668788909912 초
    10000000 이하의 모든 소수는 664579개이며, 소수의 합은 3203324994356 입니다.
    ```

### [보너스 과제 확인]

* 공간 효율적인 소수의 목록을 구하는 함수를 구현하였는가?

  * 소수를 구하는데 필요한 공간이 n에 따라 선형적으로 증가하지 않도록 구현하였는지 확인한다.

  * 실행 시간은 원래의 구현보다 조금 더 걸릴 수 있지만, 최대 3배 이상은 걸리지 않는 것이 정상적이다.

  * 결과는 다음과 같다.

    ````
    prime_numbers_fast 수행 시간 - 0.00011110305786132812 초
    1000 이하의 모든 소수는 168개이며, 소수의 합은 76127 입니다.
    prime_numbers_fast 수행 시간 - 1.6865458488464355 초
    10000000 이하의 모든 소수는 664579개이며, 소수의 합은 3203324994356 입니다.
    공간 효율적으로 구현한 경우
    prime_numbers_with_small_memory 수행 시간 - 4.216782093048096 초
    10000000 이하의 모든 소수는 664579개이며, 소수의 합은 3203324994356 입니다.
    ````

    

### [문제에 대한 이해]

- 닥터 E의 아이디어와 구현에 사용한 아이디어를 비교하고, 두 아이디어의 성능의 차이에 대해서도 설명하라.
- (보너스 과제를 해결한 경우)어떤 방법으로 공간을 절약하며 구현하였는지 방법을 제시하라.

### [코드 예시]

```python
import time

def execute_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 수행 시간 - {end - start} 초")
        return result
    return wrapper

@execute_time
def prime_numbers_fast(n):
    if n < 2:
        return []
    sieve = [True] * (n + 1)
    sieve[0] = False
    sieve[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if sieve[i] == True:
            for j in range(i + i, n + 1, i):
                sieve[j] = False
    return [i for i in range(2, n + 1) if sieve[i] == True]

def prime_numbers_with_segment(start, end, primes = None):
    if primes == None:
        primes = []
    if start == 0:
        if end < 2:
            primes == 0
            return        
        sieve = [True] * (end + 1)
        sieve[0] = False
        sieve[1] = False
        for i in range(2, int(end ** 0.5) + 1):
            if sieve[i] == True:
                for j in range(i + i, end + 1, i):
                    sieve[j] = False
        for i in range(2, end + 1):
            if sieve[i] == True:
                primes.append(i)
        return    
    number_cnt = end - start + 1
    sieve = [True] * (number_cnt)
    for prime in primes:        
        check_start = (start // prime) * prime
        if check_start < start:
            check_start += prime
        for i in range(check_start, end + 1, prime):
            sieve[i - start] = False
    for i in range(number_cnt):
        if sieve[i] == True:
            primes.append(i + start)

import math
@execute_time
def prime_numbers_with_small_memory(n):
    step_size_by_number = int((n) / math.log(n, 2))
    start = 0
    result = []
    while True:
        if start + step_size_by_number > n:
            prime_numbers_with_segment(start, n, result)
            break
        prime_numbers_with_segment(start, start + step_size_by_number - 1, result)
        start += step_size_by_number
    return result

@execute_time
def prime_numbers_slow(n):
    result = []
    if n < 2:
        return result
    for i in range(2, n + 1):
        is_prime = True
        for j in range(2, int(i ** 0.5 + 1)):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            result.append(i)
    return result

import hashlib
def hash4(prime_list: list):
    prime_list.sort()
    print(prime_list)
    return hashlib.sha256(str(prime_list).encode()).hexdigest()[:4]

def main():
    target = 1000
    primes = prime_numbers_fast(target)
    print(f"{target} 이하의 모든 소수는 {len(primes)}개이며, 소수의 합은 {sum(primes)} 입니다.")    
    target = 10000000
    primes = prime_numbers_fast(target)    
    print(f"{target} 이하의 모든 소수는 {len(primes)}개이며, 소수의 합은 {sum(primes)} 입니다.")    
    print("공간 효율적으로 구현한 경우")
    primes = prime_numbers_with_small_memory(target)
    print(f"{target} 이하의 모든 소수는 {len(primes)}개이며, 소수의 합은 {sum(primes)} 입니다.")    

if __name__ == "__main__":
    main()


```

---

# 문제 2. 소인수 분해

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

요즘의 첨단 기술 연구는 연구의 질적인 부분만 신경쓸 수 없다. 신경써야 하는 많은 요소 중에 데이터의 보안도 매우 중요하다. K 바이오 연구소에서는 모든 데이터를 암호화해서 보관하고 있다.

데이터를 암호화할 때 가장 중요한 부분은 데이터를 복원의 난이도이며, 일반적인 암호화 기술에서 이 난이도는 소인수 분해를 얼마나 빨리 하느냐에 따라 그 난이도가 결정된다. 온갖 괴팍한 행동으로 매드 사이언티스트라는 별명을 가진 닥터 O는 연구소의 암호화 방식의 안전성이 궁금해졌다. 닥터 O는 연구소의 암호화 방식을 확인한 후, 이를 복원하는 난이도를 확인하는 작업에 들어갔다.

## 수행목표

- 어떤 수 n이 주어졌을 때, 이 수를 소인수 분해하는 함수를 구현한다.

## 수행단계

- 소인수 분해에 대해서 조사한다.
- 어떤 수를 소인수 분해하는 함수를 number/factorization.py 파일에 구현한다.
- 1000이상 10000이하의 정수를 소인수 분해 한 후, 소인수 분해를 밑의 오름차순 지수 형태의 곱으로 나타낼 때의 밑과 지수 각각을 이어붙여 만든 숫자를 모두 더해서 출력한다.  예시는 다음과 같다.
  - 2940을 소인수 분해하면 $2 \times 2 \times 3 \times 5 \times 7 \times 7 = 2^2 \times 3^1 \times 5^1 \times 7^2$이고, 이를 23572112로 표현한다.
  - 1024은 $2^{10}$이고, 이를 210으로 표현한다. 


## 결과예시
- 다음 결과는 1000이상 1010에 대한 결과이다.
	- 2533, 71113111, 23167111, 175911, 225121, 3567111을 더한 결과이다.
```
1000 이상 1005 이하의 정수를 소인수 분해 한 결과를 사용해서 만든 수를 모두 더하면 98250898입니다.
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 암호를 위한 소인수 분해는 매우 큰 두 소수의 곱으로 만들어진 수백 자리의 숫자를 소인수 분해를 빠르게 할 수 있어야 한다. 이를 위해서 어떤 수를 $a \times b$로 나타낼 때, a와 b의 차이가 가장 작은 a와 b를 빠르게 구하는 방법이 필요하다. 주어진 수가 홀수이고 a, b가 반드시 소수라는 조건이 없을 때, 주어진 수에서 a, b의 쌍을 찾는 함수를 구현하고, 100000000이상 100000019 이하의 홀수에 대해서 a와 b, 그리고 그 차를 출력하라. ($a \leq b$)

  - 홀수인 모든 정수에 대해서 $n=a^2-b^2$인 두 정수 a, b가 반드시 존재한다. 이 특성을 사용해보자.

  - 결과 예시는 다음과 같다.

    ```
    100000001을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 17와 5882353이며, 그 차이는 5882336입니다.
    (이하 생략)
    ```

    


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/factorization.py 파일에 구현이 되어 있는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    1000 이상 10000 이하의 정수를 소인수 분해 한 결과를 사용해서 만든 수를 모두 더하면 5974465885091입니다.
    ```

### [보너스 과제 확인]

* 지시한 대로 구현하였는가?

  * $n = a^2 - b^2 = (a + b)(a - b)$라는 조건을 사용해서 최대한 큰 a부터 차례로 확인해 두 수의 조합을 찾아냈는지 확인한다.

* 결과는 정확한가?

  * 출력 예시는 다음과 같다.

    ```
    100000001을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 17와 5882353이며, 그 차이는 5882336입니다.
    100000003을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 643와 155521이며, 그 차이는 154878입니다.
    100000005을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 105와 952381이며, 그 차이는 952276입니다.
    100000007을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 1와 100000007이며, 그 차이는 100000006입니다.
    100000009을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 149와 671141이며, 그 차이는 670992입니다.
    100000011을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 6031와 16581이며, 그 차이는 10550입니다.
    100000013을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 827와 120919이며, 그 차이는 120092입니다.
    100000015을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 5와 20000003이며, 그 차이는 19999998입니다.
    100000017을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 9243와 10819이며, 그 차이는 1576입니다.
    100000019을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 7와 14285717이며, 그 차이는 14285710입니다.
    ```

    

### [문제에 대한 이해]

- 소인수 분해란 무엇인가?
- 어떤 수를 소인수로 분해하는데 사용한 방법을 설명하라.
- 보너스 과제에 소개한 두 수의 곱을 찾는 방법은 페르마의 분해법이라고 부른다. 이 방법을 사용해서 소인수 분해를 한다면, 어떤 방식으로 소인수 분해를 할 수 있을까?
- (보너스 과제를 해결한 경우)어떤 방식으로 가장 가까운 두 수의 곱을 찾아내었는지 설명하라.
- (보너스 과제를 해결한 경우)아주 큰 두 소수의 곱으로 만들어진 수백자리의 숫자를 소인수 분해할 때, 이 방법이 효과적인 이유를 설명하라.

### [코드 예시]

```python
import math

def find_closest_divisors(n):
    a = math.ceil(math.sqrt(n))
    b_square = a * a - n
    b = int(math.sqrt(b_square))
    while b * b != b_square:
        a += 1
        b_square = a * a - n
        b = int(math.sqrt(b_square))
    small_divisor = a - b
    large_divisor = a + b
    return small_divisor, large_divisor

def prime_numbers_fast(n):
    if n < 2:
        return []
    sieve = [True] * (n + 1)
    sieve[0] = False
    sieve[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if sieve[i] == True:
            for j in range(i + i, n + 1, i):
                sieve[j] = False
    return [i for i in range(2, n + 1) if sieve[i] == True]

def factorization(n):
    upper_bound = int(math.sqrt(n))
    primes = prime_numbers_fast(upper_bound)
    result = []
    for prime in primes:
        while n % prime == 0:
            result.append(prime)
            n //= prime
    if n != 1:
        result.append(n)
    return result

def main():
    start = 1000
    end = 10000
    result = 0
    for i in range(start, end + 1):
        factors = factorization(i)
        factors.sort()
        base = ''
        upper = ''
        before = -1
        before_upper = 0
        for j in factors:
            if before != j:
                if before != -1:
                    base += str(before)
                    upper += str(before_upper)
                before = j
                before_upper = 1
            else:
                before_upper += 1
        base += str(before)
        upper += str(before_upper)
        result += int(base + upper)
    print(f"{start} 이상 {end} 이하의 정수를 소인수 분해 한 결과를 사용해서 만든 수를 모두 더하면 {result}입니다.")
    
    for i in range(1, 20 ,2):
        n = 100000000 + i
        small_divisor, large_divisor = find_closest_divisors(n)
        print(f"{n}을 두 수의 곱셈으로 나타낼 때 가장 가까운 두 조합은 {small_divisor}와 {large_divisor}이며, 그 차이는 {large_divisor - small_divisor}입니다.")

if __name__ == '__main__':
    main()

```

---

# 문제 3. 입력 신호의 패턴의 전체 수를 찾아라.

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

신경의 신호 전달을 연구하고 있는 N 연구원은 다양한 신호 강도의 입력 패턴에 따른 신경 세포의 반응을 실험하고 있다. 이를 위해서 정해진 횟수 만큼 입력 전기의 세기를 추가하고 줄일 수 있는 모든 입력 신호 패턴에 대한 반응 결과를 기록하고 있다.

실험을 위해서 현재의 설정의 총 몇 개의 패턴이 존재하는지 확인할 필요가 있다. N 연구원은 이를 계산하는 방법을 찾다가, 컴퓨터 프로그램으로 수를 세어보기로 결정했다.

## 수행목표

- 입력하는 값 n은 입력 전기 신호의 세기를 더하고 빼는 횟수이다. 아래 그림은 n이 2일 때와 3일 때의 생성되는 모든 입력 패턴과 생성 가능한 전체 패턴의 수를 보여준다.

	![image-20240112184255620](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240112184255620.png)
	
- 입력 신호의 조절은 다음과 같은 특성을 가진다.

  - 시작할 때 보다 더 낮은 세기의 신호를 입력할 수 없다.
  - 마지막에는 반드시 입력할 때와 동일한 수준의 신호로 마무리된다.
  - 입력하는 n은 신호를 더하고 빼는 각각의 횟수이다. 즉 n = 2라는 의미는 신호의 세기를 두 번 증가시킬 수 있고, 두 번 감소시킬 수 있다는 의미이다.

- 양의 정수 n에 대해서 생성 가능한 모든 패턴의 수를 계산해 출력하는 함수를 구현한다.

- n이 1이상, 10 이하일 때 각각의 경우의 전체 패턴의 수를 출력한다.

## 수행단계

- 입력 전기 신호를 더하고 빼는 순서에 따라 달라지는 전체 패턴의 개수를 계산해 반환하는 함수를 number/input_pattern.py 파일에 구현한다.
  - 재귀 호출을 사용해서 구현한다.

- n = 1, 2, ..., 10일 때 구현한 함수를 사용해 전체 패턴의 수를 출력한다.

## 결과예시

```
n = 1일 때의 전체 패턴의 개수 : 1
n = 2일 때의 전체 패턴의 개수 : 2
n = 3일 때의 전체 패턴의 개수 : 5
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 실무에서 사용할 프로그램을 작성하거나 알고리즘 문제를 해결할 때 수학지식을 사용해 하나의 공식으로 해결할 수 있는 경우, 실행 시간을 크게 줄일 수 있다는 장점이 있다. 이 문제를 알고리즘 문제가 아닌 '수학' 문제로 가정하고 주어진 n에 대해서 만들 수 있는 모든 입력 신호 패턴의 수를 계산하는 과정을 정리한 후, 파이썬 함수로 구현한다.
  - 계산하는 과정을 설명할 수 있어야 한다.

- n = 100일 때의 결과를 출력한다.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/input_pattern.py 파일에 구현이 되어 있는지 확인한다.
  - 재귀 호출을 사용해 문제를 해결하고 있는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    n = 1일 때의 전체 패턴의 개수 : 1
    n = 2일 때의 전체 패턴의 개수 : 2
    n = 3일 때의 전체 패턴의 개수 : 5
    n = 4일 때의 전체 패턴의 개수 : 14
    n = 5일 때의 전체 패턴의 개수 : 42
    n = 6일 때의 전체 패턴의 개수 : 132
    n = 7일 때의 전체 패턴의 개수 : 429
    n = 8일 때의 전체 패턴의 개수 : 1430
    n = 9일 때의 전체 패턴의 개수 : 4862
    n = 10일 때의 전체 패턴의 개수 : 16796
    ```

### [보너스 과제의 확인]

* 문제의 수학적 구조를 사용해 해답을 구하는 함수를 구현하고, 결과를 정확하게 출력하였는가?

  * 이 문제를 수학적으로 해결하는 방법은 조합론을 사용해 카탈란 수를 구하는 방법이다.

  * 만약, 이 방법을 해결하는데 '카탈란 수를 구한다'로 답을 하는 경우 보너스 과제를 해결한 것으로 인정하지 않는다.

    * 조합론적 접근을 포함해 이 값을 수하는 수학적 유도 과정을 제시한 경우에 이를 정답으로 인정한다.

  * 결과는 다음과 같다.

    ```
    n = 100일 때의 전체 패턴의 개수 : 896519947090131496687170070074100632420837521538745909320
    ```

    

### [문제에 대한 이해]

- 재귀 호출을 사용해 이 문제를 해결하는 알고리즘을 설명하라.
- 구현한 알고리즘의 시간 복잡도를 근거를 사용해 추정해보라.
- (보너스 과제를 해결한 경우)이와 같이 해결하는 수학적 유도 과정을 설명하라.
  - 여러가지 방법이 존재한다.
  - 주어진 n에 대한 패턴의 수를 $F$라고 표현할 때, 이 패턴을 구성 가능한 경우를 패턴의 조합으로 나누고 더해서 점화식을 구할 수 있다. ($F=F_0F_{n-1} + F_1F_{n-2}+...+F_{n-1}F_0$)
  - 전체 조합에서 유효하지 앟은 조합을 빼는 방식으로도 접근할 수 있다. ($F=_{2n}\mathcal C_{n} - _{2n}\mathcal C_{n + 1}$)
  

### 코드 예시

```python
def factorial(n):
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)

def binomial_coefficient(n, k):
    return factorial(n) // (factorial(k) * factorial(n - k))

def catalan_number(n):
    return binomial_coefficient(2 * n, n) // (n + 1)

def pattern_cnt(change_remain, current_level = 0):
    if change_remain == 0:
        return 1
    result_from_minus = 0
    if current_level > 0:
        result_from_minus = pattern_cnt(change_remain, current_level - 1)
        if result_from_minus == -1:
            return -1
    result_from_plus = pattern_cnt(change_remain - 1, current_level + 1)
    if result_from_plus == -1:
        return -1
    return result_from_minus + result_from_plus

def main():
    for i in range(1, 11):
        print(f"n = {i}일 때의 전체 패턴의 개수 : {pattern_cnt(i)}")
    print(f"n = 100일 때의 전체 패턴의 개수 : {catalan_number(100)}")

if __name__ == '__main__':
    main()
```

---

# 문제 4. 원주율을 구하라.

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

K 바이오 연구소는 여러 외국의 연구소와 제휴하고 있다. 다음 상황은 K 바이오 연구소와 교류하는 어떤 나라의 생명공학 연구소에서 발생한 상황이다.

어떤 닥터 V가 연구하는 특이한 세균을 그 나라의 생명공학 연구소에서도 관심을 가지고 연구하고 있었다. (과정2의 '최후의 승자는?' 문제 참고) 이 세균은 여러 개체가 모이면 완벽한 원을 그리고 숙주를 둘러싸는 독특한 행동 패턴을 보이고 있기 때문에, 이를 현미경으로 관찰한 후, 이 원의 지름을 측정하면 원주의 길이를 구할 수 있고 세균 하나의 크기를 바탕으로 총 몇 마리의 세균이 여기에 모였는지를 추정할 수 있다. 반대로, 다른 값들을 알면 세균 모두가 이 숙주를 중심으로 둘러싸는 행동 패턴을 가지고 있는지를 알 수도 있다.

문제는, 이 나라는 교육과정에서 원주의 길이를 구하기 위한 파이($\pi$)의 값을 대충 3으로 가르키고 있다는 점이었다. 연구원 누군가는 조금 더 상세한 값을 알 수도 있었건만 불행히도 모인 사람들 중에는 이 값을 아는 사람이 아무도 없었다.

뭔가 말도 안되는 상황이 벌어지긴 했지만, 어딘가에는 이해되지 않는 상황이 발생할 수도 있는 법이다. 여튼, 누군가는 이 문제를 해결해야 하는 상황이었다.

## 수행목표

- '시뮬레이션' 방식으로 원주율을 구하는 함수를 구현한다.
- 1000000번 반복한 시뮬레이션을 통해서 구한 원주율을 출력한다. 

## 수행단계

- 다음 정보를 바탕으로 원주율 $\pi$를 구하는 시뮬레이션을 설계한다.
  - 면적이 $s_a$인 영역 A가 있다.
  - 영역 A의 내부에 완전히 포함되는 영역 B가 있고, B의 면적은 $s_b$이다.
  - 이 때 영역 A에 임의의 한 점을 찍었을 때, 이 점이 영역 B에 속할 확률은 $\frac {s_b}{s_a}$이다.

- 설계한 시뮬레이션을 주어진 회수 n번 반복해서 원주율 $\pi$의 근사값을 구하는 함수를 number/find_pi.py 파일에 구현한다.
- n = 10, 100, 1000, 10000, 100000, 1000000, 10000000일 때 구한 원주율 $\pi$의 근사치를 출력한다.

## 결과 예시

```
10번 반복한 시뮬레이션에서 pi의 근사값 : 3.2
100번 반복한 시뮬레이션에서 pi의 근사값 : 3.4
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 임의의 함수 `f(x)`는 `x`가 0과 1 사이의 임의의 실수일 때, 항상 값을 구할 수 있는 함수이다. 예를 들어서 $f(x) = x^2$인 경우, 다음과 같이 함수가 정의된다.

  ```python
  def f(x):
    return x ** 2
  ```

- 이 임의의 함수에 대해서 $\int_{0}^{1} f(x) \, dx$값의 근사값을 정해진 횟수 n번의 반복 시뮬레이션으로 구하는 함수를 구현한다.

  - 이 함수는 반복 횟수와 함수를 파라미터로 받는다.

- 다음 2개의 함수에 대해서, 이 함수의 결과를 n = 10, 100, 1000, 10000, 100000, 1000000, 10000000번 반복한 결과를 출력한다.

  - $f(x) = x^2$
  - $f(x) = e^x$


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/find_pi.py 파일에 구현이 되어 있는지 확인한다.
  - 몬테카를로 시뮬레이션 등 반복 시뮬레이션을 통해 근사값을 구했는지를 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 값은 원주율 (3.141592...)와 유사한 값이 나와야 한다.

    ```
    10번 반복한 시뮬레이션에서 pi의 근사값 : 3.2
    100번 반복한 시뮬레이션에서 pi의 근사값 : 3.4
    1000번 반복한 시뮬레이션에서 pi의 근사값 : 3.2
    10000번 반복한 시뮬레이션에서 pi의 근사값 : 3.1508
    100000번 반복한 시뮬레이션에서 pi의 근사값 : 3.14628
    1000000번 반복한 시뮬레이션에서 pi의 근사값 : 3.140296
    10000000번 반복한 시뮬레이션에서 pi의 근사값 : 3.1417912
    ```

### [보너스 과제의 확인]

* 지시한 대로 구현하였는가?

  * 몬테카를로 시뮬레이션 등 반복 시뮬레이션을 통해 정적분의 근사값을 구했는지를 확인한다.

* 적절한 근사치를 출력하였는가?

  * 결과는 다음과 같다. 값은 0.33333..., 1.171828...에 가까운 근사값으로 출력되어야 한다.

    ```
    10번 반복한 시뮬레이션에서 pi의 근사값 : 3.2
    10번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.5500721179178474
    10번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.4492977677230885
    100번 반복한 시뮬레이션에서 pi의 근사값 : 3.2
    100번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.2739763706032174
    100번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.7495884141066214
    1000번 반복한 시뮬레이션에서 pi의 근사값 : 3.116
    1000번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.32056474136739793
    1000번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.7118812561429846
    10000번 반복한 시뮬레이션에서 pi의 근사값 : 3.134
    10000번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.33287100052375435
    10000번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.7244660892433876
    100000번 반복한 시뮬레이션에서 pi의 근사값 : 3.13624
    100000번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.33354984684205685
    100000번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.720112470713169
    1000000번 반복한 시뮬레이션에서 pi의 근사값 : 3.139604
    1000000번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.3335768134336369
    1000000번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.7178456076707131
    10000000번 반복한 시뮬레이션에서 pi의 근사값 : 3.1425068
    10000000번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : 0.33342251486598445
    10000000번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : 1.7183020515153062
    ```

    

### [문제에 대한 이해]

- 시뮬레이션을 통해서 원주율을 구하는 과정을 설명하라.
- 실제 원주율의 값은 3.141592...로 시작하는 무리수이다. 시뮬레이션을 통해서 얻은 값과 실제 원주율의 값의 차이는 어디에서 기인하는가?
- 차이를 줄일 수 있는 방법에 대해서 설명해보자.
- (보너스 과제를 해결한 경우)함수의 정적분을 시뮬레이션으로 해결한 방법에 대해서 설명하라.

### [코드 예시]

```python
import random

def pi_simulation(n):
    cnt = 0
    for _ in range(n):
        x = random.random()
        y = random.random()
        if x ** 2 + y ** 2 <= 1:
            cnt += 1
    return 4 * cnt / n

def integral_simulation(n, func):
    start = 0
    end = 1
    sum = 0
    for _ in range(n):
        x = random.uniform(start, end)
        sum += func(x)
    return (end - start) * sum / n

import math
def main():
    end = 7
    func1 = lambda x: x ** 2
    func2 = lambda x: math.e ** x
    for i in range(1, end + 1):
        print(f"{10 ** i}번 반복한 시뮬레이션에서 pi의 근사값 : {pi_simulation(10 ** i)}")
        print(f"{10 ** i}번 반복한 시뮬레이션에서 y = x^2의 0에서 1사이의 정적분 값의 근사값 : {integral_simulation(10 ** i, func1)}")
        print(f"{10 ** i}번 반복한 시뮬레이션에서 y = e^x의 0에서 1사이의 정적분 값의 근사값 : {integral_simulation(10 ** i, func2)}")

if __name__ == '__main__':
    main()

```

---

# 문제 5. 텔로미어 복제 매커니즘을 검증하자.

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

유전자 서열의 마지막에 위치한 반복적인 DNA 서열을 텔로미어라고 부른다. 이 부분은 유전 정보의 내용과 무관한 반복적인 내용으로 채워져 있으므로, 과거에는 의미없는 자리 채우기 역할만 한다고 추정되었으나, 최신 연구 결과 안정적인 DNA 복제에 기여하며 세포 분열이 반복될 수록 짧아지는 특성이 있어 생물의 노화와 관련이 있다는 증거가 발견되고 있다.

생물의 노화 현상을 연구하는 닥터 A는 DNA의 텔로미어 부분을 인공적으로 복제하는 방법을 찾고 있다. 닥터 A가 오랜 연구끝에 텔로미어 인공 자가복제 매커니즘에 대한 아이디어를 발견했는데, 이 아이디어를 통해서 텔로미어를 다음과 같이 복제할 수 있을 것으로 추정했다.

> - 한 번 복제하면 입력 패턴의 길이만큼 반복해 복제한다.
> - 예를 들어서 일반적인 텔로미어의 염기서열은 `TTAGGG`가 반복되는데, 이 여섯개의 염기로 이루어진 서열을 닥터 A의 매커니즘으로 복제하면 `TTAGGG`가 6번 반복되는 길이 36의 텔로미어가 생성된다.
> - 다시 한 번 반복하면 36의 텔로미어가 36번 반복되는 길이 $36^2 = 6^4 = 1296$의 텔로미어가 생성된다.

이 매커니즘이 정상적으로 동작하려면, 복제된 유전자를 해독해서 복제 회수에 따른 길이의 예측값과, 입력 패턴이 마지막까지 반복되는지를 확인하면 된다. 하지만 이 매커니즘을 5번만 반복해도 $6^{32} = 7958661109946400884391936$라는 어마어마한 길이의 패턴이 생성되기 때문에 해독하는데 걸리는 시간이 너무 길어진다는 문제가 있었다. 반면, 닥터 A는 여러번 반복해서 복제해도 안정적으로 매커니즘이 동작한다는 것을 입증하고 싶었기 때문에 반복 횟수를 늘리면 늘렸지 줄이고 싶은 생각은 추호도 없었다.

그래서 유전자 전체를 해독하기 전에, 빠른 사전 조사를 위해서 복제된 텔로미어를 정해진 길이만큼 앞에서부터 차례로 잘라서 버리고 최종적으로 남은 부분의 유전자 염기서열을 확인해보기로 했다. 예를 들어서 두 번 복제한 1296 길이의 텔로미어를 길이 23씩 잘라서 버리는 과정을 반복하면 마지막에는 길이 8인 DNA가 남고, 이 DNA의 염기서열이 `GGTTAGGG`라면, 일단 첫 번째 관문은 넘어선 것으로 하자는 것이다. 

그런데, 길이가 $6^{32}$ 정도 되는 유전자를 길이 23씩 잘라서 버리는 과정을 반복하고 나면 마지막에 남은 DNA의 길이가 어떻게 될 지를 미리 예측하는 일도 절대로 쉬운 일이 아니었다. 고민 끝에 닥터 A도 프로그래밍 지원 게시판의 문을 두드리게 되었다.

## 수행목표

- 입력 패턴의 길이가 n, 복제 반복 회수가 r일 때, 생성되는 복제 패턴의 길이는 $n^{2^r}$가 된다. 이렇게 생성된 복제 패턴을 정해진 길이 d 단위로 잘라내고 남은 DNA 염기서열의 길이를 구한다. 

  - n, r, d는 모두 양의 정수이다.
  - 예를 들어서 길이(n)가 6인 패턴을 3번 복제하면(r), 생성되는 복제 패턴의 길이는 $6^{2^3}=6^{8}=1679616$이다.
  - 이 염기서열을 앞에서부터 차례로 길이 43(d)의 조각을 반복해 잘라서 버리고 나면 남은 염기서열은 1679616을 43으로 나눈 나머지인 36의 길이를 가진다.

- 다음 튜플의 리스트로 제공되는 10개의 값에 대해서 결과를 출력한다. 각 튜플은 순서대로 n, r, d의 값이다.

  ```python
  testcases = [
      (6, 3, 43),
      (1, 1, 1),
      (1, 20, 1),
      (2, 20, 65535),
      (6, 10, 43),
      (6, 25, 43),
      (23, 19, 17),
      (81, 10, 1039),
      (33, 3, 1000000007),
      (1079, 30, 8887)
  ]
  ```

## 수행단계

- 모듈러 연산(Modular Arithmetic)에 대해서 조사한다.
- 두 수가 주어졌을 때, 두 수를 곱한 수의 모듈러 연산의 결과와 두 수의 모듈러 연산 결과의 곱의 관계에 대해서 조사한다.
- 모듈러 연산을 $a \mod b$라고 표현할 때, $n^k \mod d$를 빠르게 계산하는 함수를 number/remainder_of_telomere.py 파일에 구현한다.
- 이 함수를 사용해 제공된 테스트케이스 10개의 결과를 구하고, 이를 출력한다.

## 결과예시

```
Testcase 1의 결과 : 36
Testcase 2의 결과 : 0
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 곱셈과 모듈러 연산은 몇 가지 특징을 더 가지고 있다. 그 중 하나는 다음과 같다.
  - $n \times 0 = 0$이고, $0\mod k = 0$이므로 $a \mod k = 0$인 경우 어떤 b에 대해서도 $(a \times b)\mod k = 0$

- 이와 같은 모듈러 연산의 특징, 그리고 거듭제곱 연산의 특징을 사용하면 훨씬 더 빠르게 동작하는 함수를 구현할 수 있다. 이를 구현하고 `(n, r, k)=(1079,30,8887)`,  `(n, r, k) = (6, 1000, 43)`일 때의 결과를 출력하라.
  - 두 경우 모두 일반적인 테스트 환경에서 '눈 깜짝할 사이'에, 아무리 느린 환경에서도 1초 이내에 계산 결과를 출력해야 한다. `(n, r, k)=(1079,30,8887)`은 마지막 테스트케이스이며 기존 구현과 성능 차이를 비교해보자.


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/remainder_of_telomere.py 파일에 구현이 되어 있는지 확인한다.
  - 곱셈에 대한 모듈러 연산의 분배법칙을 사용하도록 구현이 되어 있는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    Testcase 1의 결과 : 36
    Testcase 2의 결과 : 0
    Testcase 3의 결과 : 0
    Testcase 4의 결과 : 1
    Testcase 5의 결과 : 6
    Testcase 6의 결과 : 36
    Testcase 7의 결과 : 1
    Testcase 8의 결과 : 345
    Testcase 9의 결과 : 408608399
    Testcase 10의 결과 : 135
    ```

### [보너스 과제 확인]

* 보너스 과제를 지시한대로 정확히 해결하였는가?

  * 거듭제곱과 모듈러 연산의 특수한 성질을 사용해 문제를 해결하였는지 확인한다.

  * 다음의 결과가 거의 시간 지연없이 출력되는지 확인한다.

    ```
    (n, r, k) = (1079, 30, 8887)일 때 빠른 함수의 결과 : 135
    (n, r, k) = (6, 100, 43)일 때 빠른 함수의 결과 : 6
    ```

    

### [문제에 대한 이해]

- 모듈러 연산은 무엇인가?
- 곱셈에 대한 모듈러 연산의 분배법칙에 대해서 설명하라.
- 덧셈과 뺄셈에 대해서도 모듈러 연산의 분배법칙이 성립하는가?
- 거듭제곱의 모듈러 연산을 빠르게 계산하기 위해서 사용한 방법을 설명하라.
- (보너스 과제를 해결한 경우)결과를 더 빨리 얻기 위해서 추가로 사용한 거듭제곱과 모듈러 연산의 특징은 무엇인가?

### [코드 예시]

```python
def remainder_of_telomere(n, k, d):
    return modular_of_exponatial(n, 2 ** k, d)

def modular_of_exponatial(n, k, d):
    result = 1
    for _ in range(k):
        result = (result * n) % d        
    return result

def fast_remainder_of_telomere(n, k, d):
    return fast_modular_of_exponatial(n, 2 ** k, d)

def fast_modular_of_exponatial(n, k, d):
    result = 1    
    n = n % d

    while k > 0:
        if k % 2 == 1:
            result = (result * n) % d
        k = k // 2
        n = (n ** 2) % d
    return result

  def main():
    testcases = [
        (6, 3, 43),
        (1, 1, 1),
        (1, 20, 1),
        (2, 20, 65535),
        (6, 10, 43),
        (6, 25, 43),
        (23, 19, 17),
        (81, 10, 1039),
        (33, 3, 1000000007),
        (1079, 30, 8887)
    ]
    for i, tc in enumerate(testcases):
        result = remainder_of_telomere(*tc)
        print(f"Testcase {i + 1}의 결과 : {result}")

if __name__ == '__main__':
    main()

```

---

# 문제 6. 바이오 반도체의 가능성

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

미생물을 연구하는 닥터 S는 우연히 재미있는 미생물 하나를 발견했다. 이 미생물은 두 개의 수용체를 가지고 있으며, 평소에는 특정 신호를 항상 발생시키는데, 두 개의 수용체 모두에 다른 개체에서 발생한 신호를 연결하면 발생하던 신호가 사라지는 신기한 매커니즘을 가지고 있었다.

이를 본 닥터 S는 다음과 같이 생각했다.

'어라? 이것만 있으면 반도체를 만들 수 있지 않을까?'

## 수행목표

- 논리식에서 주로 다음과 같은 표현을 사용한다.

  | 연산      | 표현  |
  | --------- | ----- |
  | `A AND B` | `AB`  |
  | `A OR B`  | `A+B` |
  | `NOT A`   | `A'`  |

- 닥터 S가 발견한 미생물은 마치 NAND 연산처럼 동작한다. `A NAND B` 연산을 `A@B`로 표시하기로 하자. 주어진 논리식을 괄호와 NAND 연산만으로 변형해서 출력하는 함수를 구현한다.

- 다음 테스트케이스에 포함된 논리식을 NAND 연산만으로 표현해 출력한다.

## 수행단계

- 논리식을 구성하는 기본 연산인 AND, OR, NOT에 대해서 조사한다.

  - 파이썬에서 AND, OR, NOT 연산의 결과는 무엇인지 확인한다.

- NAND 연산에 대해서 조사한다.

  - AND, OR, NOT 연산을 NAND 연산으로 표현하는 방법에 대해서 조사한다.

- 어떤 논리식이 문자열로 주어졌을 때 이 논리식을 괄호와 NAND 연산만으로 표현한 새로운 논리식 문자열을 반환하는 함수를 logic/convert_into_nandonly.py 파일에 구현한다.

  - 연산의 우선 순위는 괄호, NOT, 기타의 순서이다. AND와 OR가 섞여 있는 경우, 순서대로 계산한다.

- 테스트케이스로 제공된 논리식을 변형한 결과를 출력한 결과와 해당 식의 입력에 따른 진리표를 출력한다. 이 진리표는 NAND의 결과만으로 계산해야 한다. 

  - 진리표는 다음과 같은 형식의 표를 말한다. 아래 표에서 T는 True, F는 False이다.

    - `AB`
      | A    | B    | 결과 |
      | ---- | ---- | ---- |
      | T    | T    | T    |
      | T    | F    | F    |
      | F    | T    | F    |
      | F    | F    | F    |

    - `A(B'+C)`
      | A    | B    | C    | 결과 |
      | ---- | ---- | ---- | ---- |
      | T    | T    | T    | T    |
      | T    | T    | F    | F    |
      | T    | F    | T    | T    |
      | T    | F    | F    | T    |
      | F    | T    | T    | F    |
      | F    | T    | F    | F    |
      | F    | F    | T    | F    |
      | F    | F    | F    | F    |

      


## 결과예시

```
testcase 1
    입력 - A'
    변환 결과 - (A@A)
    진리표
        A 결과
        F T
        T F

testcase 2
    입력 - AB
    변환 결과 - ((A@B)@(A@B))
    진리표
        A B 결과
        F F F
        F T F
        T F F
        T T T

testcase 3
    입력 - A+B
    변환 결과 - ((A@A)@(B@B))
    진리표
        A B 결과
        F F F
        F T T
        T F T
        T T T

testcase 4
    입력 - A'A
    변환 결과 - (((A@A)@A)@((A@A)@A))
    진리표
        A 결과
        F F
        T F
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - logic/convert_into_nandonly.py 파일에 구현이 되어 있는지 확인한다.
  - 논리식을 계산하는데 nand 이외의 다른 논리연산을 수행하지 않아야 한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 

    ```
    testcase 1
        입력 - A'
        변환 결과 - (A@A)
        진리표
            A 결과
            F T
            T F
    
    testcase 2
        입력 - AB
        변환 결과 - ((A@B)@(A@B))
        진리표
            A B 결과
            F F F
            F T F
            T F F
            T T T
    
    testcase 3
        입력 - A+B
        변환 결과 - ((A@A)@(B@B))
        진리표
            A B 결과
            F F F
            F T T
            T F T
            T T T
    
    testcase 4
        입력 - A'A
        변환 결과 - (((A@A)@A)@((A@A)@A))
        진리표
            A 결과
            F F
            T F
    
    testcase 5
        입력 - A'+A
        변환 결과 - (((A@A)@(A@A))@(A@A))
        진리표
            A 결과
            F T
            T T
    
    testcase 6
        입력 - A'B'
        변환 결과 - (((A@A)@(B@B))@((A@A)@(B@B)))
        진리표
            A B 결과
            F F T
            F T F
            T F F
            T T F
    
    testcase 7
        입력 - A+B'*C
        변환 결과 - ((((A@A)@((B@B)@(B@B)))@C)@(((A@A)@((B@B)@(B@B)))@C))
        진리표
            A B * C 결과
            F F F F F
            F F F T T
            F F T F F
            F F T T T
            F T F F F
            F T F T F
            F T T F F
            F T T T F
            T F F F F
            T F F T T
            T F T F F
            T F T T T
            T T F F F
            T T F T T
            T T T F F
            T T T T T
    
    testcase 8
        입력 - (AB)(CD)
        변환 결과 - ((((A@B)@(A@B))@((C@D)@(C@D)))@(((A@B)@(A@B))@((C@D)@(C@D))))
        진리표
            A B C D 결과
            F F F F F
            F F F T F
            F F T F F
            F F T T F
            F T F F F
            F T F T F
            F T T F F
            F T T T F
            T F F F F
            T F F T F
            T F T F F
            T F T T F
            T T F F F
            T T F T F
            T T T F F
            T T T T T
    
    testcase 9
        입력 - (A+B)C(D+B)
        변환 결과 - ((((((A@A)@(B@B))@C)@(((A@A)@(B@B))@C))@((D@D)@(B@B)))@(((((A@A)@(B@B))@C)@(((A@A)@(B@B))@C))@((D@D)@(B@B))))
        진리표
            A B C D 결과
            F F F F F
            F F F T F
            F F T F F
            F F T T F
            F T F F F
            F T F T F
            F T T F T
            F T T T T
            T F F F F
            T F F T F
            T F T F F
            T F T T T
            T T F F F
            T T F T F
            T T T F T
            T T T T T
    
    testcase 10
        입력 - (A'B')'
        변환 결과 - ((((A@A)@(B@B))@((A@A)@(B@B)))@(((A@A)@(B@B))@((A@A)@(B@B))))
        진리표
            A B 결과
            F F F
            F T T
            T F T
            T T T
    
    testcase 11
        입력 - (A'+B)''+(CD'(B'+A')')'
        변환 결과 - (((((((A@A)@(A@A))@(B@B))@(((A@A)@(A@A))@(B@B)))@((((A@A)@(A@A))@(B@B))@(((A@A)@(A@A))@(B@B))))@(((((A@A)@(A@A))@(B@B))@(((A@A)@(A@A))@(B@B)))@((((A@A)@(A@A))@(B@B))@(((A@A)@(A@A))@(B@B)))))@((((((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))@(((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A))))))@((((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))@(((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))))@(((((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))@(((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A))))))@((((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))@(((C@(D@D))@(C@(D@D)))@((((B@B)@(B@B))@((A@A)@(A@A)))@(((B@B)@(B@B))@((A@A)@(A@A)))))))))
        진리표
            A B C D 결과
            F F F F T
            F F F T T
            F F T F T
            F F T T T
            F T F F T
            F T F T T
            F T T F T
            F T T T T
            T F F F T
            T F F T T
            T F T F T
            T F T T T
            T T F F T
            T T F T T
            T T T F T
            T T T T T
    
    testcase 12
        입력 - (A+B)(C+D)(A+C)(B+D)+(AD)
        변환 결과 - ((((((((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C)))@(((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C))))@((B@B)@(D@D)))@(((((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C)))@(((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C))))@((B@B)@(D@D))))@((((((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C)))@(((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C))))@((B@B)@(D@D)))@(((((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C)))@(((((A@A)@(B@B))@((C@C)@(D@D)))@(((A@A)@(B@B))@((C@C)@(D@D))))@((A@A)@(C@C))))@((B@B)@(D@D)))))@(((A@D)@(A@D))@((A@D)@(A@D))))
        진리표
            A B C D 결과
            F F F F F
            F F F T F
            F F T F F
            F F T T F
            F T F F F
            F T F T F
            F T T F T
            F T T T T
            T F F F F
            T F F T T
            T F T F F
            T F T T T
            T T F F F
            T T F T T
            T T T F T
            T T T T T
    ```

### [문제에 대한 이해]

* AND, OR, NOT 연산의 진리표를 작성해보라.
* NAND는 연산은 어떤 연산인가?
* AND, OR, NOT 각각을 NAND로 변환하는 방법을 설명하라.
* 어떤 방법으로 주어진 논리식을 변환하고, 결과를 계산하였는지 설명하라.

### [코드 예시]

```python

def is_symbol(char):
    return char not in ['+', "'", '(', ')', '*', '@']

def make_logic_eqstack(expression):
    expression = expression.strip().replace(' ', '')
    expression_with_and = ''

    for i in range(len(expression) - 1):
        expression_with_and += expression[i]
        if expression[i] == "'" or is_symbol(expression[i]):
            if expression[i + 1] == "(" or is_symbol(expression[i + 1]):
                expression_with_and += '*'
        if expression[i] == ')':
            if expression[i + 1] == '(' or is_symbol(expression[i + 1]):
                expression_with_and += '*'
    expression_with_and += expression[-1]
    stack = []
    result = []
    for char in expression_with_and:
        if char == "'":
            result.append(char)
        elif is_symbol(char):
            result.append(char)
        elif char == '(':
            stack.append(char)
        elif char == ')':
            while stack and stack[-1] != '(':
                result.append(stack.pop())
            stack.pop()
        else:
            while stack and stack[-1] != '(':
                result.append(stack.pop())
            stack.append(char)
    while stack:
        result.append(stack.pop())
    return result

def calculate_nand(op1, op2):
    if op1 and op2:
        return False
    else:
        return True

def convert_not_to_nand(operand):
    result = f"({operand}@{operand})"
    return result    

def convert_and_to_nand(operand1, operand2):
    result = f"({operand1}@{operand2})@({operand1}@{operand2})"
    return result

def convert_or_to_nand(operand1, operand2):
    result = f"({operand1}@{operand1})@({operand2}@{operand2})"
    return result

def calculate(expression, input_tf: dict):
    st = make_logic_eqstack(expression)
    result = []
    for char in st:
        if char not in ['@']:
            result.append(input_tf[char])
        else:
            operand2 = result.pop()
            operand1 = result.pop()
            result.append(calculate_nand(operand1, operand2))
    return result[0]

def converted_to_nand_only(expression):
    st = make_logic_eqstack(expression)
    changed_result = []

    for char in st:
        if char not in ['+', '*', "'"]:
            changed_result.append(char)
        else:
            if char == "'":
                operand1 = changed_result.pop()
                changed_result.append(convert_not_to_nand(operand1))
            else:
                operand2 = changed_result.pop()
                operand1 = changed_result.pop()
                if char == '+':
                    changed_result.append("(" + convert_or_to_nand(operand1, operand2) + ")")
                elif char == '*':
                    changed_result.append("(" + convert_and_to_nand(operand1, operand2) + ")")
    return changed_result[0]

def format_tf_head(str):
    result = ''
    for c in str:
        if c == '0':
            result += "F "
        elif c == '1':
            result += "T "
        else: 
            result += c + " "
    return result

def main():
    testcase = [
        "A'",
        "AB",
        "A+B",
        "A'A",
        "A'+A",
        "A'B'",
        "A+B'*C",
        "(AB)(CD)",
        "(A+B)C(D+B)",
        "(A'B')'",
        "(A'+B)''+(CD'(B'+A')')'",
        "(A+B)(C+D)(A+C)(B+D)+(AD)",
    ]

    
    for i in range(len(testcase)):
        print("testcase", i + 1)
        print(f"    입력 - {testcase[i]}")
        converted_result = converted_to_nand_only(testcase[i])
        print(f"    변환 결과 - {converted_result}")
        variables = []
        for c in testcase[i]:
            if c not in ["'", "+", "(", ")"] and c not in variables:
                variables.append(c)
        tf_case_num = 2 ** len(variables)
        print("    진리표")
        print("        " + " ".join(variables) + " 결과")
        for j in range(tf_case_num):
            j_bin_str = bin(j)[2:]
            j_bin_str = '0' * (len(variables) - len(j_bin_str)) + j_bin_str
            input_tf = {}
            for k in range(len(variables)):
                input_tf[variables[k]] = bool(int(j_bin_str[k]))
            nand_only_result = calculate(converted_result, input_tf)
            row_head = format_tf_head(j_bin_str)
            print(f"        {row_head}{'T' if nand_only_result else 'F'}")
        print()


if __name__ == "__main__"
    main()
```

---

# 문제 7. 커플 사이의 외로운 솔로

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

연구소에는 매일 수많은 횟수의 실험이 반복되며, 이를 위해서 다양한 시약을 사용한다. 실험 시 발생할 수 있는 문제의 사후 분석을 위해서 연구소는 반드시 매 실험에 사용되는 시약의 샘플을 2개씩 별도로 보관해서 관리하도록 규정하고 있다.

연구지원팀의 W 선임행정원의 업무 중에는 이렇게 제출된 시약의 샘플 목록을 관리하는 일을 하고 있다. 각 샘플은 시약의 화학적 조성에 따라 고유번호로 관리되기 때문에 이 목록에는 항상 같은 숫자가 반드시 짝수 개씩 적혀 있어야 하며, 전체 목록의 길이는 항상 짝수여야 한다. 그렇게 몇 년을 관리해오던 W 선임행정원이 우연히 이 목록이 홀수임을 알게 되었다.

시스템의 로그를 들여다보면서 어떤 문제가 있었는지 확인해보니, 시스템의 장애로 인해서 전체 목록에서 숫자 단 하나가 저장되지 않았다는 것을 알게 되었다. 하지만, 로그에 이 번호가 적혀 있지 않은 탓에 어떤 숫자가 누락되었는지 확인하기가 영 쉽지 않았다. 이미 몇 년째 쌓여있는 목록의 길이는 어마어마하게 길었지만, 시스템의 메모리가 충분치 않아서 이를 확인하는 프로그램을 만들기가 쉽지 않았기 때문이다.

그런 W 선임행정원을 지켜보던 같은 팀 지선생이 W 선임행정원에게 조언을 했다.

"비트 연산을 사용해봐."

## 수행목표

- 양의 정수로 구성된 목록이 주어진다. 이 목록은 2 * n + 1개의 숫자가 들어 있고, n개는 같은 숫자가 두 번 씩 반복해서, 그리고 나머지 하나의 숫자는 홀로 존재하는 숫자이다.
- 홀로 존재하는 숫자를 찾는 함수를 구현한다.
  - 함수의 시간 복잡도는 $\mathcal O (n)$, 함수가 추가로 사용하는 메모리의 공간 복잡도는 $\mathcal O(1)$로 구현한다.

- 1에서 1000000까지 숫자의 리스트에서 무작위의 숫자 하나만 홀로 존재하는 길이 1999999의 리스트를 생성한다. 이 리스트에 숫자들의 순서도 무작위로 섞여 있어야 한다. 이 함수를 사용해 홀로 존재하는 숫자를 찾아서 출력한다.

## 수행단계

- XOR 연산에 대해서 조사한다.
- XOR 연산의 특성을 사용해서 주어진 리스트에서 홀로 존재하는 단 하나의 숫자를 찾는 함수를 number/find_solo.py 파일에 구현한다.
  - 함수가 추가로 사용하는 메모리의 공간 복잡도가 상수 복잡도라는 의미는, 생성되어 파라미터로 전달받은 리스트 이외로 추가로 사용하는 공간의 복잡도가 상수 복잡도라는 의미이다.

- 길이가 999999인 리스트를 만든다. 이 리스트는 1에서 100000 사이의 숫자로 구성되는데, 반드시 숫자 단 하나만 홀수 번 포함되어 있고 나머지 숫자는 모두 포함되도록 생성되어야 한다. 
  - 이 리스트는 무작위 순서로 만들어져야 하며, 어떤 숫자가 홀수 번 포함되어 있는지 미리 알 수 있도록 생성한다.

- 구현한 함수를 사용해 리스트에서 홀수 번 존재하는 숫자를 찾아 이를 출력한다.

## 결과예시

```
리스트에서 찾은 외로운 숫자는 XXX이며, 이는 예상대로 XXX입니다.
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 또 평온한 나날을 보내던 W 선임행정원에게 문제가 생겼다. 이번에도 똑같은 일이 벌어졌는데, 이전과 달리 이번에는 두 개의 숫자가 누락되었다. 다행히 시스템의 로그에 누락된 두 개의 시약 번호 중 하나는 찾을 수 있었다. 새롭게 리스트를 뒤지는 일 없이 문제에서 구현한 함수와 찾아낸 시약 번호를 사용해 나머지 하나의 누락된 시약의 번호를 찾는 함수를 구현한다.
  - 이전 문제의 함수의 동작을 제외한 추가적으로 사용하는 시간 복잡도와 공간 복잡도는 모두 상수 복잡도여야 한다.

- 문제에서와 동일한 방법으로 두 개의 숫자가 누락된 길이 999998인 리스트를 생성하고, 제거된 숫자 하나를 사용해 나머지 숫자 하나를 출력하라. 

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/find_solo.py 파일에 구현이 되어 있는지 확인한다.
  - 함수의 시간 복잡도는 $\mathcal O (n)$, 함수가 추가로 사용하는 메모리의 공간 복잡도는 $\mathcal O(1)$로 구현되어있는지를 확인한다.
  
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다. 어떤 숫자를 골라내었느냐에 따라 결과는 다르지만 제거한 숫자와 동일한 숫자를 찾을 수 있어야 한다.
  ```
  리스트에서 찾은 외로운 숫자는 29608이며, 이는 예상대로 29608입니다.
  ```

### [보너스 과제 해결 확인]

- 보너스 과제를 지시한대로 해결하였는가?

  - 추가적으로 리스트를 탐색하지 않고 원래 문제의 결과를 활용해 정답을 구했는지를 확인한다.
  - 추가적으로 사용하는 시간 및 공간이 고정되어 있어야 한다.

- 결과예시는 다음과 같다. 결과보다는 반드시 코드가 지시한대로 구현되어 있는지 확인해야 한다. 

  ```
  리스트에서 제거한 숫자는 95362과 3154이며, 이 중 95362을 알고 있을 때 찾은 나머지 숫자는 3154입니다.
  ```

### [문제에 대한 이해]

- XOR 연산은 어떤 연산인가?
- 이 문제를 해결하기 위해서 XOR 연산의 어떤 특성을 사용하였는가?
- 만약 전체 리스트에서 홀수인 수가 2개 있다고 가정해보자. 이때 XOR 연산의 결과는 무엇인가?
- (보너스 과제를 해결한 경우)문제를 해결하는데 사용한 방법을 설명하라.

### [코드 예시]

```python
def find_solo(arr):
    result = 0
    for i in arr:
        result ^= i
    return result

def find_second_solo(xor_result, n):
    return n ^ xor_result

def make_sample_list(size):
    arr = []
    for i in range((size + 1) // 2):
        random_number = random.randint(1, 100000)
        arr.append(random_number)
        arr.append(random_number)
    random.shuffle(arr)
    removed = arr.pop()
    return arr, removed

def make_sample_list2(size):
    arr = []
    for i in range((size + 1) // 2):
        random_number = random.randint(1, 100000)
        arr.append(random_number)
        arr.append(random_number)
    random.shuffle(arr)
    removed1 = arr.pop()
    removed2 = arr.pop()
    return arr, removed1, removed2

import random
def main():
    n = 999999
    arr, removed = make_sample_list(n)
    solo = find_solo(arr)
    print(f"리스트에서 찾은 외로운 숫자는 {solo}이며, 이는 예상대로 {removed}입니다.")

    n = 999998
    arr, removed1, removed2 = make_sample_list2(n)
    xor_result = find_solo(arr)
    solo = find_second_solo(xor_result, removed1)
    print(f"리스트에서 제거한 숫자는 {removed1}과 {removed2}이며, 이 중 {removed1}을 알고 있을 때 찾은 나머지 숫자는 {solo}입니다.")


if __name__ == '__main__':
    main()
```

---

# 문제 8. 빠르게 차이를 확인하라

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

세포의 약물 반응을 연구하는 C 연구원은 특정 기능의 새로운 후보 물질을 세포에 투여한 후 기존 물질과 얼마나 차이가 나는지를 확인하고 있다. 다만 세포마다 약물에 반응하는 방법이 다르기 때문에, 같은 세포에서 분열된 두 개의 세포 쌍을 대상으로 두 개의 약물의 결과가 얼마나 다른지를 다음과 같이 확인하기로 했다.

> - 서로 같은 성질을 가진 세포는 리스트에서 같은 위치에 표현된다.
> - 약물에 양성 반응을 보인 세포는 1, 음성 반응을 보인 세포는 0으로 표시된다. 예를 들어서 3개의 세포가 각각 기존 약품에 양성, 음성, 음성의 반응을 보이고, 새로운 후보 물질 A에 양성, 양성, 양성의 반응을 보이면, 각각 [1, 0, 0], [1, 1, 1]로 표현한다.
> - 두 약물의 차이는 서로 다른 결과가 나온 횟수로 계량한다. 즉 위의 예시에서 두 약물의 차이는 2이다. 이 차이를 '반응 거리'라고 부르기로 한다. 
> - 만약 다른 후보 물질 B를 4개의 세포를 대상으로 실험한 결과가 [0, 1, 1, 0]과 [1, 1, 0, 0]이라면 반응 거리는 2가 된다. 
> - 정규화 반응 거리는 이 값을 실험에 사용한 세포 수로 나눈 값이다. 후보 물질 A의 정규화 반응 거리는 2/3, 후보 물질 B의 정규화 반응 거리는 2/4 = 1/2 이므로 두 후보 물질 중 후보 물질 A의 결과가 더 큰 차이가 난다고 이야기 할 수 있다.

실험 결과가 이와 같이 리스트로 출력되도록 실험 장비의 설정을 요청하고, 그 다음날 출근해 보니, 약간 어긋난 방식으로 설정이 되어 있었다. 1과 0으로 표현된 리스트 대신, 각각을 이진수를 십진수로 바꾸는 방식의 숫자가 나오도록 실험이 설정되어 있었다. 예를 들어 위의 첫 번째 경우는 [1, 0, 0] 과 [1, 1, 1] 대신 4와 7이, 두 번째 경우는 [0, 1, 1, 0]과 [1, 1, 0, 0] 대신 6과 12가 출력된다.

설정을 정정해달라고 다시 메일을 쓰니, 이런 답신이 도착했다.

'설정을 수정하지 않고도 거리를 구할 수 있습니다.'

## 수행목표

* 어떤 두 수가 주어졌을 때 두 수의 반응거리는 두 수를 이진수로 바꾼 다음 같은 위치 비트의 값이 다른 경우의 합으로 정의한다. 
  * 예를 들어 두 수가 4와 7인 경우, 두 수를 이진수로 바꾸면 100, 111이며, 대응되는 비트의 값이 2개가 다르므로 거리는 2이다.
  * 두 수를 이진수로 바꾼 후 자릿수가 다르다면, 가장 오른쪽 자리부터 비교를 시작한다.
    * 6, 12의 경우 이진수로 바꾸면 110, 1100이고, 이를 오른쪽부터 대응되는 비트끼리 비교해보면 거리는 2이다. (6을 0110이라고 생각하고 비교하는 것과 동일하다.)
    * 6, 20의 경우 이진수로 바꾸면 110, 10100이고, 이를 오른쪽부터 대응되는 비트끼리 비교해보면 거리는 2이다. (6을 00100이라고 생각하고 비교하는 것과 동일하다.) 
  * 두 수의 반응거리를 계산할 때 반드시 XOR 연산을 사용해야 한다.
  * 모든 비교는 20개의 세포를 대상으로 진행되었으며, 실험 결과로 제공되는 두 수는 모두 0 이상 $2^{20} - 1$ 이하의 정수이다.
* 다음 첨부 파일에는 세 개의 테스트케이스가 들어 있다.
  * 첫 번째 테스트케이스에는 5개의 후보 물질에 대한 실험, 두 번째 테스트케이스는 1000개의 후보 물질에 대한 실험, 그리고 마지막 테스트케이스는 10000개의 후보 물질에 대한 실험이다.
  * 각각의 테스트케이스에서 기존 물질과 가장 차이가 큰 반응을 보인 (즉 기존 물질과 반응거리가 가장 먼) 후보 물질의 번호들의 합을 출력한다. 각 테스트케이스에서 첫 번째 테스크테이스를 1번으로 한다.

## 수행단계

- number/distance.py 파일에 두 수로 표현된 의 '반응거리'를 계산하는 함수를 구현한다.

  - 반응거리를 구할 때 분모는 1000개의 세포를 대상으로 진행되었으므로 1000이 된다.
  - 두 수의 반응거리를 계산할 때 반드시 XOR 연산을 사용한다.

- 테스트케이스는 1번 행 부터 5번 행 까지가 첫 번째, 6번 행부터 1005번 행 까지가 두 번째, 1006번 행 부터 11005번 행 까지가 세 번째 테스트케이스이다. 각 줄에는 후보 물질과 기존 물질 각각의 결과를 컴마로 구분된 두 개의 숫자로 출력하고 있다.

- 예를 들어 5개의 후보 물질을 기존 물질과 비교한 실험 결과가 다음과 같이 주어질 때의 거리는 다음과 같다.

  | 결과 A | 결과 B | 결과 A 이진표현 | 결과 B 이진표현 | 반응 거리 | 정규화 반응 거리 |
  | ------ | ------ | --------------- | --------------- | --------- | ---------------- |
  | 26     | 13     | 11010           | 1101            | 4         | 0.4              |
  | 173    | 717    | 10101101        | 1011001101      | 3         | 0.3              |
  | 17     | 142    | 10001           | 10001110        | 6         | 0.6              |
  | 123    | 13     | 1111011         | 1101            | 5         | 0.5              |
  | 154    | 77     | 10011010        | 1001101         | 6         | 0.6              |

  * 그러므로 3번째와 5번째가 가장 거리가 크며, 이 때는 이 익덱스들의 합인 8을 출력한다.

## 결과예시

```
testcase 1의 결과 : 8
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - number/distance.py 파일에 구현이 되어 있는지 확인한다.
  - 두 수의 반응 거리를 계산하는 과정에서 XOR 연산을 사용하였는지 확인한다.
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
    testcase 1의 결과 : 8
    testcase 2의 결과 : 1862
    testcase 3의 결과 : 269
    ```

### [문제에 대한 이해]

- XOR 연산으로 두 수의 반응 거리를 계산하는 방식과 이 때 사용된 XOR 연산의 특징을 설명하라.

### [코드 예시]

```python

def distance(arr):
    max = -1
    count = 0
    idx = []
    for i, (n1, n2) in enumerate(arr):                
        xor_result = n1 ^ n2
        count = bin(xor_result).count('1')
        if count > max:
            max = count
            idx = [i + 1]
        elif count == max:
            idx.append(i + 1)
    return idx, max

# bin 함수를 사용하지 않는 경우. 실행 시간이 조금 더 걸린다.
def distance2(arr):
    max = -1
    idx = []
    for i, (n1, n2) in enumerate(arr):                
        xor_result = n1 ^ n2
        count = 0
        while xor_result > 0:
            if xor_result % 2 == 1:
                count += 1
            xor_result //= 2
        if count > max:
            max = count
            idx = [i + 1]
        elif count == max:
            idx.append(i + 1)
    return idx, max

@execute_time


def make_test_list(size):
    arr = []
    for i in range(size):
        n1 = random.randint(0, 1023)
        n2 = random.randint(0, 2 ** 20 - 1)
        # n1 = random.randint(0, 1023)
        # n2 = random.randint(0, 1023)
        arr.append((n1, n2))
    return arr

def main():
    with open("new_chemical_test.txt", "r") as f:
        lines = f.readlines()
        testcases = []
        tc1 = []
        for i in range(5):
            tc1.append(tuple(map(int, lines[i].split(','))))
        testcases.append(tc1)
        tc2 = []
        for i in range(5, 1005):
            tc2.append(tuple(map(int, lines[i].split(','))))
        testcases.append(tc2)
        tc3 = []
        for i in range(1005, 11005):
            tc3.append(tuple(map(int, lines[i].split(','))))
        testcases.append(tc3)

    for i, tc in enumerate(testcases):        
        idx, _ = distance(tc)
        print(f"testcase {i + 1}의 결과 : {sum(idx)}")

if __name__ == '__main__':
    main()
```

