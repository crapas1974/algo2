# 단계 3. 문제 해결 접근의 기초

## 스토리

! 스토리 추가

---

# 문제 1. 모든 조합을 찾아라.
## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

유전자 염기서열은 'C', 'T', 'A', 'G' 네 개의 염기로 모든 유전 정보를 코딩하고 있다. 서로 다른 유전자 염기 서열은 서로 다른 유전 정보를 의미하기 때문에, C, T, A, G 네 글자로 만들 수 있는 문자열이 유전자에 포함된 유전 정보라고 말할 수 있고, 문자열이 달라지면 다른 유전 정보를 의미한다고 말할 수도 있다.

유전자 염기서열의 결과로 각 개체가 달라지는 현상을 연구하는 D 연구원은 네 가지 염기로 만들 수 있는 유전 정보에 대해서 확인해보고자 한다.

## 수행목표
- 사용할 문자의 리스트를 파라미터로 받는 다음 세 종류의 함수를 구현한다. (리스트에 포함된 문자는 중복되지 않는다.)
  - 이 문자를 사용해 구성할 수 있는 모든 '조합'의 목록을 반환하는 함수
  - 이 문자를 한 번씩 사용해 만들 수 있는 모든 단어의 목록을 반환하는 함수
  - 이 문자를 최대 한 번만 사용해 만들 수 있는 모든 단어의 목록을 반환하는 함수

- 'C', 'T', 'A', 'G' 네 개의 문자가 주어졌을 때 위 세 함수를 사용해 구한 목록의 길이와 목록을 출력한다.

## 수행단계

- 완전 탐색법에 대해서 조사한다.
- 완전 탐색법으로 주어진 리스트에 포함된 문자를 사용해서 구성할 수 있는 모든 조합을 반환하는 함수, 리스트에 포함된 문자를 한 번씩 사용해서 구성할 수 있는 모든 단어의 목록을 반환하는 함수, 리스트에 포함된 문자를 최대 한 번씩 사용해서 구성할 수 있는 모든 단어의 목록을 반환하는 함수를 basic_approach/every_case.py 파일에 구현한다.
- ['C', 'T', 'A', 'G'] 리스트에 대한 세 함수의 결과에 대해서, 이 목록을 sort 함수로 정렬한 후 그 결과를 출력한다. 

## 결과 예시
* 생략

## 참고사항

- 이 문제에서는 허용되지 않지만, itertools 모듈을 사용하면 이런 종류의 문제를 쉽게 해결할 수 있다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 그 어떤 생물의 유전자도 단순하게 구성되지 않는다. 조금 더 현실적인 유전 정보의 목록을 구하기 위해서 다음과 같은 함수를 구현해보자.
  - 중복되지 않은 문자로 구성된 리스트에 대해서, 리스트에 포함된 문자를 각각 최대 n번까지 사용해서 만들 수 있는 모든 단어의 목록을 반환하는 함수

- ['C', 'T', 'A', 'G'] 리스트에 포함된 문자를 각각 최대 2번까지 사용해서 만들 수 있는 모든 단어의 목록과 단어의 개수를 출력한다.


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/every_case.py 파일에 구현이 되어 있는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  
  - 조합에는 빈 리스트가 포함되어야 하며, 단어에는 빈 문자열 단어가 포함되어서는 안된다.
  
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    모든 조합 목록의 길이는 16입니다.
        모든 조합의 목록 : [[], ['C'], ['T'], ['C', 'T'], ['A'], ['C', 'A'], ['T', 'A'], ['C', 'T', 'A'], ['G'], ['C', 'G'], ['T', 'G'], ['C', 'T', 'G'], ['A', 'G'], ['C', 'A', 'G'], ['T', 'A', 'G'], ['C', 'T', 'A', 'G']]
        
    한 번씩 사용해 만든 모든 단어의 수는 24입니다.
        모든 단어의 목록 : ['CTAG', 'CTGA', 'CATG', 'CAGT', 'CGTA', 'CGAT', 'TCAG', 'TCGA', 'TACG', 'TAGC', 'TGCA', 'TGAC', 'ACTG', 'ACGT', 'ATCG', 'ATGC', 'AGCT', 'AGTC', 'GCTA', 'GCAT', 'GTCA', 'GTAC', 'GACT', 'GATC']
        
    최대 한 번씩 사용해 만든 모든 단어의 수는 64입니다.
        모든 단어의 목록 : ['CTAG', 'TAG', 'CAG', 'AG', 'CTG', 'TG', 'CG', 'G', 'CTGA', 'TGA', 'CGA', 'GA', 'CTA', 'TA', 'CA', 'A', 'CATG', 'ATG', 'CAGT', 'AGT', 'CGT', 'GT', 'CAT', 'AT', 'CT', 'T', 'CGTA', 'GTA', 'CGAT', 'GAT', 'TCAG', 'TCG', 'TCGA', 'TCA', 'TACG', 'ACG', 'TAGC', 'AGC', 'TGC', 'GC', 'TAC', 'AC', 'TC', 'C', 'TGCA', 'GCA', 'TGAC', 'GAC', 'ACTG', 'ACGT', 'ACT', 'ATCG', 'ATGC', 'ATC', 'AGCT', 'GCT', 'AGTC', 'GTC', 'GCTA', 'GCAT', 'GTCA', 'GTAC', 'GACT', 'GATC']
    ```

### [보너스 과제 확인]

* 각각의 문자를 최대 n번까지 사용해서 만들 수 있는 모든 단어를 반환하는 함수를 구현하고, 입력에 대해서 정확한 결과를 출력하였는가?

  * 결과 예시는 다음과 같다. 전체 목록의 출력은 일부만 포함하고 있다.

    ```
    최대 두 번씩 사용해 만든 모든 단어의 수는 7364입니다.
        모든 단어의 목록 : ['CTAGCTAG', 'TAGCTAG', 'CAGCTAG', 'AGCTAG', 'CTGCTAG', 'TGCTAG', 'CGCTAG', 'GCTAG', 'CTACTAG', 'TACTAG', 'CACTAG', 'ACTAG', 'CTCTAG', 'TCTAG', 'CCTAG', 'CTAG', 'CTAGTAG', 'TAGTAG', 'CAGTAG', ... 
    (이하 생략)
    ```
  

### [문제에 대한 이해]

- 완전 탐색법이란 무엇인가?
- 모든 조합, 모든 단어를 구하기 위해서 어떤 방법을 사용하였는가?
- 중복이 없이 목록을 구하기 위해서 사용한 메커니즘을 설명하라.
- 구현한 알고리즘의 시간 복잡도를 제시하라.
- (재귀 호출로 구현한 경우)재귀 호출을 사용하지 않은 알고리즘을 제시해보라.
- (재귀 호출로 구현하지 않은 경우)재귀 호출을 사용하는 알고리즘을 제시해보라.

### [코드 예시]

```python
def every_combinations(letters):    
    if len(letters) == 0:
        return []
    if len(letters) == 1:
        return [[], [letters[0]]]
    result = []
    following_result = every_combinations(letters[1:])
    for combination in following_result:
        result.append(combination)
        result.append([letters[0]] + combination)
    return result
    
def every_permutations(letters):
    if len(letters) == 0:
        return []
    if len(letters) == 1:
        return [letters[0]]
    result = []
    for i in range(len(letters)):
        head = letters[i]
        rest = letters[:i] + letters[i + 1:]
        following_result = every_permutations(rest)
        for combination in following_result:
            result.append(head + combination)
    return result

def every_words(letters):    
    if len(letters) == 1:
        return [letters[0]]
    result = []
    for i in range(len(letters)):
        following_result = every_words(letters[:i] + letters[i + 1:])
        for combination in following_result:
            if letters[i] + combination not in result:
                result.append(letters[i] + combination)
            if combination not in result:
                result.append(combination)
    return result

def every_words_with_max_count_per_letter(letters, max_count):
    letters_extended = letters * max_count
    return every_words(letters_extended)


def main():
    letters = ['C', 'T', 'A', 'G']
    every_combinations_result = every_combinations(letters)
    print(f"모든 조합 목록의 길이는 {len(every_combinations_result)}입니다.")
    print(f"    모든 조합의 목록 : {every_combinations_result}\n")
    every_permutations_result = every_permutations(letters)
    print(f"한 번씩 사용해 만든 모든 단어의 수는 {len(every_permutations_result)}입니다.")
    print(f"    모든 단어의 목록 : {every_permutations_result}\n")
    every_words_result = every_words(letters)
    print(f"최대 한 번씩 사용해 만든 모든 단어의 수는 {len(every_words_result)}입니다.")
    print(f"    모든 단어의 목록 : {every_words_result}\n")
    every_words_result_with_max_2 = every_words_with_max_count_per_letter(letters, 2)
    print(f"최대 두 번씩 사용해 만든 모든 단어의 수는 {len(every_words_result_with_max_2)}입니다.")
    print(f"    모든 단어의 목록 : {every_words_result_with_max_2}")

if __name__ == "__main__":
    main()

```

---

# 문제 2. 넘어가면 폭발합니다.

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 2시간

## 스토리

C 연구원은 계속해서 세포 약물 반응과 관련된 새로운 후보 물질을 찾고 있다. 이번에는 기존 화합물을 조합해서 새로운 후보 물질을 찾고 있는데, 그 중 특정 성분 B 때문에 골치가 아픈 상황이었다. 조합의 결과로 나온 물질에 이 성분이 부족하면 효과가 없는데, 이 성분이 어떤 값을 넘어가면 물질의 매우 불안정해져서 폭발 가능성이 있기 때문이다.

C 연구원은 조합할 재료 물질들에 이 성분의 양을 리스트로 만든 후, 조합 후 목표 양에 따라서 조합할 수 있는 모든 방법을 먼저 찾아두기로 했다. 그리고 그 방법을 찾기 위해서 프로그래밍 지원 게시판에 도움을 청했다.

## 수행목표

- 양의 정수를 항목으로 가지는 리스트와 목표 값이 주어졌을 때, 합이 목표값과 동일한 모든 조합의 인덱스의 리스트의 리스트를 반환하는 함수를 구현한다.

  - 예를 들어 주어진 리스트가 [1, 2, 3, 4, 5]이고, 목표값이 5인 경우 2 + 3, 1 + 4, 5 3 가지 조합이 가능하다. 이 때 이들의 인덱스에 해당하는 [[1, 2], [0, 3], [4]]를 반환한다.

- 다음 리스트들은 총 10개의 테스트케이스의 튜플이다. 각각의 테스트케이스에 대해서 전체 조합의 수와 첫 10개의 조합을 출력한다. (조합의 수가 10개 이하인 경우, 전체를 출력한다.)

  - 각 테스트케이스 튜플의 첫 번째 값은 화합물에 포함된 성분 B의 양의 목록이며, 두 번째 값은 목표값이다.

  - 출력되는 리스트는 숫자를 항목으로 가지는 내부 리스트의 경우는 오름차순으로 정렬하고, 리스트를 항목으로 가지는 외부 리스트의 경우는 파이썬에서 리스트 간의 크기를 정하는 기본 원칙에 따라 정렬한다. 파이썬에서 리스트 간의 크기를 정하는 기본 원칙은 일반적으로 sort 함수의 결과이며, 참고사항을 참고한다.

  - 위의 예시에서는 전체 조합의 수는 3, 그리고 조합은 [0, 3], [1, 2], [4] 순서로 출력되어야 한다.

    ```python
    tc1 = ([1, 2, 3, 4, 5], 5)
    tc2 = ([1, 2, 3, 4, 5], 6)
    tc3 = ([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 6)
    tc4 = ([1, 2, 3, 4, 5], 15)
    tc5 = ([1, 2, 3, 4, 5], 16)
    tc6 = ([5, 3, 5, 6, 3, 5, 3, 3, 6, 6, 3, 4, 5, 4, 4, 6, 5, 6, 5, 6, 3, 5, 5, 3, 3, 5, 4, 4, 5, 5], 20)
    tc7 = ([20, 18, 18, 15, 11, 14, 15, 11, 16, 18, 18, 15, 12, 15, 11, 20, 17, 16, 18, 20, 13, 13, 20, 18, 12, 14, 17, 11, 10, 13, 17, 19, 14, 15, 16, 19, 13, 18, 20, 17, 18, 11, 16, 19, 16, 14, 18, 17, 19, 14, 19, 12, 16, 16, 15, 17, 15, 10, 17, 15, 20, 10, 20, 17, 11, 18, 19, 15, 18, 20, 19, 18, 14, 18, 14, 14, 10, 20, 14, 19, 15, 20, 10, 11, 11, 11, 12, 15, 20, 13, 18, 10, 10, 19, 12, 16, 14, 20, 10, 18], 40)
    tc8 = ([20, 18, 18, 15, 11, 14, 15, 11, 16, 18, 18, 15, 12, 15, 11, 20, 17, 16, 18, 20, 13, 13, 20, 18, 12, 14, 17, 11, 10, 13, 17, 19, 14, 15, 16, 19, 13, 18, 20, 17, 18, 11, 16, 19, 16, 14, 18, 17, 19, 14, 19, 12, 16, 16, 15, 17, 15, 10, 17, 15, 20, 10, 20, 17, 11, 18, 19, 15, 18, 20, 19, 18, 14, 18, 14, 14, 10, 20, 14, 19, 15, 20, 10, 11, 11, 11, 12, 15, 20, 13, 18, 10, 10, 19, 12, 16, 14, 20, 10, 18], 60)   
    tc9 = ([2481, 8036, 3389, 3790, 1044, 4305, 4907, 5996, 3004, 6500, 9786, 6862, 7324, 1150, 8408, 8334, 7769, 3037, 2345, 1126, 4308, 9188, 2480, 7235, 5217, 3103, 7233, 5720, 5271, 2273, 8331, 2292, 8739, 1733, 9435, 1924, 3320, 5345, 1882, 4347, 8143, 5551, 9293, 8634, 1585, 7123, 7119, 8689, 2786, 1729, 1734, 9367, 4808, 188, 1857, 7509, 2708, 7546, 6561, 3511, 6187, 6927, 5803, 6529, 4065, 9270, 5555, 4860, 6915, 3287, 3093, 8325, 2572, 9825, 994, 9806, 8642, 3831, 3411], 10005)
    tc10 = ([[4224, 2041, 1569, 8560, 9851, 5415, 6248, 1357, 6937, 2822, 3464, 7678, 3209, 657, 5501, 738, 223, 471, 4389, 1648, 1973, 6075, 9541, 341, 308, 174, 7478, 5547, 770, 9271, 6213, 6488, 7256, 5624, 281, 8023, 8185, 6738, 624, 8544, 7372, 564, 1367, 5879, 278, 9189, 3304, 5705, 4936, 6785, 9983, 7050, 6214, 7025, 7313, 8274, 3167, 271, 9306, 7421, 9549, 3684, 7470, 9244, 6777, 1663, 3463, 1669, 8575, 5044, 4105, 5520, 8797, 9588, 2981, 9806, 7911, 4315, 1533, 7284, 9412, 2675, 2242, 1478, 6462, 2964, 1187, 3002, 3840, 1314, 9641, 1093, 7458, 5014, 6746, 4487, 3686, 7536, 7211, 2992, 4625, 1888, 3512, 7846, 1085, 2032, 3463, 1339, 3146, 5946, 8545, 3850, 6284, 7175, 4946, 3891, 3696, 5901, 3769, 7254, 6134, 2548, 2954, 8147, 1863, 8697, 1114, 4628, 1113, 6924, 2244, 7082, 9041, 9684, 3257, 9028, 4802, 3651, 8607, 4120, 1915, 4657, 9032, 8416, 7016, 2890, 8121, 3314, 8456, 8463, 3153, 7461, 7012, 1523, 3716, 9030, 6701, 5595, 3761, 2883, 1871, 8128, 5137, 8696, 1842, 7012, 1975, 5970, 10000, 8254, 6488, 8952, 6113, 8962, 4640, 9718, 7544, 2588, 4404, 9106, 9010, 9593, 7653, 5193, 5092, 4153, 8618, 6224, 2450, 1034, 9120, 1235, 9237, 1492, 6334, 9749, 6685, 7967, 5115, 4413, 7441, 7057, 2803, 3486, 1781, 8377, 4469, 8804, 2546, 7849, 7258, 2610, 6745, 3422, 9129, 7795, 2303, 2739, 5187, 7639, 4356, 7242, 6361, 9227, 5979, 6719, 3003, 3234, 3647, 6834, 4357, 8801, 8065, 3672, 7061, 8221, 8307, 1942, 7166, 8879, 8239, 1130, 7193, 7824, 9197, 5484, 3046, 2601, 5965, 2849, 3185, 4330, 6693, 6125, 9560, 5937, 1091, 5416, 1353, 3079, 6696, 1337, 3840, 1122, 1998, 1344, 4899, 3210, 6789, 7279, 2013, 2760, 9202, 1610, 7475, 3865, 7003, 4602, 2445, 7947, 9600, 6436, 3425, 5776, 1463, 7570, 2492, 2437, 1620, 4681, 1474, 3410, 4991, 4079, 6735, 1482, 4100, 2170, 8753, 4141, 1070, 1031, 6600, 5325, 3066, 5173, 1923, 1544, 9497, 3334, 9486, 3335, 6918, 4339, 3424, 4596, 2760, 7717, 2665, 1036, 3910, 8601, 7826, 6350, 9490, 7367, 2798, 5080, 5634, 2502, 2840, 3645, 9736, 7048, 1995, 3749, 9745, 5144, 8842, 1874, 4692, 5789, 8889, 2311, 2731, 4821, 2670, 9755, 2267, 2489, 6850, 1244, 5953, 5043, 2350, 4510, 5758, 7953, 4292, 8274, 4197, 7604, 8554, 1580, 4539, 7634, 3422, 7471, 7748, 3606, 8036, 2657, 3513, 7720, 3461, 3657, 7083, 5948, 8136, 9568, 5479, 7497, 2874, 4557, 5486, 6092, 6259, 9792, 4979, 4055, 7793, 2422, 8134, 3147, 4141, 2514, 9874, 4264, 1314, 3107, 6323, 3982, 8473, 1048, 7287, 3000, 3216, 7100, 2413, 7494, 2116, 2552, 7122, 2226, 2318, 6061, 1472, 8641, 8978, 4025, 2864, 7647, 9478, 5256, 7498, 3082, 3284, 1036, 6102, 2239, 1050, 5662, 3818, 7911, 2080, 8815, 2663, 6517, 3274, 3942, 7235, 9393, 4001, 4578, 3158, 2044, 4068, 9196, 7463, 3758, 6054, 5170, 6334, 9821, 7579, 5085, 7787, 9647, 7485, 7008, 5339, 1691, 4341, 4866, 5041, 4006, 4162, 5596, 3074, 7537, 5408, 5739, 1658, 1528, 9282, 2392, 1628, 3107, 7026, 8404, 4547, 1903, 8500, 4672, 4884, 3667, 7894, 5808, 2158, 8974, 1726, 7373, 4515, 1060, 6552, 7660, 6115, 8777, 5265, 8599, 5219, 3587, 9810, 3456, 9508, 7737, 4132, 3951, 9727, 7423, 4700, 6450, 4452, 7200, 8296, 9258, 1510, 5533, 2017, 6778, 9216, 3116, 8426, 4884, 2010, 4531, 7832, 6423, 6701, 4691, 5919, 3423, 3335, 9939, 8006, 6470, 2373, 1127, 2307, 4054, 3862, 1844, 3184, 9856, 3246, 1964, 8490, 9038, 5988, 9885, 5040, 1250, 4864, 6588, 1940, 1878, 7012, 5063, 7101, 1606], 961])
    
    ```

    


## 수행단계

- 백트래킹에 대해서 조사한다.
- 리스트에서 항목의 합이 주어진 값이 되는 모든 조합을 찾는 함수를 basic_approach/mixing_chemical.py 파일에 구현한다.
  - 이 함수는 백트래킹을 사용해서 조합에 검토하지 않은 남은 항목에 있더라도 더 이상 검토할 필요가 없다고 판단된다면 해당 항목은 검토하지 않도록 구현한다.
  - 백트래킹이 정상적으로 적용되지 않은 경우, 테스트케이스 중 일부에서 조합을 찾는데 매우 긴 시간이 걸리게 될 것이다.

- 제공된 테스트케이스를 사용해 결과를 구하고, 결과 목록의 갯수와 정렬된 내부 리스트의 정렬된 외부 리스트를 기준으로 첫 10개의 조합 방법의 목록을 출력한다.


## 결과예시
```
testcase 1
    모든 조합의 수 : 3
    첫 10개의 조합 : [[0, 3], [1, 2], [4]]

testcase 2
    모든 조합의 수 : 3
    첫 10개의 조합 : [[0, 1, 2], [0, 4], [1, 3]]
(이하 생략)
```

## 참고사항

- 파이썬에서 리스트의 크기를 정하는 원칙은 다음과 같다. 파이썬 3.9 버전 기준으로 sort 함수는 이 원칙을 기준으로 정렬된다.

  - 첫 번째 원소를 비교한다. 만약 첫 번째 원소가 동일하다면, 그 다음 원소를 비교하는 방식으로 같은 길이까지 비교한다.

  - 같은 길이까지 항목이 모두 동일한 경우, 그 다음에는 짧은 리스트가 더 작다.

  - 다음 결과를 참고하자.

    ```python
    >>> [1, 2, 3] > [2, 2, 3]
    False
    >>> [1, 2, 3] > [1, 3, 3]
    False
    >>> [1, 2, 3] > [1, 2, 3, 4]
    False
    >>> [1, 2, 3] == [1, 2, 3]
    True
    ```

    


## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음



---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/mixing_chemical.py 파일에 구현이 되어 있는지 확인한다.
  - 백트래킹을 사용해서 탐색 도중에 목표양을 초과한 경우 더 이상 탐색하지 않도록 구현되어 있는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    testcase 1
        모든 조합의 수 : 3
        첫 10개의 조합 : [[0, 3], [1, 2], [4]]
    
    testcase 2
        모든 조합의 수 : 3
        첫 10개의 조합 : [[0, 1, 2], [0, 4], [1, 3]]
    
    testcase 3
        모든 조합의 수 : 20
        첫 10개의 조합 : [[0, 1, 2], [0, 1, 5, 6], [0, 1, 7], [0, 2, 6], [0, 3, 5], [0, 4], [0, 5, 8], [0, 6, 7], [0, 9], [1, 2, 5]]
    
    testcase 4
        모든 조합의 수 : 1
        첫 10개의 조합 : [[0, 1, 2, 3, 4]]
    
    testcase 5
        조합이 존재하지 않습니다.
    
    testcase 6
        모든 조합의 수 : 18723
        첫 10개의 조합 : [[0, 1, 2, 4, 11], [0, 1, 2, 4, 13], [0, 1, 2, 4, 14], [0, 1, 2, 4, 26], [0, 1, 2, 4, 27], [0, 1, 2, 6, 11], [0, 1, 2, 6, 13], [0, 1, 2, 6, 14], [0, 1, 2, 6, 26], [0, 1, 2, 6, 27]]
    
    testcase 7
        모든 조합의 수 : 6050
        첫 10개의 조합 : [[0, 15], [0, 19], [0, 22], [0, 28, 57], [0, 28, 61], [0, 28, 76], [0, 28, 82], [0, 28, 91], [0, 28, 92], [0, 28, 98]]
    
    testcase 8
        모든 조합의 수 : 415130
        첫 10개의 조합 : [[0, 1, 4, 7], [0, 1, 4, 14], [0, 1, 4, 27], [0, 1, 4, 41], [0, 1, 4, 64], [0, 1, 4, 83], [0, 1, 4, 84], [0, 1, 4, 85], [0, 1, 7, 14], [0, 1, 7, 27]]
    
    testcase 9
        모든 조합의 수 : 54
        첫 10개의 조합 : [[0, 8, 48, 50], [2, 19, 20, 53, 74], [2, 19, 35, 72, 74], [3, 4, 13, 31, 49], [3, 4, 44, 49, 54], [3, 44, 50, 53, 56], [4, 5, 13, 33, 44, 53], [4, 8, 19, 48, 53, 54], [4, 9, 29, 53], [4, 13, 22, 31, 53, 54, 74]]
    
    testcase 10
        모든 조합의 수 : 2
        첫 10개의 조합 : [[15, 16], [16, 25, 41]]
    ```

### [문제에 대한 이해]

- 백트래킹의 개념을 설명하라.
- 구현한 코드에서 백트래킹을 사용한 부분을 찾아 설명하라.
- 만약 입력 리스트가 정렬되어 있다면 구현한 함수의 성능은 어떻게 될 것인지 설명해보자.

### [코드 예시]

```python
def chemical_combination(chemicals, target_amount, current_combinations = None, current_idx = 0):
    if current_combinations == None:
        current_combinations = []
    if target_amount == 0:
        return current_combinations
    if target_amount < 0:
        return None
    if current_idx == len(chemicals):
        return None
    result = []
    
    current_chemical = chemicals[current_idx]
    if current_chemical == target_amount:
        result.append(current_combinations + [current_idx])
    elif current_chemical < target_amount:
        result_with_current = chemical_combination(chemicals, target_amount - current_chemical, current_combinations + [current_idx], current_idx + 1)
        if result_with_current != None:
            result += result_with_current
    result_without_current = chemical_combination(chemicals, target_amount, current_combinations, current_idx + 1)
    if result_without_current != None:
        result += result_without_current
    return result

def main():
    tc1 = ([1, 2, 3, 4, 5], 5)
    tc2 = ([1, 2, 3, 4, 5], 6)
    tc3 = ([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 6)
    tc4 = ([1, 2, 3, 4, 5], 15)
    tc5 = ([1, 2, 3, 4, 5], 16)
    tc6 = ([5, 3, 5, 6, 3, 5, 3, 3, 6, 6, 3, 4, 5, 4, 4, 6, 5, 6, 5, 6, 3, 5, 5, 3, 3, 5, 4, 4, 5, 5], 20)
    tc7 = ([20, 18, 18, 15, 11, 14, 15, 11, 16, 18, 18, 15, 12, 15, 11, 20, 17, 16, 18, 20, 13, 13, 20, 18, 12, 14, 17, 11, 10, 13, 17, 19, 14, 15, 16, 19, 13, 18, 20, 17, 18, 11, 16, 19, 16, 14, 18, 17, 19, 14, 19, 12, 16, 16, 15, 17, 15, 10, 17, 15, 20, 10, 20, 17, 11, 18, 19, 15, 18, 20, 19, 18, 14, 18, 14, 14, 10, 20, 14, 19, 15, 20, 10, 11, 11, 11, 12, 15, 20, 13, 18, 10, 10, 19, 12, 16, 14, 20, 10, 18], 40)
    tc8 = ([20, 18, 18, 15, 11, 14, 15, 11, 16, 18, 18, 15, 12, 15, 11, 20, 17, 16, 18, 20, 13, 13, 20, 18, 12, 14, 17, 11, 10, 13, 17, 19, 14, 15, 16, 19, 13, 18, 20, 17, 18, 11, 16, 19, 16, 14, 18, 17, 19, 14, 19, 12, 16, 16, 15, 17, 15, 10, 17, 15, 20, 10, 20, 17, 11, 18, 19, 15, 18, 20, 19, 18, 14, 18, 14, 14, 10, 20, 14, 19, 15, 20, 10, 11, 11, 11, 12, 15, 20, 13, 18, 10, 10, 19, 12, 16, 14, 20, 10, 18], 60)
    tc9 = ([2481, 8036, 3389, 3790, 1044, 4305, 4907, 5996, 3004, 6500, 9786, 6862, 7324, 1150, 8408, 8334, 7769, 3037, 2345, 1126, 4308, 9188, 2480, 7235, 5217, 3103, 7233, 5720, 5271, 2273, 8331, 2292, 8739, 1733, 9435, 1924, 3320, 5345, 1882, 4347, 8143, 5551, 9293, 8634, 1585, 7123, 7119, 8689, 2786, 1729, 1734, 9367, 4808, 188, 1857, 7509, 2708, 7546, 6561, 3511, 6187, 6927, 5803, 6529, 4065, 9270, 5555, 4860, 6915, 3287, 3093, 8325, 2572, 9825, 994, 9806, 8642, 3831, 3411], 10005)
    tc10 = ([[4224, 2041, 1569, 8560, 9851, 5415, 6248, 1357, 6937, 2822, 3464, 7678, 3209, 657, 5501, 738, 223, 471, 4389, 1648, 1973, 6075, 9541, 341, 308, 174, 7478, 5547, 770, 9271, 6213, 6488, 7256, 5624, 281, 8023, 8185, 6738, 624, 8544, 7372, 564, 1367, 5879, 278, 9189, 3304, 5705, 4936, 6785, 9983, 7050, 6214, 7025, 7313, 8274, 3167, 271, 9306, 7421, 9549, 3684, 7470, 9244, 6777, 1663, 3463, 1669, 8575, 5044, 4105, 5520, 8797, 9588, 2981, 9806, 7911, 4315, 1533, 7284, 9412, 2675, 2242, 1478, 6462, 2964, 1187, 3002, 3840, 1314, 9641, 1093, 7458, 5014, 6746, 4487, 3686, 7536, 7211, 2992, 4625, 1888, 3512, 7846, 1085, 2032, 3463, 1339, 3146, 5946, 8545, 3850, 6284, 7175, 4946, 3891, 3696, 5901, 3769, 7254, 6134, 2548, 2954, 8147, 1863, 8697, 1114, 4628, 1113, 6924, 2244, 7082, 9041, 9684, 3257, 9028, 4802, 3651, 8607, 4120, 1915, 4657, 9032, 8416, 7016, 2890, 8121, 3314, 8456, 8463, 3153, 7461, 7012, 1523, 3716, 9030, 6701, 5595, 3761, 2883, 1871, 8128, 5137, 8696, 1842, 7012, 1975, 5970, 10000, 8254, 6488, 8952, 6113, 8962, 4640, 9718, 7544, 2588, 4404, 9106, 9010, 9593, 7653, 5193, 5092, 4153, 8618, 6224, 2450, 1034, 9120, 1235, 9237, 1492, 6334, 9749, 6685, 7967, 5115, 4413, 7441, 7057, 2803, 3486, 1781, 8377, 4469, 8804, 2546, 7849, 7258, 2610, 6745, 3422, 9129, 7795, 2303, 2739, 5187, 7639, 4356, 7242, 6361, 9227, 5979, 6719, 3003, 3234, 3647, 6834, 4357, 8801, 8065, 3672, 7061, 8221, 8307, 1942, 7166, 8879, 8239, 1130, 7193, 7824, 9197, 5484, 3046, 2601, 5965, 2849, 3185, 4330, 6693, 6125, 9560, 5937, 1091, 5416, 1353, 3079, 6696, 1337, 3840, 1122, 1998, 1344, 4899, 3210, 6789, 7279, 2013, 2760, 9202, 1610, 7475, 3865, 7003, 4602, 2445, 7947, 9600, 6436, 3425, 5776, 1463, 7570, 2492, 2437, 1620, 4681, 1474, 3410, 4991, 4079, 6735, 1482, 4100, 2170, 8753, 4141, 1070, 1031, 6600, 5325, 3066, 5173, 1923, 1544, 9497, 3334, 9486, 3335, 6918, 4339, 3424, 4596, 2760, 7717, 2665, 1036, 3910, 8601, 7826, 6350, 9490, 7367, 2798, 5080, 5634, 2502, 2840, 3645, 9736, 7048, 1995, 3749, 9745, 5144, 8842, 1874, 4692, 5789, 8889, 2311, 2731, 4821, 2670, 9755, 2267, 2489, 6850, 1244, 5953, 5043, 2350, 4510, 5758, 7953, 4292, 8274, 4197, 7604, 8554, 1580, 4539, 7634, 3422, 7471, 7748, 3606, 8036, 2657, 3513, 7720, 3461, 3657, 7083, 5948, 8136, 9568, 5479, 7497, 2874, 4557, 5486, 6092, 6259, 9792, 4979, 4055, 7793, 2422, 8134, 3147, 4141, 2514, 9874, 4264, 1314, 3107, 6323, 3982, 8473, 1048, 7287, 3000, 3216, 7100, 2413, 7494, 2116, 2552, 7122, 2226, 2318, 6061, 1472, 8641, 8978, 4025, 2864, 7647, 9478, 5256, 7498, 3082, 3284, 1036, 6102, 2239, 1050, 5662, 3818, 7911, 2080, 8815, 2663, 6517, 3274, 3942, 7235, 9393, 4001, 4578, 3158, 2044, 4068, 9196, 7463, 3758, 6054, 5170, 6334, 9821, 7579, 5085, 7787, 9647, 7485, 7008, 5339, 1691, 4341, 4866, 5041, 4006, 4162, 5596, 3074, 7537, 5408, 5739, 1658, 1528, 9282, 2392, 1628, 3107, 7026, 8404, 4547, 1903, 8500, 4672, 4884, 3667, 7894, 5808, 2158, 8974, 1726, 7373, 4515, 1060, 6552, 7660, 6115, 8777, 5265, 8599, 5219, 3587, 9810, 3456, 9508, 7737, 4132, 3951, 9727, 7423, 4700, 6450, 4452, 7200, 8296, 9258, 1510, 5533, 2017, 6778, 9216, 3116, 8426, 4884, 2010, 4531, 7832, 6423, 6701, 4691, 5919, 3423, 3335, 9939, 8006, 6470, 2373, 1127, 2307, 4054, 3862, 1844, 3184, 9856, 3246, 1964, 8490, 9038, 5988, 9885, 5040, 1250, 4864, 6588, 1940, 1878, 7012, 5063, 7101, 1606], 961])
    testcases = [tc1, tc2, tc3, tc4, tc5, tc6, tc7, tc8, tc9, tc10]
    for i, tc in enumerate(testcases):
        print(f"testcase {i + 1}")
        combinations = chemical_combination(*tc)
        if len(combinations) == 0:
            print("    조합이 존재하지 않습니다.")
        else:
            print(f"    모든 조합의 수 : {len(combinations)}")
            print(f"    첫 10개의 조합 : {combinations[:10]}")
        print()


if __name__ == "__main__":
    main()

```

---

# 문제 3. 빠르게 찾는다

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

유전자 목록을 정렬해서 관리할 수 있게 된 닥터 K는 여전히 답답한 부분이 남아 있었다. 어떤 유전자 염기서열을 사용해서, 그 유전자 염기 서열이 목록에 있는지, 만약 목록에 없다면 사전순으로 주어진 유전자 염기 서열의 이전, 이후 유전자 염기 서열이 어떤 것인지 알고 싶었다. 그것도 매우 빠르게.

처음부터 차례대로 비교해보기에는 유전자 목록이 너무 많았고, 영어 사전처럼 중간 중간에 첫 글자 인덱스가 붙어 있으면 좋겠지만 그런 것도 준비되어 있지 않았기 때문이다.

생각이 영어 사전에 미치자, 영어 사전에서 단어를 찾는 방법을 활용하면 좋겠다는 생각이 들었다. 아무 페이지나 펼쳐서 그 페이지의 단어와 비교해 앞에서 찾을지 뒤에서 찾을지를 결정하고, 다시 이를 반복하면서 목표 페이지를 찾아가는 방식을 떠올린 것이다.

## 수행목표

- 정렬된 리스트와 찾고자 하는 값이 주어질 때, 그 값이 리스트에 포함되어 있는 경우 그 값의 인덱스를 반환하고, 그 값이 리스트에 없는 경우 만약 그 값이 있었다면 위치해야 할 인덱스를 반환하는 함수를 구현한다.
	- 예를 들어 입력 인덱스가 주어진 리스트가 ['ACT', 'CTA', 'TTA'] 일 때 찾고자 하는 값이 'CTA'이면 1을 반환한다.
	
	- 주어진 리스트가 [1, 3, 5, 7, 7, 9]일 때 찾고자 하는 값이 6이면 3을 반환한다.
	
- 첨부한 파일은 10개의 테스트케이스가 포함되어 있다. 각각의 테스트케이스의 실행 결과를 출력한다.

## 수행단계

- 분할 정복 (divide and conquer) 방법에 대해서 조사한다.
- 분할 정복 방식으로 정렬된 리스트에서 찾고자 하는 값의 인덱스 또는 찾고자 하는 값이 있어야 했을 인덱스의 값을 반환하는 함수를 basic_approach/find_from_ordered_data.py 파일에 구현한다.
  - 이 함수의 시간 복잡도는 선형 시간 복잡도 미만이어야 한다.

- 첨부한 파일에 포함된 테스트케이스는 'testcase 번호'가 기록된 줄로 구분되며, 각각의 테스트케이스는 다음과 같이 구성되어 있다.
  - 첫 줄은 찾고자 하는 값이다.

  - 두 번째 줄 부터는 한 줄에 하나씩 목록의 항목이다. 항목이 숫자인 경우 숫자의 리스트로 생성해 실행하고, 그렇지 않은 경우 문자열의 리스트로 생성해 실행한다.

- 테스트케이스 각각에 대한 결과를 출력한다.

## 결과예시

```
testcase 1 result : 4
testcase 2 result : 4
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/find_from_ordered_data.py 파일에 구현이 되어 있는지 확인한다.
  - 분할 정복 방식을 사용해 선형 시간 복잡도 미만의 시간 복잡도로 결과를 찾을 수 있는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 테스트케이스 8의 경우, 구현 방식에 따라 95, 96, 97 셋 중 어느 값도 나올 수 있다.

    ```
    testcase 1 result : 4
    testcase 2 result : 4
    testcase 3 result : 2
    testcase 4 result : 0
    testcase 5 result : 8
    testcase 6 result : 7
    testcase 7 result : 1
    testcase 8 result : 96
    testcase 9 result : 4
    testcase 10 result : 10
    testcase 11 result : 442
    testcase 12 result : 183
    ```

### [문제에 대한 이해]

- 분할 정복 방식에 대해서 설명하라.
- 분할 정복 방식으로 주어진 문제를 해결한 방법을 설명하라.
- 이 문제의 경우, 문제의 조건만으로 복수의 결과가 정답이 되는 경우가 있다. 96의 인덱스를 찾는 테스트케이스 8의 데이터에 96이 3번 반복해 나오기 때문이다. 구체적으로는 95, 96, 97 셋 중 어느 인덱스를 제시해도 정답인데, 이 세 개의 값중 왜 그 수를 출력했는지 사용한 분할 정복 방식의 흐름을 사용해 설명하라.
- 구현한 함수의 시간 복잡도를 제시하라.

### [코드 예시]

```python
def find_index(arr, k, start, end):
    if start > end:
        return start

    mid = (start + end) // 2
    if arr[mid] == k:
        return mid
    elif arr[mid] > k:
        return find_index(arr, k, start, mid - 1)
    else:
        return find_index(arr, k, mid + 1, end)

def line_into_int_or_str(line):
    line = line.strip()
    if line.isdigit():
        return int(line)
    else:
        return line

def main():
    testcases = []
    with open("sorted_list.txt", "r") as f:
        lines = f.readlines()
    
    start_lines = []
    end_lines = []
    for i in range(len(lines)):
        if lines[i][:8] == "testcase":
            start_lines.append(i)
            if i != 0:
                end_lines.append(i - 1)
    end_lines.append(len(lines) - 1)
    tc_num = 0
    for i in range(len(start_lines)):
        tc_num += 1
        start = start_lines[i]
        end = end_lines[i]
        k = line_into_int_or_str(lines[start + 1])
        arr = []
        for j in range(start + 2, end + 1):
            arr.append(line_into_int_or_str(lines[j]))
        result = find_index(arr, k, 0, len(arr) - 1)
        print(f"testcase {tc_num} result : {result}")
    
    for i, (tc, k, size) in enumerate(testcases):
        print(f"testcase {i + 1}: {find_index(tc, k, 0, size - 1)}")


if __name__ == "__main__":
    main()
```

---

# 문제 4. 가장 전기가 잘 통하는 구간은 어디일까?

## 문제 분류

- 중요도 : 5/5
- 난이도 : 2/5
- 목표 수행 시간 : 4시간

## 스토리

신경과 신경 사이에 정보를 주고받을 때 생물은 전기 신호를 사용한다. 신경 세포를 연구하는 연구원 N은 신경 연결의 전기적 특성을 확인하기 위해서 선형으로 연결된 신경 세포의 여러 구간에서 전압을 측정했다. 이 전압의 합이 가장 큰 구간이 신호가 활발하게 발생하는 구간으로 가정하고 추가 실험을 진행하려고 하고 있다.

측정 결과를 받아든 연구원 N은 순간 멈칫했다.

'어라, 그런데 전압의 합이 가장 큰 구간은 어떻게 찾지?' 

양수와 음수를 넘나드는 긴 전압 목록은 보기만 해도 머리가 아파왔다.

## 수행목표

- 숫자로 구성된 리스트가 주어지면, 이 리스트에서 합이 가장 큰 연속된 구간을 찾아서, 시작과 끝 인덱스와 이 때의 합의 값을 반환하는 함수를 구현한다.

- 다음 15개의 리스트에 대해서 실행한 결과를 출력한다.

  ```python
  tc1 = [5, -1, 2, 3, -1, 3, -4, 3, -6]
  tc2 = [2, -5, 2, -4]
  tc3 = [1, 1, 1, 1, 1]
  tc4 = [-1, -1, -1, -1, -1]
  tc5 = [0, 0, 0]
  tc6 = [-100, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -100, 54]
  tc7 = [100]
  tc8 = [-100]
  tc9 = [5, -1, 2, 3, -1, 3, -4, 3, -100, 5, -1, 2, 3, -1, 3, -4, 3, -6]
  tc10 = [5, -29, -74, 96, 70, 20, 81, -24, 5, -70, 56, -65, -53, 83, -81, -25, -6, -20, 61, 18, 3, -2, 75, 32, -46, -49, 92, -70, -85, 13, 40, 37, 80, -52, -25, 11, 90, -56, 4, 57, -18, -9, -88, -24, 28, -5, -41, -92, 8, 47, -13, -85, -86, 1, 52, -32, 24, -33, -56, -86, -22, -9, 17, 82, -66, 4, -91, 84, -27, 52, -82, 82, 84, -29, -38, 36, -76, 72, -41, 35, 57, -21, -7, -47, 50, -12, 25, -61, -43, -9, 13, -65, -17, 48, 81, 39, 75, -45, -6, 93]
  tc11 = [58, -9, 13, -14, -59, 57, -97, 25, 62, 44, 13, -66, -51, 61, 3, 91, -60, -38, 42, -74, -43, -26, -18, -12, -47, 63, 92, -23, -36, -96, 60, -71, -43, 46, -46, 10, 99, -83, 5, 89, 28, -7, 67, -7, 99, -70, -28, 43, -81, 70, 48, 90, -68, -65, -100, -54, 24, -42, -54, -50, -26, -24, -55, -43, -26, 18, 56, -32, -67, 12, -12, 10, 17, -36, 23, -21, 8, -53, -4, -89, 8, 29, -19, 84, -37, 72, 15, -78, 11, -44, 8, 87, -65, -88, 92, -37, -74, -30, -74, 4]
  tc12 = [166, -363, -551, -715, -628, -789, -588, -401, -100, -79, 56, -693, -29, -558, -529, -671, -772, 134, -565, -214, 148, -308, -304, -543, 75, -779, -264, -487, -365, -593, -253, -744, -435, -550, 75, 103, 67, 158, 183, -71, -378, -554, -351, -644, -610, 141, -181, 68, -299, -6, -97, -535, 124, -15, -778, -91, -227, -445, -477, -423, -1, -216, -79, -722, -660, -711, -686, -3, -790, 111, -488, -773, 35, -656, -771, 117, -44, -153, -11, -461, -165, -778, -135, -748, -404, -356, -64, -601, -137, -25, -602, -448, -699, -334, 24, -559, -68, -500, -122, -79]
  tc13 = [30, 22, -12, -5, 1, -21, 13, 1, -18, -16, -9, -16, 13, 29, -18, -6, -24, 13, 3, -23, -11, 0, 13, 19, -18, 7, 11, 14, -25, 24, -24, -20, -29, 2, -27, 18, -2, 27, 7, 21, 15, -20, -25, -25, -23, -23, 12, 6, -16, 13, 8, 18, -19, 11, -20, 9, 24, 13, 15, -15, -5, -9, 22, 30, -15, -11, 13, -8, -24, 18, 1, 27, -10, -28, -1, 30, 0, -6, 19, -18, -18, 3, 27, 2, 28, -22, -11, 22, 12, -23, -12, 21, -24, -20, -11, -27, 10, 10, 24, -16, 6, -5, -19, 1, 7, 15, 11, -21, 3, 17, -28, 12, 0, 7, 20, 7, 29, 23, -9, -30, -11, 0, 14, -24, -2, 11, 1, -4, -24, -13, 26, -3, -19, 11, -4, 28, 17, 8, -30, 8, -27, -30, 18, -12, 8, -24, 21, 11, 2, 28, -17, 26, 10, 27, -21, -24, -20, -2, -9, -13, 24, -26, -29, 3, 19, -27, -5, 8, 15, 27, 23, 21, 8, -14, 20, 8, -6, -24, 0, 10, -15, -20, -11, -19, 2, -10, -4, 20, -3, 16, 5, 6, 23, -25, -12, 30, -19, 25, -26, 22, -24, 20, 2, -19, -3, 10, 26, -3, -5, 2, 9, -30, 5, -21, -7, -18, 12, 11, 29, -7, -29, 5, 1, 4, 21, -21, -6, 7, 11, -14, 3, 13, 26, 4, 2, 4, -14, 19, 18, -27, 17, -30, 2, 18, 11, -23, 5, -13, 29, 25, 17, -4, 23, -8, 21, -2, -13, -27, 14, -25, -20, -1, 19, 9, 6, -21, -24, -15, -29, 0, -4, 28, -13, -5, 28, -22, -9, -18, -17, -19, 7, 10, -9, -11, -24, 3, 14, -22, -25, 7, 15, 15, 23, -2, -26, 24, 29, -28, 2, -9, -23, 1, 5, -19, 28, 5, -20, 27, -3, 0, 15, 14, -2, -7, 6, -1, 9, 22, -29, -29, 8, 5, -13, -23, 16, 15, -14, -26, -7, 22, 1, 9, 6, 23, 0, 14, -1, -11, 26, -22, -7, 24, -8, 24, -9, 21, -30, 6, -29, -19, -5, -10, -14, 1, 24, 26, -28, 22, -18, 27, -12, 16, 9, -22, -15, -17, 10, 29, -9, -20, 26, 24, 27, -22, 18, 24, -12, 27, 19, -27, 20, 16, -30, -29, 1, -12, -13, 8, 9, 9, 26, -7, -22, 19, 4, -11, -26, -1, -10, 7, 17, 19, 21, 2, 27, 21, 24, 19, 0, 28, 23, -24, -20, -8, 2, 19, 29, 8, -12, -24, -8, -12, 29, 1, -4, 19, -26, 15, 5, -26, -22, -25, 29, -7, -24, -1, -26, -1, -1, -4, -30, 10, 22, 0, 7, 18, -29, 30, 30, 28, 18, -28, 6, -18, 6, 19, -29, -8, -9, -28, -17, -29, -21, 21, -21, -30, 0, 26, 26, -16, -25, -12, 25, -14, -5, -6, -20, -8, 14, 2, -13, -19, -15, 30, 19, -12, -26, 12, 13, 13, -22, -26, 9, -2, 7, 3, 27, 30, -27, -30, -8, -16, -3, 27, -19, -1, 6, 6, 28, 16, -14, 19, -3, -20, 22, -25, 4, -21, 27, 1, 14, -27, 28, 20, -19, 12, -21, 21, 14, -22, -26, -5, -23, 15, 12, 14, 7, -7, 10, 22, -2, -9, 27, 3, 13, -16, -6, -15, -17, 9, 14, -30, 27, 23, 4, -26, -5, 30, 0, 8, 13, 21, -27, -7, -13, -7, 12, -4, -2, 25, 15, 3, 2, -5, -11, 30, 28, -4, 9, -27, -23, 1, -17, -18, 26, 13, -18, 30, -3, 15, 14, 0, -20, 5, 28, -11, 9, -25, 2, -19, 25, -22, -27, -13, -19, 4, 20, 25, 22, -15, 13, -26, 11, 22, -17, -11, 2, -26, -4, 0, 3, 27, 16, -8, 11, 9, -24, -10, 28, 4, 11, -14, -29, -12, -17, -3, 26, 28, 21, -18, 7, 19, 23, -11, -13, -21, 4, 21, -22, -15, -5, 0, -13, 15, 23, -18, 9, 26, 8, -15, -10, 9, 29, -25, -16, -13, 25, -8, 20, -18, -30, -23, 13, -27, 30, 16, 30, 9, 13, -15, -30, 0, 23, -16, -26, -1, -26, 1, 20, -24, 23, -3, 26, 6, -4, -4, 8, -4, -15, 10, 16, 21, 21, 30, -21, 11, -28, -23, 0, -19, 15, -11, -24, -1, -25, 20, -15, 21, -1, 30, 2, 20, 16, 4, -27, -27, 8, -7, -15, 28, -24, -29, -13, -9, 26, 28, 23, 24, -15, -5, -27, 17, 14, 10, 17, 17, 11, -4, -21, 20, 14, -6, 16, 29, 9, 28, 0, -6, 8, 24, -9, -10, -27, -2, -13, 10, -4, -12, -2, 10, -18, -8, -13, -14, 5, -20, -2, -13, -28, 3, -20, -9, -29, -17, -26, 11, -15, -3, -5, 16, -5, -23, 19, 24, 20, -15, 10, 3, -27, -22, 9, -29, -15, -25, 12, -7, 12, 12, 28, 12, -21, -23, -24, 1, -20, -21, 8, 27, 10, 20, 7, 1, -23, -19, 17, 4, 13, -18, 11, -21, 8, -9, 16, 16, 13, -18, -17, 28, -5, 29, 25, -24, -12, 18, 19, 1, -15, 3, 24, 9, -18, 7, -27, -1, 17, -16, 9, 22, -30, 21, 13, 25, 18, 13, -30, -1, 3, 28, -8, 2, 9, 24, 21, -12, 7, 5, -16, 19, 27, -28, -26, -19, -30, 9, 8, 11, -21, -4, -23, 4, -21, -29, 1, 29, -5, 7, 6, -9, 1, -6, -4, 16, -17, -30, -30, 2, 25, 26, 7, 6, 6, 10, 5, 27, -29, -13, 3, 26, -3, -2, 9, 4, -23, 21, 16, 6, 26, 24, 17, 13, 6, 11, 18, 19, 30, -26, 5, 11, 7, -28, -14, 8, 5, 7, -7, 3, -30, 29, -14, 22, 20, 24, 17, 28, 25, 14, 13, -4, 30, -1, -16, 29, 7, -22, 22, -18, -23, -2, 14, -28, 26, -14, 16, 25, 0, 7, -13, -4, 6, -4, 10, -15, -4, -12, -19, 18, -25, -8, -26, 14, -8, -30, -20, 2, -21, 7, -28, 14, -3, 12]
  tc14 = [45, 20, 29, 41, 6, -9, 38, 4, -9, 33, 40, -7, 14, -10, 46, -7, 41, 29, 6, 38, -5, -1, 22, 17, 49, 4, 29, 4, 20, 20, 50, 12, 0, 14, 33, 15, 43, 39, 35, -6, -5, 0, 6, 29, 5, 28, 50, 47, -7, 32, 0, 12, 16, 1, 24, -5, -9, 6, 6, 9, 19, 25, 48, 31, 21, 24, 32, 24, -2, 40, -5, 34, 26, 31, 28, 28, 26, 12, 19, 43, 3, 40, 12, 3, -3, -4, 8, 31, 15, 44, 23, 35, -1, -1, 31, 0, 50, 20, 39, 24, -9, -9, -8, -2, 6, 33, 19, 35, 44, 33, 1, 16, 8, 22, -5, 46, -5, 17, 6, -10, 5, 35, 13, -4, 9, 8, 6, -7, 24, 13, 4, 23, 27, 21, -1, -10, -2, 13, 2, 48, 22, 39, 20, 26, 6, 43, 44, -8, 3, 9, 15, 8, 9, 12, 33, 37, 23, 39, 40, 5, 25, 48, 28, 10, 38, 20, 1, -4, 41, -7, 11, -4, 2, 7, 29, 38, 32, 43, 14, 45, 18, 45, 35, 48, -7, 25, 49, 24, 39, 19, 18, 24, -7, 17, 32, -1, 38, 25, 45, 15, 14, 45, 45, -6, 23, 24, 33, 38, 0, 39, 50, 42, 33, 12, 31, 41, 33, 12, -3, -2, 28, 7, 37, 32, 13, 5, 13, 39, 16, 0, 9, 18, 12, 2, -8, 44, 16, 46, 7, 22, 47, 24, 43, 43, 4, 48, 41, 13, 40, -7, 14, 1, -10, 4, 29, 33, 37, -10, 25, -9, 49, 10, 49, 48, 3, 27, 36, -1, 10, 19, -1, 3, 38, 3, 38, 45, 22, 33, 31, 13, 15, 1, 46, 37, 0, 18, 24, 36, 20, 17, 38, -4, 2, 19, 37, 31, 9, 44, 30, 24, 26, 17, -8, 36, 32, 30, 40, 39, 4, -1, 7, 7, 24, 41, 43, 18, 19, 31, 47, -7, 17, 24, 38, 43, 43, 34, 44, 49, 37, 3, 10, 39, 23, 14, 49, 38, 43, 16, -1, 8, 44, -3, 38, 47, 30, -3, -6, 17, -9, -9, 42, 5, -2, -2, 28, 49, 32, 7, 37, 28, -10, 6, 46, 26, 6, 18, 44, 32, 45, -5, 16, 39, 44, 24, 20, 25, 47, 4, 19, -6, 27, 22, -3, 9, 1, 3, 33, 30, 1, 34, 32, 35, 16, 28, 17, 43, 39, 42, 36, 21, -3, 17, 12, 37, 20, 34, 1, 24, 39, 19, 21, 21, 47, 38, 41, -6, 48, 18, 29, 42, 50, 2, 0, 41, 25, 31, 11, 32, 31, 31, -4, 8, 20, 33, 26, 13, 10, 25, 0, 20, 33, 41, -4, 2, 22, 3, 16, 1, 36, 36, -6, 12, -2, 17, 43, 45, 16, 37, 26, 44, 15, 27, 33, 35, -4, 49, 38, 17, 3, 22, -7, 33, -4, 36, 13, 15, 30, 19, 16, 9, 34, 4, 14, 39, -6, -3, -8, 6, 50, 13, 34, 21, 34, 19, -4, 25, 25, 0, 0, 39, 0, 49, 38, 39, 45, 44, 14, 9, 43, 21, 11, 6, 36, 44, 31, -5, 34, 16, 20, 25, 20, 11, 13, 39, -8, 48, 39, 9, 44, 9, 35, 31, 29, 13, 37, 10, 15, 17, 34, 41, 26, 27, -1, 18, 16, 31, 3, 33, 14, -7, -10, 37, 19, 32, 50, 48, 3, 1, 4, 3, -7, 26, 47, 4, 29, -2, -8, 18, -4, 13, 9, 31, 12, 11, 1, 29, 4, -2, -8, 36, 24, 24, 40, 14, 33, 48, -4, 35, -5, 9, -3, -4, 46, 31, 18, 23, 23, -9, 38, 45, 2, 31, 16, 38, 9, 1, 50, 37, 40, 24, 19, 39, 30, 18, 6, 44, 4, 20, 42, 50, 0, 3, 4, -8, 17, 49, 17, 6, 41, 48, 6, 40, 36, 1, -7, 7, 11, 25, 9, 36, -5, 13, 17, -3, 49, 24, 31, -6, 0, -7, -10, 6, 47, -2, 46, 26, 26, 3, 4, -6, 45, 20, -2, 44, 11, 15, 39, 9, 13, 23, 17, 33, 7, 6, 37, -8, 34, 27, 43, -2, 9, 42, -1, 14, 12, 6, -9, 47, 7, 44, 36, 31, 45, 32, 2, 25, 49, 5, 27, 3, 43, 14, 21, -6, 45, -5, 32, 49, 22, 23, 44, 14, 49, 22, 32, 7, 17, 40, 32, 36, 7, 20, 9, -4, 17, 39, 29, 40, -10, 5, 37, 20, 3, 13, 30, 31, 41, 38, 5, 12, 35, 32, 20, 7, -7, 49, 27, 2, 13, 42, 27, -8, 4, -10, 28, 8, -5, 39, 40, 0, 47, 30, 45, 29, 2, 45, 46, -6, 40, 10, 43, 17, -10, -2, 8, 22, 36, 46, 17, -9, 33, 24, -5, 5, 36, 7, 48, 13, -7, 28, 16, -7, 22, -3, 12, 35, -3, 11, -6, 25, 35, 41, 13, 50, 36, -4, 8, -8, -1, 38, 0, 7, 40, 47, 13, 25, 46, 35, 21, 7, 31, 9, 18, 17, 4, 14, 10, 8, 40, 20, 21, 21, 44, 10, 14, -2, 12, 20, -4, 6, 45, 10, 33, -6, 22, 44, 14, 11, 4, 9, 31, 38, 11, 42, 33, 25, 1, 10, 44, 49, 18, -4, -9, 48, -6, 17, -1, 43, 5, 42, 37, 43, 37, 31, 23, 31, 27, 8, -9, 27, 45, 20, 26, -6, 27, 39, 8, 45, 22, -5, 29, 41, 15, 2, 6, 3, 13, 16, 46, 10, 36, 24, 22, 9, 18, 41, 21, -1, 44, 24, 12, 31, 40, 31, 30, 26, 47, 31, 6, -8, -7, 8, 41, 5, 13, -6, -3, 1, -4, 0, 17, 25, 15, 25, 4, 8, 24, 13, -6, 7, 20, 6, 21, 43, 9, 18, 10, 28, 33, 25, 46, -1, 20, 40, 23, 33, 11, 50, 16, -5, 44, 28, 41, 40, 23, -5, 24, 8, 6, 8, 33, 43, 45, 43, 25, 26, 0, 30, -7, 7, 23, 1, 4, 27, 46, 5, 29, 20, -6, 40, 40, 16, -7, 39, -5, 28, 6, 45, 5, 43]
  tc15 = [-1, 0, 0, -1, 0, 1, 1, 0, 0, 1, -1, 0, -1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 0, -1, 1, 1, -1, -1, -1, -1, 1, 0, 0, 0, 1, 0, -1, 1, -1, 1, 0, 0, 0, 1, 0, 0, -1, 1, -1, 1, 1, -1, 1, 1, 0, 1, -1, 1, 1, 0, -1, 1, -1, 1, 1, 1, -1, 0, 0, 0, -1, -1, 1, -1, 0, 1, 1, -1, -1, 0, 0, -1, 1, 1, 0, -1, -1, -1, 1, -1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, -1, 0, 0, 0, -1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, -1, -1, -1, -1, 0, -1, 0, 0, 0, 1, 0, 0, 1, 1, 1, -1, 0, -1, 1, 0, -1, -1, -1, 0, 0, -1, -1, 0, 1, 1, -1, 1, 1, -1, 0, 1, -1, 1, 1, -1, 0, 1, 1, 1, 1, 0, -1, -1, 0, 0, 1, 0, 1, -1, -1, 1, 0, 0, 1, 0, 0, 1, 1, -1, -1, -1, 1, 1, 0, 0, -1, 1, -1, 1, -1, 1, 0, 1, 1, 0, 1, 0, 0, -1, 0, -1, -1, -1, -1, 1, 0, 0, 1, -1, 0, -1, 1, 1, -1, 1, 0, 0, 0, -1, -1, -1, -1, 0, -1, 0, 0, 0, 0, 0, 1, 1, 0, -1, -1, 0, -1, -1, 0, 0, -1, 1, -1, 1, 0, -1, 1, 1, -1, -1, 1, 1, -1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, -1, -1, 0, 1, 1, 0, 0, -1, 0, -1, 0, 1, 1, 1, 0, 1, 0, 0, -1, 0, -1, 0, 0, 0, -1, 1, 1, 0, -1, -1, -1, 0, -1, 0, 0, -1, -1, 0, 1, 1, 1, 1, 0, 0, -1, 0, -1, -1, 1, 0, 0, 0, -1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, -1, 0, 0, -1, -1, 0, 1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 1, 1, -1, 0, 1, 0, -1, 1, 1, 1, -1, -1, 0, 1, 0, 0, 1, 0, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, -1, 0, -1, -1, -1, 1, 1, -1, -1, -1, 0, -1, -1, -1, 0, -1, -1, 1, -1, -1, -1, 0, -1, -1, 0, 1, 1, 1, 0, -1, -1, 0, 0, 0, 0, 0, 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 0, 0, 0, 0, -1, 1, 1, -1, 1, 0, 0, -1, -1, -1, 1, -1, 0, 0, -1, 1, -1, -1, 1, 0, -1, -1, 0, 0, 0, 0, 0, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, -1, -1, 1, 1, 0, 1, 0, 0, 1, -1, 1, -1, -1, 0, -1, -1, 1, 1, 1, 1, 0, 1, -1, -1, -1, 0, -1, -1, -1, -1, 1, -1, -1, 1, 1, 0, 1, -1, -1, -1, 1, 0, 0, -1, 0, -1, 1, 1, 1, 0, -1, -1, -1, 1, -1, 0, 0, 1, -1, -1, 1, 0, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 0, 0, 1, 1, 0, 0, 0, -1, 1, -1, -1, -1, 0, 0, 0, -1, -1, 1, -1, 1, 1, -1, 1, 1, -1, 1, -1, 0, 1, -1, -1, 0, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, 1, 0, -1, 0, 1, 1, 1, 0, 0, 0, 1, 1, -1, -1, 1, 0, 0, 0, -1, -1, -1, 0, 0, 0, 0, 1, 0, 1, 0, -1, 1, 1, -1, -1, -1, -1, 0, -1, 0, -1, 0, 1, 0, 0, 0, 0, 1, 0, 1, -1, 0, 1, -1, 1, 0, 1, -1, 1, -1, 1, 0, 1, 0, 1, 1, -1, 0, -1, 0, 1, 0, 1, -1, 1, -1, 1, 1, 0, 0, -1, 1, 1, 1, -1, 0, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 0, 0, 0, 1, 1, 1, 0, 1, 1, -1, 0, 0, -1, 0, 1, 0, -1, 0, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 0, -1, -1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 0, 0, 0, 1, 0, 0, -1, -1, -1, -1, 0, -1, 1, -1, 1, 0, 0, 0, 0, 0, -1, 0, -1, 0, 0, -1, -1, 1, 0, -1, 0, -1, 1, -1, -1, 0, -1, -1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, -1, 0, -1, -1, 1, 1, 0, 1, -1, 1, 1, 0, 0, 0, 0, -1, 1, -1, -1, -1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 1, 0, 0, 0, 1, -1, 0, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, 0, 0, 1, -1, -1, 0, -1, 0, 0, 1, 1, 1, -1, 0, 0, -1, 1, 0, -1, -1, 1, 0, -1, 1, -1, -1, 0, -1, -1, 0, 0, -1, 0, 0, 1, -1, 0, 1, 1, -1, 1, 0, 0, 0, -1, 0, -1, -1, -1, 0, 0, -1, -1, -1, 0, 1, 0, 1, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, -1, 1, -1, 1, -1, -1, 0, -1, -1, -1, 1, -1, 1, 1, 0, 1, 1, 1, 0, 0, 0, -1, 0, 1, 1, 1, -1, -1, 1, 0, -1, 1, 0, 0, 1, 0, -1, 1, 0, 1, 0, -1, 0, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, -1, 1, 0, 1, -1, 1, -1, 1, 0, -1, 0, 1, 1, -1, 0, 1, -1, 0, 0, 1, -1, -1, -1, 0, -1, -1, 0, -1, 1, 1, 0, 1, 1, 0, -1, 1, 0, 0, -1, -1, -1, 1, 1, 0, 0, -1, 1, 1, 0, 1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 0, 0, -1, -1, 1, 1, 0, -1, 1, 1, 1, 0, -1, -1, 0, -1, 0, 0, -1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 0, 1, 0, 1, -1, 1, -1, -1, 0, -1, 1, 1, 0, 1, 1, 0, 1, 1, 0, -1, 1, -1, 0, 0, -1, 0, 1, -1, 1, 1, -1, 0, 1, -1, 0, -1, 0, 1, -1, -1, 0, 0, -1, 1, -1, -1, 1, -1, -1, 0, 1, 0, 1, 1, -1, -1, 1, -1, 1, 0, -1, 1, -1, 0, -1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, -1, -1, 1, -1, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 0, -1, 0, 1, -1, -1, 1, 0, 0, 1, 1, 1, 1, -1, 0, 0, 1, 1, -1, -1, 0, -1, -1, 1, 1, 0, 1, 0, 0, 0, 1, -1, 0, 1, 0, 0, -1, 0, 1, 1, 1, -1, -1, 0, -1, 0, 1, 1, -1, 1, 0, 1, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, -1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, 1, 0, -1, 1, -1, 1, 1, 1, -1, 1, 1, 0, -1, 1, 1, 0, -1, 0, -1, 1, 1, -1, 1, 0, 0, 1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, 0, 0, 1, -1, -1, 0, -1, 0, 1, 0, -1, -1, 0, 0, 0, -1, 1, 0, -1, -1, -1, 1, -1, 1, 0, 1, -1, -1, -1, 0, -1, -1, 1, 0, 0, 0, 1, 0, 0, 1, 1, -1, -1, 0, 0, 1, -1, 0, 1, -1, 0, 1, 0, -1, 1, 0, -1, 1, -1, -1, -1, 1, 1, 0, 0, -1, 0, -1, 0, -1, 1, 1, -1, -1, 0, -1, 0, 0, -1, 0, 1, -1, 0, -1, 0, 1, 1, -1, -1, 1, -1, -1, 1, 1, 0, -1, 1, -1, 0, 0, 1, 0, -1, 1, 1, 1, 1, 1, -1, 0, 1, 0, -1, 0, -1, 0, 1, -1, 0, -1, 1, -1, 1, 1, 0, -1, 0, -1, -1, 1, 0, -1, 1, 1, 1, 0, 0, 1, -1, -1, 1, 1, 0, 1, 1, 0, 0, 1, -1, 1, 0, 1, -1, 1, -1, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 1, 1, 0, 1, -1, 0, 0, 0, 0, 0, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, -1, -1, 0, 0, 0, 0, 1, 1, -1, -1, 1, -1, 0, -1, 1, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, -1, 0, 0, -1, 0, 0, 0, -1, -1, 0, 0, -1, -1, 0, 1, -1, -1, -1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 1, -1, 0, 1, 0, -1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, -1, 1, 1, -1, 1, 0, -1, 1, -1, -1, 0, -1, 0, 0, 0, 0, 1, 1, 1, -1, 0, 0, 0, -1, 1, 0, 0, -1, 1, -1, 0, 0, -1, 0, 1, 0, 1, 0, 0, 1, -1, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, 0, 1, -1, 1, 0, -1, -1, 1, 1, 1, 1, 0, -1, -1, 1, 0, 0, -1, -1, 0, 0, 1, 1, 0, 1, 1, -1, 0, 1, 0, 0, -1, 1, -1, -1, 0, -1, 0, -1, 1, -1, 1, -1, 0, 0, 1, 1, 1, -1, 1, 1, 1, 1, 0, -1, 1, -1, -1, 0, 1, -1, -1, 0, 0, -1, -1, 1, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 0, 0, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 0, -1, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0, 0, 0, -1, 0, -1, 0, 0, 1, 0, -1, -1, 0, -1, 0, 1, -1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, -1, 0, 1, 1, 1, 1, 1, 1, 1, -1, 0, -1, 0, 1, 1, -1, 0, 0, -1, -1, 1, 1, -1, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, 1, 0, 1, 0, -1, 1, 0, 1, -1, 0, 0, 0, 1, -1, 0, 0, 0, 1, -1, 1, 0, -1, 0, 0, 0, 1, 1, 0, -1, -1, 1, -1, 1, 1, 0, 1, 0, 0, 1, -1, 1, 1, 1, 0, 0, -1, -1, 1, 0, 0, 1, -1, -1, 1, 1, -1, 1, 0, -1, 1, -1, 1, 0, 0, 1, 0, 0, 1, 1, -1, -1, 0, 1, 1, 1, -1, 0, 0, 1, -1, -1, 0, 0, 1, 1, 1, -1, 0, 0, 1, -1, -1, 0, 0, 1, 1, 0, -1, 1, -1, 0, 0, 0, -1, 1, -1, 1, 1, 0, -1, -1, 0, -1, 1, -1, -1, -1, 0, 1, -1, -1, 1, -1, 0, 1, -1, 0, 0, 1, 0, -1, -1, 0, 1, 1, 1, -1, 0, 0, -1, 1, 1, -1, 0, 1, -1, 0, 1, 1, 0, 1, -1, -1, 0, 0, -1, -1, -1, 1, -1, -1, 0, -1, 0, 0, 1, -1, 0, 1, 0, 1, 0, 1, 0, -1, 0, 1, 0, -1, 0, -1, -1, -1, 0, -1, 0, -1, -1, -1, -1, 1, -1, 1, 0, 1, -1, -1, -1, -1, 1, -1, -1, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0, 1, -1, 1, -1, 1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 0, 0, -1, 0, 0, 0, 0, -1, 1, 1, 0, 1, 1, 0, -1, 1, 0, 1, -1, -1, 1, 0, 0, -1]
  
  ```

  

## 수행단계

- 주어진 리스트에서 합이 가장 큰 연속된 구간을 찾는 함수를 basic_approach/find_energetic_neuron_sequence.py 파일에 구현한다.
  - 이 함수는 숫자로 구성된 리스트에서 합이 가장 큰 연속된 구간을 분할 정복 방식으로 찾는다.
  - 이 구간의 시작 인덱스와 끝 인덱스로 구성된 리스트와 이 구간의 전압의 합을 반환한다.
  - 예를 들어서 주어진 리스트가 [5, -1, 2, 3, -1, 3, -4, 3, -6]인 경우, 이 리스트에서 값의 합이 11이 되는 [5, -1, 2, 3, -1, 3] 구간이 합이 가장 큰 구간이므로, 11을 반환한다.
  - 주어진 리스트가 [2, -5, 2, -1, 1]인 경우, 첫 번째 인덱스의 [2]와 세 번째 인덱스의 [2], 그리고 [2, -1, 1]이 구간의 합이 2로 가장 큰 구간이다. 그러므로 이 함수는 2를 반환한다.

- 첨부한 리스트를 사용해 실행한 결과를 출력한다.

## 결과 예시

```
testcase 1
    최대 부분 합 : 11
testcase 2
    최대 부분 합 : 2
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 사실 연구원 N에게 도움이 되는 결과는 전압의 합이 가장 큰 구간의 전압의 합이 아니라, 이 구간이 어디인지에 대한 정보이다. 전압의 합과 함께 어떤 구간에서 전압의 합이 가장 큰지도 반환하도록 함수를 구현하고, 문제에서 제공한 테스트케이스에서 그 구간의 시작과 끝 인덱스의 튜플의 목록을 출력해보자.
  - 문제에서 제시한 예제 리스트의 경우, 첫 번째 리스트는 [(0, 5)]를 출력해야 하며, 두 번째 리스트는 모든 위치의 목록, 즉 [(0, 0), (2, 2), (2, 4)]를 출력해야 한다. 리스트를 출력하는 순서는 시작 인덱스와 끝 인덱스 순서로 정렬해서 출력한다.
  


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/find_energetic_neuron_sequence.py 파일에 구현이 되어 있는지 확인한다.
  - 분할 정복 방식으로 문제를 나누어가며 해결하엿는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 

    ```
    testcase 1
        최대 부분 합 : 11
    testcase 2
        최대 부분 합 : 2
    testcase 3
        최대 부분 합 : 5
    testcase 4
        최대 부분 합 : -1
    testcase 5
        최대 부분 합 : 0
    testcase 6
        최대 부분 합 : 55
    testcase 7
        최대 부분 합 : 100
    testcase 8
        최대 부분 합 : -100
    testcase 9
        최대 부분 합 : 11
    testcase 10
        최대 부분 합 : 300
    testcase 11
        최대 부분 합 : 372
    testcase 12
        최대 부분 합 : 586
    testcase 13
        최대 부분 합 : 552
    testcase 14
        최대 부분 합 : 20222
    testcase 15
        최대 부분 합 : 22
    ```

### [보너스 과제의 확인]

* 지시한 대로 구현하였는가?

  * 최대 합이 되는 구간의 시작 인덱스와 끝 인덱스를 시작 인덱스 우선으로 정렬해 출력하고 있는지 확인한다.

* 결과는 정확한가?

  * 결과는 다음과 같다. 

    ```
    testcase 1
        최대 부분 합 : 11
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 5)]
    testcase 2
        최대 부분 합 : 2
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 0), (2, 2), (2, 4)]
    testcase 3
        최대 부분 합 : 5
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 4)]
    testcase 4
        최대 부분 합 : -1
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]
    testcase 5
        최대 부분 합 : 0
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2)]
    testcase 6
        최대 부분 합 : 55
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(1, 10)]
    testcase 7
        최대 부분 합 : 100
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 0)]
    testcase 8
        최대 부분 합 : -100
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 0)]
    testcase 9
        최대 부분 합 : 11
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 5), (9, 14)]
    testcase 10
        최대 부분 합 : 300
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(67, 99)]
    testcase 11
        최대 부분 합 : 372
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(33, 51), (35, 51)]
    testcase 12
        최대 부분 합 : 586
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(34, 38)]
    testcase 13
        최대 부분 합 : 552
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(289, 975)]
    testcase 14
        최대 부분 합 : 20222
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(0, 999)]
    testcase 15
        최대 부분 합 : 22
        최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : [(1687, 1835), (1687, 1839), (1687, 1845), (1687, 1846), (1687, 1848), (1687, 1857), (1687, 1858), (1688, 1835), (1688, 1839), (1688, 1845), (1688, 1846), (1688, 1848), (1688, 1857), (1688, 1858), (1690, 1835), (1690, 1839), (1690, 1845), (1690, 1846), (1690, 1848), (1690, 1857), (1690, 1858), (1691, 1835), (1691, 1839), (1691, 1845), (1691, 1846), (1691, 1848), (1691, 1857), (1691, 1858)]
    ```
    
    

### [문제에 대한 이해]

- 분할 정복 방식으로 문제를 해결하기 위해서 문제를 어떻게 나누었는지 설명하라.
- 문제를 작은 문제로 분할했을 때 중첩되지 않는 회색지대에 해당하는 부분이 남아 있었다면 어떤 부분인지, 그리고 이 부분의 문제를 어떻게 해결하였는지 설명하라.

### [코드 예시]

```python
def find_maxsum_subarray(arr, start = None, end = None):
    if start == None:
        start = 0
    if end == None:
        end = len(arr) - 1
    if start == end:
        return arr[start], [(start, end)]
    mid = (start + end) // 2
    leading_max, leading_max_parts = find_maxsum_subarray(arr, start, mid)
    trailing_max, trailing_max_parts = find_maxsum_subarray(arr, mid + 1, end)
    forwaring_sum = 0
    backwarding_sum = 0
    
    forwarding_max = float("-inf")
    backwarding_max = float("-inf")
    forwarding_max_indices = []
    backwarding_max_indices = []
    for i in range(mid, start - 1, -1):
        forwaring_sum += arr[i]
        if forwaring_sum > forwarding_max:
            forwarding_max = forwaring_sum
            forwarding_max_indices = [i]
        elif forwaring_sum == forwarding_max:
            forwarding_max_indices.append(i)

    for i in range(mid + 1, end + 1):
        backwarding_sum += arr[i]
        if backwarding_sum > backwarding_max:
            backwarding_max = backwarding_sum
            backwarding_max_indices = [i]
        elif backwarding_sum == backwarding_max:
            backwarding_max_indices.append(i)
    crossing_max = forwarding_max + backwarding_max
    crossing_max_parts = []
    for i in forwarding_max_indices:
        for j in backwarding_max_indices:
            crossing_max_parts.append((i, j))
    sum_dict = {}
    sum_dict[crossing_max] = crossing_max_parts
    if leading_max in sum_dict:
        sum_dict[leading_max] += leading_max_parts
    else:
        sum_dict[leading_max] = leading_max_parts
    if trailing_max in sum_dict:
        sum_dict[trailing_max] += trailing_max_parts
    else:
        sum_dict[trailing_max] = trailing_max_parts
    max_sum = max(crossing_max, leading_max, trailing_max)
    return max_sum, sum_dict[max_sum]
    
    

def main():
    tc1 = [5, -1, 2, 3, -1, 3, -4, 3, -6]
    tc2 = [2, -5, 2, -1, 1]
    tc3 = [1, 1, 1, 1, 1]
    tc4 = [-1, -1, -1, -1, -1]
    tc5 = [0, 0, 0]
    tc6 = [-100, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -100, 54]
    tc7 = [100]
    tc8 = [-100]
    tc9 = [5, -1, 2, 3, -1, 3, -4, 3, -100, 5, -1, 2, 3, -1, 3, -4, 3, -6]
    tc10 = [5, -29, -74, 96, 70, 20, 81, -24, 5, -70, 56, -65, -53, 83, -81, -25, -6, -20, 61, 18, 3, -2, 75, 32, -46, -49, 92, -70, -85, 13, 40, 37, 80, -52, -25, 11, 90, -56, 4, 57, -18, -9, -88, -24, 28, -5, -41, -92, 8, 47, -13, -85, -86, 1, 52, -32, 24, -33, -56, -86, -22, -9, 17, 82, -66, 4, -91, 84, -27, 52, -82, 82, 84, -29, -38, 36, -76, 72, -41, 35, 57, -21, -7, -47, 50, -12, 25, -61, -43, -9, 13, -65, -17, 48, 81, 39, 75, -45, -6, 93]
    tc11 = [58, -9, 13, -14, -59, 57, -97, 25, 62, 44, 13, -66, -51, 61, 3, 91, -60, -38, 42, -74, -43, -26, -18, -12, -47, 63, 92, -23, -36, -96, 60, -71, -43, 46, -46, 10, 99, -83, 5, 89, 28, -7, 67, -7, 99, -70, -28, 43, -81, 70, 48, 90, -68, -65, -100, -54, 24, -42, -54, -50, -26, -24, -55, -43, -26, 18, 56, -32, -67, 12, -12, 10, 17, -36, 23, -21, 8, -53, -4, -89, 8, 29, -19, 84, -37, 72, 15, -78, 11, -44, 8, 87, -65, -88, 92, -37, -74, -30, -74, 4]
    tc12 = [166, -363, -551, -715, -628, -789, -588, -401, -100, -79, 56, -693, -29, -558, -529, -671, -772, 134, -565, -214, 148, -308, -304, -543, 75, -779, -264, -487, -365, -593, -253, -744, -435, -550, 75, 103, 67, 158, 183, -71, -378, -554, -351, -644, -610, 141, -181, 68, -299, -6, -97, -535, 124, -15, -778, -91, -227, -445, -477, -423, -1, -216, -79, -722, -660, -711, -686, -3, -790, 111, -488, -773, 35, -656, -771, 117, -44, -153, -11, -461, -165, -778, -135, -748, -404, -356, -64, -601, -137, -25, -602, -448, -699, -334, 24, -559, -68, -500, -122, -79]
    tc13 = [30, 22, -12, -5, 1, -21, 13, 1, -18, -16, -9, -16, 13, 29, -18, -6, -24, 13, 3, -23, -11, 0, 13, 19, -18, 7, 11, 14, -25, 24, -24, -20, -29, 2, -27, 18, -2, 27, 7, 21, 15, -20, -25, -25, -23, -23, 12, 6, -16, 13, 8, 18, -19, 11, -20, 9, 24, 13, 15, -15, -5, -9, 22, 30, -15, -11, 13, -8, -24, 18, 1, 27, -10, -28, -1, 30, 0, -6, 19, -18, -18, 3, 27, 2, 28, -22, -11, 22, 12, -23, -12, 21, -24, -20, -11, -27, 10, 10, 24, -16, 6, -5, -19, 1, 7, 15, 11, -21, 3, 17, -28, 12, 0, 7, 20, 7, 29, 23, -9, -30, -11, 0, 14, -24, -2, 11, 1, -4, -24, -13, 26, -3, -19, 11, -4, 28, 17, 8, -30, 8, -27, -30, 18, -12, 8, -24, 21, 11, 2, 28, -17, 26, 10, 27, -21, -24, -20, -2, -9, -13, 24, -26, -29, 3, 19, -27, -5, 8, 15, 27, 23, 21, 8, -14, 20, 8, -6, -24, 0, 10, -15, -20, -11, -19, 2, -10, -4, 20, -3, 16, 5, 6, 23, -25, -12, 30, -19, 25, -26, 22, -24, 20, 2, -19, -3, 10, 26, -3, -5, 2, 9, -30, 5, -21, -7, -18, 12, 11, 29, -7, -29, 5, 1, 4, 21, -21, -6, 7, 11, -14, 3, 13, 26, 4, 2, 4, -14, 19, 18, -27, 17, -30, 2, 18, 11, -23, 5, -13, 29, 25, 17, -4, 23, -8, 21, -2, -13, -27, 14, -25, -20, -1, 19, 9, 6, -21, -24, -15, -29, 0, -4, 28, -13, -5, 28, -22, -9, -18, -17, -19, 7, 10, -9, -11, -24, 3, 14, -22, -25, 7, 15, 15, 23, -2, -26, 24, 29, -28, 2, -9, -23, 1, 5, -19, 28, 5, -20, 27, -3, 0, 15, 14, -2, -7, 6, -1, 9, 22, -29, -29, 8, 5, -13, -23, 16, 15, -14, -26, -7, 22, 1, 9, 6, 23, 0, 14, -1, -11, 26, -22, -7, 24, -8, 24, -9, 21, -30, 6, -29, -19, -5, -10, -14, 1, 24, 26, -28, 22, -18, 27, -12, 16, 9, -22, -15, -17, 10, 29, -9, -20, 26, 24, 27, -22, 18, 24, -12, 27, 19, -27, 20, 16, -30, -29, 1, -12, -13, 8, 9, 9, 26, -7, -22, 19, 4, -11, -26, -1, -10, 7, 17, 19, 21, 2, 27, 21, 24, 19, 0, 28, 23, -24, -20, -8, 2, 19, 29, 8, -12, -24, -8, -12, 29, 1, -4, 19, -26, 15, 5, -26, -22, -25, 29, -7, -24, -1, -26, -1, -1, -4, -30, 10, 22, 0, 7, 18, -29, 30, 30, 28, 18, -28, 6, -18, 6, 19, -29, -8, -9, -28, -17, -29, -21, 21, -21, -30, 0, 26, 26, -16, -25, -12, 25, -14, -5, -6, -20, -8, 14, 2, -13, -19, -15, 30, 19, -12, -26, 12, 13, 13, -22, -26, 9, -2, 7, 3, 27, 30, -27, -30, -8, -16, -3, 27, -19, -1, 6, 6, 28, 16, -14, 19, -3, -20, 22, -25, 4, -21, 27, 1, 14, -27, 28, 20, -19, 12, -21, 21, 14, -22, -26, -5, -23, 15, 12, 14, 7, -7, 10, 22, -2, -9, 27, 3, 13, -16, -6, -15, -17, 9, 14, -30, 27, 23, 4, -26, -5, 30, 0, 8, 13, 21, -27, -7, -13, -7, 12, -4, -2, 25, 15, 3, 2, -5, -11, 30, 28, -4, 9, -27, -23, 1, -17, -18, 26, 13, -18, 30, -3, 15, 14, 0, -20, 5, 28, -11, 9, -25, 2, -19, 25, -22, -27, -13, -19, 4, 20, 25, 22, -15, 13, -26, 11, 22, -17, -11, 2, -26, -4, 0, 3, 27, 16, -8, 11, 9, -24, -10, 28, 4, 11, -14, -29, -12, -17, -3, 26, 28, 21, -18, 7, 19, 23, -11, -13, -21, 4, 21, -22, -15, -5, 0, -13, 15, 23, -18, 9, 26, 8, -15, -10, 9, 29, -25, -16, -13, 25, -8, 20, -18, -30, -23, 13, -27, 30, 16, 30, 9, 13, -15, -30, 0, 23, -16, -26, -1, -26, 1, 20, -24, 23, -3, 26, 6, -4, -4, 8, -4, -15, 10, 16, 21, 21, 30, -21, 11, -28, -23, 0, -19, 15, -11, -24, -1, -25, 20, -15, 21, -1, 30, 2, 20, 16, 4, -27, -27, 8, -7, -15, 28, -24, -29, -13, -9, 26, 28, 23, 24, -15, -5, -27, 17, 14, 10, 17, 17, 11, -4, -21, 20, 14, -6, 16, 29, 9, 28, 0, -6, 8, 24, -9, -10, -27, -2, -13, 10, -4, -12, -2, 10, -18, -8, -13, -14, 5, -20, -2, -13, -28, 3, -20, -9, -29, -17, -26, 11, -15, -3, -5, 16, -5, -23, 19, 24, 20, -15, 10, 3, -27, -22, 9, -29, -15, -25, 12, -7, 12, 12, 28, 12, -21, -23, -24, 1, -20, -21, 8, 27, 10, 20, 7, 1, -23, -19, 17, 4, 13, -18, 11, -21, 8, -9, 16, 16, 13, -18, -17, 28, -5, 29, 25, -24, -12, 18, 19, 1, -15, 3, 24, 9, -18, 7, -27, -1, 17, -16, 9, 22, -30, 21, 13, 25, 18, 13, -30, -1, 3, 28, -8, 2, 9, 24, 21, -12, 7, 5, -16, 19, 27, -28, -26, -19, -30, 9, 8, 11, -21, -4, -23, 4, -21, -29, 1, 29, -5, 7, 6, -9, 1, -6, -4, 16, -17, -30, -30, 2, 25, 26, 7, 6, 6, 10, 5, 27, -29, -13, 3, 26, -3, -2, 9, 4, -23, 21, 16, 6, 26, 24, 17, 13, 6, 11, 18, 19, 30, -26, 5, 11, 7, -28, -14, 8, 5, 7, -7, 3, -30, 29, -14, 22, 20, 24, 17, 28, 25, 14, 13, -4, 30, -1, -16, 29, 7, -22, 22, -18, -23, -2, 14, -28, 26, -14, 16, 25, 0, 7, -13, -4, 6, -4, 10, -15, -4, -12, -19, 18, -25, -8, -26, 14, -8, -30, -20, 2, -21, 7, -28, 14, -3, 12]
    tc14 = [45, 20, 29, 41, 6, -9, 38, 4, -9, 33, 40, -7, 14, -10, 46, -7, 41, 29, 6, 38, -5, -1, 22, 17, 49, 4, 29, 4, 20, 20, 50, 12, 0, 14, 33, 15, 43, 39, 35, -6, -5, 0, 6, 29, 5, 28, 50, 47, -7, 32, 0, 12, 16, 1, 24, -5, -9, 6, 6, 9, 19, 25, 48, 31, 21, 24, 32, 24, -2, 40, -5, 34, 26, 31, 28, 28, 26, 12, 19, 43, 3, 40, 12, 3, -3, -4, 8, 31, 15, 44, 23, 35, -1, -1, 31, 0, 50, 20, 39, 24, -9, -9, -8, -2, 6, 33, 19, 35, 44, 33, 1, 16, 8, 22, -5, 46, -5, 17, 6, -10, 5, 35, 13, -4, 9, 8, 6, -7, 24, 13, 4, 23, 27, 21, -1, -10, -2, 13, 2, 48, 22, 39, 20, 26, 6, 43, 44, -8, 3, 9, 15, 8, 9, 12, 33, 37, 23, 39, 40, 5, 25, 48, 28, 10, 38, 20, 1, -4, 41, -7, 11, -4, 2, 7, 29, 38, 32, 43, 14, 45, 18, 45, 35, 48, -7, 25, 49, 24, 39, 19, 18, 24, -7, 17, 32, -1, 38, 25, 45, 15, 14, 45, 45, -6, 23, 24, 33, 38, 0, 39, 50, 42, 33, 12, 31, 41, 33, 12, -3, -2, 28, 7, 37, 32, 13, 5, 13, 39, 16, 0, 9, 18, 12, 2, -8, 44, 16, 46, 7, 22, 47, 24, 43, 43, 4, 48, 41, 13, 40, -7, 14, 1, -10, 4, 29, 33, 37, -10, 25, -9, 49, 10, 49, 48, 3, 27, 36, -1, 10, 19, -1, 3, 38, 3, 38, 45, 22, 33, 31, 13, 15, 1, 46, 37, 0, 18, 24, 36, 20, 17, 38, -4, 2, 19, 37, 31, 9, 44, 30, 24, 26, 17, -8, 36, 32, 30, 40, 39, 4, -1, 7, 7, 24, 41, 43, 18, 19, 31, 47, -7, 17, 24, 38, 43, 43, 34, 44, 49, 37, 3, 10, 39, 23, 14, 49, 38, 43, 16, -1, 8, 44, -3, 38, 47, 30, -3, -6, 17, -9, -9, 42, 5, -2, -2, 28, 49, 32, 7, 37, 28, -10, 6, 46, 26, 6, 18, 44, 32, 45, -5, 16, 39, 44, 24, 20, 25, 47, 4, 19, -6, 27, 22, -3, 9, 1, 3, 33, 30, 1, 34, 32, 35, 16, 28, 17, 43, 39, 42, 36, 21, -3, 17, 12, 37, 20, 34, 1, 24, 39, 19, 21, 21, 47, 38, 41, -6, 48, 18, 29, 42, 50, 2, 0, 41, 25, 31, 11, 32, 31, 31, -4, 8, 20, 33, 26, 13, 10, 25, 0, 20, 33, 41, -4, 2, 22, 3, 16, 1, 36, 36, -6, 12, -2, 17, 43, 45, 16, 37, 26, 44, 15, 27, 33, 35, -4, 49, 38, 17, 3, 22, -7, 33, -4, 36, 13, 15, 30, 19, 16, 9, 34, 4, 14, 39, -6, -3, -8, 6, 50, 13, 34, 21, 34, 19, -4, 25, 25, 0, 0, 39, 0, 49, 38, 39, 45, 44, 14, 9, 43, 21, 11, 6, 36, 44, 31, -5, 34, 16, 20, 25, 20, 11, 13, 39, -8, 48, 39, 9, 44, 9, 35, 31, 29, 13, 37, 10, 15, 17, 34, 41, 26, 27, -1, 18, 16, 31, 3, 33, 14, -7, -10, 37, 19, 32, 50, 48, 3, 1, 4, 3, -7, 26, 47, 4, 29, -2, -8, 18, -4, 13, 9, 31, 12, 11, 1, 29, 4, -2, -8, 36, 24, 24, 40, 14, 33, 48, -4, 35, -5, 9, -3, -4, 46, 31, 18, 23, 23, -9, 38, 45, 2, 31, 16, 38, 9, 1, 50, 37, 40, 24, 19, 39, 30, 18, 6, 44, 4, 20, 42, 50, 0, 3, 4, -8, 17, 49, 17, 6, 41, 48, 6, 40, 36, 1, -7, 7, 11, 25, 9, 36, -5, 13, 17, -3, 49, 24, 31, -6, 0, -7, -10, 6, 47, -2, 46, 26, 26, 3, 4, -6, 45, 20, -2, 44, 11, 15, 39, 9, 13, 23, 17, 33, 7, 6, 37, -8, 34, 27, 43, -2, 9, 42, -1, 14, 12, 6, -9, 47, 7, 44, 36, 31, 45, 32, 2, 25, 49, 5, 27, 3, 43, 14, 21, -6, 45, -5, 32, 49, 22, 23, 44, 14, 49, 22, 32, 7, 17, 40, 32, 36, 7, 20, 9, -4, 17, 39, 29, 40, -10, 5, 37, 20, 3, 13, 30, 31, 41, 38, 5, 12, 35, 32, 20, 7, -7, 49, 27, 2, 13, 42, 27, -8, 4, -10, 28, 8, -5, 39, 40, 0, 47, 30, 45, 29, 2, 45, 46, -6, 40, 10, 43, 17, -10, -2, 8, 22, 36, 46, 17, -9, 33, 24, -5, 5, 36, 7, 48, 13, -7, 28, 16, -7, 22, -3, 12, 35, -3, 11, -6, 25, 35, 41, 13, 50, 36, -4, 8, -8, -1, 38, 0, 7, 40, 47, 13, 25, 46, 35, 21, 7, 31, 9, 18, 17, 4, 14, 10, 8, 40, 20, 21, 21, 44, 10, 14, -2, 12, 20, -4, 6, 45, 10, 33, -6, 22, 44, 14, 11, 4, 9, 31, 38, 11, 42, 33, 25, 1, 10, 44, 49, 18, -4, -9, 48, -6, 17, -1, 43, 5, 42, 37, 43, 37, 31, 23, 31, 27, 8, -9, 27, 45, 20, 26, -6, 27, 39, 8, 45, 22, -5, 29, 41, 15, 2, 6, 3, 13, 16, 46, 10, 36, 24, 22, 9, 18, 41, 21, -1, 44, 24, 12, 31, 40, 31, 30, 26, 47, 31, 6, -8, -7, 8, 41, 5, 13, -6, -3, 1, -4, 0, 17, 25, 15, 25, 4, 8, 24, 13, -6, 7, 20, 6, 21, 43, 9, 18, 10, 28, 33, 25, 46, -1, 20, 40, 23, 33, 11, 50, 16, -5, 44, 28, 41, 40, 23, -5, 24, 8, 6, 8, 33, 43, 45, 43, 25, 26, 0, 30, -7, 7, 23, 1, 4, 27, 46, 5, 29, 20, -6, 40, 40, 16, -7, 39, -5, 28, 6, 45, 5, 43]
    tc15 = [-1, 0, 0, -1, 0, 1, 1, 0, 0, 1, -1, 0, -1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 0, -1, 1, 1, -1, -1, -1, -1, 1, 0, 0, 0, 1, 0, -1, 1, -1, 1, 0, 0, 0, 1, 0, 0, -1, 1, -1, 1, 1, -1, 1, 1, 0, 1, -1, 1, 1, 0, -1, 1, -1, 1, 1, 1, -1, 0, 0, 0, -1, -1, 1, -1, 0, 1, 1, -1, -1, 0, 0, -1, 1, 1, 0, -1, -1, -1, 1, -1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, -1, 0, 0, 0, -1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, -1, -1, -1, -1, 0, -1, 0, 0, 0, 1, 0, 0, 1, 1, 1, -1, 0, -1, 1, 0, -1, -1, -1, 0, 0, -1, -1, 0, 1, 1, -1, 1, 1, -1, 0, 1, -1, 1, 1, -1, 0, 1, 1, 1, 1, 0, -1, -1, 0, 0, 1, 0, 1, -1, -1, 1, 0, 0, 1, 0, 0, 1, 1, -1, -1, -1, 1, 1, 0, 0, -1, 1, -1, 1, -1, 1, 0, 1, 1, 0, 1, 0, 0, -1, 0, -1, -1, -1, -1, 1, 0, 0, 1, -1, 0, -1, 1, 1, -1, 1, 0, 0, 0, -1, -1, -1, -1, 0, -1, 0, 0, 0, 0, 0, 1, 1, 0, -1, -1, 0, -1, -1, 0, 0, -1, 1, -1, 1, 0, -1, 1, 1, -1, -1, 1, 1, -1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, -1, -1, 0, 1, 1, 0, 0, -1, 0, -1, 0, 1, 1, 1, 0, 1, 0, 0, -1, 0, -1, 0, 0, 0, -1, 1, 1, 0, -1, -1, -1, 0, -1, 0, 0, -1, -1, 0, 1, 1, 1, 1, 0, 0, -1, 0, -1, -1, 1, 0, 0, 0, -1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, -1, 0, 0, -1, -1, 0, 1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 1, 1, -1, 0, 1, 0, -1, 1, 1, 1, -1, -1, 0, 1, 0, 0, 1, 0, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, -1, 0, -1, -1, -1, 1, 1, -1, -1, -1, 0, -1, -1, -1, 0, -1, -1, 1, -1, -1, -1, 0, -1, -1, 0, 1, 1, 1, 0, -1, -1, 0, 0, 0, 0, 0, 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 0, 0, 0, 0, -1, 1, 1, -1, 1, 0, 0, -1, -1, -1, 1, -1, 0, 0, -1, 1, -1, -1, 1, 0, -1, -1, 0, 0, 0, 0, 0, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, -1, -1, 1, 1, 0, 1, 0, 0, 1, -1, 1, -1, -1, 0, -1, -1, 1, 1, 1, 1, 0, 1, -1, -1, -1, 0, -1, -1, -1, -1, 1, -1, -1, 1, 1, 0, 1, -1, -1, -1, 1, 0, 0, -1, 0, -1, 1, 1, 1, 0, -1, -1, -1, 1, -1, 0, 0, 1, -1, -1, 1, 0, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 0, 0, 1, 1, 0, 0, 0, -1, 1, -1, -1, -1, 0, 0, 0, -1, -1, 1, -1, 1, 1, -1, 1, 1, -1, 1, -1, 0, 1, -1, -1, 0, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, 1, 0, -1, 0, 1, 1, 1, 0, 0, 0, 1, 1, -1, -1, 1, 0, 0, 0, -1, -1, -1, 0, 0, 0, 0, 1, 0, 1, 0, -1, 1, 1, -1, -1, -1, -1, 0, -1, 0, -1, 0, 1, 0, 0, 0, 0, 1, 0, 1, -1, 0, 1, -1, 1, 0, 1, -1, 1, -1, 1, 0, 1, 0, 1, 1, -1, 0, -1, 0, 1, 0, 1, -1, 1, -1, 1, 1, 0, 0, -1, 1, 1, 1, -1, 0, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 0, 0, 0, 1, 1, 1, 0, 1, 1, -1, 0, 0, -1, 0, 1, 0, -1, 0, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 0, -1, -1, 1, 0, 0, -1, -1, -1, -1, 1, 1, 0, 0, 0, 1, 0, 0, -1, -1, -1, -1, 0, -1, 1, -1, 1, 0, 0, 0, 0, 0, -1, 0, -1, 0, 0, -1, -1, 1, 0, -1, 0, -1, 1, -1, -1, 0, -1, -1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, -1, 0, -1, -1, 1, 1, 0, 1, -1, 1, 1, 0, 0, 0, 0, -1, 1, -1, -1, -1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 1, 0, 0, 0, 1, -1, 0, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, 0, 0, 1, -1, -1, 0, -1, 0, 0, 1, 1, 1, -1, 0, 0, -1, 1, 0, -1, -1, 1, 0, -1, 1, -1, -1, 0, -1, -1, 0, 0, -1, 0, 0, 1, -1, 0, 1, 1, -1, 1, 0, 0, 0, -1, 0, -1, -1, -1, 0, 0, -1, -1, -1, 0, 1, 0, 1, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, -1, 1, -1, 1, -1, -1, 0, -1, -1, -1, 1, -1, 1, 1, 0, 1, 1, 1, 0, 0, 0, -1, 0, 1, 1, 1, -1, -1, 1, 0, -1, 1, 0, 0, 1, 0, -1, 1, 0, 1, 0, -1, 0, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, -1, 1, 0, 1, -1, 1, -1, 1, 0, -1, 0, 1, 1, -1, 0, 1, -1, 0, 0, 1, -1, -1, -1, 0, -1, -1, 0, -1, 1, 1, 0, 1, 1, 0, -1, 1, 0, 0, -1, -1, -1, 1, 1, 0, 0, -1, 1, 1, 0, 1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 0, 0, -1, -1, 1, 1, 0, -1, 1, 1, 1, 0, -1, -1, 0, -1, 0, 0, -1, 1, 1, 0, 0, -1, -1, -1, 1, 1, 0, 1, 0, 1, -1, 1, -1, -1, 0, -1, 1, 1, 0, 1, 1, 0, 1, 1, 0, -1, 1, -1, 0, 0, -1, 0, 1, -1, 1, 1, -1, 0, 1, -1, 0, -1, 0, 1, -1, -1, 0, 0, -1, 1, -1, -1, 1, -1, -1, 0, 1, 0, 1, 1, -1, -1, 1, -1, 1, 0, -1, 1, -1, 0, -1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, -1, -1, 1, -1, 0, -1, 1, 0, -1, -1, -1, -1, 1, 1, 0, -1, 0, 1, -1, -1, 1, 0, 0, 1, 1, 1, 1, -1, 0, 0, 1, 1, -1, -1, 0, -1, -1, 1, 1, 0, 1, 0, 0, 0, 1, -1, 0, 1, 0, 0, -1, 0, 1, 1, 1, -1, -1, 0, -1, 0, 1, 1, -1, 1, 0, 1, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, -1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, -1, -1, -1, -1, -1, -1, 0, 0, 1, 0, -1, 1, -1, 1, 1, 1, -1, 1, 1, 0, -1, 1, 1, 0, -1, 0, -1, 1, 1, -1, 1, 0, 0, 1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, 0, 0, 1, -1, -1, 0, -1, 0, 1, 0, -1, -1, 0, 0, 0, -1, 1, 0, -1, -1, -1, 1, -1, 1, 0, 1, -1, -1, -1, 0, -1, -1, 1, 0, 0, 0, 1, 0, 0, 1, 1, -1, -1, 0, 0, 1, -1, 0, 1, -1, 0, 1, 0, -1, 1, 0, -1, 1, -1, -1, -1, 1, 1, 0, 0, -1, 0, -1, 0, -1, 1, 1, -1, -1, 0, -1, 0, 0, -1, 0, 1, -1, 0, -1, 0, 1, 1, -1, -1, 1, -1, -1, 1, 1, 0, -1, 1, -1, 0, 0, 1, 0, -1, 1, 1, 1, 1, 1, -1, 0, 1, 0, -1, 0, -1, 0, 1, -1, 0, -1, 1, -1, 1, 1, 0, -1, 0, -1, -1, 1, 0, -1, 1, 1, 1, 0, 0, 1, -1, -1, 1, 1, 0, 1, 1, 0, 0, 1, -1, 1, 0, 1, -1, 1, -1, 0, -1, 1, 0, 0, -1, 1, 0, 0, -1, 1, 1, 1, 0, 1, -1, 0, 0, 0, 0, 0, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, -1, -1, 0, 0, 0, 0, 1, 1, -1, -1, 1, -1, 0, -1, 1, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, -1, 0, 0, -1, 0, 0, 0, -1, -1, 0, 0, -1, -1, 0, 1, -1, -1, -1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 1, -1, 0, 1, 0, -1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, -1, 1, 1, -1, 1, 0, -1, 1, -1, -1, 0, -1, 0, 0, 0, 0, 1, 1, 1, -1, 0, 0, 0, -1, 1, 0, 0, -1, 1, -1, 0, 0, -1, 0, 1, 0, 1, 0, 0, 1, -1, 1, 0, 1, 0, -1, 0, -1, 0, -1, 0, 0, 1, -1, 1, 0, -1, -1, 1, 1, 1, 1, 0, -1, -1, 1, 0, 0, -1, -1, 0, 0, 1, 1, 0, 1, 1, -1, 0, 1, 0, 0, -1, 1, -1, -1, 0, -1, 0, -1, 1, -1, 1, -1, 0, 0, 1, 1, 1, -1, 1, 1, 1, 1, 0, -1, 1, -1, -1, 0, 1, -1, -1, 0, 0, -1, -1, 1, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 0, 0, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 0, -1, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0, 0, 0, -1, 0, -1, 0, 0, 1, 0, -1, -1, 0, -1, 0, 1, -1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, -1, 0, 1, 1, 1, 1, 1, 1, 1, -1, 0, -1, 0, 1, 1, -1, 0, 0, -1, -1, 1, 1, -1, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, 1, 0, 1, 0, -1, 1, 0, 1, -1, 0, 0, 0, 1, -1, 0, 0, 0, 1, -1, 1, 0, -1, 0, 0, 0, 1, 1, 0, -1, -1, 1, -1, 1, 1, 0, 1, 0, 0, 1, -1, 1, 1, 1, 0, 0, -1, -1, 1, 0, 0, 1, -1, -1, 1, 1, -1, 1, 0, -1, 1, -1, 1, 0, 0, 1, 0, 0, 1, 1, -1, -1, 0, 1, 1, 1, -1, 0, 0, 1, -1, -1, 0, 0, 1, 1, 1, -1, 0, 0, 1, -1, -1, 0, 0, 1, 1, 0, -1, 1, -1, 0, 0, 0, -1, 1, -1, 1, 1, 0, -1, -1, 0, -1, 1, -1, -1, -1, 0, 1, -1, -1, 1, -1, 0, 1, -1, 0, 0, 1, 0, -1, -1, 0, 1, 1, 1, -1, 0, 0, -1, 1, 1, -1, 0, 1, -1, 0, 1, 1, 0, 1, -1, -1, 0, 0, -1, -1, -1, 1, -1, -1, 0, -1, 0, 0, 1, -1, 0, 1, 0, 1, 0, 1, 0, -1, 0, 1, 0, -1, 0, -1, -1, -1, 0, -1, 0, -1, -1, -1, -1, 1, -1, 1, 0, 1, -1, -1, -1, -1, 1, -1, -1, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0, 1, -1, 1, -1, 1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 0, 0, -1, 0, 0, 0, 0, -1, 1, 1, 0, 1, 1, 0, -1, 1, 0, 1, -1, -1, 1, 0, 0, -1]
    testcases = [tc1, tc2, tc3, tc4, tc5, tc6, tc7, tc8, tc9, tc10, tc11, tc12, tc13, tc14, tc15]
    for i, tc in enumerate(testcases):
        print(f"testcase {i + 1}")
        max_sum, max_sum_indices = find_maxsum_subarray(tc)
        print(f"    최대 부분 합 : {max_sum}")
        max_sum_indices.sort()
        print(f"    최대 부분 합을 갖는 부분 배열의 시작과 끝 인덱스의 리스트 : {max_sum_indices}")

if __name__ == "__main__":
    main()
```

---

# 문제 5. 그룹장의 업무

## 문제 분류

- 중요도 : 5/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

생화학 연구그룹의 X 그룹장은 작년에 좋은 평가를 받지 못했다. 탁월한 연구성과로 그룹장의 보직을 맡았지만, 연구원으로서의 자질과 조직장으로서의 자질은 항상 일치하지 않는 법이다.

곰곰히 생각해보니, 우선 그룹에 속한 팀들의 연구 진행 사항을 꼼꼼하게 파악하는 것이 필요하겠다는 생각이 들었다. 그룹장은 소속 팀들의 회의 일정을 확인하고, 되도록 많은 회의에 직접 참석하기로 결정했다. 이 소식을 전해들은 각 연구팀은 오히려 그룹장의 회의 참석이 달갑지 않았다. 조금이라도 더 많은 연구비를 확보하기 위해 팀간, 그룹간 경쟁이 벌어지고 있는 마당에 그룹장이 어떤 자잘한 문제라도 발견하면 곤란해질 수 있겠다는 생각이 들어서였다. 결국 각 팀은 다른 팀의 회의 일정을 확인하고 회의 일정을 일부로 겹쳐 잡는 방식으로 회의 시간을 조정해 그룹장이 최대한 자주 회의에 들어오지 못하도록 하고자 했다.

각 팀의 회의 일정을 받아든 X 그룹장은 중첩된 일정을 확인하고 생각에 잠겼다.

'뭐, 일정이 이렇게 된건 대충 짐작은 간단 말이야. 나도 재작년까지는 저랬을꺼야. 뭐, 이 일정 기준으로라도 최대한 많은 회의에 들어가봐야겠군...'

## 수행목표

- 1번의 회의는 시작 시간과 끝 시간으로 정의되며, 한 번 회의에 참석하면 회의가 끝날때까지 자리를 지키는 것을 원칙으로 한다. 회의가 종료된 후, 다음 회의에 참석하는데 필요한 이동 시간은 10분이라고 가정했을 때 최대로 참석 가능한 회의의 수를 반환하는 함수를 구현한다.

  - 각 시간을 표현하는 숫자는 정수부가 시간, 소숫점 이하는 10분 단위의 분이다. 예를 들어 11은 11시, 14.4는 14시 40분을 의미한다.
  
  - 11시에 회의가 종료되면 11시에 시작하는 다음 회의는 참석할 수 없고, 빨라도 11시 10분(11.1)에 시작하는 회의에 참석할 수 있다. 

- 다음은 시작 시간과 종료 시간의 튜플로 구성된 리스트로 이루어진 매 요일의 회의 스케쥴이다. 요일 별로 참석 가능한 회의의 개수를 출력하라. 

  ```python
  tc_mon = [(9, 10), (9, 9.5), (10, 10.3), (10.3, 11), (10.4, 11.3)]
  tc_tue = [(9, 10.5), (10, 11.5), (11, 12.5), (12, 13.5)]
  tc_wed = [(9, 10), (10, 11), (11, 12), (12, 13), (13, 14), (14, 15), (15, 16), (16, 17), (17, 18)]
  tc_thr = [(11.4, 18.5), (11.2, 12.2), (15.1, 15.3), (9.3, 13.5), (9.2, 16.1), (12.2, 18.5), (17.2, 17.5), (11.3, 15.1), (9.2, 12.2), (13.1, 14.4), (14.2, 15.5), (15.1, 18.4), (9.1, 18.3), (15.2, 18.2), (16.4, 18.4), (15.0, 15.2), (9.5, 18.2), (13.3, 18.1), (17.3, 18.3), (10.5, 16.3), (11.1, 13.2), (12.3, 16.5), (9.2, 10.4), (16.3, 18.3), (16.3, 16.5), (16.2, 17.4), (14.2, 16.1), (14.3, 15.3), (15.1, 16.1), (12.0, 17.1)]
  tc_fri = [(16.0, 18), (17.1, 17.4), (12.5, 15.4), (14.3, 17.5), (17.3, 17.4), (11.2, 14.0), (9.4, 17.3), (17.5, 18), (10.5, 14.2), (13.0, 14.0), (13.5, 15.2), (15.0, 17.1), (16.3, 17.0), (11.3, 17.0), (14.0, 15.3), (9.3, 11.0), (13.0, 17.1), (13.2, 14.5), (12.3, 14.4), (14.1, 15.1), (14.3, 15.4), (13.0, 13.5), (9.2, 10.5), (14.0, 15.2), (17.5, 18), (10.3, 14.4), (13.3, 13.5), (10.5, 14.2), (11.3, 15.3), (14.2, 15.2), (16.4, 18.0), (12.4, 14.0), (11.0, 15.4), (11.0, 16.2), (11.4, 14.2), (17.0, 18.0), (9.0, 17.2), (11.1, 16.1), (13.1, 16.1), (12.2, 12.5), (14.3, 18), (16.4, 17.1), (9.4, 12.2), (9.0, 12.1), (13.0, 15.3), (11.3, 12.0), (15.1, 16.3), (9.0, 14.1), (15.5, 16.2), (12.3, 17.2), (13.5, 14.0), (15.5, 17.4), (9.1, 15.1), (9.1, 14.0), (13.1, 17.4), (17.1, 17.4), (17.1, 18), (17.5, 18), (14.3, 14.5), (17.2, 18), (11.4, 12.5), (17.1, 18), (11.4, 12.1), (14.0, 18), (10.0, 17.4), (10.1, 15.1), (11.3, 13.0), (10.5, 17.3), (14.5, 15.3), (11.3, 16.4), (16.4, 18), (13.5, 16.0), (11.1, 12.0), (15.5, 17.4), (17.4, 18), (14.4, 15.3), (17.1, 18), (17.0, 18), (12.0, 14.1), (14.3, 16.0), (9.2, 12.1), (11.1, 11.4), (12.2, 18.0), (17.3, 18), (16.4, 17.2), (16.1, 17.2), (14.3, 16.2), (12.0, 13.2), (14.0, 15.0), (12.4, 13.2), (9.2, 16.1), (15.1, 17.5), (10.2, 17.0), (11.0, 15.0), (13.2, 18.0), (17.4, 18), (14.3, 18.0), (13.2, 18.0), (14.2, 17.2), (12.5, 16.5)]
  ```

  

## 수행단계

- 그리디 알고리즘(Greedy algorithm)에 대해서 조사한다.
- 회의의 목록은 시작 시간과 종료 시간의 튜플의 리스트로 주어진다. 이 리스트를 기준으로 최대한 많은 회의에 참석하는 스케쥴을 그리디 알고리즘을 사용해 작성하는 함수를 basic_approach/greedy_meeting.py 파일에 구현한다.
  - 반환하는 값은 리스트로 주어진 스케쥴에서 최대로 참석 가능한 회의의 수이다.
  - 예를 들어서 주어진 회의 일정이 [(9, 10), (9, 9.5), (10, 10.3), (10.3, 11), (10.4, 11.3)]인 경우, 9시에 시작해서 9시 50분에 끝나는 회의, 10시에 시작해서 10시 30분에 끝나는 회의, 10시 40분에 시작해서 11시 30분에 끝나는 회의에 참석할 수 있으며, 이때는 3을 반환한다.
  - 회의 일정이 [(9, 10.5), (10, 11.5), (11, 12.5), (12, 13.5)]로 주어진 경우, 9시와 11시에 시작하는 회의 또는 10시와 12시에 시작하는 회의에 참석할 수 있으며, 이 때는 2를 반환한다.

- 주어진 회의 스케쥴을 사용해 요일 별 결과를 출력한다.

## 결과예시

```
월요일 회의 스케쥴
    참석 가능한 최대 회의 횟수 : 3

화요일 회의 스케쥴
    참석 가능한 최대 회의 횟수 : 2
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/greedy_meeting.py 파일에 구현이 되어 있는지 확인한다.
  - 그리디 알고리즘을 사용해 구현하였는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 결과는 다음과 같다. 출력 형식은 평가하지 않는다.
    ```
    월요일 회의 스케쥴
        참석 가능한 최대 회의 횟수 : 3
    
    화요일 회의 스케쥴
        참석 가능한 최대 회의 횟수 : 2
    
    수요일 회의 스케쥴
        참석 가능한 최대 회의 횟수 : 5
    
    목요일 회의 스케쥴
        참석 가능한 최대 회의 횟수 : 6
    
    금요일 회의 스케쥴
        참석 가능한 최대 회의 횟수 : 9
    ```

### [문제에 대한 이해]

- 그리디 알고리즘에 대해서 설명하라.
- 그리디 알고리즘을 이 문제의 해결에 사용한 방법을 설명하라.
- 그리디 알고리즘을 사용했을 때, 이 문제에 대한 정답이 제공되는 이유를 설명하라.

### [코드 예시]

```python
def meeting_count(meeting_list):
    meeting_list_sorted = sorted(meeting_list, key=lambda x: x[1])
    
    attended_meeting = [meeting_list_sorted[0]]
    current_meeting_finish_time = meeting_list_sorted[0][1]

    for meeting in meeting_list_sorted[1:]:
        if meeting[0] > current_meeting_finish_time:
            attended_meeting.append(meeting)
            current_meeting_finish_time = meeting[1]

    return len(attended_meeting)

def main():
    tc_mon = [(9, 10), (9, 9.5), (10, 10.3), (10.3, 11), (10.4, 11.3)]
    tc_tue = [(9, 10.5), (10, 11.5), (11, 12.5), (12, 13.5)]
    tc_wed = [(9, 10), (10, 11), (11, 12), (12, 13), (13, 14), (14, 15), (15, 16), (16, 17), (17, 18)]
    tc_thr = [(11.4, 18.5), (11.2, 12.2), (15.1, 15.3), (9.3, 13.5), (9.2, 16.1), (12.2, 18.5), (17.2, 17.5), (11.3, 15.1), (9.2, 12.2), (13.1, 14.4), (14.2, 15.5), (15.1, 18.4), (9.1, 18.3), (15.2, 18.2), (16.4, 18.4), (15.0, 15.2), (9.5, 18.2), (13.3, 18.1), (17.3, 18.3), (10.5, 16.3), (11.1, 13.2), (12.3, 16.5), (9.2, 10.4), (16.3, 18.3), (16.3, 16.5), (16.2, 17.4), (14.2, 16.1), (14.3, 15.3), (15.1, 16.1), (12.0, 17.1)]
    tc_fri = [(16.0, 18), (17.1, 17.4), (12.5, 15.4), (14.3, 17.5), (17.3, 17.4), (11.2, 14.0), (9.4, 17.3), (17.5, 18), (10.5, 14.2), (13.0, 14.0), (13.5, 15.2), (15.0, 17.1), (16.3, 17.0), (11.3, 17.0), (14.0, 15.3), (9.3, 11.0), (13.0, 17.1), (13.2, 14.5), (12.3, 14.4), (14.1, 15.1), (14.3, 15.4), (13.0, 13.5), (9.2, 10.5), (14.0, 15.2), (17.5, 18), (10.3, 14.4), (13.3, 13.5), (10.5, 14.2), (11.3, 15.3), (14.2, 15.2), (16.4, 18.0), (12.4, 14.0), (11.0, 15.4), (11.0, 16.2), (11.4, 14.2), (17.0, 18.0), (9.0, 17.2), (11.1, 16.1), (13.1, 16.1), (12.2, 12.5), (14.3, 18), (16.4, 17.1), (9.4, 12.2), (9.0, 12.1), (13.0, 15.3), (11.3, 12.0), (15.1, 16.3), (9.0, 14.1), (15.5, 16.2), (12.3, 17.2), (13.5, 14.0), (15.5, 17.4), (9.1, 15.1), (9.1, 14.0), (13.1, 17.4), (17.1, 17.4), (17.1, 18), (17.5, 18), (14.3, 14.5), (17.2, 18), (11.4, 12.5), (17.1, 18), (11.4, 12.1), (14.0, 18), (10.0, 17.4), (10.1, 15.1), (11.3, 13.0), (10.5, 17.3), (14.5, 15.3), (11.3, 16.4), (16.4, 18), (13.5, 16.0), (11.1, 12.0), (15.5, 17.4), (17.4, 18), (14.4, 15.3), (17.1, 18), (17.0, 18), (12.0, 14.1), (14.3, 16.0), (9.2, 12.1), (11.1, 11.4), (12.2, 18.0), (17.3, 18), (16.4, 17.2), (16.1, 17.2), (14.3, 16.2), (12.0, 13.2), (14.0, 15.0), (12.4, 13.2), (9.2, 16.1), (15.1, 17.5), (10.2, 17.0), (11.0, 15.0), (13.2, 18.0), (17.4, 18), (14.3, 18.0), (13.2, 18.0), (14.2, 17.2), (12.5, 16.5)]
    testcases = [tc_mon, tc_tue, tc_wed, tc_thr, tc_fri]
    wday_list = ["월", "화", "수", "목", "금"]
    for i, tc in enumerate(testcases):
        print(f"{wday_list[i]}요일 회의 스케쥴")
        count = meeting_count(tc)
        print(f"    참석 가능한 최대 회의 횟수 : {count}")
        print()    

if __name__ == "__main__":
    main()

```

---

# 문제 6. 미국에서 동전으로 버스타기

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 2시간

## 스토리

학회 참석을 위해서 미국 여행중인 닥터 S는 난감한 상황에 빠졌다. 대한민국은 어디서나 교통카드로 대중교통을 이용할 수 있었는데, 미국 지방 소도시에서 버스를 타려고 하니 카드로 버스를 탈 수 없었던 것이다. 그래서 주섬주섬 호주머니에서 동전을 꺼내고 있는데, 요금통 앞에 다음과 같은 안내문이 적혀 있었다.

>Use the mimnimum number of coins to pay the fare if possible.

## 수행목표

- 미국은 여섯 종류의 동전을 발행한다. 미국에서 사용 가능한 동전은 100센트, 50센트, 25센트, 10센트, 5센트, 1센트 여섯 종류의 동전을 발행하고 있다.
- 버스 요금 n센트를 지불하는데 필요한 최소한의 동전의 개수와 이 때 각 동전 별 사용 개수를 반환하는 함수를 구현한다.
- 버스 요금이 99센트, 398센트, 399센트인 구간의 요금을 지불하는테 필요한 최소한의 동전의 개수와 이 때 동전 별로 사용해야 하는 개수를 출력한다.

## 수행단계

- 정해진 구성의 동전을 사용해 특정 금액의 요금을 최소한의 동전의 개수를 구하는 그리디 알고리즘 접근 방법을 찾는다.
  - 그리디 알고리즘으로 정답을 찾을 수 있는 경우의 조건을 확인한다.
  
- 그리디 알고리즘을 사용해 최소한의 동전 개수와 이 때 사용할 동전 별 개수를 반환하는 함수를 basic_approach/bus_fare.py 파일에 구현한다.

- 버스 요금이 99센트, 398센트, 399센트인 구간의 결과를 출력한다.


## 결과예시

```
99센트를 거슬러 줄 때 필요한 동전의 최소 개수: 8
이 때의 각 동전의 개수:  {50: 1, 25: 1, 10: 2, 1: 4}
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 동전을 무한히 가지고 있다면 어떤 금액이라도 지불할 수 있겠지만, 동전을 많이 들고 있는 경우는 드물다. 각 동전 별로 사용 가능한 개수가 정해져 있을 때, 이러한 제한 상황에서 최소의 개수의 동전으로 요금을 지불할 때 필요한 동전의 개수와 동전 별 사용 개수를 반환하는 함수를 구현한다.
  - 그리디 알고리즘을 사용해서 구현한다.
  - 만약 제한으로 인해서 요즘을 지불할 수 없다면, 모자란 최소의 금액을 출력한다.

- 100센트, 50센트, 5센트 동전은 제한이 없고 25센트는 0개, 10센트는 1개, 1센트는 3개를 가지고 있을 때, 99센트, 398센트, 399센트를 지불해야 하는 상황의 동전의 최소 개수와 각 동전 별 사용 개수, 그리고 지불할 수 없는 최소의 금액을 출력해보자.

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/bus_fare.py 파일에 구현이 되어 있는지 확인한다.
  - 그리디 알고리즘을 사용해 구현하였는지 확인한다.
  
- 제약사항을 준수하였는가?
  - 허용되지 않은 모듈, 라이브러리, 패키지의 사용 여부 (직접 구현한 경우 사용 가능하다.)
  - 입력과 무관하게 프로그램이 처리되지 않은 예외를 발생시키지 않고 정상적으로 종료되어야 한다.
  
- 결과가 정확한가?

  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다. 

    ```
    99센트를 거슬러 줄 때 필요한 동전의 최소 개수: 8
    이 때의 각 동전의 개수:  {50: 1, 25: 1, 10: 2, 1: 4}
    398센트를 거슬러 줄 때 필요한 동전의 최소 개수: 10
    이 때의 각 동전의 개수:  {100: 3, 50: 1, 25: 1, 10: 2, 1: 3}
    399센트를 거슬러 줄 때 필요한 동전의 최소 개수: 11
    이 때의 각 동전의 개수:  {100: 3, 50: 1, 25: 1, 10: 2, 1: 4}
    ```

### [보너스 과제 확인]

* 지시한 대로 보너스 과제를 해결하였는가?

  * 그리디 알고리즘을 사용해 구현하였는가?

* 결과가 정확한가?

  ```
  99센트를 거슬러 줄 때 필요한 동전의 최소 개수: 12
  이 때의 각 동전의 개수:  {50: 1, 25: 0, 10: 1, 5: 7, 1: 3}
  남은 금액:  1
  398센트를 거슬러 줄 때 필요한 동전의 최소 개수: 15
  이 때의 각 동전의 개수:  {100: 3, 50: 1, 25: 0, 10: 1, 5: 7, 1: 3}
  남은 금액:  0
  399센트를 거슬러 줄 때 필요한 동전의 최소 개수: 15
  이 때의 각 동전의 개수:  {100: 3, 50: 1, 25: 0, 10: 1, 5: 7, 1: 3}
  남은 금액:  1
  ```

### [문제에 대한 이해]

* 이 문제를 해결하기 위해서 택한 탐욕적 선택에 대해서 설명하라.
* 어떤 나라의 동전이 1원, 25원, 30원으로 구성되어 있다고 할 때, 그리디 알고리즘으로 이 문제를 해결할 수 있는가? 이유와 함께 설명하라.

### [코드 예시]

```python

TBD
```

---

# 문제 7. 깊숙히, 더 깊숙히

## 문제 분류

- 중요도 : 3/5
- 난이도 : 2/5
- 목표 수행 시간 : 1시간

## 스토리

동물의 지능을 연구하는 연구원 T는 다양한 크기, 다양한 형태의 미로에서 쥐가 미로를 탈출하는 방식을 연구하고 있다. 어느날 한 친구가 말했다.

"쥐를 왜 저런 곳에 가둬두고 고생을 시켜?"

물론 농담으로 한 말이긴 한데, 그날 밤 꿈 자신이 그 미로에 갖혀서 헤메는 꿈을 꾸었다. 미로를 위에서 내려다 볼 때는 별 감흥이 없었는데 정작 제한된 시야로 미로를 헤메는 것은 지독한 악몽이었다. 그 끝나지 않을 것 같은 꿈에서 깨어난 연구원 T는 혹시라도 자신이 죽은 후에, 자신이 행한 실험때문에 미로 형태의 지옥에 갖히게 되면 어떻게 해야 할 지와 같은 망상에 사로잡히게 되었다.

## 수행목표

- 그래프 형태의 미로가 주어지고, 미로의 두 꼭짓점 중 두 곳이 입구 꼭짓점과 출구 꼭짓점으로 지정된다. 입구 꼭짓점의 이름은 'start'로 고정되며, 출구 꼭짓점의 이름은 'end'로 고정된다. 미로 그래프의 클래스를 만들고 주어진 미로에서 출구로 가는 방법을 출력하는 메소드를 구현한다.
- 미로를 표현하는 그래프는 다음의 특성을 가지고 있다.
  - 방향성이 없는 그래프이며, 연결된 두 점을 어느 방향으로도 진행할 수 있지만, 최종적으로 반환하는 결과에는 한 번 방문한 꼭짓점은 다시 방문하지 않는 형태로 구성되어야 한다.
  - 그래프는 순환 구조를 가지고 있지 않다. 즉 어떤 꼭짓점에서 자기 자신으로 연결되는 변은 존재하지 않는다.

- 다음 데이터는 7개의 미로를 그래프로 표현한 데이터이다. 이 다섯개의 데이터에서 입구에서 출구까지 진행 가능한 여러 방법 중 하나를 찾아 출력한다.
  - 만약 입구에서 시작해 출구에 도착할 수 없는 경우, 미로를 찾을 수 없다고 출력해야 한다.
  - 각각의 데이터는 한 줄에 하나씩의 변을 표현한다. 꼭짓점의 이름은 임의의 고유한 소문자 조합으로 제시되며, start와 end라는 이름의 꼭짓점이 반드시 포함된다.
  - 첨부한 데이터의 첫 번째 미로는 다음 그림의 미로를 나타낸다.


![image-20240114231923053](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240114231923053.png)



```python
tc1 = [('start', 'bbb'), ('bbb', 'ccc'), ('bbb', 'ddd'), ('ccc', 'aaa'), ('ccc', 'end'), ('end', 'ddd')]
tc2 = [('start', 'hhh'), ('hhh', 'aaa'), ('aaa', 'ccc'), ('ccc', 'iii'), ('iii', 'kkk'), ('kkk', 'ddd'), ('ddd', 'end'), ('end', 'bbb'), ('bbb', 'fff'), ('fff', 'jjj'), ('jjj', 'ggg'), ('jjj', 'aaa'), ('bbb', 'aaa'), ('ccc', 'bbb'), ('end', 'ccc'), ('end', 'iii'), ('end', 'fff'), ('fff', 'ggg'), ('ggg', 'ddd'), ('ggg', 'start'), ('start', 'jjj'), ('hhh', 'jjj'), ('hhh', 'lll'), ('aaa', 'lll'), ('aaa', 'mmm'), ('mmm', 'eee'), ('eee', 'iii'), ('iii', 'mmm'), ('ccc', 'mmm'), ('mmm', 'lll')]
tc3 = [('start', 'hhh'), ('hhh', 'jjj'), ('jjj', 'ggg'), ('jjj', 'start'), ('ggg', 'start'), ('ccc', 'mmm'), ('mmm', 'lll'), ('ggg', 'hhh'), ('aaa', 'lll'), ('aaa', 'ccc'), ('eee', 'mmm'), ('iii', 'ccc'), ('iii', 'eee'), ('eee', 'ccc'), ('eee', 'aaa'), ('iii', 'lll'), ('mmm', 'aaa'), ('lll', 'eee'), ('lll', 'ccc'), ('mmm', 'iii'), ('iii', 'aaa'), ('end', 'kkk'), ('kkk', 'ddd'), ('ddd', 'fff'), ('fff', 'bbb'), ('bbb', 'end'), ('end', 'ddd'), ('fff', 'kkk'), ('kkk', 'bbb'), ('ddd', 'bbb'), ('end', 'fff')]
tc4 = [('bbb', 'end'), ('bbb', 'ccc'), ('ccc', 'iii'), ('iii', 'lll'), ('lll', 'kkk'), ('kkk', 'ddd'), ('ddd', 'fff'), ('fff', 'jjj'), ('jjj', 'ggg'), ('ggg', 'aaa'), ('aaa', 'eee'), ('eee', 'mmm'), ('mmm', 'hhh'), ('hhh', 'start')]
tc5 = [('lll', 'eee'), ('lll', 'bbb'), ('lll', 'ccc'), ('lll', 'kkk'), ('lll', 'ddd'), ('lll', 'fff'), ('lll', 'ggg'), ('lll', 'jjj'), ('lll', 'aaa'), ('lll', 'start'), ('lll', 'hhh'), ('lll', 'mmm'), ('lll', 'end')]
tc6 = [('ccc', 'mmm'), ('bbb', 'iii'), ('iii', 'end'), ('iii', 'kkk'), ('jjj', 'kkk'), ('jjj', 'aaa'), ('start', 'hhh'), ('start', 'ggg'), ('start', 'aaa'), ('aaa', 'lll'), ('lll', 'eee'), ('jjj', 'ddd'), ('ddd', 'end'), ('jjj', 'fff')]
tc7 = [('start', 'aaa'), ('aaa', 'bbb'), ('bbb', 'ccc'), ('ccc', 'ddd'), ('ddd', 'fff'), ('ccc', 'eee'), ('bbb', 'ggg'), ('ggg', 'ccc'), ('ccc', 'ijk'), ('shd', 'eee'), ('eee', 'hjb'), ('hsh', 'kec'), ('seb', 'cra'), ('cra', 'end'), ('ino', 'kec'), ('ino', 'eee'), ('vat', 'hsh'), ('vat', 'ddd'), ('ion', 'ino'), ('seb', 'vat'), ('cat', 'dog'), ('dog', 'pig'), ('pig', 'rat'), ('rat', 'gom'), ('gom', 'pig'), ('pig', 'cat'), ('bbb', 'hjf'), ('aaa', 'bed'), ('ggg', 'poi'), ('ino', 'bhj'), ('vat', 'okj'), ('cra', 'pas'), ('vat', 'dak'), ('seb', 'bes'), ('ddd', 'rnr'), ('dra', 'gon'), ('gon', 'shd'), ('fac', 'eof'), ('eof', 'fla'), ('fla', 'ten'), ('ten', 'fac')]
```



## 수행단계

- DFS 탐색 방법에 대해서 조사한다.

- 기초 자료구조 챕터에서 그래프를 인접 리스트로 표현해 구현하는 방법에 대해서 학습했다. 당시에 문제에서 제시한 방향성 그래프와 달리, 이 문제는 비방향성 그래프를 구성해야 한다. 인접 리스트로 비방향성 그래프를 다루는 방법에 대해서 조사한다.

- start 꼭짓점에서 end 꼭짓점으로 이동하는 경로 중 하나를 찾아 출력하기 위한 클래스와 메소드를 basic_approach/find_route.py 파일에 구현한다.

  - DFS 탐색 방법을 적용해서 경로를 찾아야 한다.
  - 찾아낸 경로는 같은 꼭짓점을 다시 방문하지 않는다.
  - 반환하는 경로는 꼭짓점의 이름의 목록으로 반환한다. 위의 그래프에서는 ['start', 'bbb', 'ccc', 'end'] 또는 ['start', 'bbb', 'ddd', 'end'] 둘 중 하나를 반환한다.
  - 만약 start에서 end로 갈 수 있는 방법이 없는 경우, 빈 리스트를 반환한다.

- 미로 그래프를 만들기 위한 데이터는 일곱 개의 리스트로 주어지는데, 리스트의 각 항목은 연결된 두 꼭짓점의 이름의 튜플로 주어진다.

  - 예시 그림의 그래프는 tc1의 리스트로 표현하고 있다.

  * 그래프의 표현에서 꼭짓점의 순서는 그래프의 구조와 무관하다. 예를 들어 end,ddd와 ddd,end는 동일하다.
  * 7개의 미로 그래프의 객체를 생성하고, 구현한 메소드를 사용해 얻은 결과를 출력한다.

## 결과예시

```
testcase 1
    탈출 경로 : start -> bbb -> ccc -> end
(이하 생략)
```

## 참고사항

- 없음

## 제약사항

- 과정에서 제시한 제약 사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 없음

---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/find_route.py 파일에 구현이 되어 있는지 확인한다.
  - 깊이 우선 탐색 방법으로 경로를 찾고 있는지 확인한다.
  - 탈출 경로를 확인할 수 없을 때 이를 출력할 수 있도록 구현하였는지 확인한다.
  
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 실행 결과의 예시는 다음과 같다. 어떤 숫자를 골라내었느냐에 따라 결과는 다르지만 제거한 숫자와 동일한 숫자를 찾을 수 있어야 한다.
  ```
  testcase 1
      탈출 경로 : start -> bbb -> ccc -> end
  
  testcase 2
      탈출 경로 : start -> hhh -> aaa -> ccc -> iii -> kkk -> ddd -> end
  
  testcase 3
      탈출할 수 없음
  
  testcase 4
      탈출 경로 : start -> hhh -> mmm -> eee -> aaa -> ggg -> jjj -> fff -> ddd -> kkk -> lll -> iii -> ccc -> bbb -> end
  
  testcase 5
      탈출 경로 : start -> lll -> end
  
  testcase 6
      탈출 경로 : start -> aaa -> jjj -> kkk -> iii -> end
  
  testcase 7
      탈출 경로 : start -> aaa -> bbb -> ccc -> ddd -> vat -> seb -> cra -> end
  
  ```

### [문제에 대한 이해]

- DFS란 무엇인가?
- 그래프 자료구조에서 DFS 방식으로 탐색을 할 때, 한 번 방문한 꼭짓점을 다시 방문하지 않도록 하기 위해서 어떤 방법을 사용하였는가?

### [코드 예시]

```python
class MazeGraph:
    def __init__(self):
        self.vertices = {}

    def add_edge(self, vertex1, vertex2):
        if vertex1 not in self.vertices:
            self.vertices[vertex1] = []
        if vertex2 not in self.vertices[vertex1]:
            self.vertices[vertex1].append(vertex2)
        if vertex2 not in self.vertices:
            self.vertices[vertex2] = []
        if vertex1 not in self.vertices[vertex2]:
            self.vertices[vertex2].append(vertex1)

    def find_route(self, start, end, visited = None):
        if visited == None:
            visited = []
        if start == end:
            return [end]
        visited.append(start)
        for neighbor in self.vertices[start]:
            if neighbor not in visited:
                route_after = self.find_route(neighbor, end, visited)
                if route_after != None:
                    return [start] + route_after
        return None

def main():
    tc1 = [('start', 'bbb'), ('bbb', 'ccc'), ('bbb', 'ddd'), ('ccc', 'aaa'), ('ccc', 'end'), ('end', 'ddd')]
    tc2 = [('start', 'hhh'), ('hhh', 'aaa'), ('aaa', 'ccc'), ('ccc', 'iii'), ('iii', 'kkk'), ('kkk', 'ddd'), ('ddd', 'end'), ('end', 'bbb'), ('bbb', 'fff'), ('fff', 'jjj'), ('jjj', 'ggg'), ('jjj', 'aaa'), ('bbb', 'aaa'), ('ccc', 'bbb'), ('end', 'ccc'), ('end', 'iii'), ('end', 'fff'), ('fff', 'ggg'), ('ggg', 'ddd'), ('ggg', 'start'), ('start', 'jjj'), ('hhh', 'jjj'), ('hhh', 'lll'), ('aaa', 'lll'), ('aaa', 'mmm'), ('mmm', 'eee'), ('eee', 'iii'), ('iii', 'mmm'), ('ccc', 'mmm'), ('mmm', 'lll')]
    tc3 = [('start', 'hhh'), ('hhh', 'jjj'), ('jjj', 'ggg'), ('jjj', 'start'), ('ggg', 'start'), ('ccc', 'mmm'), ('mmm', 'lll'), ('ggg', 'hhh'), ('aaa', 'lll'), ('aaa', 'ccc'), ('eee', 'mmm'), ('iii', 'ccc'), ('iii', 'eee'), ('eee', 'ccc'), ('eee', 'aaa'), ('iii', 'lll'), ('mmm', 'aaa'), ('lll', 'eee'), ('lll', 'ccc'), ('mmm', 'iii'), ('iii', 'aaa'), ('end', 'kkk'), ('kkk', 'ddd'), ('ddd', 'fff'), ('fff', 'bbb'), ('bbb', 'end'), ('end', 'ddd'), ('fff', 'kkk'), ('kkk', 'bbb'), ('ddd', 'bbb'), ('end', 'fff')]
    tc4 = [('bbb', 'end'), ('bbb', 'ccc'), ('ccc', 'iii'), ('iii', 'lll'), ('lll', 'kkk'), ('kkk', 'ddd'), ('ddd', 'fff'), ('fff', 'jjj'), ('jjj', 'ggg'), ('ggg', 'aaa'), ('aaa', 'eee'), ('eee', 'mmm'), ('mmm', 'hhh'), ('hhh', 'start')]
    tc5 = [('lll', 'eee'), ('lll', 'bbb'), ('lll', 'ccc'), ('lll', 'kkk'), ('lll', 'ddd'), ('lll', 'fff'), ('lll', 'ggg'), ('lll', 'jjj'), ('lll', 'aaa'), ('lll', 'start'), ('lll', 'hhh'), ('lll', 'mmm'), ('lll', 'end')]
    tc6 = [('ccc', 'mmm'), ('bbb', 'iii'), ('iii', 'end'), ('iii', 'kkk'), ('jjj', 'kkk'), ('jjj', 'aaa'), ('start', 'hhh'), ('start', 'ggg'), ('start', 'aaa'), ('aaa', 'lll'), ('lll', 'eee'), ('jjj', 'ddd'), ('ddd', 'end'), ('jjj', 'fff')]
    tc7 = [('start', 'aaa'), ('aaa', 'bbb'), ('bbb', 'ccc'), ('ccc', 'ddd'), ('ddd', 'fff'), ('ccc', 'eee'), ('bbb', 'ggg'), ('ggg', 'ccc'), ('ccc', 'ijk'), ('shd', 'eee'), ('eee', 'hjb'), ('hsh', 'kec'), ('seb', 'cra'), ('cra', 'end'), ('ino', 'kec'), ('ino', 'eee'), ('vat', 'hsh'), ('vat', 'ddd'), ('ion', 'ino'), ('seb', 'vat'), ('cat', 'dog'), ('dog', 'pig'), ('pig', 'rat'), ('rat', 'gom'), ('gom', 'pig'), ('pig', 'cat'), ('bbb', 'hjf'), ('aaa', 'bed'), ('ggg', 'poi'), ('ino', 'bhj'), ('vat', 'okj'), ('cra', 'pas'), ('vat', 'dak'), ('seb', 'bes'), ('ddd', 'rnr'), ('dra', 'gon'), ('gon', 'shd'), ('fac', 'eof'), ('eof', 'fla'), ('fla', 'ten'), ('ten', 'fac')]
    testcases = [tc1, tc2, tc3, tc4, tc5, tc6, tc7]
    for i, tc in enumerate(testcases):
        maze = MazeGraph()
        for vertex1, vertex2 in tc:
            maze.add_edge(vertex1, vertex2)
        print(f"testcase {i + 1}")
        route = maze.find_route('start', 'end')
        if route == None:
            print("    탈출할 수 없음")
        else:
            route_in_str = ' -> '.join(route)
            print(f"    탈출 경로 : {route_in_str}")
        print()


if __name__ == '__main__':
    main()
```

---

# 문제 8. 계통도를 공유하려는데... (1)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

공동 연구를 수행중인 외부 연구팀으로부터 계통도 데이터의 공유 요청을 받은 닥터 E의 고민은 계통도의 전달 방법이었다. 몇몇 계통도는 너무 방대해서 출력 문서로 전달은 커녕, 이미지 파일로 만든다 할 지라도 어마어마하게 커다란 그림파일을 만들어야 할 판이었다. 게다가 문서나 이미지로 전달해 봤자, 다시 일일이 손으로 입력을 해야 하는 데이터를 상대방이 좋아할리가 만무했다.

그래서 계통도를 적당한 문자열로 표현해서 전달하는 방법을 찾기 위해서 프로그래밍 지원 게시판에 도움을 청하게 되었다.

## 수행목표

* 이진 트리가 주어졌을 때, 이 이진 트리를 다음의 조건을 만족하는 문자열로 표현하고자 한다.

  > - 어떤 계통도를 이 방법을 사용해서 표현하면 항상 동일한 결과가 나온다.
  > - 서로 다른 계통도는 항상 다른 문자열로 표현된다.
  > - 이 문자열을 사용해서 원래의 계통도를 복원할 수 있다.

* 이러한 문자열 표현 방법은 여러가지가 있다. 이 중 하나는 다음과 같은 방법이다. 

  * 이진 트리의 최상위 노드를 기록한다.
  * 이진 트리의 그 다음 레벨의 노드를 왼쪽부터 차례로 기록한다. 만약 비어 있는 노드가 있다면, 이 위치를 알 수 있도록 한다.
  * 이 과정을 반복해 이진 트리의 최하위 레벨의 노드를 왼쪽부터 차례로 기록한다.
  * 다음은 두 개의 트리와, 이 두 트리를 이 방법으로 문자열로 바꾼 예이다.

    * 트리 1 : `G0,G1_1,G1_2,G2_1,G2_2,G2_3,G2_4`

      ![image-20240116200733387](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240116200733387.png)
    * 트리 2 : `G0,G1_1,G1_2,,G2_2,G2_3,,,,,,G3_5`

      ![image-20240116201127404](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240116201127404.png)
  * 이진 트리를 이와 같은 방식으로 표현하는 함수를 구현한다.

* 다음 첨부파일에는 8개의 트리가 포함되어 있다. 이 트리를 문자열로 바꾸고 출력한다.

## 수행단계

- BFS에 대해서 조사한다.
  - 트리 자료구조에서 BFS 방식으로 트리를 탐사하는 방법을 조사한다.

- 이진 트리를 생성한 후, 이 이진 트리를 BFS 방식으로 고유한 문자열로 바꾸는 함수를 basic_approach/convert_tree_to_str_b.py 파일에 구현한다.
  - 이진 트리를 문자열로 바꾸기 위해서 트리 전체를 탐사하는 방식은 너비 우선 탐석(BFS) 방식을 사용한다.
  - 이 함수는 트리를 최상위 레벨부터 최하위 레벨까지 차례로 쉼표로 구분해 나열한다.
  - 만약 특정 위치에 노드가 없다면 쉼표와 쉼표 사이에 아무 값도 추가하지 않는 방식으로 이를 표현한다.
  - 최하위 레벨의 존재하는 마지막 노드 이후의 빈 자리는 표시하지 않는다.

- 이 함수를 사용해 첨부한 파일에 포함된 8개의 트리를 문자열 형식으로 변경한 후, 이 문자열을 다음 함수를 사용해 만든 간이 해시값을 출력한다.
  - 파일은 자료 구조 과정에서 이진 트리의 문제에 사용한 것과 동일한 구조의 파일이다. 
  - 각 줄이 하나의 노드이며, 노드의 위치와 이름으로 구성되어 있다. 
  - 위치에서 O는 최상위 노드를 의미하며, l은 왼쪽 자식 노드, r은 오른쪽 자식 노드를 의미한다. 
  - 각 노드의 순서는 무작위로 셔플되어 있으나, 데이터에 포함된 모든 노드를 사용해 트리를 생성해야 한다.


## 결과예시

```
Testcase 1
    BFS 문자열 표현의 간이 해시값 : 669e

Testcase 2
    BFS 문자열 표현의 간이 해시값 : 3d7c

Testcase 3
    BFS 문자열 표현의 간이 해시값 : 669e

Testcase 4
    BFS 문자열 표현의 간이 해시값 : 433b

(이하 생략)
```

## 참고사항
- 테스트케이스 1, 2, 3, 4 트리의 문자열 표현은 다음과 같다.
	- a0,b0,b1,c0,c1,c2,c3
	- b0,a0
	- a0,b0,b1,c0,c1,c2,c3
	- a0,b0,,c0,,,,d0,,,,,,,,e0
- 이 문제를 해결하기 위해서 이전에 구현한 datastructure/evolution_binarytree.py 파일을 import해서 사용하거나, 이 파일에서 필요한 코드를 복사해 사용해도 좋다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 친절한 닥터 E는 공동 연구를 진행하는 외부 연구팀을 위해서 이렇게 만들어진 문자열 형식의 트리를 원래의 트리로 변경하는 방법도 제공해주기로 하였다. 이를 위해서 위의 형식으로 주어진 문자열을 트리로 복원하는 함수를 구현하라.
  - 문제에서 제공한 8개의 트리를 문자열로 바꾼 결과를 다시 트리로 복원하고, 이를 다시 문자열로 바꾸어 출력한다. 


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/convert_tree_to_str_b.py 파일에 구현이 되어 있는지 확인한다.
  - 너비 우선 탐색(BFS) 방식으로 트리를 탐색하면서 트리의 문자열을 생성하는지 확인한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
	Testcase 1
	    BFS 문자열 표현의 간이 해시값 : 669e
	
	Testcase 2
	    BFS 문자열 표현의 간이 해시값 : 3d7c
	
	Testcase 3
	    BFS 문자열 표현의 간이 해시값 : 669e
	
	Testcase 4
	    BFS 문자열 표현의 간이 해시값 : 433b
	
	Testcase 5
	    BFS 문자열 표현의 간이 해시값 : 4254
	
	Testcase 6
	    BFS 문자열 표현의 간이 해시값 : 5698
	
	Testcase 7
	    BFS 문자열 표현의 간이 해시값 : 7917
	
	Testcase 8
	    BFS 문자열 표현의 간이 해시값 : 399b

    ```

### [보너스 과제 확인]
- 결과가 정확한가?
	- 원래의 트리를 그대로 복원하여, 복원한 트리의 문자열 표현이 원래의 문자열 표현과 동일한지 확인한다.
```
Testcase 1
    BFS 문자열 표현의 간이 해시값 : 669e
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 669e
    원래의 트리와 일치합니다.

Testcase 2
    BFS 문자열 표현의 간이 해시값 : 3d7c
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 3d7c
    원래의 트리와 일치합니다.

Testcase 3
    BFS 문자열 표현의 간이 해시값 : 669e
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 669e
    원래의 트리와 일치합니다.

Testcase 4
    BFS 문자열 표현의 간이 해시값 : 433b
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 433b
    원래의 트리와 일치합니다.

Testcase 5
    BFS 문자열 표현의 간이 해시값 : 4254
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 4254
    원래의 트리와 일치합니다.

Testcase 6
    BFS 문자열 표현의 간이 해시값 : 5698
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 5698
    원래의 트리와 일치합니다.

Testcase 7
    BFS 문자열 표현의 간이 해시값 : 7917
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 7917
    원래의 트리와 일치합니다.

Testcase 8
    BFS 문자열 표현의 간이 해시값 : 399b
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 399b
    원래의 트리와 일치합니다.
```

### [문제에 대한 이해]

- 너비 우선 탐색 (BFS)란 무엇인가?
- 트리에서 BFS 방식으로 탐색하는 순서를 임의의 트리를 사용해 설명하라.
- 파이썬 프로그램에서 트리의 BFS 탐색을 위해서 어떠한 방법을 사용하였는가?

### [코드 예시]

```python

class Species:
    def __init__(self, name):
        self.name = name
        self.left = None
        self.right = None

def add_child(species_name: str, parent: Species, is_left: bool) -> Species:
    new_species = Species(species_name)
    if parent != None:
        if is_left:
            if parent.left != None:
                return None
            else:
                parent.left = new_species
        else:
            if parent.right != None:
                return None
            else:
                parent.right = new_species
    return new_species

def convert_tree_bfs(root: Species):   
    if root == None:
        return ''
    result = root.name + ','
    node_for_explore = [root.left, root.right]
    while True:
        next_node_count = 0
        node_for_explore_next = []
        for node in node_for_explore:
            if node == None:
                result += ','
                node_for_explore_next += [None, None]
            else:
                result += node.name + ','
                if node.left != None:
                    node_for_explore_next.append(node.left)
                    next_node_count += 1
                else:
                    node_for_explore_next.append(None)
                if node.right != None:
                    node_for_explore_next.append(node.right)
                    next_node_count += 1
                else:
                    node_for_explore_next.append(None)
        if next_node_count == 0:
            break
        node_for_explore = node_for_explore_next
    while result[-1] == ',':
        result = result[:-1]
    return result

def recover_tree(tree_str: str):
    nodes = tree_str.split(',')
    if len(nodes) == 0:
        return None
    root = Species(nodes[0])
    parent_nodes = [root]
    next_parent_nodes = []
    idx = 1
    while idx < len(nodes):
        if len(parent_nodes) == 0:
            parent_nodes = next_parent_nodes
            next_parent_nodes = []

        parent_node = parent_nodes.pop(0)
        if parent_node == None:
            next_parent_nodes += [None, None]
        else:
            next_child = nodes[idx]
            if next_child != '':
                parent_node.left = Species(next_child)
                next_parent_nodes.append(parent_node.left)            
            else:
                next_parent_nodes.append(None)
            if idx + 1 >= len(nodes):
                break
            next_child = nodes[idx + 1]
            if next_child != '':
                parent_node.right = Species(next_child)
                next_parent_nodes.append(parent_node.right)
            else:
                next_parent_nodes.append(None)
        idx += 2
    return root

def make_tree(nodes: list[(str, str)]):
    check_node_location = nodes[0][0]
    nodes.sort(key=lambda x: len(x[0]))

    root = add_child(nodes[0][1], None, True)
    check_node = None
    if check_node_location == 'O':
        check_node = root
    for i in range(1, len(nodes)):
        location = nodes[i][0]
        name = nodes[i][1]
        parent = root
        discovery_str = ''
        for j in range(1, len(location) - 1):
            if location[j] == 'l':
                parent = parent.left
                discovery_str += 'l'
            else:
                parent = parent.right
                discovery_str += 'r'

        if location[-1] == 'l':
            added_node = add_child(name, parent, True)

        else:
            added_node = add_child(name, parent, False)
        if location == check_node_location:
            check_node = added_node
    return root, check_node


import hashlib

def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]


def main():
    with open("tree_example.txt", "r") as f:
        lines = f.readlines()

    testcases = []
    testcase = []
    for line in lines:
        if line[:8] == 'Testcase':
            if testcase != []:
                testcases.append(testcase)
                testcase = []
        else:
            testcase.append(line.strip().split(','))
    testcases.append(testcase)

    for i, tc in enumerate(testcases):
        print(f"Testcase {i+1}")
        root, _ = make_tree(tc)
        tree_description = convert_tree_bfs(root)
        print(f"    BFS 문자열 표현의 간이 해시값 : {hash4(tree_description)}")
        recovered_tree = recover_tree(tree_description)
        recovered_tree_description = convert_tree_bfs(recovered_tree)
        if tree_description == recovered_tree_description:
            print(f"    복원한 트리의 BFS 문자열 표현의 간이 해시값 : {hash4(recovered_tree_description)}")
            print(f"    원래의 트리와 일치합니다.")
        else:
            print(f"    복원한 트리의 BFS 문자열 표현의 간이 해시값 : {hash4(recovered_tree_description)}")
            print(f"    원래의 트리와 일치하지 않습니다.")
        print()

if __name__ == "__main__":
    main()
```

---

# 문제 9. 계통도를 공유하려는데... (2)

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

계통도를 공유하기 위해서 프로그래밍 게시판에서 조언한 방법에 따라 계통도를 문자열로 만들어놓고 보니 그 결과가 닥터 E의 마음을 불편하게 했다. 쓸데없이 문자열이 길어졌고, 또 주어진 문자열 만으로 트리의 형태를 유추하는게 쉽지 않았기 때문이다.

곰곰히 생각해 보니 더 좋은 방법이 있는 것 같았다. 머리 속의 생각을 정리하고 이를 실제로 만들어보니 결과가 꽤나 흡족했다.

## 수행목표

- 이진 트리를 다음과 같은 문자열로 표현한다.
	- 같은 부모를 공유하는 두 자식 노드는 괄호로 묶는다.
	- 형제가 없는 노드는 빈 문자열로 표현한다.
	- 자식 노드는 부모 노드 뒤에 붙여서 표현한다.
	- 자식 노드가 없는 노드는 더 이상 확장해 표현하지 않는다. 
  	- 다음은 두 개의 트리와, 이 두 트리를 이 방법으로 문자열로 바꾼 예이다.
    * 트리 1 : `G0(G1_1(G2_1,G2_2),G1_2(G2_3,G2_4))`

      ![image-20240116200733387](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240116200733387.png)
    * 트리 2 : `G0(G1_1(,G2_2),G1_2(G2_3(G3_5,),),)`

      ![image-20240116201127404](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240116201127404.png)
  * 이진 트리를 이와 같은 방식으로 표현하는 함수를 구현한다.

* 다음 첨부파일에는 8개의 트리가 포함되어 있다. 이 트리를 문자열로 바꾸고 출력한다.

## 수행단계

- 트리 자료구조에서 DFS 방식으로 탐사하는 방법에 대해서 조사한다.

- 이진 트리를 생성한 후, 이 이진 트리를 DFS 방식으로 고유한 문자열로 바꾸는 함수를 basic_approach/convert_tree_to_str_d.py 파일에 구현한다.
  - 이진 트리를 문자열로 바꾸기 위해서 트리 전체를 탐사하는 방식은 깊이 우선 탐석(DFS) 방식을 사용한다.
  - 이 함수는 레벨과 무관하게 자식 노드들을 먼저 확인해 괄호와 쉼표를 사용해 나열한다.
  - 형제 노드 중 하나가 없는 경우, 빈 자리는 빈 문자열로 표현해 왼쪽, 오른쪽 중 비어 있는 쪽이 어디인지 알 수 있도록 한다.

- 이 함수를 사용해 첨부한 파일에 포함된 8개의 트리를 문자열 형식으로 변경한 후, 이 문자열을 다음 함수를 사용해 만든 간이 해시값을 출력한다.
  - 파일은 자료 구조 과정에서 이진 트리의 문제에 사용한 것과 동일한 구조의 파일이다. 
  - 각 줄이 하나의 노드이며, 노드의 위치와 이름으로 구성되어 있다. 
  - 위치에서 O는 최상위 노드를 의미하며, l은 왼쪽 자식 노드, r은 오른쪽 자식 노드를 의미한다. 
  - 각 노드의 순서는 무작위로 셔플되어 있으나, 데이터에 포함된 모든 노드를 사용해 트리를 생성해야 한다.


## 결과예시

```
Testcase 1
    BFS 문자열 표현의 간이 해시값 : 6822

Testcase 2
    BFS 문자열 표현의 간이 해시값 : a86b

Testcase 3
    BFS 문자열 표현의 간이 해시값 : 6822

Testcase 4
    BFS 문자열 표현의 간이 해시값 : e919
(이하 생략)
```

## 참고사항
- 테스트케이스 1, 2, 3, 4 트리의 문자열 표현은 다음과 같다.
	- a0(b0(c0,c1),b1(c2,c3))
	- b0(a0,)
	- a0(b0(c0,c1),b1(c2,c3))
	- a0(b0(c0(d0(e0,),),),)
- 이 문제를 해결하기 위해서 이전에 구현한 datastructure/evolution_binarytree.py 파일을 import해서 사용하거나, 이 파일에서 필요한 코드를 복사해 사용해도 좋다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 친절한 닥터 E는 공동 연구를 진행하는 외부 연구팀을 위해서 수정한 방식으로 만든 문자열 형식의 트리 데이터를 원래의 트리로 변경하는 방법도 제공해주기로 하였다. 이를 위해서 위의 형식으로 주어진 문자열을 트리로 복원하는 함수를 구현하라.
  - 문제에서 제공한 8개의 트리를 문자열로 바꾼 결과를 다시 트리로 복원하고, 이를 다시 문자열로 바꾸어 출력한다. 


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/convert_tree_to_str_d.py 파일에 구현이 되어 있는지 확인한다.
  - 깊이 우선 탐색(DFS) 방식으로 트리를 탐색하면서 트리의 문자열을 생성하는지 확인한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
	Testcase 1
	    BFS 문자열 표현의 간이 해시값 : 6822
	
	Testcase 2
	    BFS 문자열 표현의 간이 해시값 : a86b
	
	Testcase 3
	    BFS 문자열 표현의 간이 해시값 : 6822
	
	Testcase 4
	    BFS 문자열 표현의 간이 해시값 : e919
	
	Testcase 5
	    BFS 문자열 표현의 간이 해시값 : 336f
	
	Testcase 6
	    BFS 문자열 표현의 간이 해시값 : cca6
	
	Testcase 7
	    BFS 문자열 표현의 간이 해시값 : f4b4
	
	Testcase 8
	    BFS 문자열 표현의 간이 해시값 : 5f48
    ```

### [보너스 과제 확인]
- 결과가 정확한가?
	- 원래의 트리를 그대로 복원하여, 복원한 트리의 문자열 표현이 원래의 문자열 표현과 동일한지 확인한다.
```
Testcase 1
    BFS 문자열 표현의 간이 해시값 : 669e
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 669e
    원래의 트리와 일치합니다.

Testcase 2
    BFS 문자열 표현의 간이 해시값 : 3d7c
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 3d7c
    원래의 트리와 일치합니다.

Testcase 3
    BFS 문자열 표현의 간이 해시값 : 669e
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 669e
    원래의 트리와 일치합니다.

Testcase 4
    BFS 문자열 표현의 간이 해시값 : 433b
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 433b
    원래의 트리와 일치합니다.

Testcase 5
    BFS 문자열 표현의 간이 해시값 : 4254
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 4254
    원래의 트리와 일치합니다.

Testcase 6
    BFS 문자열 표현의 간이 해시값 : 5698
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 5698
    원래의 트리와 일치합니다.

Testcase 7
    BFS 문자열 표현의 간이 해시값 : 7917
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 7917
    원래의 트리와 일치합니다.

Testcase 8
    BFS 문자열 표현의 간이 해시값 : 399b
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 399b
    원래의 트리와 일치합니다.
```

### [문제에 대한 이해]

- 트리에서 DFS 방식으로 탐색하는 순서를 임의의 트리를 사용해 설명하라.
- 파이썬 프로그램에서 트리의 DFS 탐색을 위해서 어떠한 방법을 사용하였는가?
- 만약 재귀 호출을 사용하지 않고 DFS와 BFS를 구현해야 할 때, 스택 또는 큐 둘 중 하나를 사용할 수 있다고 가정하자. DFS와 BFS 각각은 어떤 자료구조를 사용해서 구현하는 것이 바람직한지 의견을 근거와 함께 제시하라.

### [코드 예시]
```python
class Species:
    def __init__(self, name):
        self.name = name
        self.left = None
        self.right = None

def add_child(species_name: str, parent: Species, is_left: bool) -> Species:
    new_species = Species(species_name)
    if parent != None:
        if is_left:
            if parent.left != None:
                return None
            else:
                parent.left = new_species
        else:
            if parent.right != None:
                return None
            else:
                parent.right = new_species
    return new_species

def convert_tree_dfs(root: Species):   
    if root == None:
        return ''
    result = root.name
    if root.left == None and root.right == None:
        return result
    if root.left != None:
        result += '(' + convert_tree_dfs(root.left) + ','
    else:
        result += '(,'
    if root.right != None:
        result += convert_tree_dfs(root.right) + ')'
    else:
        result += ')'
    return result

def recover_tree(tree_str: str):
    if tree_str == '':
        return None
    if '(' not in tree_str:
        return Species(tree_str)
    depth = 0
    p_start = -1
    comma_at = -1
    p_end = -1
    idx = 0
    while True:
        if tree_str[idx] == '(':
            if depth == 0:
                p_start = idx
            depth += 1
        elif tree_str[idx] == ',':
            if depth == 1:
                comma_at = idx
        elif tree_str[idx] == ')':
            depth -= 1
            if depth == 0:
                p_end = idx
                break
        idx += 1
    left = tree_str[p_start + 1:comma_at]
    right = tree_str[comma_at + 1:p_end]
    node = Species(tree_str[:p_start])
    if left != '':
        node.left = recover_tree(left)
    if right != '':
        node.right = recover_tree(right)
    return node

def make_tree(nodes: list[(str, str)]):
    check_node_location = nodes[0][0]
    nodes.sort(key=lambda x: len(x[0]))

    root = add_child(nodes[0][1], None, True)
    check_node = None
    if check_node_location == 'O':
        check_node = root
    for i in range(1, len(nodes)):
        location = nodes[i][0]
        name = nodes[i][1]
        parent = root
        discovery_str = ''
        for j in range(1, len(location) - 1):
            if location[j] == 'l':
                parent = parent.left
                discovery_str += 'l'
            else:
                parent = parent.right
                discovery_str += 'r'

        if location[-1] == 'l':
            added_node = add_child(name, parent, True)

        else:
            added_node = add_child(name, parent, False)
        if location == check_node_location:
            check_node = added_node
    return root, check_node


import hashlib

def hash4(input):
    return hashlib.md5(input.encode()).hexdigest()[:4]


def main():
    with open("tree_example.txt", "r") as f:
        lines = f.readlines()

    testcases = []
    testcase = []
    for line in lines:
        if line[:8] == 'Testcase':
            if testcase != []:
                testcases.append(testcase)
                testcase = []
        else:
            testcase.append(line.strip().split(','))
    testcases.append(testcase)

    for i, tc in enumerate(testcases):
        print(f"Testcase {i+1}")
        root, _ = make_tree(tc)
        tree_description = convert_tree_dfs(root)
        print(f"    BFS 문자열 표현의 간이 해시값 : {hash4(tree_description)}")
        recovered_tree = recover_tree(tree_description)
        recovered_tree_description = convert_tree_dfs(recovered_tree)
        if tree_description == recovered_tree_description:
           print(f"    복원한 트리의 BFS 문자열 표현의 간이 해시값 : {hash4(recovered_tree_description)}")
           print(f"    원래의 트리와 일치합니다.")
        else:
           print(f"    복원한 트리의 BFS 문자열 표현의 간이 해시값 : {hash4(recovered_tree_description)}")
           print(f"    원래의 트리와 일치하지 않습니다.")
        print()

if __name__ == "__main__":
    main()
```

---

# 문제 10. 진화 계통도 상의 생물들을 의미있게 나열하라

## 문제 분류

- 중요도 : 4/5
- 난이도 : 3/5
- 목표 수행 시간 : 4시간

## 스토리

연구 내용을 논문으로 정리하던 닥터 E는 트리로 구성된 계통도의 이점에 대해서 다음과 같이 적었다.
>- 트리 형태로 표현한 계통도는, 정해진 방법으로 각 노드를 순회하며 나열하면 자동으로 다음과 같은 순서의 목록을 생성할 수 있다.
>	- 전체 목록에서 항상 조상 생물이 후손 생물보다 앞에 오도록 나열
>   - 반대로 항상 후손 생물이 

에 포함된 동물을 다음과 같이 적어 내려갔다.

'파충류, '


전위 G0 G1_1 G2_1 G2_2 G1_2 G2_3 G2_4
: 부모는 항상 자식보다 먼저 온다.

후위 G2_1 G2_2 G1_1 G2_3 G2_4 G1_2 G0
: 자식은 항상 부모보다 먼저 온다.

중위 G2_1 G2_2 G1_1 G0 G2_3 G2_4 G1_2
: 왼쪽이 항상 오른쪽보다 먼저 온다.


계통도를 공유하기 위해서 프로그래밍 게시판에서 조언한 방법에 따라 계통도를 문자열로 만들어놓고 보니 그 결과가 닥터 E의 마음을 불편하게 했다. 쓸데없이 문자열이 길어졌고, 또 주어진 문자열 만으로 트리의 형태를 유추하는게 쉽지 않았기 때문이다.

곰곰히 생각해 보니 더 좋은 방법이 있는 것 같았다. 머리 속의 생각을 정리하고 이를 실제로 만들어보니 결과가 꽤나 흡족했다.

## 수행목표

- 이진 트리를 다음과 같은 문자열로 표현한다.
	- 같은 부모를 공유하는 두 자식 노드는 괄호로 묶는다.
	- 형제가 없는 노드는 빈 문자열로 표현한다.
	- 자식 노드는 부모 노드 뒤에 붙여서 표현한다.
	- 자식 노드가 없는 노드는 더 이상 확장해 표현하지 않는다. 
  	- 다음은 두 개의 트리와, 이 두 트리를 이 방법으로 문자열로 바꾼 예이다.
    * 트리 1 : `G0(G1_1(G2_1,G2_2),G1_2(G2_3,G2_4))`

      ![image-20240116200733387](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240116200733387.png)
    * 트리 2 : `G0(G1_1(,G2_2),G1_2(G2_3(G3_5,),),)`

      ![image-20240116201127404](/Users/edbergbak/Library/Application Support/typora-user-images/image-20240116201127404.png)
  * 이진 트리를 이와 같은 방식으로 표현하는 함수를 구현한다.

* 다음 첨부파일에는 8개의 트리가 포함되어 있다. 이 트리를 문자열로 바꾸고 출력한다.

## 수행단계

- 트리 자료구조에서 DFS 방식으로 탐사하는 방법에 대해서 조사한다.

- 이진 트리를 생성한 후, 이 이진 트리를 DFS 방식으로 고유한 문자열로 바꾸는 함수를 basic_approach/convert_tree_to_str_d.py 파일에 구현한다.
  - 이진 트리를 문자열로 바꾸기 위해서 트리 전체를 탐사하는 방식은 깊이 우선 탐석(DFS) 방식을 사용한다.
  - 이 함수는 레벨과 무관하게 자식 노드들을 먼저 확인해 괄호와 쉼표를 사용해 나열한다.
  - 형제 노드 중 하나가 없는 경우, 빈 자리는 빈 문자열로 표현해 왼쪽, 오른쪽 중 비어 있는 쪽이 어디인지 알 수 있도록 한다.

- 이 함수를 사용해 첨부한 파일에 포함된 8개의 트리를 문자열 형식으로 변경한 후, 이 문자열을 다음 함수를 사용해 만든 간이 해시값을 출력한다.
  - 파일은 자료 구조 과정에서 이진 트리의 문제에 사용한 것과 동일한 구조의 파일이다. 
  - 각 줄이 하나의 노드이며, 노드의 위치와 이름으로 구성되어 있다. 
  - 위치에서 O는 최상위 노드를 의미하며, l은 왼쪽 자식 노드, r은 오른쪽 자식 노드를 의미한다. 
  - 각 노드의 순서는 무작위로 셔플되어 있으나, 데이터에 포함된 모든 노드를 사용해 트리를 생성해야 한다.


## 결과예시

```
Testcase 1
    BFS 문자열 표현의 간이 해시값 : 6822

Testcase 2
    BFS 문자열 표현의 간이 해시값 : a86b

Testcase 3
    BFS 문자열 표현의 간이 해시값 : 6822

Testcase 4
    BFS 문자열 표현의 간이 해시값 : e919
(이하 생략)
```

## 참고사항
- 테스트케이스 1, 2, 3, 4 트리의 문자열 표현은 다음과 같다.
	- a0(b0(c0,c1),b1(c2,c3))
	- b0(a0,)
	- a0(b0(c0,c1),b1(c2,c3))
	- a0(b0(c0(d0(e0,),),),)
- 이 문제를 해결하기 위해서 이전에 구현한 datastructure/evolution_binarytree.py 파일을 import해서 사용하거나, 이 파일에서 필요한 코드를 복사해 사용해도 좋다.

## 제약사항

- 과정에서 제시한 제약사항을 준수한다.

## 개발환경

- 3.9 버전 이상의 파이썬 프로그램으로 작성한다.

## 보너스 과제

- 친절한 닥터 E는 공동 연구를 진행하는 외부 연구팀을 위해서 수정한 방식으로 만든 문자열 형식의 트리 데이터를 원래의 트리로 변경하는 방법도 제공해주기로 하였다. 이를 위해서 위의 형식으로 주어진 문자열을 트리로 복원하는 함수를 구현하라.
  - 문제에서 제공한 8개의 트리를 문자열로 바꾼 결과를 다시 트리로 복원하고, 이를 다시 문자열로 바꾸어 출력한다. 


---

## 평가질문/평가가이드

### [수행목표 확인]

- 문제에서 지시한 형식을 준수하였는가?
  - basic_approach/convert_tree_to_str_d.py 파일에 구현이 되어 있는지 확인한다.
  - 깊이 우선 탐색(DFS) 방식으로 트리를 탐색하면서 트리의 문자열을 생성하는지 확인한다.
- 결과가 정확한가?
  - 파이썬 3.9 이상에서 동작 여부를 확인한다.
  - 프로그램의 결과는 다음과 같다. 출력 형식은 평가하지 않는다.

    ```
	Testcase 1
	    BFS 문자열 표현의 간이 해시값 : 6822
	
	Testcase 2
	    BFS 문자열 표현의 간이 해시값 : a86b
	
	Testcase 3
	    BFS 문자열 표현의 간이 해시값 : 6822
	
	Testcase 4
	    BFS 문자열 표현의 간이 해시값 : e919
	
	Testcase 5
	    BFS 문자열 표현의 간이 해시값 : 336f
	
	Testcase 6
	    BFS 문자열 표현의 간이 해시값 : cca6
	
	Testcase 7
	    BFS 문자열 표현의 간이 해시값 : f4b4
	
	Testcase 8
	    BFS 문자열 표현의 간이 해시값 : 5f48
    ```

### [보너스 과제 확인]
- 결과가 정확한가?
	- 원래의 트리를 그대로 복원하여, 복원한 트리의 문자열 표현이 원래의 문자열 표현과 동일한지 확인한다.
```
Testcase 1
    BFS 문자열 표현의 간이 해시값 : 669e
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 669e
    원래의 트리와 일치합니다.

Testcase 2
    BFS 문자열 표현의 간이 해시값 : 3d7c
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 3d7c
    원래의 트리와 일치합니다.

Testcase 3
    BFS 문자열 표현의 간이 해시값 : 669e
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 669e
    원래의 트리와 일치합니다.

Testcase 4
    BFS 문자열 표현의 간이 해시값 : 433b
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 433b
    원래의 트리와 일치합니다.

Testcase 5
    BFS 문자열 표현의 간이 해시값 : 4254
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 4254
    원래의 트리와 일치합니다.

Testcase 6
    BFS 문자열 표현의 간이 해시값 : 5698
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 5698
    원래의 트리와 일치합니다.

Testcase 7
    BFS 문자열 표현의 간이 해시값 : 7917
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 7917
    원래의 트리와 일치합니다.

Testcase 8
    BFS 문자열 표현의 간이 해시값 : 399b
    복원한 트리의 BFS 문자열 표현의 간이 해시값 : 399b
    원래의 트리와 일치합니다.
```

### [문제에 대한 이해]

- 트리에서 DFS 방식으로 탐색하는 순서를 임의의 트리를 사용해 설명하라.
- 파이썬 프로그램에서 트리의 DFS 탐색을 위해서 어떠한 방법을 사용하였는가?
- 만약 재귀 호출을 사용하지 않고 DFS와 BFS를 구현해야 할 때, 스택 또는 큐 둘 중 하나를 사용할 수 있다고 가정하자. DFS와 BFS 각각은 어떤 자료구조를 사용해서 구현하는 것이 바람직한지 의견을 근거와 함께 제시하라.

### [코드 예시]
